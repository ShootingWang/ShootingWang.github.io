<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>概率统计基础</title>
    <link href="/2020/05/09/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1%E5%9F%BA%E7%A1%80/"/>
    <url>/2020/05/09/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<p>概率论与数理统计</p><a id="more"></a><h1><span id="概率论基础">概率论基础</span></h1><h2><span id="函数">函数</span></h2><h3><span id="beta函数">Beta函数</span></h3><script type="math/tex; mode=display">B(\alpha, \beta)=\int_0^1 x^{\alpha-1}(1-x)^{\beta-1}\mathrm{d}x ,\quad \alpha,\beta>0</script><ul><li>$B(\alpha,\beta)=\frac{\Gamma(\alpha)\Gamma(\beta)}{\Gamma(\alpha+\beta)}$<br>证明：</li></ul><h3><span id="gamma函数">Gamma函数</span></h3><script type="math/tex; mode=display">\Gamma(\alpha)=\int_0^{+\infty}x^{\alpha-1}e^{-x}\mathrm{d}x ,\quad \alpha>0</script><ul><li>$\Gamma(\alpha+1)=\alpha\Gamma(\alpha)$</li><li>$\Gamma(n+1)=n!,\quad n\in \mathbb{N}$.</li></ul><h2><span id="随机变量">随机变量</span></h2><h3><span id="期望">期望</span></h3><ul><li><strong>条件均值</strong>（Conditional Mean）：<script type="math/tex; mode=display">E\left(X|Y=y\right)=\int xf_{X|Y}(x|y)\mathrm{d}x</script></li><li>条件方差<script type="math/tex; mode=display">Var\left(X|Y=y\right)=\int \left[x-E\left(X|Y=y \right)\right]^2f_{X|Y}(x|y)\mathrm{d}x</script></li><li>重期望<script type="math/tex; mode=display">E(X)=E\left[E\left(X|Y\right) \right]</script></li><li><script type="math/tex; mode=display">Var(X)=E\left[Var(X|Y) \right]+Var\left[E\left(X|Y \right)\right]</script></li></ul><h2><span id="分布">分布</span></h2><ul><li><strong>概率密度函数</strong>（pdf，probability density function）</li></ul><h3><span id="贝塔分布">贝塔分布</span></h3><p>Beta Distribution<br>$X\sim B(\alpha, \beta)$, 则$X$的概率密度函数为</p><script type="math/tex; mode=display">f_X(x)=\frac{1}{B(\alpha,\beta)}x^{\alpha-1}(1-x)^{\beta-1},\quad 0< x < 1</script><ul><li><p>$E(X)=\frac{\alpha}{\alpha+\beta}$</p><font face="仿宋">\begin{equation}\begin{aligned}E(X)&=\int_0^1 x\frac{1}{B(\alpha,\beta)}x^{\alpha-1}(1-x)^{\beta-1}\mathrm{d}x\\&=\end{aligned}\end{equation}</font></li><li><p>$Var(X)=\frac{\alpha\beta}{(\alpha+\beta)^2(\alpha+\beta+1)}$</p></li></ul><h3><span id="泊松分布">泊松分布</span></h3><ul><li><a href="/2020/04/27/%E6%B3%8A%E6%9D%BE%E5%88%86%E5%B8%83/" title="泊松分布">泊松分布</a></li></ul><h3><span id="伽马分布">伽马分布</span></h3><p>Gamma Distribution<br>$X\sim \Gamma(\alpha, \beta)$, 则$X$的概率密度函数为</p><script type="math/tex; mode=display">f_X(x)=\frac{\beta^{\alpha}}{\Gamma(\alpha)}x^{\alpha-1}e^{-\beta x},\quad x>0</script><ul><li>$E(X)=\frac{\alpha}{\beta}$</li><li>$Var(X)=\frac{\alpha}{\beta^2}$</li></ul><h1><span id="数理统计基础">数理统计基础</span></h1><h1><span id="参考资料">参考资料</span></h1>]]></content>
    
    
    <categories>
      
      <category>概率统计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>概率统计基础</tag>
      
      <tag>概率分布</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JAVA</title>
    <link href="/2020/05/08/JAVA%E5%AD%A6%E4%B9%A0/"/>
    <url>/2020/05/08/JAVA%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p>JAVA小白的学习之路</p><a id="more"></a><h1><span id="安装">安装</span></h1><h2><span id="安装java">安装JAVA</span></h2><ul><li><a href="https://courses.edx.org/courses/course-v1:Microsoft+DEV285x+3T2019/courseware/a8a0bb660fda4b71b4c7439aa4a07dae/16d23967e4514f7fa6a3e78a3edfc0eb/?child=first" target="_blank" rel="noopener">安装JAVA和IDE</a></li></ul><h2><span id="安装ide">安装IDE</span></h2><ul><li><a href="https://www.jetbrains.com/idea/download/download-thanks.html?platform=windows&amp;code=IIC" target="_blank" rel="noopener">IntelliJ IDEA下载</a></li></ul><h1><span id="参考资料">参考资料</span></h1><p>[1] <a href="https://cn.bing.com/images/search?view=detailV2&amp;ccid=zThJuq%2bC&amp;id=474DFD30EC584147A5C8FC0F10952D615CF2795A&amp;thid=OIP.zThJuq-CIVq3uElNx7mDVQHaEK&amp;mediaurl=https%3a%2f%2fwww.vizteams.com%2fwp-content%2fuploads%2f2015%2f07%2fjava-logo.png&amp;exph=576&amp;expw=1024&amp;q=java&amp;simid=608020279042638133&amp;selectedIndex=2" target="_blank" rel="noopener">首页缩略图</a><br>[2] <a href></a><br>[3] <a href></a><br>[4] <a href></a></p>]]></content>
    
    
    <categories>
      
      <category>编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编程</tag>
      
      <tag>JAVA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Algorithms and Data Structures</title>
    <link href="/2020/05/04/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    <url>/2020/05/04/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>Basic!</p><a id="more"></a><h1><span id="算法">算法</span></h1><p>一个算法应该是<u>问题求解步骤的描述</u></p><blockquote><p>Algorithm by definition is precise steps that describes the solution of a certain task or a problem.</p><p><strong>算法</strong>（algorithm）是对特定问题求解步骤的一种描述，是指令的有序序列，其中每一条指令表示一个或多个操作。</p></blockquote><p>算法具有5个基本特征：</p><ol><li>有穷性</li><li>确定性</li><li>可行性</li><li>输入（$\geq 0$）</li><li>输出（$\geq 1$）</li></ol><h2><span id="查找方法">查找方法</span></h2><ul><li><a href="/2020/05/04/%E4%BA%8C%E5%88%86%E6%B3%95/" title="简单查找">简单查找</a></li><li><a href="/2020/05/04/%E4%BA%8C%E5%88%86%E6%B3%95/" title="二分查找">二分查找</a><blockquote><ul><li>二分查找的速度比简单查找快得多</li><li>$O(\log{n})$比$O(n)$快</li></ul></blockquote></li></ul><h2><span id="排序方法">排序方法</span></h2><ul><li><a href="/2020/05/05/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/" title="选择排序">选择排序</a></li><li><a href="/2020/05/05/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/" title="快速排序">快速排序</a></li><li></li></ul><h2><span id="图相关">图相关</span></h2><ul><li><a href="/2020/05/05/BFS/" title="广度优先搜索">广度优先搜索</a><ul><li>用于在非加权图中查找最短路径 </li></ul></li><li><a href="/2020/05/05/%E7%8B%84%E5%85%8B%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95/" title="狄克斯特拉算法">狄克斯特拉算法</a><ul><li>Dijkstra’s Algorithm</li><li>用于在加权图中查找最短路径</li><li>不能用于包含负权边的图</li></ul></li><li><a href="/2020/05/05/%E8%B4%9D%E5%B0%94%E6%9B%BC-%E7%A6%8F%E5%BE%B7%E7%AE%97%E6%B3%95/" title="贝尔曼-福德算法">贝尔曼-福德算法</a><ul><li>用于含负权边的加权图查找最短路径</li></ul></li><li><a href="/2020/05/05/%E8%B4%AA%E5%A9%AA%E7%AE%97%E6%B3%95/" title="贪婪算法">贪婪算法</a></li></ul><h2><span id> </span></h2><ul><li><a href="/2020/05/05/%E9%80%92%E5%BD%92/" title="递归">递归</a></li><li><a href="/2020/05/05/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" title="背包问题">背包问题</a><ul><li><a href="/2020/05/05/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" title="动态规划">动态规划</a></li></ul></li></ul><h2><span id="数据结构">数据结构</span></h2><ul><li><a href="/2020/05/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" title="数据结构">数据结构</a><ul><li><a href="/2020/05/01/%E6%A0%91/" title="树">树</a></li><li></li></ul></li></ul><h1><span id="通用知识">通用知识</span></h1><h2><span id="运行时间">运行时间</span></h2><ul><li>算法运行时间并不以秒为单位</li><li>算法运行时间是从其增速的角度度量的</li><li>算法运行时间用<strong>大O表示法</strong>表示</li></ul><h3><span id="大o表示法">大O表示法</span></h3><ul><li>指出了算法运行时间的增速<blockquote><p>表示的并非是以秒为单位的速度</p></blockquote></li><li>指出了最糟情况下的运行时间</li></ul><p>常见的<strong>大O运行时间</strong>：</p><ul><li>$O(\log{n})$：对数时间<ul><li>二分查找</li></ul></li><li>$O(n)$：线性时间<ul><li>简单查找</li></ul></li><li>$O(n\log{n})$<ul><li>快速排序</li></ul></li><li>$O(n^2)$<ul><li>选择排序</li></ul></li><li>$O(n!)$<ul><li>旅行商问题</li></ul></li></ul><p>算法的运行时间通常有个<strong>常量</strong>$c$，表示算法所需的固定时间</p><blockquote><p>如：简单查找的运行时间为10ms$*n$，二分查找的运行时间为1s$*\log{n}$。其中，10ms和1s都是常量</p></blockquote><ul><li>通常情况下，常量几乎没什么影响</li><li>但有时候，常量的影响可能很大<blockquote><p>如：运行时间都为$O(n\log{n})$的快速排序和合并排序，快速排序将会快很多</p></blockquote></li></ul><p>常见的数组和链表操作的运行时间：</p><div class="table-container"><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">数组</th><th style="text-align:center">链表</th></tr></thead><tbody><tr><td style="text-align:center">读取</td><td style="text-align:center">$O(1)$<sup><a href="#fn_1" id="reffn_1">1</a></sup></td><td style="text-align:center">$O(n)$<sup><a href="#fn_2" id="reffn_2">2</a></sup></td></tr><tr><td style="text-align:center">插入</td><td style="text-align:center">$O(n)$<sup><a href="#fn_3" id="reffn_3">3</a></sup></td><td style="text-align:center">$O(1)$<sup><a href="#fn_4" id="reffn_4">4</a></sup></td></tr><tr><td style="text-align:center">删除</td><td style="text-align:center">$O(n)$<sup><a href="#fn_5" id="reffn_5">5</a></sup></td><td style="text-align:center">$O(1)$<sup><a href="#fn_6" id="reffn_6">6</a></sup></td></tr></tbody></table></div><blockquote id="fn_1"><sup>1</sup>. 数组的元素的位置都已知，直接根据索引读取某元素<a href="#reffn_1" title="Jump back to footnote [1] in the text."> &#8617;</a></blockquote><blockquote id="fn_2"><sup>2</sup>. 要访问链表的某个元素，必须先访问第一个元素以获得第二个元素的地址，再访问第二个元素以获得第三个元素的地址，……<a href="#reffn_2" title="Jump back to footnote [2] in the text."> &#8617;</a></blockquote><blockquote id="fn_3"><sup>3</sup>. 在数组中插入元素时，必须将后面的元素都向后移<a href="#reffn_3" title="Jump back to footnote [3] in the text."> &#8617;</a></blockquote><blockquote id="fn_4"><sup>4</sup>. 在链表中插入元素，只需修改那个元素指向的位置<a href="#reffn_4" title="Jump back to footnote [4] in the text."> &#8617;</a></blockquote><blockquote id="fn_5"><sup>5</sup>. 删除数组的某个元素后，该元素后的所有元素都需要向前移<a href="#reffn_5" title="Jump back to footnote [5] in the text."> &#8617;</a></blockquote><blockquote id="fn_6"><sup>6</sup>. 链表的第一个元素和最后一个元素已知，删除这些元素的运行时间为$O(1)$<a href="#reffn_6" title="Jump back to footnote [6] in the text."> &#8617;</a></blockquote><ul><li>数组擅长随机访问</li><li>链表擅长插入和删除</li></ul><h1><span id="参考资料">参考资料</span></h1><p>[1] <a href="https://tse1-mm.cn.bing.net/th/id/OIP.7h7LM5AhzNGHuM9T73jq1QHaEl?w=300&amp;h=178&amp;c=7&amp;o=5&amp;dpr=1.5&amp;pid=1.7" target="_blank" rel="noopener">首页缩略图</a><br>[2] <a href="https://book.douban.com/subject/26979890/" target="_blank" rel="noopener">图解算法</a></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>基础算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>基础算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>假设检验</title>
    <link href="/2020/05/04/%E5%81%87%E8%AE%BE%E6%A3%80%E9%AA%8C/"/>
    <url>/2020/05/04/%E5%81%87%E8%AE%BE%E6%A3%80%E9%AA%8C/</url>
    
    <content type="html"><![CDATA[<p>Hypothesis Testing</p><a id="more"></a><h1><span id="hypothesis">Hypothesis</span></h1><h2><span id="error">Error</span></h2><ul><li><strong>type Ⅰ Error</strong><br>   $H_0$ is true but reject $H_0$<script type="math/tex; mode=display">\alpha=P(H_1|H_0)</script>   错误拒绝</li><li><strong>type Ⅱ Error</strong><br>   $H_0$ is not true but accept $H_0$<script type="math/tex; mode=display">P(H_0|H_1)</script>   错误接受</li></ul><h1><span id="检验方法">检验方法</span></h1><h2><span id="参数检验">参数检验</span></h2><ul><li>两均值对比<ul><li>Z检验<blockquote><p>适用于样本量大、总体方差已知的样本</p></blockquote></li><li><a href="/2020/05/04/t%E6%A3%80%E9%AA%8C/" title="t检验">t检验</a><blockquote><p>适用于样本量小、总体方差未知的样本</p></blockquote></li></ul></li></ul><h2><span id="非参数检验">非参数检验</span></h2><ul><li>两均值对比<ul><li><a href="/2020/05/04/U%E6%A3%80%E9%AA%8C/" title="Mann-Whitney U检验">Mann-Whitney U检验</a></li></ul></li></ul><p><meta name="referrer" content="no-referrer"><br><img src="/2020/05/04/%E5%81%87%E8%AE%BE%E6%A3%80%E9%AA%8C/howtochoose.png" srcset="/img/loading.gif" class title="What Test?"></p><div class="table-container"><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">功能</th><th style="text-align:center">正态性</th><th style="text-align:center">不服从正态分布时</th><th style="text-align:center">方差齐性</th></tr></thead><tbody><tr><td style="text-align:center">单样本t检验</td><td style="text-align:center">与某数字对比</td><td style="text-align:center">服从正态分布</td><td style="text-align:center">单样本Wilcoxon检验</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">配对样本t检验</td><td style="text-align:center">配对数据差异</td><td style="text-align:center">差值服从正态分布</td><td style="text-align:center">配对Wilcoxon检验</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">独立样本t检验</td><td style="text-align:center">两组数据的差异</td><td style="text-align:center">两组数据都服从正态分布</td><td style="text-align:center">Mann-Whitney U检验</td><td style="text-align:center">要求同方差</td></tr></tbody></table></div><h1><span id="参考资料">参考资料</span></h1><p>[1] <a href="https://tse3-mm.cn.bing.net/th/id/OIP.Kswu83OuyrC-6NiH646D-QHaGg?w=222&amp;h=160&amp;c=7&amp;o=5&amp;dpr=1.5&amp;pid=1.7" target="_blank" rel="noopener">首页缩略图</a><br>[2] <a href="https://www.skillsyouneed.com/num/statistics-identifying-patterns.html" target="_blank" rel="noopener">Statistical Analysis: Identifying Patterns</a><br>[3] <a href="https://zhuanlan.zhihu.com/p/68736699" target="_blank" rel="noopener">三种T检验的详细区分</a></p>]]></content>
    
    
    <categories>
      
      <category>概率统计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>概率统计基础</tag>
      
      <tag>检验</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性回归</title>
    <link href="/2020/05/04/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/"/>
    <url>/2020/05/04/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/</url>
    
    <content type="html"><![CDATA[<p>Linear Regression</p><a id="more"></a><h1><span id="线性回归">线性回归</span></h1><p>自变量$x$和因变量$y$之间存在线性相关关系</p><h2><span id="变量别名">变量别名</span></h2><div class="table-container"><table><thead><tr><th style="text-align:center"><strong>自变量</strong></th><th style="text-align:center"><strong>因变量</strong></th></tr></thead><tbody><tr><td style="text-align:center">input variable</td><td style="text-align:center">outcome variable</td></tr><tr><td style="text-align:center">explanatory variable</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">regressor</td><td style="text-align:center">regressand</td></tr><tr><td style="text-align:center">independent variable</td><td style="text-align:center">dependent variable</td></tr><tr><td style="text-align:center">feature</td><td style="text-align:center">target</td></tr><tr><td style="text-align:center">predictor variable</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">exogenous variable</td><td style="text-align:center">endogenous variable</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">criterion variable</td></tr></tbody></table></div><h2><span id="用途">用途</span></h2><ul><li>确定自变量对因变量影响的强度<br>to identify the strength of the effect that the independent variable(s) have on a dependent variable</li><li>预测效应<br>to forecast effects or impact of changes</li><li>预测趋势<br>to predict trends and future values</li></ul><h2><span id="类型">类型</span></h2><p>线性回归的类型有：</p><ul><li><strong>Simple linear regression</strong></li></ul><div class="table-container"><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">dependent variable</th><th style="text-align:center">independent variable</th></tr></thead><tbody><tr><td style="text-align:center">amount</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">type</td><td style="text-align:center">interval / ratio</td><td style="text-align:center">interval / ratio / dichotomous<sup><a href="#fn_1" id="reffn_1">1</a></sup></td></tr></tbody></table></div><blockquote id="fn_1"><sup>1</sup>. dichotomous：二分类<a href="#reffn_1" title="Jump back to footnote [1] in the text."> &#8617;</a></blockquote><ul><li><strong>Multiple linear regression</strong></li></ul><div class="table-container"><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">dependent variable</th><th style="text-align:center">independent variable</th></tr></thead><tbody><tr><td style="text-align:center">amount</td><td style="text-align:center">1</td><td style="text-align:center">2+</td></tr><tr><td style="text-align:center">type</td><td style="text-align:center">interval / ratio</td><td style="text-align:center">interval / ratio / dichotomous</td></tr></tbody></table></div><ul><li><strong>Logistic regression</strong></li></ul><div class="table-container"><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">dependent variable</th><th style="text-align:center">independent variable</th></tr></thead><tbody><tr><td style="text-align:center">amount</td><td style="text-align:center">1</td><td style="text-align:center">2+</td></tr><tr><td style="text-align:center">type</td><td style="text-align:center">dichotomous</td><td style="text-align:center">interval / ratio / dichotomous</td></tr></tbody></table></div><ul><li><strong>Ordinal regression</strong></li></ul><div class="table-container"><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">dependent variable</th><th style="text-align:center">independent variable</th></tr></thead><tbody><tr><td style="text-align:center">amount</td><td style="text-align:center">1</td><td style="text-align:center">1+</td></tr><tr><td style="text-align:center">type</td><td style="text-align:center">ordinal<sup><a href="#fn_2" id="reffn_2">2</a></sup></td><td style="text-align:center">nominal<sup><a href="#fn_3" id="reffn_3">3</a></sup> or dichotomous</td></tr></tbody></table></div><blockquote id="fn_2"><sup>2</sup>. ordinal：有序，序数<a href="#reffn_2" title="Jump back to footnote [2] in the text."> &#8617;</a></blockquote><blockquote id="fn_3"><sup>3</sup>. nominal：名义<a href="#reffn_3" title="Jump back to footnote [3] in the text."> &#8617;</a></blockquote><ul><li><strong>Multinominal regression</strong></li></ul><div class="table-container"><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">dependent variable</th><th style="text-align:center">independent variable</th></tr></thead><tbody><tr><td style="text-align:center">amount</td><td style="text-align:center">1</td><td style="text-align:center">1+</td></tr><tr><td style="text-align:center">type</td><td style="text-align:center">nominal</td><td style="text-align:center">interval / ratio / dichotomous</td></tr></tbody></table></div><ul><li><strong>Discriminant analysis</strong><br>判别分析</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">dependent variable</th><th style="text-align:center">independent variable</th></tr></thead><tbody><tr><td style="text-align:center">amount</td><td style="text-align:center">1</td><td style="text-align:center">1+</td></tr><tr><td style="text-align:center">type</td><td style="text-align:center">nominal</td><td style="text-align:center">interval / ratio</td></tr></tbody></table></div><h2><span id="基本模型">基本模型</span></h2><script type="math/tex; mode=display">y=\beta_0+\beta_1x_1+\beta_2x_2+\cdots+\beta_px_p+\varepsilon</script><ul><li>因变量（regressand）：$y$</li><li>自变量（regressor）：$x_1,\cdots,x_p$<ul><li>是确定性变量，不是随机变量 </li></ul></li><li>随机误差项：$\varepsilon$</li><li>截距项（intercept）：$\beta_0$</li><li>回归系数（regression coefficient）</li></ul><p>考虑$n$个样本、$p$个自变量$(\mathbf{X}_1,\mathbf{X}_2,\cdots, \mathbf{X}_p)$</p><p>\begin{equation}<br>\textbf{y}=\textbf{X} \mathbf{\beta} + \mathbf{\varepsilon}, \qquad \mathbf{\varepsilon} \sim \mathcal{N}(\mathbf{0},\sigma^2\mathbf{I})<br>\end{equation}</p><p>其中</p><script type="math/tex; mode=display">\mathbf{X}=(\mathbf{1},\mathbf{X}_1,\mathbf{X}_2,\cdots, \mathbf{X}_p)=\left(\begin{array}{cccc}  1 & X_{11} & \cdots & X_{1p}\\  1 & X_{21} & \cdots & X_{2p}\\  \vdots & \vdots & \ddots & \vdots \\  1 & X_{n1} & \cdots & X_{np}\end{array}\right)</script><script type="math/tex; mode=display">\mathbf{\beta}=\left(\begin{array}{c}  \beta_0\\ \beta_1 \\ \vdots \\ \beta_p\end{array}\right),\qquad \mathbf{\varepsilon}=\left(\begin{array}{c}  \varepsilon_1 \\ \varepsilon_2 \\ \vdots \\ \varepsilon_n\end{array}\right)</script><h2><span id="基本假设">基本假设</span></h2><ol><li>自变量和因变量线性相关</li><li>自变量之间相互独立<ul><li>解释变量之间不存在（完全的）线性关系<script type="math/tex; mode=display">\mathrm{rank}(X)=p</script></li><li>若不满足，则模型具有<strong>多重共线性</strong>（Multicollinearity）</li></ul></li><li>随机误差项相互独立<ul><li>若不满足，则模型具有<strong>自相关性</strong>（Autocorrelation）</li></ul></li><li>$\varepsilon\sim i.i.d. N(0,\sigma^2)$<ul><li>随机误差项服从均值为零、方差为常数的正态分布</li><li>随机误差项独立同分布（i.i.d.，independent and identical distribution）<ul><li>随机误差项<strong>同方差</strong>（Homoskedasticity）；若不满足，则存在<strong>异方差性</strong>（Heteroskedasticity）</li></ul></li></ul></li><li>自变量和误差项之间相互独立</li></ol><h2><span id="参数估计">参数估计</span></h2><p>Linear regression:</p><script type="math/tex; mode=display">h_\beta(x)=\sum_{j=0}^p\beta_jx_j</script><p>where $x_0=1$.</p><p>Cost function:</p><script type="math/tex; mode=display">J(\beta)=\frac{1}{2n}\sum_{i=1}^n\left(h_\beta(x^{(i)})-y^{(i)}\right)^2</script><p>Objective function:</p><script type="math/tex; mode=display">\min_\beta J(\beta)</script><h3><span id="batch-gradient-descent">(Batch) Gradient Descent</span></h3><p>（全批量）梯度下降法<br>Linear Regression with <strong>(Batch) Gradient Descent</strong>：<br>repeat until convergence $\{$</p><script type="math/tex; mode=display">\beta_j:=\beta_j-\alpha\frac{1}{n}\sum_{i=1}^n\left(h_\beta(x^{(i)})-y^{(i)}\right)x_j^{(i)}</script><p>for $\forall$ $j=0,1,\cdots,p$.<br>$\}$</p><p>其中<br>$\alpha$为<strong>学习率/学习步长</strong>（learning rate）：</p><ul><li>决定了在每一步梯度下降迭代过程中，<ul><li>每一步沿梯度负方向前进的长度（如果是最小化目标函数）</li><li>每一步沿梯度正方向前进的长度（如果是最大化目标函数）</li></ul></li><li>学习率过小，需要迭代的步数较多，需要花费较多的学习时间</li><li>学习率过大，会导致迭代过快，容易出现点在最优点的左右反复横跳（可能错过最优点）</li><li>需要经过多次试验，选取较优的学习率/步长</li></ul><blockquote><p>learning rate, $\alpha$, basically controls how big step we take downhill with gradient descent. If $\alpha$ is large, then that corresponds to a very aggressive gradient descent procedure, where we’re trying to take huge steps downhill. And if $\alpha$ is very small, then we’re taking little, little baby steps downhill.——吴恩达-机器学习</p></blockquote><h2><span id="正则化">正则化</span></h2><p>若训练模型过于复杂，容易出现<strong>过拟合</strong>（overfitting）问题。</p><p>解决方法：</p><ol><li>减少特征的数量</li><li>降低特征的权重，即正则化</li></ol><p><strong>正则化</strong>（Regularization）：<br>原目标函数为</p><script type="math/tex; mode=display">\hat{\beta}=\arg\min_\beta\left\{\sum_{i=1}^n(y_i-\sum_{j=0}^p\beta_jx_{ij})^2\right\}</script><p>在原始目标函数上添加惩罚项（penalty term）</p><script type="math/tex; mode=display">\hat{\beta}=\arg\min_\beta\left\{\sum_{i=1}^n(y_i-\sum_{j=0}^p\beta_jx_{ij})^2+\lambda g(\beta)\right\}</script><h3><span id="岭回归">岭回归</span></h3><p>Ridge regression</p><script type="math/tex; mode=display">\hat{\beta}^{ridge}={\arg\min}_\beta\left\{\sum_{i=1}^n(y_i-\sum_{j=0}^p\beta_jx_{ij})^2+\lambda \sum_{j=1}^p\beta_j^2\right\}</script><ul><li>若自变量间存在严重的共线性问题，普通最小二乘法并不适用，可以选用岭回归方法</li></ul><h3><span id="lasso">Lasso</span></h3><script type="math/tex; mode=display">\hat{\beta}^{lasso}=\arg\min_\beta\left\{\sum_{i=1}^n(y_i-\sum_{j=0}^p\beta_jx_{ij})^2+\lambda \sum_{j=1}^p|\beta_j|\right\}</script><h3><span id="elastic-net">Elastic Net</span></h3><script type="math/tex; mode=display">\hat{\beta}^{EN}=\arg\min_\beta\left\{\sum_{i=1}^n(y_i-\sum_{j=0}^p\beta_jx_{ij})^2+\lambda_2 \sum_{j=1}^p\beta_j^2+\lambda_1 \sum_{j=1}^p|\beta_j|\right\}</script><h2><span id="残差">残差</span></h2><script type="math/tex; mode=display">e_i=y_i-\hat{y}_i</script><h2><span id="相关检验">相关检验</span></h2><h3><span id="dw检验">DW检验</span></h3><p>用于检验残差是否具有自相关性<br>Durbin-Watson统计量</p><script type="math/tex; mode=display">DW=\frac{\sum_{i=2}^n(e_i-e_{i-1})^2}{\sum_{i=1}^ne_i^2}</script><h3><span id="残差检验">残差检验</span></h3><h2><span id="平方和">平方和</span></h2><h3><span id="1-总平方和">1. 总平方和</span></h3><ul><li>总平方和</li><li>总离差平方和</li><li>SST (Sum of Squares Total)</li><li>TSS (Total Sum of Squares)<script type="math/tex; mode=display">\mathbf{\sum_{i=1}^n(y_i-\bar{y})^2}</script></li></ul><h3><span id="2-回归平方和">2. 回归平方和</span></h3><ul><li>回归平方和</li><li>解释平方和</li><li>SSR (Sum of Squares Regression)</li><li>ESS (Explained Sum of Squares)</li></ul><script type="math/tex; mode=display">\mathbf{\sum_{i=1}^n(\hat{y}_i-\bar{y})^2}</script><h3><span id="3-残差平方和">3. 残差平方和</span></h3><ul><li>残差平方和</li><li>SSE (Sum of Squared estimate of Errors/ Sum of Squares Error)</li><li>RSS (Residual Sum of Squares)</li><li>SSR (Sum of Squared Residuals)</li></ul><script type="math/tex; mode=display">\mathbf{\sum_{i=1}^n(y_i-\hat{y}_i)^2}</script><h3><span id="sstssrsse">SST=SSR+SSE</span></h3><ul><li>Simple linear regression情况<script type="math/tex; mode=display">y_i=\beta_0 +\beta_1 x_i+\varepsilon_i</script>\begin{equation}<br>\begin{aligned}<br>  SST&amp;=SSR+SSE\\<br>  SST&amp;=\sum_{i=1}^n(y_i-\bar{y})^2\\<br>  &amp;= \sum_{i=1}^n(y_i-\hat{y}_i+\hat{y}_i-\bar{y})^2\\<br>  &amp;= \sum_{i=1}^n(y_i-\hat{y}_i)^2 + 2\sum_{i=1}^n (y_i-\hat{y}_i)(\hat{y}_i-\bar{y})+ \sum_{i=1}^n(\hat{y}_i-\bar{y})^2\\<br>  &amp;= \sum_{i=1}^n(y_i-\hat{y}_i)^2 + \sum_{i=1}^n(\hat{y}_i-\bar{y})^2\\<br>  &amp;= SSR + SSE<br>\end{aligned}<br>\end{equation}</li></ul><p>下面证明</p><script type="math/tex; mode=display">\sum_{i=1}^n (y_i-\hat{y}_i)(\hat{y}_i-\bar{y})=0</script><p>在最小二乘法中，最小化$SSE$</p><script type="math/tex; mode=display">(\hat{\beta}_0,\hat{\beta}_1)=\arg \min_{\beta_0,\beta_1}\sum_{i=1}^n(y_i-\beta_0-\beta_1x_i)^2</script><p>$SSE$分别关于$\beta_0,\beta_1$求偏导<br>\begin{equation}<br>  \begin{aligned}<br>    \frac{\partial{SSE}}{\partial{\beta_0}}&amp;=\sum_{i=1}^n2(y_i-\beta_0-\beta_1x_i)(-1)=0\\<br>    \frac{\partial{SSE}}{\partial{\beta_1}}&amp;=\sum_{i=1}^n2(y_i-\beta_0-\beta_1x_i)(-x_i)=0<br>  \end{aligned}<br>\end{equation}<br>所以有</p><script type="math/tex; mode=display">\sum_{i=1}^n(y_i-\hat{\beta}_0-\hat{\beta}_1x_i)=0</script><script type="math/tex; mode=display">\sum_{i=1}^n(y_i-\hat{\beta}_0-\hat{\beta}_1x_i)x_i=0</script><p>因此<br>\begin{equation}<br>  \begin{aligned}<br>    \sum_{i=1}^n (y_i-\hat{y}_i)(\hat{y}_i-\bar{y})&amp;=\sum_{i=1}^n(y-\hat{\beta}_0-\hat{\beta}_1x_i)(\hat{\beta}_0+\hat{\beta}_1x_i-\bar{y})\\<br>    &amp;=(\hat{\beta}_0-\bar{y})\underline{\sum_{i=1}^n(y-\hat{\beta}_0-\hat{\beta}_1x_i)}+\hat{\beta}_1\underline{\sum_{i=1}^n(y-\hat{\beta}_0-\hat{\beta}_1x_i)x_i}\\<br>    &amp;=0<br>  \end{aligned}<br>\end{equation}</p><ul><li>Multiple linear regression情况<br>考虑$p$个自变量$({X}_1,{X}_2,\cdots, {X}_p)$<br>\begin{equation}<br>\textbf{y}=\textbf{X}{\beta} + {\varepsilon}, \qquad {\varepsilon} \sim \mathcal{N}(\mathbf{0},\sigma^2\mathbf{I})<br>\end{equation}<br>由最小二乘法得到的$\hat{\mathbf{\beta}}$满足<script type="math/tex; mode=display">\hat{\mathbf{\beta}}=\arg \min_{\mathbf{\beta}} \hat{\mathbf{\varepsilon}}^\prime \hat{\mathbf{\varepsilon}}=\arg \min_{\mathbf{\beta}} (\mathbf{y}-\mathbf{X}\mathbf{\beta})^\prime(\mathbf{y}-\mathbf{X}\mathbf{\beta})</script></li></ul><script type="math/tex; mode=display">\frac{\partial{\hat{\varepsilon}^\prime \hat{\varepsilon}}}{\partial{\beta}}=-2\mathbf{X}^\prime \mathbf{y}+2\mathbf{X}^\prime \mathbf{X}\mathbf{\beta}=\mathbf{0}</script><p>$\Longrightarrow$</p><script type="math/tex; mode=display">\hat{\beta}=(\mathbf{X}^\prime\mathbf{X})^{-1}\mathbf{X}^\prime \mathbf{y}</script><p>因此</p><script type="math/tex; mode=display">\hat{\mathbf{y}}=\mathbf{X}\hat{\mathbf{\beta}}=\mathbf{X}(\mathbf{X}^\prime\mathbf{X})^{-1}\mathbf{X}^\prime \mathbf{y}\triangleq \mathbf{H}\mathbf{y}</script><p>其中<br>$\mathbf{H}=\mathbf{X}(\mathbf{X}^\prime\mathbf{X})^{-1}\mathbf{X}^\prime$ 对称幂等，且$\mathbf{I}-\mathbf{H}$对称幂等。</p><p>\begin{equation}<br>  \begin{aligned}<br>    SST&amp;=(\textbf{y}-\bar{\textbf{y}})^\prime(\textbf{y}-\bar{\textbf{y}})\\<br>    SSR&amp;=(\hat{\textbf{y}}-\bar{\textbf{y}})^\prime(\hat{\textbf{y}}-\bar{\textbf{y}})\\<br>    SSE&amp;=(\textbf{y}-\hat{\textbf{y}})^\prime(\textbf{y}-\hat{\textbf{y}})<br>  \end{aligned}<br>\end{equation}<br>定义$\textbf{1}_n=(1,1,\cdots,1)^\prime$为元素全是1的 $n$ 维列向量，则均值算子为$\frac{\textbf{1}_n\textbf{1}_n^\prime}{n}$ （全是$\frac{1}{n}$ 的$n\times n$方阵），$\textbf{1}_n^\prime\textbf{1}_n=n$，且</p><script type="math/tex; mode=display">\left(\textbf{I}-\frac{\textbf{1}_n\textbf{1}_n^\prime}{n}\right)^\prime = \left(\textbf{I}-\frac{\textbf{1}_n\textbf{1}_n^\prime}{n}\right)</script><script type="math/tex; mode=display">\left(\textbf{I}-\frac{\textbf{1}_n\textbf{1}_n^\prime}{n}\right)^\prime\left(\textbf{I}-\frac{\textbf{1}_n\textbf{1}_n^\prime}{n}\right)=\textbf{I}-\frac{\textbf{1}_n\underline{\textbf{1}_n^\prime\textbf{1}_n}\textbf{1}_n^\prime}{n^2}=\left(\textbf{I}-\frac{\textbf{1}_n\textbf{1}_n^\prime}{n}\right)</script><p>即$\left(\textbf{I}-\frac{\textbf{1}_n\textbf{1}_n^\prime}{n}\right)$ 是对称幂等阵。则有<br>\begin{equation}<br>  \begin{aligned}<br>    \textbf{y}-\bar{\textbf{y}}&amp;=\left(\textbf{I}-\frac{\textbf{1}_n\textbf{1}_n^\prime}{n}\right)\textbf{y}\\<br>    \hat{\mathbf{y}}-\bar{\mathbf{y}}&amp;=\left(\mathbf{H}-\frac{\textbf{1}_n\textbf{1}_n^\prime}{n}\right)\mathbf{y}\\<br>    \textbf{y}-\hat{\textbf{y}}&amp;=(\mathbf{I}-\mathbf{H})\mathbf{y}\\<br>    SST&amp;=\textbf{y}^\prime\left(\textbf{I}-\frac{\textbf{1}_n\textbf{1}_n^\prime}{n}\right)^\prime \left(\textbf{I}-\frac{\textbf{1}_n\textbf{1}_n^\prime}{n}\right) \textbf{y}=\textbf{y}^\prime \left(\textbf{I}-\frac{\textbf{1}_n\textbf{1}_n^\prime}{n}\right) \textbf{y}\\<br>    SSR&amp;=\mathbf{y}^\prime\left(\mathbf{H}-\frac{\textbf{1}_n\textbf{1}_n^\prime}{n}\right)^\prime\left(\mathbf{H}-\frac{\textbf{1}_n\textbf{1}_n^\prime}{n}\right)\mathbf{y}=\mathbf{y}^\prime\left(\mathbf{H}-\frac{\textbf{1}_n\textbf{1}_n^\prime}{n}\right)\mathbf{y}\\<br>    SSE&amp;=\mathbf{y}^\prime (\mathbf{I}-\mathbf{H})^\prime (\mathbf{I}-\mathbf{H}) \mathbf{y}=\mathbf{y}^\prime (\mathbf{I}-\mathbf{H}) \mathbf{y}<br>  \end{aligned}<br>\end{equation}<br>所以 <script type="math/tex">SST=SSR+SSE</script></p><h1><span id="面试题">面试题</span></h1><ul><li>State the <strong>assumptions</strong> in linear regression model<blockquote><ul><li>自变量和因变量线性相关</li><li>自变量间相互独立</li><li>误差项间相互独立</li><li>误差项服从均值为零、方差为常数的比正态分布</li><li>自变量和误差项相互独立</li></ul></blockquote></li><li>How to avoid <strong>overfitting</strong> in linear regression?<blockquote><ul><li>减少特征的数量</li><li>减少自变量的权重，控制模型的复杂度。即，进行正则化<strong>Regularization</strong></li></ul></blockquote></li><li><p>Explain <strong>gradient descent</strong> with respect to linear regression</p></li><li><p>How to choose the value of the parameter <strong>learning rate</strong> $\alpha$?</p></li><li><p>How to choose the <strong>regularization parameter</strong>?</p></li></ul><p>未完</p><h1><span id="参考资料">参考资料</span></h1><p>[1] <a href="https://cn.bing.com/images/search?view=detailV2&amp;ccid=j0Y73Gqu&amp;id=AEF02E292E6BB108E395DACCC888AE85CFE435E2&amp;thid=OIP.j0Y73Gqu8shJ-xwd0dLzogHaD7&amp;mediaurl=https%3a%2f%2fcdn-images-1.medium.com%2fmax%2f2000%2f1*oXPGYqgTeIn0Ey3SWgkbsA.jpeg&amp;exph=865&amp;expw=1629&amp;q=regression&amp;simid=608039305763750244&amp;selectedIndex=4" target="_blank" rel="noopener">首页缩略图</a><br>[2] <a href="https://www.statisticssolutions.com/what-is-linear-regression/" target="_blank" rel="noopener">What is Linear Regression?</a><br>[3] <a href="https://www.dataapplab.com/linear-regression-5-quiz/" target="_blank" rel="noopener">Linear regression 5道经典必考题自测</a></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>编程题库</title>
    <link href="/2020/05/04/%E7%BC%96%E7%A8%8B%E9%A2%98%E5%BA%93/"/>
    <url>/2020/05/04/%E7%BC%96%E7%A8%8B%E9%A2%98%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<p>编程刷题记录</p><a id="more"></a><h1><span id="huawei">HUAWEI</span></h1><ul><li><a href="/2020/05/06/HUAWEI%E9%A2%98%E5%BA%93/" title="HUAWEI相关编程题库">HUAWEI相关编程题库</a></li></ul><h1><span id="pinduoduo">PINDUODUO</span></h1><ul><li><a href="/2020/05/06/%E6%8B%BC%E5%A4%9A%E5%A4%9A%E9%A2%98%E5%BA%93/" title="PinDuoDuo相关编程题库">PinDuoDuo相关编程题库</a></li></ul><h1><span id="无从属">无从属</span></h1><h2><span id="质数素数">质数/素数</span></h2><pre><code class="lang-Python">## 列出小于整数n的所有质数## 不导入模块n = 20[i for i in range(2, n) if 0 not in [i%j for j in range(2, int(i**0.5) + 1)]]# [2, 3, 5, 7, 11, 13, 17, 19]## 使用Python的模块[i for i in range(2, n) if 0 not in [i%j for j in range(2, int(math.sqrt(i)) + 1)]]# [2, 3, 5, 7, 11, 13, 17, 19]</code></pre><h2><span id="最大乘积">最大乘积</span></h2><ul><li>给定一个无序数组，包含正数、负数和0，要求从中找出3个数的乘积，使得乘积最大，要求时间复杂度：O(n)，空间复杂度：O(1)</li><li>输入共2行，第一行包括一个整数n，表示数组长度</li><li>第二行为n个以空格隔开的整数，分别为A1,A2, … ,An<blockquote><p>拼多多2018年校招内推编程题</p></blockquote></li></ul><pre><code class="lang-Python">while True:    try:        n = int(input())        lst = list(map(int, input().split()))        lst.sort()        print(max(lst[0]*lst[1]*lst[-1], lst[-3]*lst[-2]*lst[-1]))    except:        break</code></pre><h1><span id> </span></h1><p><a href>题目详情</a></p><pre><code class="lang-Python"></code></pre><h1><span id> </span></h1><p><a href>题目详情</a></p><pre><code class="lang-Python"></code></pre><h1><span id> </span></h1><p><a href>题目详情</a></p><pre><code class="lang-Python"></code></pre><h1><span id="参考资料">参考资料</span></h1><p>[1] <a href="https://cn.bing.com/images/search?view=detailV2&amp;ccid=8hu8uJ6w&amp;id=03F94B8D85C64E6F1EF23C9F3C91DB4C8F5822D3&amp;thid=OIP.8hu8uJ6wIQFmKueeKunj0wHaE8&amp;mediaurl=https%3a%2f%2fimages.idgesg.net%2fimages%2farticle%2f2019%2f02%2fabstract_binary_code_background_arrows_coding_programming_analytics_data_transfer_by_aleksei_derin_gettyimages-914850304_2400x1600-100788496-large.3x2.jpg&amp;exph=800&amp;expw=1200&amp;q=code&amp;simid=607994049680312069&amp;selectedIndex=6" target="_blank" rel="noopener">首页缩略图</a></p>]]></content>
    
    
    <categories>
      
      <category>藏宝库</category>
      
      <category>题库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python</title>
    <link href="/2020/05/03/Python/"/>
    <url>/2020/05/03/Python/</url>
    
    <content type="html"><![CDATA[<p>Python使用手册</p><a id="more"></a><h1><span id="基础">基础</span></h1><ul><li><a href="/2020/05/03/python-4-%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7/" title="运算符">运算符</a></li><li><a href="/2020/05/03/python-5-%E5%87%BD%E6%95%B0/" title="函数">函数</a></li><li><a href="/2020/05/03/python-6-%E5%BE%AA%E7%8E%AF/" title="循环">循环</a></li><li><a href="/2020/05/03/python-8-%E6%A8%A1%E5%9D%97/" title="模块">模块</a></li></ul><h1><span id="数据类型">数据类型</span></h1><ul><li><ul><li><a href="/2020/05/03/python-8-%E6%A8%A1%E5%9D%97/" title="模块">模块</a></li></ul></li></ul><h1><span id="模块">模块</span></h1><h2><span id="pip">pip</span></h2><h2><span id="collections">collections</span></h2><a href="/2020/05/05/python-collections%E6%A8%A1%E5%9D%97/" title="collections模块">collections模块</a><h2><span id="keras">keras</span></h2><a href="/2020/05/10/python-keras/" title="keras模块">keras模块</a><h2><span id="numpy">NumPy</span></h2><a href="/2020/05/10/python-numpy%E6%A8%A1%E5%9D%97/" title="NumPy">NumPy</a><h2><span id="pyecharts">pyecharts</span></h2><a href="/2020/05/08/python-pyecharts%E6%A8%A1%E5%9D%97/" title="pyecharts模块">pyecharts模块</a><h2><span id="re">re</span></h2><a href="/2020/05/03/python-re%E6%A8%A1%E5%9D%97/" title="re模块">re模块</a>]]></content>
    
    
    <categories>
      
      <category>软件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Machine Learning-汇总</title>
    <link href="/2020/05/02/Machine-Learning-%E6%B1%87%E6%80%BB/"/>
    <url>/2020/05/02/Machine-Learning-%E6%B1%87%E6%80%BB/</url>
    
    <content type="html"><![CDATA[<p>Machine Learning 算法汇总</p><a id="more"></a><h1><span id="machine-learning">Machine Learning</span></h1><ul><li>Classical Learning<ul><li>Supervised Learning</li><li>Unsupervised Learning</li></ul></li><li>Ensemble Methods<ul><li>Bagging</li><li>Boosting</li><li>Stacking</li></ul></li><li>Reinforcement Learning</li><li>Neural Networks and Deep Learning</li></ul><h2><span id="classical-learning">Classical Learning</span></h2><ul><li>Supervised Learning<ul><li>Classification</li><li>Regression</li></ul></li><li>Unsupervised Learning<ul><li>Clustering</li><li>Pattern Search</li><li>Dimension Reduction</li></ul></li></ul><h3><span id="supervised-learning">Supervised Learning</span></h3><h4><span id="classification">Classification</span></h4><ul><li>K-NN</li><li>Naive Bayes</li><li>SVM</li><li>Decision Tree</li><li>Logistic Regression</li></ul><h5><span id="k-nn">K-NN</span></h5><h5><span id="naive-bayes">Naive Bayes</span></h5><h5><span id="svm">SVM</span></h5><ul><li><a href="/2020/04/28/%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/" title="支持向量机">支持向量机</a> Support Vector Machine</li></ul><h5><span id="decision-tree">Decision Tree</span></h5><ul><li><a href="/2020/04/28/%E5%86%B3%E7%AD%96%E6%A0%91/" title="决策树">决策树</a></li></ul><h5><span id="logistic-regression">Logistic Regression</span></h5><h4><span id="regression">Regression</span></h4><ul><li>Linear Regression</li><li>Ridge/Lasso Regression</li></ul><h5><span id="linear-regression">Linear Regression</span></h5><ul><li><a href="/2020/05/04/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/" title="线性回归">线性回归</a><h5><span id="ridgelasso-regression">Ridge/Lasso Regression</span></h5><h3><span id="unsupervised-learning">Unsupervised Learning</span></h3><h4><span id="clustering">Clustering</span></h4></li><li>K-Means</li><li>Mean-Shift</li><li>DBSCAN</li><li>OPTICS</li><li>Agglomerative</li><li>Fuzzy C-Means</li></ul><h5><span id="k-means">K-Means</span></h5><h5><span id="mean-shift">Mean-Shift</span></h5><h5><span id="dbscan">DBSCAN</span></h5><h5><span id="optics">OPTICS</span></h5><h5><span id="agglomerative">Agglomerative</span></h5><h5><span id="fuzzy-c-means">Fuzzy C-Means</span></h5><h4><span id="pattern-search">Pattern Search</span></h4><ul><li>Euclat</li><li>Apriori</li><li>FP-Growth</li></ul><h5><span id="euclat">Euclat</span></h5><h5><span id="apriori">Apriori</span></h5><h5><span id="fp-growth">FP-Growth</span></h5><h4><span id="dimension-reduction">Dimension Reduction</span></h4><ul><li>t-SNE</li><li>PCA</li><li>LSA</li><li>SVD</li><li>LDA</li></ul><h5><span id="t-sne">t-SNE</span></h5><h5><span id="pca">PCA</span></h5><h5><span id="lsa">LSA</span></h5><h5><span id="svd">SVD</span></h5><h5><span id="lda">LDA</span></h5><h2><span id="ensemble-methods">Ensemble Methods</span></h2><ul><li>Bagging</li><li>Boosting</li><li>Stacking</li></ul><h4><span id="bagging">Bagging</span></h4><ul><li>Random Forest</li></ul><h5><span id="random-forest">Random Forest</span></h5><ul><li><a href="/2020/04/28/%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/" title="随机森林">随机森林</a></li></ul><h4><span id="boosting">Boosting</span></h4><ul><li>AdaBoost</li><li>XGBoost</li><li>LightGBM</li><li>CatBoost</li></ul><h5><span id="adaboost">AdaBoost</span></h5><h5><span id="xgboost">XGBoost</span></h5><h5><span id="lightgbm">LightGBM</span></h5><h5><span id="catboost">CatBoost</span></h5><h4><span id="stacking">Stacking</span></h4><h2><span id="reinforcement-learning">Reinforcement Learning</span></h2><ul><li>Genetic Algorithm</li><li>A3C</li><li>SARSA</li><li>Q-Learning</li><li>DQN</li></ul><h3><span id="genetic-algorithm">Genetic Algorithm</span></h3><h3><span id="a3c">A3C</span></h3><h3><span id="sarsa">SARSA</span></h3><h3><span id="q-learning">Q-Learning</span></h3><h3><span id="dqn">DQN</span></h3><p>Deep Q-Network</p><h2><span id="neural-nets-and-deep-learning">Neural Nets and Deep Learning</span></h2><ul><li>CNN</li><li>RNN</li><li>GAN</li><li>Autoencoders</li><li>MLP</li></ul><h3><span id="cnn">CNN</span></h3><h3><span id="rnn">RNN</span></h3><ul><li>LSM</li><li>LSTM</li><li>GRU</li></ul><h4><span id="lsm">LSM</span></h4><h4><span id="lstm">LSTM</span></h4><h4><span id="gru">GRU</span></h4><ul><li>GAN</li><li>Autoencoders</li><li>Perceptrons (MLP)</li></ul><h3><span id="gan">GAN</span></h3><p>Generative Adversarial Nerworks</p><h3><span id="autoencoders">Autoencoders</span></h3><p>seq2seq</p><h3><span id="perceptrons-mlp">Perceptrons (MLP)</span></h3><h1><span id="参考资料">参考资料</span></h1><p>[1] <a href="https://cn.bing.com/images/search?view=detailV2&amp;ccid=k5LiTi5l&amp;id=95DF77DEC29B1CD7083F9435F1AE55043B0C0081&amp;thid=OIP.k5LiTi5lt_ND02kaBT_SAAHaE7&amp;mediaurl=https%3a%2f%2fwww.smartdatacollective.com%2fwp-content%2fuploads%2f2018%2f11%2fMachine-learning-1024x682.jpg&amp;exph=682&amp;expw=1024&amp;q=machine+learning&amp;simid=608018054240865990&amp;selectedIndex=3" target="_blank" rel="noopener">首页缩略图</a></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据分析业务向-问题和方法汇总</title>
    <link href="/2020/05/02/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%9A%E5%8A%A1%E5%90%91-%E9%97%AE%E9%A2%98%E5%92%8C%E6%96%B9%E6%B3%95%E6%B1%87%E6%80%BB/"/>
    <url>/2020/05/02/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%9A%E5%8A%A1%E5%90%91-%E9%97%AE%E9%A2%98%E5%92%8C%E6%96%B9%E6%B3%95%E6%B1%87%E6%80%BB/</url>
    
    <content type="html"><![CDATA[<p>Data Analyst<br><a id="more"></a></p><h1><span id="数据分析">数据分析</span></h1><p>数据分析的<strong>本质</strong>是<u>解决某一个业务问题</u>。</p><p>数据分析的步骤：</p><ol><li>明确分析的目的</li><li>要了解数据来源的相关信息，包括各项指标的定义、采集点和上报机制<sup><a href="#fn_1" id="reffn_1">1</a></sup></li><li></li></ol><blockquote id="fn_1"><sup>1</sup>. 上报机制：是指数据上报的时机、内容和技术实现形式<a href="#reffn_1" title="Jump back to footnote [1] in the text."> &#8617;</a></blockquote><p>在数据来源正确的前提下，进行数据分析的方法可分为</p><ul><li><strong>定性分析</strong>：对事物的性质作出判断——“是什么”</li><li><strong>定量分析</strong>：对事物的数量作出统计——“有多少”</li></ul><p>数据分析就是定性分析与定量分析相互结合、不断验证的过程。<br>提出假设、设计方案、分析数据、验证或推翻假设，最后抽丝剥茧，逐渐接近真相。</p><p><strong>用户研究</strong>：通过对网站访问量、应用行为统计登数据的分析，从中发现用户使用产品的情况，从中总结出一定的规律和趋势，供其他部门（市场营销、产品规划等）制定决策用。</p><h1><span id="问题">问题</span></h1><ul><li><a href="/2020/05/01/%E8%B4%B9%E7%B1%B3%E9%97%AE%E9%A2%98/" title="费米问题">费米问题</a></li><li><a href="/2020/05/02/%E6%8C%87%E6%A0%87%E5%BC%82%E5%8A%A8%E7%B1%BB%E9%97%AE%E9%A2%98/" title="指标异动类问题">指标异动类问题</a></li><li><a href="/2020/05/02/VIP%E4%BC%9A%E5%91%98%E5%A5%97%E9%A4%90%E5%AE%9A%E4%BB%B7%E7%AD%96%E7%95%A5/" title="VIP会员套餐定价策略">VIP会员套餐定价策略</a></li><li></li></ul><h1><span id="方法">方法</span></h1><ul><li><a href="/2020/05/07/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90-AARRR%E6%A8%A1%E5%9E%8B/" title="AARRR模型">AARRR模型</a></li></ul><h1><span id="指标定义">指标/定义</span></h1><ul><li><p><strong>获客成本</strong>（CAC，）</p></li><li><p>访问路径（FR，Flow Report）：用户在网站上的访问行为，各个页面的进入率和跳出率</p></li></ul><ul><li><p><strong>用户生命周期价值</strong>（LTV）</p></li><li><p>最小可行性产品（MVP）</p></li><li>PMF（Product/Market Fit）：产品与市场相契合的状态</li><li><p>点击付费广告（PPC，Pay Per Click）</p></li><li><p><strong>页面浏览量</strong>（PV，Page View）：网站在某一段时间内的页面浏览量是多少</p></li></ul><ul><li>搜索引擎优化（SEO，Search Engine Optimization）</li><li><p>渠道来源（Traffic Sources）：用户流量来源于哪些不同的渠道</p></li><li><p>访客特征（UD，User Demographics）：访问用户具有哪些特征值，可用来做用户分类</p></li><li><strong>用户浏览量</strong>（UV，User View）：网站在某一段时间内的用户浏览量是多少</li></ul><h1><span id="不同行业">不同行业</span></h1><h2><span id="电商">电商</span></h2><p>电商用户的转化漏斗一般是：</p><p><pre class="mermaid">graph LR;    访问--> 注册;    注册-->搜索;    搜索-->浏览;    浏览-->加入购物车;    加入购物车-->支付;</pre><br>以及可能的“未来的退货”。</p><h2><span id="在线旅游">在线旅游</span></h2><h2><span id="求职网站">求职网站</span></h2><ul><li><a href="/2020/05/07/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90-LinkedIn/" title="LinkedIn">LinkedIn</a></li><li></li></ul><p>求职网站变现的三种思路：</p><ol><li>用户信息收费</li><li>用人企业发布广告费用</li><li>猎头借助平台寻找精英的数据使用费用</li></ol><p>用户增长渠道：</p><ul><li>电子邮件邀请<br>用户被动地接受信息</li><li>搜索<br>用户主动地获取信息</li></ul><h2><span id="即时通信">即时通信</span></h2><h3><span id="陌陌">陌陌</span></h3><ul><li>主推陌生人交友特性，基于地理位置的“看附近的人”是其早期引爆增长的卖点</li><li>陌陌内部对每天“活跃用户”的定义是“登录成功并提交地理位置一次”</li></ul><h2><span id="其他">其他</span></h2><p>初创公司的常见问题：</p><ul><li>如何提升转化率？</li><li>如何提高留存度？<br>早期进来的用户一般是核心用户，留存度相对较高；后期拉来的用户相对黏度比较低。</li><li>创业公司不同阶段如何用好数据？<br>早期靠直觉，后期靠科学</li></ul><h1><span id="工具">工具</span></h1><h2><span id="ab-test">A/B test</span></h2><ul><li>网站Optimize.ly</li><li>网站Unbouce</li></ul><h2><span id="应用统计分析">应用统计分析</span></h2><p>移动应用统计分析平台：</p><ul><li>Google Analytics</li><li>友盟</li><li>Talking Data</li></ul><h1><span id="参考资料">参考资料</span></h1><p>[1] <a href="https://cn.bing.com/images/search?view=detailV2&amp;ccid=OeAo7X3d&amp;id=8DE4FFE2C9784F70995A7259FAA0FE7BC2FDC0BD&amp;thid=OIP.OeAo7X3dW94x7RoxwI0P_AHaEU&amp;mediaurl=http%3a%2f%2fwww.appadhoc.com%2fblog%2fwp-content%2fuploads%2f2017%2f02%2fwebanalysis.png&amp;exph=350&amp;expw=600&amp;q=%e6%95%b0%e6%8d%ae%e5%88%86%e6%9e%90&amp;simid=607999727637630187&amp;selectedIndex=42" target="_blank" rel="noopener">首页缩略图</a><br>[2] <a href="http://blog.growingio.com/growth/298" target="_blank" rel="noopener">增长秘籍：互联网增长的第一本数据分析手册</a><br>[3] <a href="https://book.douban.com/subject/27593848/" target="_blank" rel="noopener">增长黑客</a><br>[4] <a href="https://mp.weixin.qq.com/s/XJPZtgA1owg7noLORLcMHw" target="_blank" rel="noopener">一套数据分析的实用方法论</a></p>]]></content>
    
    
    <categories>
      
      <category>数据分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据分析</tag>
      
      <tag>业务向</tag>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>树</title>
    <link href="/2020/05/01/%E6%A0%91/"/>
    <url>/2020/05/01/%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<p>Tree</p><p><meta name="referrer" content="no-referrer"><br><a id="more"></a></p><p>一对多的数据结构——树</p><h1><span id="树">树</span></h1><h2><span id="树">树</span></h2><p><strong>树</strong>（Tree）是$n$个结点的有限集。</p><ul><li><strong>空树</strong>：$n=0$</li><li><p><strong>非空树</strong>：</p><ul><li>$n&gt;0$</li><li>有且仅有一个特定的<strong>根结点</strong>（Root）</li><li>当$n&gt;1$时，其余结点可分为$m(m&gt;0)$个互不相交的有限集$T_1,\cdots,T_m$；其中每一个集合自身是一棵树，称之为根的<strong>子树</strong>（SubTree）</li></ul></li><li><p><strong>有序树</strong><br>如果树中结点的各子树从左至右是有次序的、不能互换左右子树的，则该树为有序树</p></li><li><strong>无序树</strong><br>树中结点可互换左右子树，则该树为无序树</li></ul><h2><span id="森林">森林</span></h2><p><strong>森林</strong>（Forest）：$m$棵互不相交的树的集合</p><ul><li>树中的每个结点的子树的集合就是森林</li></ul><h1><span id="结点">结点</span></h1><p>树的<strong>结点</strong>（Node）包含一个数据元素及若干指向其子树的分支。</p><h2><span id="度">度</span></h2><p>结点拥有的子树的数目称为结点的<strong>度</strong>（Degree）。</p><ul><li><strong>叶结点</strong>（Leaf）：度为0的结点</li><li><strong>非终端结点/分支结点</strong>：度不为0的结点</li><li><strong>内部结点</strong>：除根结点外的分支结点</li></ul><p><strong>树的度</strong>是指树内各结点的度的最大值。</p><h2><span id="结点间关系">结点间关系</span></h2><ul><li><strong>Child</strong>：结点的子树的根，称为该结点的Child</li><li><strong>Parent</strong>：Child的前一个结点称为Child的Parent</li><li><strong>Sibling</strong>：同一个Parent的Child之间互称Sibling（兄弟）</li><li><strong>祖先</strong>：某结点的祖先是从根结点（Root）到该结点所经分支上的所有结点</li><li><strong>子孙</strong>：以某结点为根的所有子树的结点都称为该结点的子孙</li><li><strong>堂兄弟</strong>：双亲在同一层的结点互为堂兄弟</li></ul><h2><span id="层次">层次</span></h2><p>结点的<strong>层次</strong>（Level）：从根开始，根为第一层；根的孩子为第二层；第二层结点的孩子（第二层结点的子树的根）所在的为第三层；依此类推。</p><p>树的<strong>深度</strong>（Depth）或<strong>高度</strong>：树中结点的最大层次</p><h1><span id="二叉树">二叉树</span></h1><p><strong>二叉树</strong>（Binary Tree）：$n$个结点的有限集合</p><ul><li><strong>空二叉树</strong>：$n=0$</li><li>由一个根结点和两棵互不相交的二叉树组成。这两棵二叉树称为根结点的<strong>左子树</strong>和<strong>右子树</strong></li></ul><p>二叉树的<strong>特点</strong>：</p><ul><li>每个结点最多有2棵子树。即，二叉树的所有结点的度$\leq2$</li><li>二叉树是<u>有序树</u>。左子树和右子树的次序不能任意颠倒</li><li>即使某个结点的子树只有一棵，也必须区分它是左子树还是右子树</li></ul><p>二叉树可能的<strong>基本形态</strong>：</p><ol><li>空二叉树（$n=0$）</li><li>只有一个根结点（$n=1$）</li><li>根结点只有左子树（$n=2$）</li><li>根结点只有右子树（$n=2$）</li><li>根结点既有左子树又有右子树（$n\geq3$）</li></ol><blockquote><p>具有2个结点的二叉树的可能形态有2种<br>具有3个结点的二叉树的可能形态有5种</p></blockquote><h2><span id="斜树">斜树</span></h2><p>左斜树和右斜树统称为斜树。</p><ul><li><strong>左斜树</strong>：所有结点都只有左子树的二叉树</li><li><strong>右斜树</strong>：所有结点都只有右子树的二叉树<ul><li>斜树的每一层都只有一个结点</li><li>斜树的结点个数与树的深度相同</li></ul></li></ul><h2><span id="满二叉树">满二叉树</span></h2><p>所有分支结点都存在左子树和右子树、所有叶子结点都在同一层上的二叉树称为<strong>满二叉树</strong>(Full Binary Tree)。</p><p>满二叉树的<strong>特点</strong>：</p><ul><li>叶子结点只能出现在最底层</li><li>非叶子结点的度一定为2</li><li>在同样深度的二叉树中，满二叉树的结点个数最多、叶子结点数最多</li></ul><h2><span id="完全二叉树">完全二叉树</span></h2><p>定义（待补充）(Complete Binary Tree)</p><ul><li>满二叉树一定是一棵完全二叉树</li><li>完全二叉树不一定是满二叉树</li></ul><p>完全二叉树的<strong>特点</strong>：</p><ul><li>叶子结点只能出现在最底两层</li><li>最底层的叶子结点一定集中在左部连续位置（？？）</li><li>倒数第二层，若有叶子结点，一定都在右部连续位置（？？）</li><li>完全二叉树不存在只有右子树的情况</li><li>同样结点数的二叉树，完全二叉树的深度最小</li></ul><h2><span id="平衡二叉树">平衡二叉树</span></h2><p><strong>平衡二叉树</strong>（BT，Balance Tree），又称<strong>AVL树</strong>：是一棵空树，或它的左右子树的高度差的绝对值不超过1，且左右子树都是一棵平衡二叉树</p><h2><span id="二叉树性质">二叉树性质</span></h2><ol><li>二叉树的第$i$层上最多有$2^{i-1}$个结点（$i\geq 1$）</li><li>深度为$k$的二叉树最多有$2^k-1$个结点（$k\geq1$）<ul><li>$k=1$：最多有$1(2^1-1)$个结点</li><li>$k=1$：最多有$1+2=3(2^2-1)$个结点</li><li>$k=2$：最多有$1+2+2^2=7(2^3-1)$个结点</li><li>……</li><li>对任意的$k$，最多有$2^0+2^1+\cdots+2^k=2^k-1$个结点</li></ul></li><li>对任意一棵二叉树$T$，有$n_0$个叶子结点（度为0）、$n_2$个度为2的结点，则有$n_1=n_2+1$<ul><li>度为0的结点数为$n_0$</li><li>度为1的结点数为$n_1$</li><li>度为2的结点数为$n_2$<ul><li>二叉树的结点的度最多为2，所以树$T$的结点总数为<script type="math/tex; mode=display">n=n_0+n_1+n_2</script></li></ul></li><li>只有根结点没有连接线进入，其他结点都有连接线进入，所以连接线总数为$n-1$</li><li>度为1的结点有一条向下的连接线，度为2的结点有2条向下的连接线，度为0的结点没有向下的连接线，所以连接线总数为$n_1+2n_2$<ul><li>连接线总数为<script type="math/tex; mode=display">n_L=n-1=n_1+2n_2</script></li></ul></li><li>由上面两个等式可得<script type="math/tex; mode=display">n_0=n_2+1</script></li></ul></li><li>具有$n$个结点的完全二叉树的深度为$[\log_2{n}]+1$（$[x]$表示不大于$x$的最大整数）<ul><li>深度为$k$的满二叉树的结点数为$n=2^k-1$</li><li>有$n$个结点的满二叉树的深度为$k=\log_2{(n+1)}$</li><li>完全二叉树的叶子结点只可能出现在最下面两层，则深度为$k$的完全二叉树的结点数$n$一定多于深度为$k-1$的满二叉树、不多于深度为$k$的满二叉树。即<script type="math/tex; mode=display">2^{k-1}-1<n\leq2^k-1</script>  也即<script type="math/tex; mode=display">2^{k-1}\leq n<2^k</script><script type="math/tex; mode=display">k-1\leq\log_2n<k</script>  所以有<script type="math/tex">k=[\log_2n]+1</script></li></ul></li><li>对一棵有$n$个结点的完全二叉树（深度为$[\log_2n]+1$）的结点按层序编号（从第1层到第$[\log_2n]+1$层，每层从左到右），对任一结点$i(1\leq i\leq n)$有：<ul><li>如果$i=1$，则结点$i$为二叉树的根结点，无双亲（Parent）</li><li>如果$i&gt;1$，则结点$i$的双亲是$[\frac{i}{2}]$</li><li>如果$2i&gt;n$，则结点$i$为叶子结点、无左孩子（Left Child）；否则其左孩子是结点$2i$</li><li>如果$2i+1&gt;n$，则结点$i$为叶子结点、无右孩子（Right Child）；否则其右孩子是结点$2i+1$</li></ul></li></ol><h2><span id="二叉树的存储结构">二叉树的存储结构</span></h2><h3><span id="顺序存储">顺序存储</span></h3><ul><li>用一维数组存储二叉树中的结点，数组的下标是结点的存储位置</li><li>深度为$k$的二叉树的顺序存储有$2^k-1$个存储单元空间</li><li>顺序存储结构一般只用于完全二叉树</li></ul><h3><span id="二叉链表">二叉链表</span></h3><ul><li>一个数据域（存储结点）、两个指针域（分别存储left child和right child）的链式存储结构</li></ul><h2><span id="二叉树的遍历">二叉树的遍历</span></h2><p>遍历二叉树（traversing binary tree）是指从根结点（Root）出发，按照某种次序依次访问二叉树中的所有结点，使得每个结点被访问一次、且只被访问一次。</p><ul><li>已知前序遍历序列和中序遍历序列，可以唯一确定一棵二叉树</li><li>已知后序遍历序列和中序遍历序列，可以唯一确定一棵二叉树</li><li>已知前序和后序遍历序列，不能确定一棵二叉树</li></ul><h3><span id="前序遍历">前序遍历</span></h3><ul><li>二叉树为空<blockquote><p>返回空</p></blockquote></li><li>二叉树非空<blockquote><script type="math/tex; mode=display">根结点 \rightarrow前序遍历左子树 \rightarrow 前序遍历右子树</script><script type="math/tex; mode=display">中\rightarrow左\rightarrow右</script></blockquote></li></ul><p><meta name="referrer" content="no-referrer"><br><img src="/2020/05/01/%E6%A0%91/preorder.png" srcset="/img/loading.gif" class title="前序遍历"></p><script type="math/tex; mode=display">1→2→4→5→3→6→7</script><h3><span id="中序遍历">中序遍历</span></h3><ul><li>二叉树为空<blockquote><p>返回空</p></blockquote></li><li>二叉树非空<blockquote><script type="math/tex; mode=display">中序遍历根结点的左子树\rightarrow根结点\rightarrow中序遍历右子树</script><script type="math/tex; mode=display">左\rightarrow中\rightarrow右</script></blockquote></li></ul><p><meta name="referrer" content="no-referrer"><br><img src="/2020/05/01/%E6%A0%91/inorder.png" srcset="/img/loading.gif" class title="中序遍历"></p><script type="math/tex; mode=display">4→2→5→1→6→3→7</script><h3><span id="后序遍历">后序遍历</span></h3><ul><li>二叉树为空<blockquote><p>返回空</p></blockquote></li><li>二叉树非空<blockquote><script type="math/tex; mode=display">后序遍历左子树\rightarrow后序遍历右子树\rightarrow根结点</script><script type="math/tex; mode=display">左\rightarrow右\rightarrow中</script></blockquote></li></ul><p><meta name="referrer" content="no-referrer"><br><img src="/2020/05/01/%E6%A0%91/postorder.png" srcset="/img/loading.gif" class title="后序遍历"></p><script type="math/tex; mode=display">4→5→2→6→7→3→1</script><h3><span id="层序遍历">层序遍历</span></h3><ul><li>二叉树为空<blockquote><p>返回空</p></blockquote></li><li>二叉树非空<blockquote><p>从根结点、从上往下逐层遍历；在同一层，按从左到右的顺序对结点逐个访问</p></blockquote></li></ul><p><meta name="referrer" content="no-referrer"><br><img src="/2020/05/01/%E6%A0%91/cneg.png" srcset="/img/loading.gif" class title="层序遍历"></p><script type="math/tex; mode=display">1→2→3→4→5→6→7</script><h1><span id="赫夫曼">赫夫曼</span></h1><h2><span id="赫夫曼树">赫夫曼树</span></h2><h2><span id="赫夫曼编码">赫夫曼编码</span></h2><h1><span id="二叉查找树">二叉查找树</span></h1><p><strong>二叉搜索树/二叉查找树</strong>（Binary Search Tree）</p><ul><li>是一种数据结构</li><li>不能随机访问</li></ul><p>左子树上所有结点的值均小于根结点的值，而右子树上所有结点的值均大于根结点的值（？？？）</p><h2><span id="运行时间">运行时间</span></h2><ul><li>平均运行时间为$O(\log{n})$</li><li>最糟的运行时间为$O(n)$</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">数组</th><th style="text-align:center">二叉查找树</th></tr></thead><tbody><tr><td style="text-align:center">查找</td><td style="text-align:center">$O(\log{n})$</td><td style="text-align:center">$O(\log{n})$</td></tr><tr><td style="text-align:center">插入</td><td style="text-align:center">$O(n)$</td><td style="text-align:center">$O(\log{n})$</td></tr><tr><td style="text-align:center">删除</td><td style="text-align:center">$O(n)$</td><td style="text-align:center">$O(\log{n})$</td></tr></tbody></table></div><h1><span id="最小生成树">最小生成树</span></h1><p><strong>最小生成树</strong>（MST，Minimum Spanning Tree）：一个有$n$个结点的连通图的生成树是原图的极小连通子图，且包含原图中的所有$n$个结点，并且有保持图连通的最少的边。</p><ul><li>一个图可以有许多棵不同的生成树</li><li>生成树的定点数与图的定点数相同</li><li>生成树是图的<strong>极小连通子图</strong>，去掉一条边则非连通</li><li>一个有$n$个顶点的连通图的生成树有$n-1$条边</li><li>含$n$个顶点、$n-1$条边的图不一定是生成树</li></ul><h2><span id="实现">实现</span></h2><p>可用</p><ul><li>克鲁斯卡尔算法（Kruskal）</li><li>普里姆算法（Prim）<br>实现</li></ul><p>B树、红黑树、堆、伸展树</p><p>未完</p><h1><span id="参考资料">参考资料</span></h1><p>[1] <a href="https://cn.bing.com/images/search?view=detailV2&amp;ccid=XefGGltQ&amp;id=E54C3AB5E5AE8818E00FAF3812C8D0BED63054FB&amp;thid=OIP.XefGGltQanM0KYZIyOSEZQHaHV&amp;mediaurl=http%3a%2f%2fupload-images.jianshu.io%2fupload_images%2f1115031-7020c17d7a881499.jpg%3fimageMogr2%2fauto-orient%2fstrip%257CimageView2%2f2%2fw%2f1240&amp;exph=1228&amp;expw=1240&amp;q=%e4%ba%8c%e5%8f%89%e6%a0%91+%e6%89%8b%e7%bb%98&amp;simid=608032377976981561&amp;selectedIndex=0" target="_blank" rel="noopener">首页缩略图</a><br>[2] <a href="https://book.douban.com/subject/6424904/" target="_blank" rel="noopener">大话数据结构</a><br>[3] <a href="https://www.cnblogs.com/songwenjie/p/8955856.html" target="_blank" rel="noopener">【图解数据结构】二叉树遍历</a><br>[4] <a href="https://book.douban.com/subject/26979890/" target="_blank" rel="noopener">图解算法</a><br>[5] <a href="https://baijiahao.baidu.com/s?id=1646617486319372351&amp;wfr=spider&amp;for=pc" target="_blank" rel="noopener">一文读懂平衡二叉树</a><br>[6] <a href="https://my.oschina.net/u/4365394/blog/3234185/print" target="_blank" rel="noopener">最小生成树</a></p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Data Cleaning Projects</title>
    <link href="/2020/04/30/Data-Cleaning-Projects/"/>
    <url>/2020/04/30/Data-Cleaning-Projects/</url>
    
    <content type="html"><![CDATA[<p>Data Cleansing Projects 汇总</p><a id="more"></a><ul><li><a href="/2020/04/30/data-clean-Titanic/" title="数据集Titanic">数据集Titanic</a></li></ul><h4><span id="参考资料">参考资料</span></h4><p>[1] <a href="https://cn.bing.com/images/search?view=detailV2&amp;ccid=gpCSzLGU&amp;id=1898D7F14E27BFCC00B895A307ECC5F04313DE94&amp;thid=OIP.gpCSzLGUdIzn2Pkx-1iVFAHaEN&amp;mediaurl=https%3a%2f%2fpublic.tableau.com%2fs%2fsites%2fdefault%2ffiles%2fmedia%2fdata-cleaning-thumb2_20.jpg&amp;exph=766&amp;expw=1349&amp;q=data+cleaning&amp;simid=608010194433082183&amp;selectedIndex=175" target="_blank" rel="noopener">首页缩略图</a></p>]]></content>
    
    
    <categories>
      
      <category>Projects</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Cleaning</tag>
      
      <tag>Python</tag>
      
      <tag>R</tag>
      
      <tag>Projects</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Jupyter Notebook使用技巧</title>
    <link href="/2020/04/30/Jupyter-Notebook%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
    <url>/2020/04/30/Jupyter-Notebook%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/</url>
    
    <content type="html"><![CDATA[<p>Jupyter Tips!</p><a id="more"></a><h3><span id="输出结果显示图片">输出结果显示图片</span></h3><pre><code class="lang-Python">%matplotlib inline</code></pre><h3><span id="同时输出多个命令的结果">同时输出多个命令的结果</span></h3><ol><li>方法一：在文件开头添加以下命令（仅对当前文件有效）<pre><code class="lang-Python">from IPython.core.interactiveshell import InteractiveShellInteractiveShell.ast_node_interactivity = &quot;all&quot;</code></pre></li><li>方法二：直接添加配置文件（对所有文件有效）<pre><code class="lang-Python">vi ~/.ipython/profile_default/ipython_config.py</code></pre>配置文件内容为：<pre><code class="lang-python">c = get_config()#Run all nodes interactivelyc.InteractiveShell.ast_node_interactivity = &quot;all&quot;</code></pre></li></ol><h3><span id="安装r-kernel">安装R kernel</span></h3><p>先在R中安装以下几个package：</p><pre><code class="lang-R">install.packages(c(&#39;repr&#39;, &#39;IRdisplay&#39;, &#39;evaluate&#39;, &#39;crayon&#39;,                    &#39;pbdZMQ&#39;, &#39;devtools&#39;, &#39;uuid&#39;, &#39;digest&#39;))devtools::install_github(&#39;IRkernel/IRkernel&#39;)</code></pre><p>在Anaconda Prompt中输入以下命令：<br>第一步：输入R，调用R</p><pre><code>R</code></pre><p>第二步：安装R kernel，有2种方式（自由选择，个人建议第二种）：</p><ol><li>直接安装在当前用户中：<pre><code class="lang-r">IRkernel::installspec()</code></pre></li><li>安装在系统中：<pre><code class="lang-r">IRkernel::installspec(user = FALSE)</code></pre></li></ol><h3><span id="运行时间">运行时间</span></h3><p>在cell中添加 <code>%%time</code> ，返回结果中会含有cell单次运行的时间。<br>在cell中添加 <code>%timeit</code> ，会运行该cell 100,000次（默认），然后以运行最快的3次结果的平均值作为结果。</p><pre><code class="lang-Python">import numpy%timeit numpy.random.normal(size = 10)# 5.91 µs ± 258 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)%%timeimport timefor _ in range(100):    time.sleep(0.01)# Wall time: 1.73 s</code></pre><h3><span id="插件管理器">插件管理器</span></h3><p>Nbextensions相当于Jupyter的插件管理器。<br>安装：（在Anaconda Prompt中输入）</p><pre><code class="lang-bash">conda install -c conda-forge jupyter_contrib_nbextensions</code></pre><p>安装过程需要选择[y/n]，输入y。</p><p>该选项卡下方罗列了大量Jupyter可用的插件；点击某个插件的名称，即可在列表下方显示该插件的说明文档；勾选某个插件前面的方框，则系统会加载启用该插件。</p><h3><span id="jupyter-lab">Jupyter Lab！</span></h3><p>超好用！是Project Jupyter的下一代用户界面，具体安装和使用说明请见《<a href="https://mp.weixin.qq.com/s/T-Afq0vAw0lVB9Bave-aNQ" target="_blank" rel="noopener">Jupyter：超强的下一代Jupyter Notebook</a>》（原文作者Parul Pandey，EarlGrey翻译，<a href="https://towardsdatascience.com/jupyter-lab-evolution-of-the-jupyter-notebook-5297cacde6b?gi=dec00114bf03" target="_blank" rel="noopener">原文网址</a>）。</p><h3><span id="切换code和markdown">切换Code和Markdown</span></h3><p>要快捷地切换Cell的形式（Code或Markdown），可按如下操作：<br>选中Cell（光标在Cell中闪烁），点击“Esc”，进入命令模式（光标不再Cell中闪烁，但Cell左侧仍有蓝色粗线条）；然后键盘按“Y”将Cell切换为Code模式，键盘按“M”则将Cell切换为Markdown模式。即</p><ul><li>Esc+Y：code模式</li><li>Esc+M：Markdown模式</li><li>Esc+B：快速添加新的Cell</li></ul><h3><span id="禁止输出警告warnings">禁止输出警告（warnings）</span></h3><p>运行以下代码：</p><pre><code class="lang-Python">import warningswarnings.filterwarnings(&quot;ignore&quot;)</code></pre><h4><span id="参考资料">参考资料</span></h4><p>[1] <a href="https://www.google.com/Jupyter" target="_blank" rel="noopener">首页缩略图</a><br>[2] <a href="https://www.cnblogs.com/bella1102/p/11032519.html" target="_blank" rel="noopener">Jupyter Notebook 如何让一个Cell 可以同时输出多个语句的值？</a><br>[3] <a href="https://www.sohu.com/a/219989263_774914" target="_blank" rel="noopener">Jupyter Notebook/Lab中添加R Kernel的详细步骤</a><br>[4] <a href="https://blog.csdn.net/create115721/article/details/79243641" target="_blank" rel="noopener">Jupyter Notebook的27个窍门，技巧和快捷键</a><br>[5] <a href="https://mp.weixin.qq.com/s/5sFkpI4eEodVQuLya3K5rw" target="_blank" rel="noopener">九大神招，让Python里数据分析神器Jupyter，完美升华</a></p>]]></content>
    
    
    <categories>
      
      <category>无从属</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Jupyter</tag>
      
      <tag>软件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SQL</title>
    <link href="/2020/04/30/SQL%E9%A2%98%E5%BA%93/"/>
    <url>/2020/04/30/SQL%E9%A2%98%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<p>SQL相关知识积累~</p><a id="more"></a><h1><span id="通用">通用</span></h1><ul><li><a href="/2020/05/03/sql-1-%E8%8C%83%E5%BC%8F/" title="范式">范式</a></li><li><a href="/2020/05/03/sql-2-%E6%A8%A1%E5%BC%8F/" title="模式">模式</a></li><li><a href="/2020/05/03/sql-3-%E6%95%B0%E6%8D%AE%E5%AE%8C%E6%95%B4%E6%80%A7/" title="数据完整性">数据完整性</a></li><li></li></ul><h1><span id="mysql">MySQL</span></h1><ul><li></li></ul><h1><span id="ms-sql-server">MS SQL Server</span></h1><ul><li></li></ul><h1><span id="access">ACCESS</span></h1><ul><li><a href="/2020/05/03/access-1/" title="ACCESS窗体">ACCESS窗体</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SQL</tag>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode刷题</title>
    <link href="/2020/04/29/Leetcode%E5%88%B7%E9%A2%98/"/>
    <url>/2020/04/29/Leetcode%E5%88%B7%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>Leetcode刷题记录~</p><a id="more"></a><h1><span id="1-two-sum">1. Two Sum</span></h1><p><a href="https://leetcode.com/problems/two-sum/" target="_blank" rel="noopener">题目详情</a></p><pre><code class="lang-Python">class Solution:    def twoSum(self, nums: List[int], target: int) -&gt; List[int]:        i = 0        while nums:            num = nums[0]            nums.pop(0)            if target - num in nums:                return [i, nums.index(target-num) + i + 1]            i += 1</code></pre><p><a href>题目详情</a></p><pre><code class="lang-Python"></code></pre><p><a href>题目详情</a></p><pre><code class="lang-Python"></code></pre><h1><span id="67-add-binary">67. Add Binary</span></h1><p><a href="https://leetcode.com/problems/add-binary/" target="_blank" rel="noopener">题目详情</a></p><pre><code class="lang-Python">class Solution:    def addBinary(self, a: str, b: str) -&gt; str:        return bin(int(a, 2) + int(b, 2))[2:]</code></pre><p><a href>题目详情</a></p><pre><code class="lang-Python"></code></pre><p><a href>题目详情</a></p><pre><code class="lang-Python"></code></pre><h1><span id="177-nth-highest-salary">177. Nth Highest Salary</span></h1><p><a href="https://leetcode.com/problems/nth-highest-salary/" target="_blank" rel="noopener">题目详情</a></p><pre><code class="lang-SQL">-- Runtime=553msCREATE FUNCTION getNthHighestSalary(N INT) RETURNS INTBEGINDECLARE M INT;SET M=N-1;  RETURN (      # Write your MySQL query statement below.      SELECT Salary FROM             (SELECT DISTINCT Salary FROM Employee ORDER BY Salary DESC) a      LIMIT 1 OFFSET M  );END-- Runtime=416msCREATE FUNCTION getNthHighestSalary(N INT) RETURNS INTBEGINDECLARE M INT;SET M=N-1;  RETURN (      # Write your MySQL query statement below.      SELECT DISTINCT Salary FROM Employee      ORDER BY Salary DESC      LIMIT 1 OFFSET M  );</code></pre><h1><span id="657-robot-return-to-origin">657. Robot Return to Origin</span></h1><p><a href="https://leetcode.com/problems/robot-return-to-origin/" target="_blank" rel="noopener">题目详情</a></p><pre><code class="lang-Python">## Runtime=64ms, Memory=13.8MBclass Solution:    def judgeCircle(self, moves: str) -&gt; bool:        pos = [0, 0]        for move in moves:            if move==&#39;L&#39;:                pos[0] += 1            elif move==&#39;R&#39;:                pos[0] -= 1            elif move==&#39;U&#39;:                pos[1] += 1            else:                pos[1] -= 1        return pos==[0,0]## Solution## Runtime=60ms, Memory=13.8MBclass Solution:    def judgeCircle(self, moves: str) -&gt; bool:        x = y = 0        for move in moves:            if move == &#39;U&#39;: y -= 1            elif move == &#39;D&#39;: y += 1            elif move == &#39;L&#39;: x -= 1            elif move == &#39;R&#39;: x += 1        return x == y == 0</code></pre><h1><span id="728-self-dividing-numbers">728. Self Dividing Numbers</span></h1><p><a href="https://leetcode.com/problems/self-dividing-numbers/" target="_blank" rel="noopener">题目详情</a></p><pre><code class="lang-Python">## Runtime=68ms, Memory=13.9MBclass Solution:    def selfDividingNumbers(self, left: int, right: int) -&gt; List[int]:        result = []        for num in range(left, right+1):            nums = list(map(int, list(str(num))))            count = 0            if 0 in nums:                pass            else:                for j in nums:                    if num%j == 0:                        count += 1                if count == len(nums):                    result.append(num)        return result## 参考 Solution## Rumtime=36ms, Memory=14MBclass Solution:    def selfDividingNumbers(self, left: int, right: int) -&gt; List[int]:        result = []        for num in range(left, right+1):            for x in str(num):                if x == &quot;0&quot; or num % int(x) != 0:                    break            else:                result.append(num)        return result</code></pre><p><a href>题目详情</a></p><pre><code class="lang-Python"></code></pre><h1><span id="832-flipping-an-image">832. Flipping an Image</span></h1><p><a href="https://leetcode.com/problems/flipping-an-image/" target="_blank" rel="noopener">题目详情</a></p><pre><code class="lang-Python">## Runtime=56ms, Memory=13.9MBclass Solution:    def flipAndInvertImage(self, A: List[List[int]]) -&gt; List[List[int]]:        for i in range(len(A)):            A[i].reverse()            A[i] = [1-x for x in A[i]]        return A## Runtime=52ms, Memory=14MBclass Solution:    def flipAndInvertImage(self, A: List[List[int]]) -&gt; List[List[int]]:        for i in range(len(A)):            A[i] = A[i][::-1]  ## difference            A[i] = [1-x for x in A[i]]        return A## Runtime=48ms, Memory=14MBclass Solution:    def flipAndInvertImage(self, A: List[List[int]]) -&gt; List[List[int]]:        for i, row in enumerate(A):  ## differencee            A[i] = row[::-1]            for j, col in enumerate(A[i]):  ## difference                A[i][j] = 1 - col        return A</code></pre><h1><span id="852-peak-index-in-a-mountain-array">852. Peak Index in a Mountain Array</span></h1><p><a href="https://leetcode.com/problems/peak-index-in-a-mountain-array/" target="_blank" rel="noopener">题目详情</a></p><pre><code class="lang-Python">## Runtime=84ms, Memory=15.1MBclass Solution:    def peakIndexInMountainArray(self, A: List[int]) -&gt; int:        idx = int((len(A)-1)/2 if len(A)%2==1 else len(A)/2)        left, right = idx-1, idx+1        while left&gt;=0 and right&lt;len(A):            if A[idx]&gt;A[left] and A[idx]&gt;A[right]:                break            elif A[idx]&lt;A[left]:                left -= 1                idx -= 1                right -= 1            else:                left += 1                idx += 1                right += 1        return idx## Runtime=80ms, Memory=15MB## Binary search in Solutionclass Solution:    def peakIndexInMountainArray(self, A: List[int]) -&gt; int:        lo, hi = 0, len(A) - 1        while lo &lt; hi:            mi = int((lo + hi) / 2)            if A[mi] &lt; A[mi + 1]:                lo = mi + 1            else:                hi = mi        return lo## Runtime=84ms, Memory=15.2MB## Linear scanclass Solution:    def peakIndexInMountainArray(self, A: List[int]) -&gt; int:        for i in range(len(A)):            if A[i] &gt; A[i+1]:                return i</code></pre><h1><span id="942-di-string-match">942. DI String Match</span></h1><p><a href="https://leetcode.com/problems/di-string-match/" target="_blank" rel="noopener">题目详情</a></p><pre><code class="lang-Python">## 参考了 Solutionclass Solution:    def diStringMatch(self, S: str) -&gt; List[int]:        low, high = 0, len(S)        result = []        for s in S:            if s == &#39;I&#39;:                result.append(low)                low += 1            else:                result.append(high)                high -= 1        return result + [low]</code></pre><h1><span id="965-univalued-binary-tree">965. Univalued Binary Tree</span></h1><p><a href="https://leetcode.com/problems/univalued-binary-tree/" target="_blank" rel="noopener">题目详情</a></p><pre><code class="lang-Python"># Definition for a binary tree node.# class TreeNode:#     def __init__(self, val=0, left=None, right=None):#         self.val = val#         self.left = left#         self.right = rightclass Solution:    def isUnivalTree(self, root: TreeNode) -&gt; bool:        values = []        def dfs(node):            if node:                values.append(node.val)                dfs(node.left)                dfs(node.right)        dfs(root)        return len(set(values)) == 1</code></pre><h1><span id="977-squares-of-a-sorted-array">977. Squares of a Sorted Array</span></h1><p><a href="https://leetcode.com/problems/squares-of-a-sorted-array/" target="_blank" rel="noopener">题目详情</a></p><pre><code class="lang-Python">## Runtime=228ms, Memory=15.7MBclass Solution:    def sortedSquares(self, A: List[int]) -&gt; List[int]:         return sorted([x**2 for x in A])## Runtime=216ms, Memory=15.8MBclass Solution:    def sortedSquares(self, A: List[int]) -&gt; List[int]:         return sorted([x*x for x in A])</code></pre><h1><span id="1021-remove-outermost-parentheses">1021. Remove Outermost Parentheses</span></h1><p><a href="https://leetcode.com/problems/remove-outermost-parentheses/" target="_blank" rel="noopener">题目详情</a></p><pre><code class="lang-Python">## 参考了solutions in discussclass Solution:    def removeOuterParentheses(self, S: str) -&gt; str:        count, result = 0, []        for s in S:            if s == &quot;)&quot;:  ##  完整配对count=0；增加一个&quot;)&quot;count减一；增加一个&quot;(&quot;count加一                count -= 1            if count &gt; 0:                result.append(s)            if s == &quot;(&quot;:                 count += 1        return &quot;&quot;.join(result)</code></pre><p><a href>题目详情</a></p><pre><code class="lang-Python"></code></pre><h1><span id="1108-defanging-an-ip-address">1108. Defanging an IP Address</span></h1><p><a href="https://leetcode.com/problems/defanging-an-ip-address/" target="_blank" rel="noopener">题目详情</a></p><pre><code class="lang-Python">class Solution:    def defangIPaddr(self, address: str) -&gt; str:        return address.replace(&quot;.&quot;, &quot;[.]&quot;)</code></pre><h1><span id="1221-split-a-string-in-balanced-strings">1221. Split a String in Balanced Strings</span></h1><p><a href="https://leetcode.com/problems/split-a-string-in-balanced-strings/" target="_blank" rel="noopener">题目详情</a></p><pre><code class="lang-Python">class Solution:    def balancedStringSplit(self, s: str) -&gt; int:        ans_count = 0        L_num, R_num = 0, 0        for ss in s:            if ss==&quot;L&quot;:                L_num += 1            else:                R_num += 1            if L_num==R_num:                ans_count += 1                L_num, R_num = 0, 0        return ans_count</code></pre><h1><span id="1252-cells-with-odd-values-in-a-matrix">1252. Cells with Odd Values in a Matrix</span></h1><p><a href="https://leetcode.com/problems/cells-with-odd-values-in-a-matrix/" target="_blank" rel="noopener">题目详情</a></p><pre><code class="lang-Python">class Solution:    def oddCells(self, n: int, m: int, indices: List[List[int]]) -&gt; int:        nums = [[0]*m]*n  ## 快速创建0矩阵        rows, cols = [0]*n, [0]*m        lst = []        for index in indices:            ri, ci = index[0], index[1]            rows[ri] += 1            cols[ci] += 1        for i in range(n):            for j in range(m):                nums[i][j] = rows[i] + cols[j]            lst += nums[i]        return sum([1 if x%2==1 else 0 for x in lst])</code></pre><p><a href>题目详情</a></p><pre><code class="lang-Python"></code></pre><h1><span id="1266-minimum-time-visiting-all-points">1266. Minimum Time Visiting All Points</span></h1><p><a href="https://leetcode.com/problems/minimum-time-visiting-all-points/" target="_blank" rel="noopener">题目详情</a></p><pre><code class="lang-Python">class Solution:    def minTimeToVisitAllPoints(self, points: List[List[int]]) -&gt; int:        steps = 0        for i in range(len(points)-1):            x1, y1 = points[i][0], points[i][1]            x2, y2 = points[i+1][0], points[i+1][1]            m, n = abs(x2 - x1), abs(y2 - y1)            steps += max(m, n)        return steps</code></pre><h1><span id="1281-subtract-the-product-and-sum-of-digits-of-an-integer">1281. Subtract the Product and Sum of Digits of an Integer</span></h1><p><a href="https://leetcode.com/problems/subtract-the-product-and-sum-of-digits-of-an-integer/" target="_blank" rel="noopener">题目详情</a></p><pre><code class="lang-Python">class Solution:    def subtractProductAndSum(self, n: int) -&gt; int:        num = [x for x in str(n)]        num = list(map(int, num))  ## 将int拆开成单个数字列表        pp = 1        ss = 0        for nn in num:            pp *= nn            ss += nn        return pp - ss</code></pre><h1><span id="1290-convert-binary-number-in-a-linked-list-to-integer">1290. Convert Binary Number in a Linked List to Integer</span></h1><p><a href="https://leetcode.com/problems/convert-binary-number-in-a-linked-list-to-integer/" target="_blank" rel="noopener">题目详情</a></p><pre><code class="lang-Python"># Definition for singly-linked list.# class ListNode:#     def __init__(self, val=0, next=None):#         self.val = val#         self.next = nextclass Solution:    def getDecimalValue(self, head: ListNode) -&gt; int:        str_num = &quot;&quot;        while head:  ## 当head非空            str_num += str(head.val)            head = head.next        return int(str_num, 2)</code></pre><p><a href>题目详情</a></p><pre><code class="lang-Python"></code></pre><h1><span id="1295-find-numbers-with-even-number-of-digits">1295. Find Numbers with Even Number of Digits</span></h1><p><a href="https://leetcode.com/problems/find-numbers-with-even-number-of-digits/" target="_blank" rel="noopener">题目详情</a></p><pre><code class="lang-Python">class Solution:    def findNumbers(self, nums: List[int]) -&gt; int:        ans_count = 0        for num in nums:            num_count = 0            while num:                num_count += 1                num //= 10  ## num除以10的商            if num_count % 2 == 0:  ## num_count除以2的余数等于0                ans_count += 1        return ans_count</code></pre><h1><span id="1299-replace-elements-with-greatest-element-on-right-side">1299. Replace Elements with Greatest Element on Right Side</span></h1><p><a href="https://leetcode.com/problems/replace-elements-with-greatest-element-on-right-side/" target="_blank" rel="noopener">题目详情</a></p><pre><code class="lang-Python">## Runtime=4720msclass Solution:    def replaceElements(self, arr: List[int]) -&gt; List[int]:        out = []        n = len(arr)        for i in range(n-1):            out.append(max(arr[(i+1):]))        out.append(-1)        return out## A solution in &#39;Discuss&#39;## Runtime=125msclass Solution:    def replaceElements(self, arr: List[int]) -&gt; List[int]:        max_num = -1        for i in range(len(arr)-1, -1, -1):            hold = arr[i]            arr[i] = max_num            if hold &gt; max_num:                max_num = hold        return arr</code></pre><h1><span id="1304-find-n-unique-integers-sum-up-to-zero">1304. Find N Unique Integers Sum up to Zero</span></h1><p><a href="https://leetcode.com/problems/find-n-unique-integers-sum-up-to-zero/" target="_blank" rel="noopener">题目详情</a></p><pre><code class="lang-Python">class Solution:    def sumZero(self, n: int) -&gt; List[int]:        result = []        if n % 2 == 0:            lst = [x for x in range(n-1)]            result.extend(lst)            result.append(-sum(lst))        else:            lst = [x for x in range(1,int((n+1)//2))]            result.extend(lst)            result.extend([-x for x in lst])            result.append(0)        return result</code></pre><h1><span id="1309-decrypt-string-from-alphabet-to-integer-mapping">1309. Decrypt String from Alphabet to Integer Mapping</span></h1><p><a href="https://leetcode.com/problems/decrypt-string-from-alphabet-to-integer-mapping/" target="_blank" rel="noopener">题目详情</a></p><pre><code class="lang-Python">class Solution:    def freqAlphabets(self, s: str) -&gt; str:        result = &quot;&quot;        dic = {}        for i in range(97,123):            if i &lt;= 105:                dic[str(i - 96)] = chr(i)            else:                dic[str(i - 96) + &#39;#&#39;] = chr(i)        i = 0        while i &lt; len(s):            if  i+2 &lt; len(s) and s[i+2] == &#39;#&#39;:                key = s[i:i+3]                i += 3            else:                key = s[i]                i += 1            result += dic[key]        return result</code></pre><h1><span id="1313-decompress-run-length-encoded-list">1313. Decompress Run-Length Encoded List</span></h1><p><a href="https://leetcode.com/problems/decompress-run-length-encoded-list/" target="_blank" rel="noopener">题目详情</a></p><pre><code class="lang-Python">class Solution:    def decompressRLElist(self, nums: List[int]) -&gt; List[int]:        n = len(nums)        ans = []        for i in range(int(n/2)):            n = nums[2*i]            num = nums[2*i+1]            for j in range(n):                ans.append(num)        return ans</code></pre><h1><span id="1323-maximum-69-number">1323. Maximum 69 Number</span></h1><p><a href="https://leetcode.com/problems/maximum-69-number/" target="_blank" rel="noopener">题目详情</a></p><pre><code class="lang-Python">class Solution:    def maximum69Number (self, num: int) -&gt; int:        i = 0        out = [x for x in str(num)]        while i&lt;len(out):            if out[i] == &#39;6&#39;:                out[i] = &#39;9&#39;                break            i += 1        return int(&#39;&#39;.join(out))</code></pre><h1><span id="1342-number-of-steps-to-reduce-a-number-to-zero">1342. Number of Steps to Reduce a Number to Zero</span></h1><p><a href="https://leetcode.com/problems/number-of-steps-to-reduce-a-number-to-zero/" target="_blank" rel="noopener">题目详情</a></p><pre><code class="lang-Python">class Solution:    def numberOfSteps (self, num: int) -&gt; int:        cou = 0        while num&gt;0:            if num % 2 == 0:  ## if even                num = int(num / 2)            else:  ## if odd                num -= 1            cou += 1        return cou</code></pre><h1><span id="1351-count-negative-numbers-in-a-sorted-matrix">1351. Count Negative Numbers in a Sorted Matrix</span></h1><p><a href="https://leetcode.com/problems/count-negative-numbers-in-a-sorted-matrix/" target="_blank" rel="noopener">题目详情</a></p><pre><code class="lang-Python">class Solution:    def countNegatives(self, grid: List[List[int]]) -&gt; int:        nums = []        for i in range(len(grid)):            nums += grid[i]        return sum([1 if x&lt;0 else 0 for x in nums])</code></pre><h1><span id="1370-increasing-decreasing-string">1370. Increasing Decreasing String</span></h1><p><a href="https://leetcode.com/problems/increasing-decreasing-string/" target="_blank" rel="noopener">题目详情</a></p><pre><code class="lang-Python">## 参考了 solution in discussclass Solution:    def sortString(self, s: str) -&gt; str:        result = []        s = [x for x in s]  ## 等价于 s = list(s)        direct = 1  ## =1表示从小到大；=-1表示从大到小        while s:  ## 当s非空时            if direct == 1:                ss = sorted(set(s))  ## 从小到大            else:                 ss = sorted(set(s))[::-1]  ## 从大到小            result.extend(ss)            for x in ss:                s.remove(x)            direct *= -1  ## 反向        return &quot;&quot;.join(result)</code></pre><h1><span id="1374-generate-a-string-with-characters-that-have-odd-counts">1374. Generate a String With Characters That Have Odd Counts</span></h1><p><a href="https://leetcode.com/problems/generate-a-string-with-characters-that-have-odd-counts/" target="_blank" rel="noopener">题目详情</a></p><pre><code class="lang-Python">class Solution:    def generateTheString(self, n: int) -&gt; str:        if n%2==0:            return &#39;a&#39;*(n-1) + &#39;b&#39;        else:            return &#39;a&#39;*n</code></pre><h1><span id="1380-lucky-numbers-in-a-matrix">1380. Lucky Numbers in a Matrix</span></h1><p><a href="https://leetcode.com/problems/lucky-numbers-in-a-matrix/" target="_blank" rel="noopener">题目详情</a></p><pre><code class="lang-Python">class Solution:    def luckyNumbers (self, matrix: List[List[int]]) -&gt; List[int]:        rows = [min(x) for x in matrix]        n, m = len(matrix), len(matrix[0])        cols, ans = [], []        for j in range(m):            col = [x[j] for x in matrix]            cols.append(max(col))        for i in range(n):            for j in range(m):                if matrix[i][j] == rows[i] and matrix[i][j] == cols[j]:                    ans.append(matrix[i][j])        return ans</code></pre><h1><span id="1389-create-target-array-in-the-given-order">1389. Create Target Array in the Given Order</span></h1><p><a href="https://leetcode.com/problems/create-target-array-in-the-given-order/" target="_blank" rel="noopener">题目详情</a></p><pre><code class="lang-Python">class Solution:    def createTargetArray(self, nums: List[int], index: List[int]) -&gt; List[int]:        ans = []        for i in range(len(nums)):            num, idx = nums[i], index[i]            if idx &gt;= len(ans):                ans.append(num)            else:                a, b = ans[:idx], ans[idx:]                ans = a + [num] + b        return ans</code></pre><p><a href>题目详情</a></p><pre><code class="lang-Python"></code></pre><p><a href>题目详情</a></p><pre><code class="lang-Python"></code></pre><h1><span id="推荐资料">推荐资料</span></h1><p>[1] <a href="https://www.ranxiaolang.com/static/leetcode_python.pdf" target="_blank" rel="noopener">Leetcode-Python解题思路</a></p>]]></content>
    
    
    <categories>
      
      <category>藏宝库</category>
      
      <category>题库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
      <tag>编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python题库</title>
    <link href="/2020/04/29/Python%E9%A2%98%E5%BA%93/"/>
    <url>/2020/04/29/Python%E9%A2%98%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<p>Python相关题目积累~</p><a id="more"></a><ul><li><a href="/2020/04/29/Python-is-%E5%92%8C-%E7%9A%84%E5%8C%BA%E5%88%AB/" title="is和&#x3D;&#x3D;的区别">is和&#x3D;&#x3D;的区别</a></li><li><a href="/2020/04/29/python-2-tuple%E5%92%8Clist/" title="tuple（元组）和list（列表）的区别">tuple（元组）和list（列表）的区别</a></li><li><a href="/2020/04/29/python-3/" title="b, B, KB, MB, GB的区别">b, B, KB, MB, GB的区别</a></li><li><a href="/2020/05/03/python-7-%E5%88%87%E7%89%87%E6%93%8D%E4%BD%9C/" title="切片操作不会引起下标越界异常">切片操作不会引起下标越界异常</a></li><li></li><li></li></ul>]]></content>
    
    
    <categories>
      
      <category>藏宝库</category>
      
      <category>题库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo+GitHub+Markdown常用用法</title>
    <link href="/2020/04/28/Hexo-GitHub-Markdown%E5%B8%B8%E7%94%A8%E7%94%A8%E6%B3%95/"/>
    <url>/2020/04/28/Hexo-GitHub-Markdown%E5%B8%B8%E7%94%A8%E7%94%A8%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>记录一些Hexo+Markdown的常用语法~</p><a id="more"></a><!--toc--><h1><span id="hexo">Hexo</span></h1><h2><span id="部署">部署</span></h2><h3><span id="新建博客">新建博客</span></h3><pre><code class="lang-shell">$ hexo n &#39;博客名称&#39;</code></pre><h3><span id="上传">上传</span></h3><pre><code class="lang-shell">$ hexo g</code></pre><p>即 <code>hexo generate</code></p><h2><span id="首页">首页</span></h2><h3><span id="fork-me-on-github">Fork me on GitHub</span></h3><ul><li><a href="https://blog.csdn.net/fly_wt/article/details/86674138" target="_blank" rel="noopener">在右上角实现fork me on github</a></li></ul><h2><span id="正文">正文</span></h2><h3><span id="标题自动编号">标题自动编号</span></h3><ul><li><a href="http://r12f.com/posts/adding-index-to-your-headings-with-hexo-heading-index/" target="_blank" rel="noopener">为Hexo博客标题自动添加序号：hexo-heading-index</a></li></ul><h2><span id="代码">代码</span></h2><h3><span id="高亮">高亮</span></h3><ul><li><a href="https://www.zfl9.com/hexo-code.html" target="_blank" rel="noopener">使用prism.js进行代码高亮</a></li><li><a href="https://www.jianshu.com/p/1f223eb78ad8" target="_blank" rel="noopener">markdown代码块支持的语言</a></li></ul><h2><span id="主题">主题</span></h2><h3><span id="fluid主题">Fluid主题</span></h3><p>安装可见：<a href="https://hexo.fluid-dev.com/docs/guide/#%E4%B8%BB%E9%A2%98%E7%AE%80%E4%BB%8B" target="_blank" rel="noopener">Hexo-fluid</a></p><p>压缩包<a href="https://github.com/fluid-dev/hexo-theme-fluid/releases/tag/v1.8.0-beta2">下载</a></p><h2><span id="其他功能">其他功能</span></h2><h3><span id="评论">评论</span></h3><ul><li><a href="https://litstronger.github.io/2020/04/03/hexo-fluid%E6%B7%BB%E5%8A%A0utterances%E8%AF%84%E8%AE%BA%E5%8A%9F%E8%83%BD/" target="_blank" rel="noopener">hexo-fluid添加utterances评论功能</a><h3><span id="流程图">流程图</span></h3></li><li><a href="https://www.cnblogs.com/icoty23/p/10911231.html" target="_blank" rel="noopener">Hexo引入Mermaid流程图和MathJax数学公式</a></li><li><a href="https://blog.csdn.net/Olivia_Vang/article/details/92987859#%E8%AF%AD%E6%B3%95" target="_blank" rel="noopener">Hexo中插入mermaid diagrams</a></li></ul><h1><span id="markdown">Markdown</span></h1><h2><span id="font-matter区">Font-matter区</span></h2><p>Font-matter区即 两行<code>---</code>之间的内容</p><h2><span id="正文">正文</span></h2><h3><span id="文章摘要">文章摘要</span></h3><p>若想要在博客首页只展示文章的摘要，在摘要与正文中间插入</p><pre><code class="lang-md">&lt;!--more--&gt;</code></pre><h3><span id="引用站内文章">引用站内文章</span></h3><pre><code class="lang-md">{% post_link 站内文章对应的.md名称（不带后缀.md） %}</code></pre><p>如：引用站内文章《<a href="/2020/04/27/Restart/" title="Restart!">Restart!</a>》，对应的文件名是<code>Restart.md</code></p><pre><code class="lang-md">{% post_link Restart %}</code></pre><h3><span id="字体">字体</span></h3><pre><code class="lang-md">&lt;font face=&quot;字体&quot; size=&quot;字号&quot; color=&quot;颜色&quot;&gt;这里是需要突出显示的内容&lt;/font&gt;</code></pre><h3><span id="插入图片">插入图片</span></h3><p>参考：<a href="https://blog.csdn.net/xjm850552586/article/details/84101345" target="_blank" rel="noopener">hexo引用本地图片无法显示</a></p><p>Markdown语法：</p><pre><code class="lang-md">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt;{% asset_img inorder.png 中序遍历 %}</code></pre><p>或</p><pre><code class="lang-md">![title](name.jpg)</code></pre><h1><span id="参考资料">参考资料</span></h1>]]></content>
    
    
    <categories>
      
      <category>无从属</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>GitHub</tag>
      
      <tag>Markdown</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>随机森林</title>
    <link href="/2020/04/28/%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/"/>
    <url>/2020/04/28/%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/</url>
    
    <content type="html"><![CDATA[<p>Random Forest</p><a id="more"></a><ul><li>随机森林是一种<u>判别分类方法</u></li><li>随机森林是建立在<a href="/2020/04/28/%E5%86%B3%E7%AD%96%E6%A0%91/" title="决策树">决策树</a>基础上的集成学习器</li></ul>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>机器学习</tag>
      
      <tag>分类</tag>
      
      <tag>有监督学习</tag>
      
      <tag>判别式模型</tag>
      
      <tag>集成学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>决策树</title>
    <link href="/2020/04/28/%E5%86%B3%E7%AD%96%E6%A0%91/"/>
    <url>/2020/04/28/%E5%86%B3%E7%AD%96%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<p>Decision Tree</p><a id="more"></a><h6><span id="参考资料">参考资料</span></h6><p>[1] <a href="http://vas3k.com/blog/machine_learning/" target="_blank" rel="noopener">封面图片来源</a></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>机器学习</tag>
      
      <tag>分类</tag>
      
      <tag>有监督学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Tableau学习资源</title>
    <link href="/2020/04/27/Tableau%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90/"/>
    <url>/2020/04/27/Tableau%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90/</url>
    
    <content type="html"><![CDATA[<p>汇总Tableau软件的相关学习资料~</p><a id="more"></a><h2><span id="书籍">书籍</span></h2><h3><span id="触手可及的大数据分析工具tableau案例集">《触手可及的大数据分析工具：Tableau案例集》</span></h3><p><a href="https://book.douban.com/subject/26614166/" target="_blank" rel="noopener">豆瓣图书</a></p><h2><span id="视频">视频</span></h2><h3><span id="未明学院-tableau可视化软件的基础操作和进阶">未明学院-Tableau可视化软件的基础操作和进阶</span></h3><p><a href="https://www.bilibili.com/video/av66028664?from=search&amp;seid=5882922976125124544" target="_blank" rel="noopener">视频地址</a></p><p>共14个视频</p><ol><li>Tableau简介、条形图与直方图</li><li>数据预处理、折线图、饼图</li><li>基本表、树状图、气泡图、词云</li><li>标靶图、甘特图、瀑布图</li><li>Tableau进阶：数据集合并、符号地图、智能显示、插入自定义形状、仪表板</li><li>填充地图、多维地图、混合地图</li><li>多边形地图和背景地图：设置地理信息，自定义地图码导入、设置地图源</li><li>数据分层、数据分组、数据集</li><li>计算字段与表计算：粒度、聚合与比率</li><li>人口金字塔、漏斗图、箱线图</li><li>范围：线图、倾斜图</li><li>网络图与弧线图</li><li>雷达图与弧线图</li><li>回归分析、时间序列分析</li></ol>]]></content>
    
    
    <categories>
      
      <category>藏宝库</category>
      
      <category>资源</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Tableau</tag>
      
      <tag>可视化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Restart!</title>
    <link href="/2020/04/27/Restart/"/>
    <url>/2020/04/27/Restart/</url>
    
    <content type="html"><![CDATA[<p>从零开始我的个人博客！</p><a id="more"></a><p>一年前已经成功搭建此博客，但是我在调整博客主题时把它搞成404了（泪目），于是重新搭建了，那么就从零restart吧！</p><h3><span id="参考">参考</span></h3><p>[1] <a href="https://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html" target="_blank" rel="noopener">使用hexo+github搭建免费个人博客详细教程</a><br>[2] <a href="https://wangcong.net/article/HexoWihLaTeX.html" target="_blank" rel="noopener">Hexo中Latex公式渲染</a><br>[3] <a href="https://github.com/iissnan/hexo-theme-next/wiki/%E5%88%9B%E5%BB%BA%E5%88%86%E7%B1%BB%E9%A1%B5%E9%9D%A2">创建分类页面</a><br>[4] <a href="https://www.jianshu.com/p/70e46dc95676" target="_blank" rel="noopener">设定代码高亮格式</a><br>[5] <a href="https://bing.ioliu.cn/photo/MalhamStars_ZH-CN4163177154?force=home_6" target="_blank" rel="noopener">博客首页图片</a></p>]]></content>
    
    
    <categories>
      
      <category>无从属</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
