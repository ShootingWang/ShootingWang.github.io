<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>R语言编程</title>
    <url>/R.html</url>
    <content><![CDATA[<center>R语言</center>

<a id="more"></a>
<h1 id="base"><a href="#base" class="headerlink" title="base"></a>base</h1><h2 id="class"><a href="#class" class="headerlink" title="class"></a>class</h2><p>变量的类别</p>
<h2 id="merge"><a href="#merge" class="headerlink" title="merge"></a>merge</h2><p>合并两个数据框（DataFrame）<br><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">merge(x, y, by = intersect(names(x), names(y)),</span><br><span class="line">      by.x = by, by.y = by, all = <span class="literal">FALSE</span>, all.x = all, all.y = all,</span><br><span class="line">      sort = <span class="literal">TRUE</span>, suffixes = c(<span class="string">".x"</span>,<span class="string">".y"</span>), no.dups = <span class="literal">TRUE</span>,</span><br><span class="line">      incomparables = <span class="literal">NULL</span>, <span class="keyword">...</span>)</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>all=FALSE</code>：相当于<code>natural join</code>，仅返回匹配的行</li>
<li><code>all=TRUE</code>：相当于<code>full outer join</code></li>
<li><code>all.x=TRUE</code>：相当于<code>left outer join</code></li>
<li><code>all.y=TRUE</code>：相当于<code>right outer join</code></li>
</ul>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">x &lt;- data.frame(k1 = c(<span class="literal">NA</span>,<span class="literal">NA</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>), k2 = c(<span class="number">1</span>,<span class="literal">NA</span>,<span class="literal">NA</span>,<span class="number">4</span>,<span class="number">5</span>), data = <span class="number">1</span>:<span class="number">5</span>)</span><br><span class="line">x</span><br><span class="line"><span class="comment">#  k1 k2 data</span></span><br><span class="line"><span class="comment">#1 NA  1    1</span></span><br><span class="line"><span class="comment">#2 NA NA    2</span></span><br><span class="line"><span class="comment">#3  3 NA    3</span></span><br><span class="line"><span class="comment">#4  4  4    4</span></span><br><span class="line"><span class="comment">#5  5  5    5</span></span><br><span class="line">y &lt;- data.frame(k1 = c(<span class="literal">NA</span>,<span class="number">2</span>,<span class="literal">NA</span>,<span class="number">4</span>,<span class="number">5</span>), k2 = c(<span class="literal">NA</span>,<span class="literal">NA</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>), data = <span class="number">1</span>:<span class="number">5</span>)</span><br><span class="line">y</span><br><span class="line"><span class="comment">#  k1 k2 data</span></span><br><span class="line"><span class="comment">#1 NA NA    1</span></span><br><span class="line"><span class="comment">#2  2 NA    2</span></span><br><span class="line"><span class="comment">#3 NA  3    3</span></span><br><span class="line"><span class="comment">#4  4  4    4</span></span><br><span class="line"><span class="comment">#5  5  5    5</span></span><br><span class="line"></span><br><span class="line">merge(x, y, by = c(<span class="string">"k1"</span>,<span class="string">"k2"</span>)) <span class="comment"># NA's match</span></span><br><span class="line"><span class="comment">#  k1 k2 data.x data.y</span></span><br><span class="line"><span class="comment">#1  4  4      4      4</span></span><br><span class="line"><span class="comment">#2  5  5      5      5</span></span><br><span class="line"><span class="comment">#3 NA NA      2      1</span></span><br><span class="line"></span><br><span class="line">merge(x, y, by = <span class="string">"k1"</span>) <span class="comment"># NA's match, so 6 rows</span></span><br><span class="line"><span class="comment">#  k1 k2.x data.x k2.y data.y</span></span><br><span class="line"><span class="comment">#1  4    4      4    4      4</span></span><br><span class="line"><span class="comment">#2  5    5      5    5      5</span></span><br><span class="line"><span class="comment">#3 NA    1      1   NA      1</span></span><br><span class="line"><span class="comment">#4 NA    1      1    3      3</span></span><br><span class="line"><span class="comment">#5 NA   NA      2   NA      1</span></span><br><span class="line"><span class="comment">#6 NA   NA      2    3      3</span></span><br><span class="line"></span><br><span class="line">merge(x, y, by = <span class="string">"k2"</span>, incomparables = <span class="literal">NA</span>) <span class="comment"># 2 rows</span></span><br><span class="line"><span class="comment">#  k2 k1.x data.x k1.y data.y</span></span><br><span class="line"><span class="comment">#1  4    4      4    4      4</span></span><br><span class="line"><span class="comment">#2  5    5      5    5      5</span></span><br></pre></td></tr></table></figure>
<h2 id="mode"><a href="#mode" class="headerlink" title="mode"></a>mode</h2><p>返回对象在内存中的存储类型</p>
<ul>
<li><code>numeric</code>：integer、double</li>
<li></li>
</ul>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">mode(<span class="literal">NA</span>)</span><br><span class="line"><span class="comment"># [1] "logical"</span></span><br></pre></td></tr></table></figure>
<h2 id="paste"><a href="#paste" class="headerlink" title="paste"></a>paste</h2><p>组合字符串</p>
<ul>
<li>可以将任意数量的参数组合在一起<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">paste(<span class="keyword">...</span>, sep = <span class="string">" "</span>, collapse = <span class="literal">NULL</span>)</span><br></pre></td></tr></table></figure></li>
<li><code>...</code>：要组合的任何数量的参数</li>
<li><code>sep</code>：表示参数之间的分隔符</li>
<li><code>collapse</code>：用于消除两个字符串之间的空间；但不是在一个字符串的两个词的空间</li>
</ul>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">(nth &lt;- paste0(<span class="number">1</span>:<span class="number">12</span>, c(<span class="string">"st"</span>, <span class="string">"nd"</span>, <span class="string">"rd"</span>, rep(<span class="string">"th"</span>, <span class="number">9</span>))))</span><br><span class="line"><span class="comment"># [1] "1st"  "2nd"  "3rd"  "4th"  "5th"  "6th"  "7th"  "8th"  "9th"  "10th" "11th" "12th"</span></span><br><span class="line"></span><br><span class="line">month.abb</span><br><span class="line"><span class="comment"># [1] "Jan" "Feb" "Mar" "Apr" "May" "Jun" "Jul" "Aug" "Sep" "Oct" "Nov" "Dec"</span></span><br><span class="line">paste(month.abb, <span class="string">"is the"</span>, nth, <span class="string">"month of the year."</span>)</span><br><span class="line"><span class="comment"># [1] "Jan is the 1st month of the year."  "Feb is the 2nd month of the year." </span></span><br><span class="line"><span class="comment"># [3] "Mar is the 3rd month of the year."  "Apr is the 4th month of the year." </span></span><br><span class="line"><span class="comment"># [5] "May is the 5th month of the year."  "Jun is the 6th month of the year." </span></span><br><span class="line"><span class="comment"># [7] "Jul is the 7th month of the year."  "Aug is the 8th month of the year." </span></span><br><span class="line"><span class="comment"># [9] "Sep is the 9th month of the year."  "Oct is the 10th month of the year."</span></span><br><span class="line"><span class="comment">#[11] "Nov is the 11th month of the year." "Dec is the 12th month of the year."</span></span><br><span class="line"></span><br><span class="line">letters</span><br><span class="line"><span class="comment"># [1] "a" "b" "c" "d" "e" "f" "g" "h" "i" "j" "k" "l" "m" "n" "o" "p" "q" "r" "s" "t" "u" "v"</span></span><br><span class="line"><span class="comment">#[23] "w" "x" "y" "z"</span></span><br><span class="line">paste(month.abb, letters)</span><br><span class="line"><span class="comment"># [1] "Jan a" "Feb b" "Mar c" "Apr d" "May e" "Jun f" "Jul g" "Aug h" "Sep i" "Oct j" "Nov k"</span></span><br><span class="line"><span class="comment">#[12] "Dec l" "Jan m" "Feb n" "Mar o" "Apr p" "May q" "Jun r" "Jul s" "Aug t" "Sep u" "Oct v"</span></span><br><span class="line"><span class="comment">#[23] "Nov w" "Dec x" "Jan y" "Feb z"</span></span><br></pre></td></tr></table></figure>
<h2 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h2><p>对变量类型的细分</p>
<h1 id="stats"><a href="#stats" class="headerlink" title="stats"></a>stats</h1><h2 id="r-分布"><a href="#r-分布" class="headerlink" title="r+分布"></a>r+分布</h2><p>产生特定分布的随机数（random）</p>
<p>|||</p>
<h1 id="Packages"><a href="#Packages" class="headerlink" title="Packages"></a>Packages</h1><h2 id="Amelia"><a href="#Amelia" class="headerlink" title="Amelia"></a>Amelia</h2><a href="/R%E8%AF%AD%E8%A8%80-Amelia.html" title="Amelia包">Amelia包</a>
<ul>
<li>可视化缺失值</li>
</ul>
<h2 id="grpreg"><a href="#grpreg" class="headerlink" title="grpreg"></a>grpreg</h2><a href="/R%E8%AF%AD%E8%A8%80-grpreg.html" title="grpreg包">grpreg包</a>
<ul>
<li>组变量选择</li>
</ul>
<h2 id="installr"><a href="#installr" class="headerlink" title="installr"></a>installr</h2><p>更新RGui</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 在RGui中输入下列命令</span></span><br><span class="line">install.packages(<span class="string">'installr'</span>)</span><br><span class="line"><span class="keyword">library</span>(installr)</span><br><span class="line">updateR()</span><br></pre></td></tr></table></figure>
<h2 id="MICE"><a href="#MICE" class="headerlink" title="MICE"></a>MICE</h2><a href="/R%E8%AF%AD%E8%A8%80-MICE.html" title="MICE包">MICE包</a>（Multivariate Imputation by Chained Equations）

- 填补缺失值
- 可视化缺失值



<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://cn.bing.com/images/search?view=detailV2&amp;ccid=y7PQyqXC&amp;id=617BD652FC2012861BB5E27035D4C092C9467682&amp;thid=OIP.y7PQyqXC-XCIFzc0BC5JawHaHa&amp;mediaurl=https%3a%2f%2fwww.rstudio.com%2fwp-content%2fuploads%2f2019%2f02%2frstudio-og.png&amp;exph=1200&amp;expw=1200&amp;q=Rstudio&amp;simid=607993942360785821&amp;selectedIndex=18" target="_blank" rel="noopener">首页缩略图</a></li>
<li><a href="https://blog.csdn.net/neweastsun/article/details/79435271" target="_blank" rel="noopener">使用R中merge()函数合并数据</a></li>
<li><a href="https://www.cnblogs.com/csguo/p/7294057.html" target="_blank" rel="noopener">R语言paste函数</a></li>
<li><a href="https://www.cnblogs.com/xihehe/p/7306449.html" target="_blank" rel="noopener">R语言学习笔记：mode，class，typeof的区别</a></li>
<li><a href="https://blog.csdn.net/weixin_41859179/article/details/97570369" target="_blank" rel="noopener">Windows下更新R版本及Rstudio</a></li>
<li><a href></a></li>
</ul>
]]></content>
      <categories>
        <category>R语言</category>
      </categories>
      <tags>
        <tag>R</tag>
      </tags>
  </entry>
  <entry>
    <title>Python</title>
    <url>/Python.html</url>
    <content><![CDATA[<center>Python使用手册</center>

<a id="more"></a>
<h1 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h1><ul>
<li><a href="/python-categorical-encoders.html" title="Categorical_encoders">Categorical_encoders</a>
<ul>
<li>对类别变量进行0-1编码、独热编码(One-Hot Encoding)</li>
</ul>
</li>
<li><a href="/python-cmath.html" title="cmath">cmath</a>
<ul>
<li>对复数进行操作</li>
</ul>
</li>
<li><a href="/python-collections%E6%A8%A1%E5%9D%97.html" title="Collections">Collections</a>
<ul>
<li>对队列进行操作</li>
</ul>
</li>
<li><a href="/python-heapq.html" title="heapq">heapq</a>
<ul>
<li>对堆进行操作</li>
<li>可进行堆排序</li>
</ul>
</li>
<li><a href="/python-jieba.html" title="jieba">jieba</a>
<ul>
<li>文本分词</li>
</ul>
</li>
<li><a href="/python-keras.html" title="Keras">Keras</a></li>
<li><a href="/python-missingno.html" title="missingno">missingno</a>
<ul>
<li>可视化缺失值</li>
</ul>
</li>
<li><a href="/python-numpy%E6%A8%A1%E5%9D%97.html" title="NumPy">NumPy</a>
<ul>
<li>对数组、矩阵操作</li>
</ul>
</li>
<li><a href="/python-pandas%E6%A8%A1%E5%9D%97.html" title="Pandas">Pandas</a>
<ul>
<li>对序列Series、数据框DataFrame进行操作</li>
</ul>
</li>
<li><a href="/python-pip.html" title="pip">pip</a>
<ul>
<li>安装python模块</li>
</ul>
</li>
<li><a href="/python-pyecharts%E6%A8%A1%E5%9D%97.html" title="Pyecharts">Pyecharts</a></li>
<li><a href="/python-re%E6%A8%A1%E5%9D%97.html" title="re">re</a></li>
<li><a href="/python-seaborn.html" title="Seaborn">Seaborn</a>
<ul>
<li>基于Matplotlib的数据可视化库</li>
</ul>
</li>
<li><a href="/python-sklearn.html" title="sklearn">sklearn</a></li>
<li><a href="/python-string.html" title="string">string</a></li>
<li><a href="/python-textwrap.html" title="TextWrap">TextWrap</a>
</li>
</ul>

<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><ul>
<li><a href="/python-%E5%91%BD%E5%90%8D%E6%96%B9%E5%BC%8F.html" title="命名方式">命名方式</a></li>
<li><a href="/python-4-%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7.html" title="运算符">运算符</a></li>
<li><a href="/python-5-%E5%87%BD%E6%95%B0.html" title="函数">函数</a></li>
<li><a href="/python-6-%E5%BE%AA%E7%8E%AF.html" title="循环">循环</a></li>
<li><a href="/python-8-%E6%A8%A1%E5%9D%97.html" title="模块">模块</a>
</li>
</ul>
<h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p>Python中的对象包含三个基本要素：</p>
<ul>
<li>id （身份标识）</li>
<li>type （数据类型）</li>
<li>vlaue （值）</li>
</ul>
<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p>Python3的6个标准数据类型：</p>
<ul>
<li>不可变：<ul>
<li>数字Number</li>
<li>字符串String</li>
<li>元组Tuple</li>
</ul>
</li>
<li>可变：<ul>
<li>列表List</li>
<li>字典Dictionary</li>
<li>集合Set</li>
</ul>
</li>
</ul>
<h2 id="数字Number"><a href="#数字Number" class="headerlink" title="数字Number"></a>数字Number</h2><p>Python3支持int、float、bool、complex数字类型。</p>
<h3 id="复数"><a href="#复数" class="headerlink" title="复数"></a>复数</h3><ul>
<li>表示复数的语法是<code>real + image j</code></li>
<li>实部<code>real</code>和虚部<code>image</code>都是浮点数</li>
<li>虚部的后缀可以是<code>j</code>或<code>J</code></li>
<li>复数的conjugate方法可以返回该复数的共轭复数</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lst1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]  <span class="comment">## 可变对象</span></span><br><span class="line">lst2 = lst1  <span class="comment">## 引用传递</span></span><br><span class="line">lst1.append(<span class="number">5</span>)</span><br><span class="line">lst2</span><br><span class="line"><span class="comment"># [1, 2, 3, 5]</span></span><br><span class="line"><span class="comment">## 不可变对象为值传递</span></span><br></pre></td></tr></table></figure>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><a href="/python-%E5%AD%97%E7%AC%A6%E4%B8%B2.html" title="Python | String 字符串">Python | String 字符串</a>
<h2 id="元组Tuple"><a href="#元组Tuple" class="headerlink" title="元组Tuple"></a>元组Tuple</h2><ul>
<li>是一种<strong>有序</strong>列表，和list非常相似</li>
<li>一旦初始化就不能修改</li>
<li>可以获取元素但不能赋值变成其他的元素</li>
<li>元组只包含一个元素时，要在元素后面添加逗号来消除歧义</li>
<li>元组的元素不允许删除</li>
<li>可用del删除整个元组</li>
<li>元组之间可以用 + 和 * 进行运算</li>
<li>创建tuple比list要快，存储空间比list占用更小</li>
<li>tuple是不可变的，可以作为dict的key</li>
<li>成员关系操作符 in 和 not in 也可以直接用在元组上</li>
<li>用圆括号封装 （）</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cmp(tuple1, tuple2)  <span class="comment">##比较两个元组元素</span></span><br><span class="line">len(tuple)  <span class="comment">##计算元组元素个数</span></span><br><span class="line">max(tuple)  <span class="comment">##返回元组中元素最大值</span></span><br><span class="line">min(tuple)  <span class="comment">##返回元组中元素最小值</span></span><br><span class="line">tuple(seq)  <span class="comment">##把列表seq转换为元组</span></span><br></pre></td></tr></table></figure>
<h2 id="列表List"><a href="#列表List" class="headerlink" title="列表List"></a>列表List</h2><a href="/python-%E5%88%97%E8%A1%A8.html" title="Python | List 列表">Python | List 列表</a>
<ul>
<li>是一种<strong>有序</strong>的集合，可以随时添加和删除其中的元素</li>
<li>元素类型可以不同</li>
<li>list可以嵌套（即list的元素可以是list）</li>
<li>成员关系操作符 in 和 not in 可直接用在列表上</li>
<li>list 是可变的对象</li>
<li>用方括号封装 [ ]</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lst.append(a)   <span class="comment">##在列表lst尾部添加元素a</span></span><br><span class="line">lst.insert(num, c)  <span class="comment">##在列表lst的第num+1个位置（索引为num）插入元素c</span></span><br><span class="line">lst.pop()  <span class="comment">##删除列表lst的最后一个元素，并返回该元素</span></span><br><span class="line">lst.pop(i)  <span class="comment">##删除列表lst的索引为i的元素（i可以是负数；i=-2表示删除倒数第二个元素）</span></span><br></pre></td></tr></table></figure>
<h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><h2 id="集合set"><a href="#集合set" class="headerlink" title="集合set()"></a>集合set()</h2><a href="/python-%E9%9B%86%E5%90%88.html" title="Python | Set 集合">Python | Set 集合</a>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">set((<span class="string">"Rank"</span>))</span><br><span class="line"><span class="comment">#&#123;'R', 'a', 'k', 'n'&#125;</span></span><br><span class="line">set(<span class="string">"Rank"</span>)</span><br><span class="line"><span class="comment">#&#123;'R', 'a', 'k', 'n'&#125;</span></span><br><span class="line">set([<span class="string">"Rank"</span>])</span><br><span class="line"><span class="comment">#&#123;'Rank'&#125;</span></span><br></pre></td></tr></table></figure>
<h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><p>正则表达式：对字符串类型数据进行匹配、提取等操作的逻辑公式。</p>
<h2 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h2><p>元字符（Meta Characters）：标点等特殊字符。主要有<code>. $ * + ? | \ ^ [ ] { } ( )</code>等。</p>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: center;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: center;">
      <th>字符</th>
      <th>说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>.</th>
      <td>匹配除换行符（\n，\r）之外的任何单个字符。<br>若要匹配包括\n在内的任何字符，则应使用 (.\|\n)。</td>
    </tr>
    <tr>
      <th>$</th>
      <td>匹配输入字符串的结束位置。<br>如果设置了regex对象的Multiline属性，则$也匹配\n或\r之前的位置。如果$置于character class （即[$]）中，则消除了其特殊意义。<br>例如，[akm$]示匹配a、k、m或$。</td>
    </tr>
    <tr>
      <th>*</th>
      <td>匹配*前面的子表达式零次或多次。<br>等价于 {0,}。</td>
    </tr>
    <tr>
      <th>+</th>
      <td>匹配+前面的子表达式一次或多次；至少匹配一次。<br>等价于{1,}</td>
    </tr>
    <tr>
      <th>?</th>
      <td>匹配?前面的子表达式零次或一次。<br>等价于{0,1}</td>
    </tr>
    <tr>
      <th>|</th>
      <td>表示可选项（或），即 | 前后的表达式任选一个。</td>
    </tr>
    <tr>
      <th>\</th>
      <td>将一个字符标记为一个特殊字符/原义字符，或一个向后引用、或一个八进制转义符。<br>例如：\n表示换行符，而 n 表示字母“n”； \ 表示右斜杠“\”；\t表示制表符。</td>
    </tr>
    <tr>
      <th>^</th>
      <td>取非匹配</td>
    </tr>
    <tr>
      <th>[]</th>
      <td>选择方括号例的任意一个。<br>例如，[0-2]与[012]完全等价，[Rr] 表示匹配字母R和r</td>
    </tr>
    <tr>
      <th>{}</th>
      <td>前面的字符或表达式的重复次数。<br>例如，{5,12}表示重复的次数不能小于5，不能多于12，否则都不匹配</td>
    </tr>
    <tr>
      <th>()</th>
      <td>提取匹配的字符串。<br>例如，(\\s*)表示连续空格的字符串</td>
    </tr>
    <tr>
  </tr></tbody>
</table>
</div>

<h2 id="数量词"><a href="#数量词" class="headerlink" title="数量词"></a>数量词</h2><p>数量词（Quantifiers）</p>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: center;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: center;">
      <th>字符</th>
      <th>说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>{n}</th>
      <td>至少匹配n次。<br>例如，“o{2,}”不能匹配“Bob”中的“o”，但能匹配“fooooood”中的所有“o”；“o{1,}”等价于“o+”；“o{0,}”等价于“o*”</td>
    </tr>
    <tr>
      <th>{n,m}</th>
      <td>n小于等于m。最少匹配n次且最多匹配m次。<br>【注】在逗号和两个数之间不能有空格。<br>例如，“o{1,3}”表示匹配“fooooood”中的前三个“o”；“o{0,1}”等价于“o?”，匹配“o”零次或1次。</td>
    </tr>
    <tr>
  </tr></tbody>
</table>
</div>

<h2 id="序列"><a href="#序列" class="headerlink" title="序列"></a>序列</h2><p>序列（Sequences）：用于匹配字符序列。</p>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: center;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: center;">
      <th>字符</th>
      <th>说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>\b</th>
      <td>匹配一个单词边界（boundary），即单词和空格间的位置。<br>例如，“er\b”可以匹配单词“never”中的“er”，但不能匹配单词“verb”中的“er”。</td>
    </tr>
    <tr>
      <th>\B</th>
      <td>匹配非单词边界。<br>例如，“er\B”可以匹配单词“verb”中的“er”，但不能匹配单词“never”中的“er”。</td>
    </tr>
    <tr>
      <th>\d</th>
      <td>匹配任何一个数字字符（digits）。<br>等价于 “[0-9]”。</td>
    </tr>
    <tr>
      <th>\D</th>
      <td>匹配任何一个非数字字符。<br>等价于 “[^0-9]”。</td>
    </tr>
    <tr>
      <th>\f</th>
      <td>换页符。<br>等价于 “\x0c” 和 “\cL”。</td>
    </tr>
    <tr>
      <th>\h</th>
      <td>匹配水平间隔</td>
    </tr>
    <tr>
      <th>\H</th>
      <td>匹配非水平间隔</td>
    </tr>
    <tr>
      <th>\n</th>
      <td>换行符<br>等价于 “\x0a” 和 “\cJ”</td>
    </tr>
    <tr>
      <th>\r</th>
      <td>回车符<br>等价于 “\x0d” 和 “\cM”</td>
    </tr>
    <tr>
      <th>\s</th>
      <td>匹配任何空白字符，包括空格、制表符、换页符等等。<br>等价于 “[\f\n\r\t\v]”。</td>
    </tr>
    <tr>
      <th>\S</th>
      <td>匹配任何非空白字符<br>等价于 “[^\f\n\r\t\v]”。</td>
    </tr>
    <tr>
      <th>\t</th>
      <td>制表符（tab）<br>等价于 “\x09” 和 “\cl”。</td>
    </tr>
    <tr>
      <th>\v</th>
      <td>垂直制表符<br>等价于 “x0b” 和 “cK”</td>
    </tr>
    <tr>
      <th>\V</th>
      <td>匹配非垂直间隔</td>
    </tr>
    <tr>
      <th>\w</th>
      <td>匹配任何字母、数字、下划线（单词）（word）<br>等价于 “[A-Za-z0-9]”</td>
    </tr>
    <tr>
      <th>\W</th>
      <td>匹配任何非字母、数字、下划线<br>等价于“[^A-Za-z0-9]”
</td>
    </tr>
    <tr>
  </tr></tbody>
</table>
</div>

<h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><h2 id="身份运算符-is"><a href="#身份运算符-is" class="headerlink" title="身份运算符 is"></a>身份运算符 is</h2><p><code>is</code>：身份运算符，比较变量的 id 地址是否相同，即是否指向同一块内存地址</p>
<h2 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h2><p>`==``:比较运算符，比较变量的 value 是否相同，即不管是否是同一块内存地址，只要其值相同即可</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 涉及Python的深浅拷贝问题</span></span><br><span class="line"><span class="comment">##数字、字符串等不可变数据类型</span></span><br><span class="line"><span class="comment">##value一样，id一样</span></span><br><span class="line">a = <span class="number">2</span></span><br><span class="line">b = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">print(id(a), id(b))</span><br><span class="line"><span class="number">140710848664416</span> <span class="number">140710848664416</span></span><br><span class="line"></span><br><span class="line">print(a == b, a <span class="keyword">is</span> b)</span><br><span class="line"><span class="literal">True</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##对于列表和字典等可变数据类型</span></span><br><span class="line"><span class="comment">##即使value一样，id也不一样</span></span><br><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">b = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">print(id(a), id(b))</span><br><span class="line"><span class="number">2348645341512</span> <span class="number">2348645363144</span></span><br><span class="line"></span><br><span class="line">print(a == b, a <span class="keyword">is</span> b</span><br><span class="line"><span class="literal">True</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 涉及Python的深浅拷贝问题</span></span><br><span class="line"><span class="comment">##数字、字符串等不可变数据类型</span></span><br><span class="line"><span class="comment">##value一样，id一样</span></span><br><span class="line">a = <span class="number">2</span></span><br><span class="line">b = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">print(id(a), id(b))</span><br><span class="line"><span class="number">140710848664416</span> <span class="number">140710848664416</span></span><br><span class="line"></span><br><span class="line">print(a == b, a <span class="keyword">is</span> b)</span><br><span class="line"><span class="literal">True</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##对于列表和字典等可变数据类型</span></span><br><span class="line"><span class="comment">##即使value一样，id也不一样</span></span><br><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">b = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">print(id(a), id(b))</span><br><span class="line"><span class="number">2348645341512</span> <span class="number">2348645363144</span></span><br><span class="line"></span><br><span class="line">print(a == b, a <span class="keyword">is</span> b)</span><br><span class="line"><span class="literal">True</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<h1 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h1><h2 id="open"><a href="#open" class="headerlink" title="open()"></a>open()</h2><p>打开一个文件，创建一个file对象</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">open(name[, mode[, buffering]])</span><br></pre></td></tr></table></figure>
<ul>
<li><code>name</code>：文件名称</li>
<li><code>mode</code>：打开文件的模式</li>
<li><code>buffering</code>：是否寄存<ul>
<li><code>buffering=0</code>：不寄存</li>
<li><code>buffering=1</code>：访问文件时会寄存行</li>
<li><code>buffering=c</code>：$c&gt;1$，表明寄存区的缓冲大小</li>
<li><code>buffering=c</code>：$c&lt;0$，寄存区的缓冲大小为系统默认</li>
</ul>
</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">模式</th>
<th style="text-align:left">打开方式</th>
<th style="text-align:left">其他说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>r</code></td>
<td style="text-align:left">只读</td>
<td style="text-align:left">（1）文件的指针放在文件的开头<br>（2）默认模式</td>
</tr>
<tr>
<td style="text-align:center"><code>rb</code></td>
<td style="text-align:left">以二进制格式打开文件用于只读</td>
<td style="text-align:left">（1）文件的指针放在文件的开头<br>（2）默认模式</td>
</tr>
<tr>
<td style="text-align:center"><code>r+</code></td>
<td style="text-align:left">用于读写</td>
<td style="text-align:left">文件的指针放在文件的开头</td>
</tr>
<tr>
<td style="text-align:center"><code>rb+</code></td>
<td style="text-align:left">以二进制格式打开文件用于读写</td>
<td style="text-align:left">文件的指针放在文件的开头</td>
</tr>
<tr>
<td style="text-align:center"><code>w</code></td>
<td style="text-align:left">只用于写入</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center"><code>wb</code></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center"><code>w+</code></td>
<td style="text-align:left">用于读写</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center"><code>wb+</code></td>
<td style="text-align:left">以二进制格式打开文件用于读写</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center"><code>a</code></td>
<td style="text-align:left">用于追加</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center"><code>ab</code></td>
<td style="text-align:left">以二进制格式打开文件用于追加</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center"><code>a+</code></td>
<td style="text-align:left">用于读写</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center"><code>ab+</code></td>
<td style="text-align:left">以二进制格式打开文件用于追加</td>
<td style="text-align:left">（1）如果该文件已存在，文件指针将会放在文件的结尾<br>（2）如果该文件不存在，创建新文件用于读写。</td>
</tr>
</tbody>
</table>
</div>
<h2 id="r"><a href="#r" class="headerlink" title="r"></a>r</h2><p>表示 <code>&#39;&#39;</code>内的字符串默认不转义<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="string">'Hello,\nWorld'</span>)  <span class="comment">## ''内的\n发生了转义（换行）</span></span><br><span class="line"><span class="comment">#Hello,</span></span><br><span class="line"><span class="comment">#World</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">r'Hello,\nWorld'</span>)   <span class="comment">## ''内的\n视为字符串（不转义）</span></span><br><span class="line"><span class="comment">#Hello,\nWorld</span></span><br></pre></td></tr></table></figure></p>
<h2 id="str"><a href="#str" class="headerlink" title="str()"></a>str()</h2><h2 id="zip"><a href="#zip" class="headerlink" title="zip()"></a>zip()</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> part <span class="keyword">in</span> zip(*[iter(<span class="string">'AABCAAADA'</span>)]*<span class="number">3</span>):</span><br><span class="line">    print(part)</span><br><span class="line"><span class="comment">#('A', 'A', 'B')</span></span><br><span class="line"><span class="comment">#('C', 'A', 'A')</span></span><br><span class="line"><span class="comment">#('A', 'D', 'A')</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> part <span class="keyword">in</span> zip(*[iter(<span class="string">'AABCAAADA'</span>)]*<span class="number">3</span>):</span><br><span class="line">    ans = []</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> part:</span><br><span class="line">        <span class="keyword">if</span> x <span class="keyword">not</span> <span class="keyword">in</span> ans:</span><br><span class="line">            ans.append(x)</span><br><span class="line">    print(<span class="string">""</span>.join(ans))</span><br><span class="line"><span class="comment">#AB</span></span><br><span class="line"><span class="comment">#CA</span></span><br><span class="line"><span class="comment">#AD</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://www.runoob.com/python/python-func-open.html" target="_blank" rel="noopener">Python open() 函数</a></li>
<li><a href="https://www.cnblogs.com/Allen-rg/p/10501125.html" target="_blank" rel="noopener">Python endswith() 函数</a></li>
</ul>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Machine Learning | 汇总</title>
    <url>/Machine-Learning-%E6%B1%87%E6%80%BB.html</url>
    <content><![CDATA[<center>Machine Learning 算法汇总</center>




<a id="more"></a>
<ul>
<li><a href="/Machine-Learning-%E5%88%86%E7%B1%BB%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0.html" title="分类模型评估">分类模型评估</a></li>
<li><a href="/Machine-Learning-%E8%81%9A%E7%B1%BB%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0.html" title="聚类模型评估">聚类模型评估</a></li>
<li><a href="/%E7%AE%97%E6%B3%95-%E8%BF%87%E6%8B%9F%E5%90%88.html" title="如何防止过拟合？">如何防止过拟合？</a></li>
<li><a href="/Machine-Learning-%E7%86%B5.html" title="熵">熵</a></li>
<li><a href="/%E7%AE%97%E6%B3%95-%E7%89%B9%E5%BE%81%E5%BD%92%E4%B8%80%E5%8C%96.html" title="归一化、特征缩放">归一化、特征缩放</a>
</li>
</ul>
<h1 id="Machine-Learning-机器学习"><a href="#Machine-Learning-机器学习" class="headerlink" title="Machine Learning 机器学习"></a>Machine Learning 机器学习</h1><ul>
<li>Classical Learning<ul>
<li>Supervised Learning</li>
<li>Unsupervised Learning</li>
</ul>
</li>
<li>Ensemble Methods<ul>
<li>Bagging</li>
<li>Boosting</li>
<li>Stacking</li>
</ul>
</li>
<li>Reinforcement Learning</li>
<li>Neural Networks and Deep Learning</li>
</ul>
<h2 id="Classical-Learning-分类"><a href="#Classical-Learning-分类" class="headerlink" title="Classical Learning 分类"></a>Classical Learning 分类</h2><ul>
<li><a href="/%E7%AE%97%E6%B3%95-SupervisedLearning.html" title="Supervised Learning">Supervised Learning</a>
<ul>
<li>Classification</li>
<li>Regression</li>
</ul>
</li>
<li>Unsupervised Learning<ul>
<li>Clustering</li>
<li>Pattern Search</li>
<li>Dimension Reduction</li>
</ul>
</li>
</ul>
<h3 id="Supervised-Learning-有监督学习"><a href="#Supervised-Learning-有监督学习" class="headerlink" title="Supervised Learning 有监督学习"></a>Supervised Learning 有监督学习</h3><h4 id="Classification"><a href="#Classification" class="headerlink" title="Classification"></a>Classification</h4><p>主要分类算法：</p>
<ul>
<li><a href="/%E7%AE%97%E6%B3%95-KNN.html" title="KNN">KNN</a></li>
<li><a href="/%E7%AE%97%E6%B3%95-%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF.html" title="Naive Bayes 朴素贝叶斯">Naive Bayes 朴素贝叶斯</a></li>
<li><a href="/%E7%AE%97%E6%B3%95-SVM.html" title="SVM 支持向量机">SVM 支持向量机</a></li>
<li><a href="/%E7%AE%97%E6%B3%95-DecisionTree.html" title="Decision Tree 决策树">Decision Tree 决策树</a></li>
<li><a href="/%E7%AE%97%E6%B3%95-LogisticRegression.html" title="Logistic Regression 逻辑回归">Logistic Regression 逻辑回归</a>
</li>
</ul>
<p>相关文章：</p>
<ul>
<li><a href="/Machine-Learning-%E5%88%86%E7%B1%BB%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0.html" title="分类模型评估">分类模型评估</a>
</li>
</ul>
<p>从<strong>使用的主要技术</strong>上看，可以把分类方法归结为4种类型：</p>
<ol>
<li>基于距离的分类方法<ul>
<li>最邻近方法</li>
</ul>
</li>
<li>决策树分类方法<ul>
<li>ID3</li>
<li>C4.5</li>
<li>VFDT</li>
</ul>
</li>
<li>贝叶斯分类方法<ul>
<li>朴素贝叶斯</li>
<li>EM算法</li>
</ul>
</li>
<li>规则归纳方法<ul>
<li>AQ算法</li>
<li>CN2算法</li>
<li>FOIL算法</li>
</ul>
</li>
</ol>
<h4 id="Regression"><a href="#Regression" class="headerlink" title="Regression"></a>Regression</h4><p>主要回归算法：</p>
<ul>
<li><a href="/%E7%AE%97%E6%B3%95-%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92.html" title="Linear Regression 线性回归">Linear Regression 线性回归</a></li>
<li>Ridge Regression 岭回归</li>
<li>Lasso Regression</li>
</ul>
<h3 id="Unsupervised-Learning"><a href="#Unsupervised-Learning" class="headerlink" title="Unsupervised Learning"></a>Unsupervised Learning</h3><h4 id="Clustering"><a href="#Clustering" class="headerlink" title="Clustering"></a>Clustering</h4><ul>
<li>分割聚类算法：<ul>
<li><a href="/%E7%AE%97%E6%B3%95-K-Means.html" title="K-Means K均值聚类">K-Means K均值聚类</a></li>
<li>K-Medoids</li>
<li><a href="/%E7%AE%97%E6%B3%95-CLARANS.html" title="CLARANS">CLARANS</a></li>
</ul>
</li>
<li>层次聚类算法：<ul>
<li><a href="/%E7%AE%97%E6%B3%95-DBSCAN.html" title="DBSCAN">DBSCAN</a></li>
<li>OPTICS</li>
<li><a href="/%E7%AE%97%E6%B3%95-BIRCH.html" title="BIRCH">BIRCH</a></li>
<li>CURE</li>
</ul>
</li>
<li>Mean-Shift</li>
<li>Agglomerative</li>
<li>Fuzzy C-Means</li>
</ul>
<p>相关文章：</p>
<ul>
<li><a href="/Machine-Learning-%E8%81%9A%E7%B1%BB%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0.html" title="聚类模型评估">聚类模型评估</a></li>
<li>
</li>
</ul>
<p><u>表：各种聚类算法对比</u></p>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: center;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: center;">
      <th>算法</th>
      <th>算法效率</th>
      <th>适合的数据类型</th>
      <th>能够发现的聚类类型</th>
      <th>对异常值的敏感性</th>
      <th>对数据输入顺序的敏感性</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>CLARANS</th>
      <td>较低</td>
      <td>数值</td>
      <td>凸形/球形</td>
      <td>不敏感</td>
      <td>非常敏感</td>
    </tr>
    <tr>
      <th>BIRCH</th>
      <td>高</td>
      <td>数值</td>
      <td>凸形/球形</td>
      <td>不敏感</td>
      <td>不太敏感</td>
    </tr>
    <tr>
      <th>DBSCAN</th>
      <td>一般</td>
      <td>数值</td>
      <td>任意形状</td>
      <td>敏感</td>
      <td>敏感</td>
    </tr>
    <tr>
      <th>CURE</th>
      <td>较高</td>
      <td>数值</td>
      <td>任意形状</td>
      <td>不敏感</td>
      <td>不太敏感</td>
    </tr>
    <tr>
      <th>K-poto</th>
      <td>一般</td>
      <td>数值/符号</td>
      <td>凸形/球形</td>
      <td>敏感</td>
      <td>一般</td>
    </tr>
    <tr>
      <th>CUQUE</th>
      <td>较低</td>
      <td>数值</td>
      <td>凸形/球形</td>
      <td>一般</td>
      <td>不敏感</td>
    </tr>
  </tbody>
</table>
</div>


<h4 id="Pattern-Search"><a href="#Pattern-Search" class="headerlink" title="Pattern Search"></a>Pattern Search</h4><ul>
<li>Euclat</li>
<li><a href="/%E7%AE%97%E6%B3%95-Apriori.html" title="Apriori">Apriori</a></li>
<li>FP-Growth</li>
</ul>
<h4 id="Dimension-Reduction"><a href="#Dimension-Reduction" class="headerlink" title="Dimension Reduction"></a>Dimension Reduction</h4><ul>
<li><a href="/%E7%AE%97%E6%B3%95-t-SNE.html" title="t-SNE">t-SNE</a></li>
<li>PCA</li>
<li>LSA</li>
<li>SVD</li>
<li>LDA</li>
</ul>
<h2 id="Ensemble-Methods"><a href="#Ensemble-Methods" class="headerlink" title="Ensemble Methods"></a>Ensemble Methods</h2><a href="/%E7%AE%97%E6%B3%95-%E9%9B%86%E6%88%90%E6%96%B9%E6%B3%95.html" title="集成方法">集成方法</a>
<ul>
<li>Bagging</li>
<li>Boosting</li>
<li>Stacking</li>
</ul>
<h3 id="Bagging"><a href="#Bagging" class="headerlink" title="Bagging"></a>Bagging</h3><ul>
<li><a href="/%E7%AE%97%E6%B3%95-%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97.html" title="Random Forest 随机森林">Random Forest 随机森林</a>
</li>
</ul>
<h3 id="Boosting"><a href="#Boosting" class="headerlink" title="Boosting"></a>Boosting</h3><ul>
<li><a href="/%E7%AE%97%E6%B3%95-AdaBoost.html" title="AdaBoost">AdaBoost</a></li>
<li><a href="/%E7%AE%97%E6%B3%95-XGBoost.html" title="XGBoost">XGBoost</a></li>
<li>LightGBM</li>
<li>CatBoost</li>
<li><a href="/%E7%AE%97%E6%B3%95-BoostingTree.html" title="Boosting Tree 提升树">Boosting Tree 提升树</a>
</li>
</ul>
<div class="note default">
            <p>Boosting is a method of converting a set of weak learners into strong learners.</p>
          </div>
<p>Boosting是一种将弱学习器转化成强学习器的方法。</p>
<p>假设进行的是二分类任务：</p>
<ul>
<li>弱学习器的分类错误率仅略小于0.5（分类效果只比扔硬币好一点）</li>
<li>强学习器的分类错误率接近0<br>将弱学习器转化为强学习器——将多个弱学习器<sup><a href="#fn_1" id="reffn_1">1</a></sup>联合起来，通过投票得到最后分类结果</li>
</ul>
<blockquote id="fn_1">
<sup>1</sup>. 这里的弱学习器之间相关性要小<a href="#reffn_1" title="Jump back to footnote [1] in the text."> &#8617;</a>
</blockquote>
<div class="note primary">
            <p>为实现弱学习器互补，则需要解决两个问题：</p><ol><li>怎样获得不同的弱学习器？</li><li>怎样组合弱学习器？</li></ol>
          </div>
<h3 id="Stacking"><a href="#Stacking" class="headerlink" title="Stacking"></a>Stacking</h3><h2 id="Reinforcement-Learning"><a href="#Reinforcement-Learning" class="headerlink" title="Reinforcement Learning"></a>Reinforcement Learning</h2><ul>
<li>Genetic Algorithm</li>
<li>A3C</li>
<li>SARSA</li>
<li>Q-Learning</li>
<li>DQN</li>
</ul>
<h2 id="Neural-Nets-and-Deep-Learning"><a href="#Neural-Nets-and-Deep-Learning" class="headerlink" title="Neural Nets and Deep Learning"></a>Neural Nets and Deep Learning</h2><ul>
<li>CNN</li>
<li>RNN</li>
<li>GAN</li>
<li>Autoencoders</li>
<li>MLP</li>
</ul>
<p>其他:</p>
<ul>
<li><a href="/%E7%AE%97%E6%B3%95-%E6%84%9F%E7%9F%A5%E6%9C%BA.html" title="感知机Perceptron">感知机Perceptron</a></li>
<li><a href="/%E7%AE%97%E6%B3%95-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C.html" title="神经网络的激活函数">神经网络的激活函数</a>
</li>
</ul>
<h3 id="CNN"><a href="#CNN" class="headerlink" title="CNN"></a>CNN</h3><h3 id="RNN"><a href="#RNN" class="headerlink" title="RNN"></a>RNN</h3><ul>
<li>LSM</li>
<li>LSTM</li>
<li>GRU</li>
</ul>
<h4 id="LSM"><a href="#LSM" class="headerlink" title="LSM"></a>LSM</h4><h4 id="LSTM"><a href="#LSTM" class="headerlink" title="LSTM"></a>LSTM</h4><h4 id="GRU"><a href="#GRU" class="headerlink" title="GRU"></a>GRU</h4><ul>
<li>GAN</li>
<li>Autoencoders</li>
<li>Perceptrons (MLP)</li>
</ul>
<h3 id="GAN"><a href="#GAN" class="headerlink" title="GAN"></a>GAN</h3><p>Generative Adversarial Nerworks</p>
<h3 id="Autoencoders"><a href="#Autoencoders" class="headerlink" title="Autoencoders"></a>Autoencoders</h3><p>seq2seq</p>
<h3 id="Perceptrons-MLP"><a href="#Perceptrons-MLP" class="headerlink" title="Perceptrons (MLP)"></a>Perceptrons (MLP)</h3><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://cn.bing.com/images/search?view=detailV2&amp;ccid=k5LiTi5l&amp;id=95DF77DEC29B1CD7083F9435F1AE55043B0C0081&amp;thid=OIP.k5LiTi5lt_ND02kaBT_SAAHaE7&amp;mediaurl=https%3a%2f%2fwww.smartdatacollective.com%2fwp-content%2fuploads%2f2018%2f11%2fMachine-learning-1024x682.jpg&amp;exph=682&amp;expw=1024&amp;q=machine+learning&amp;simid=608018054240865990&amp;selectedIndex=3" target="_blank" rel="noopener">首页缩略图</a></li>
<li><a href="http://cda.pinggu.org/view/20203.html" target="_blank" rel="noopener">聚类分析中几种算法的比较</a></li>
</ul>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>数据分析 | 汇总</title>
    <url>/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90-%E4%B8%9A%E5%8A%A1%E5%90%91%E9%97%AE%E9%A2%98%E5%92%8C%E6%96%B9%E6%B3%95%E6%B1%87%E6%80%BB.html</url>
    <content><![CDATA[<p><center>Data Analysis</center><br><a id="more"></a></p>
<h1 id="数据分析"><a href="#数据分析" class="headerlink" title="数据分析"></a>数据分析</h1><p>数据分析的<strong>本质</strong>是<u>解决某一个业务问题</u>。</p>
<blockquote id="fn_1">
<sup>1</sup>. 上报机制：是指数据上报的时机、内容和技术实现形式<a href="#reffn_1" title="Jump back to footnote [1] in the text."> &#8617;</a>
</blockquote>
<p>在数据来源正确的前提下，进行数据分析的方法可分为</p>
<ul>
<li><strong>定性分析</strong>：对事物的性质作出判断——“是什么”</li>
<li><strong>定量分析</strong>：对事物的数量作出统计——“有多少”</li>
</ul>
<p>数据分析就是定性分析与定量分析相互结合、不断验证的过程。<br>提出假设、设计方案、分析数据、验证或推翻假设，最后抽丝剥茧，逐渐接近真相。</p>
<p><strong>用户研究</strong>：通过对网站访问量、应用行为统计登数据的分析，从中发现用户使用产品的情况，从中总结出一定的规律和趋势，供其他部门（市场营销、产品规划等）制定决策用。</p>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><ul>
<li><a href="/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90-%E8%B4%B9%E7%B1%B3%E9%97%AE%E9%A2%98.html" title="费米问题">费米问题</a></li>
<li><a href="/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90-%E6%8C%87%E6%A0%87%E5%BC%82%E5%8A%A8%E7%B1%BB%E9%97%AE%E9%A2%98.html" title="指标异动类问题">指标异动类问题</a></li>
<li><a href="/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90-VIP%E4%BC%9A%E5%91%98%E5%A5%97%E9%A4%90%E5%AE%9A%E4%BB%B7%E7%AD%96%E7%95%A5.html" title="VIP会员套餐定价策略">VIP会员套餐定价策略</a>
</li>
<li>
</li>
</ul>
<h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><ul>
<li><a href="/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90-AARRR%E6%A8%A1%E5%9E%8B.html" title="AARRR模型">AARRR模型</a></li>
<li>波特五力模型</li>
<li>SWOT分析模型</li>
<li>SPACE矩阵（战略第位与行动评价矩阵）</li>
<li>SCP分析模型</li>
<li>战略钟</li>
<li>波士顿分析矩阵</li>
<li>GE行业吸引力矩阵</li>
<li>三四矩阵</li>
<li>价值链模型</li>
<li>ROS/RMS矩阵</li>
<li><a href="/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90-ABtest.html" title="ABtest">ABtest</a>
</li>
</ul>
<h1 id="指标-定义"><a href="#指标-定义" class="headerlink" title="指标/定义"></a>指标/定义</h1><ul>
<li><a href="/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90-%E6%B8%B8%E6%88%8F%E7%B1%BB%E5%90%8D%E8%AF%8D%E5%92%8C%E6%8C%87%E6%A0%87.html" title="游戏类名词和指标">游戏类名词和指标</a></li>
<li><a href="/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90-%E4%B8%BB%E8%A6%81%E6%8C%87%E6%A0%87.html" title="常见数据分析业务相关指标">常见数据分析业务相关指标</a>
</li>
</ul>
<h1 id="不同行业"><a href="#不同行业" class="headerlink" title="不同行业"></a>不同行业</h1><h2 id="电商"><a href="#电商" class="headerlink" title="电商"></a>电商</h2><p>电商用户的转化漏斗一般是：</p>
<p><pre class="mermaid">graph LR;
    访问--> 注册;
    注册-->搜索;
    搜索-->浏览;
    浏览-->加入购物车;
    加入购物车-->支付;</pre><br>以及可能的“未来的退货”。</p>
<h2 id="文化娱乐"><a href="#文化娱乐" class="headerlink" title="文化娱乐"></a>文化娱乐</h2><h3 id="微博"><a href="#微博" class="headerlink" title="微博"></a>微博</h3><ul>
<li><a href="https://www.nowcoder.com/discuss/427494" target="_blank" rel="noopener">如何提升微博付费会员数量？</a><ul>
<li>用户动机角度<ul>
<li>身份特权：微博红名、挂件、尊贵标识、优质昵称等</li>
<li>功能特权：带图评论、悄悄关注、编辑已发布内容、粉丝认证号等</li>
</ul>
<ol>
<li>对提升用户会员身份感知进行拆解分析</li>
<li>对功能进行拆解分析</li>
</ol>
</li>
<li>会员本身角度<ul>
<li>会员定价策略</li>
<li>会员付费模式</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="视频"><a href="#视频" class="headerlink" title="视频"></a>视频</h3><ul>
<li><a href="https://www.nowcoder.com/discuss/427663" target="_blank" rel="noopener">设置哪些指标来判断视频质量好坏，如何与是否推荐精准区别</a><ul>
<li>从<u>用户行为角度</u>分析</li>
<li>用户的行为包括：点击进入（点击率）、观看（视频观看进度完成率）、转评赞（转评赞点击率）、关注创作者（关注率）等等</li>
<li>从用户行为区别质量差的视频和推荐不精准但质量好的视频<ul>
<li>质量差：点击进入后观看一段时间（如10s以上）然后退出；在给大量用户推荐后仍不会产生大量的转评赞</li>
<li>推荐不准但质量好：用户不会点击进入，或点击后发现不感兴趣在5s内退出；视频在广泛推荐后，转评赞的产生率和数量高，并且由该视频产生的关注点击率高</li>
</ul>
</li>
</ul>
</li>
<li><a href="https://www.nowcoder.com/discuss/427638" target="_blank" rel="noopener">长短视频的区别以及彼此的优势与改进思路</a><br>从<u>内容角度</u>分析</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">长视频</th>
<th style="text-align:center">短视频</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">内容类型</td>
<td style="text-align:center">成系列的剧集、综艺、电影等</td>
<td style="text-align:center">信息流</td>
</tr>
<tr>
<td style="text-align:center">时间</td>
<td style="text-align:center">$\geq 5$分钟</td>
<td style="text-align:center">$&lt;5$分钟</td>
</tr>
<tr>
<td style="text-align:center">内容产生</td>
<td style="text-align:center">平台提供</td>
<td style="text-align:center">用户上传</td>
</tr>
</tbody>
</table>
</div>
<p> 从<u>用户行为角度</u>分析</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">长视频</th>
<th style="text-align:center">短视频</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">使用场景</td>
<td style="text-align:center">需要较长时间观看</td>
<td style="text-align:center">可在碎片化时间观看</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">常在电视机、电脑上观看</td>
<td style="text-align:center">在手机上观看</td>
</tr>
<tr>
<td style="text-align:center">软件使用</td>
<td style="text-align:center">转频赞、发弹幕、切换需要多步操作</td>
<td style="text-align:center">无缝衔接一步切换</td>
</tr>
</tbody>
</table>
</div>
<p>从<u>盈利模式角度</u>分析</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">长视频</th>
<th style="text-align:center">短视频</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">广告</td>
<td style="text-align:center">视频前广告植入</td>
<td style="text-align:center">精准匹配广告短视频</td>
</tr>
<tr>
<td style="text-align:center">会员</td>
<td style="text-align:center">跳过广告、观看会员剧集</td>
<td style="text-align:center">针对创作者的会员权益</td>
</tr>
</tbody>
</table>
</div>
<h2 id="在线旅游"><a href="#在线旅游" class="headerlink" title="在线旅游"></a>在线旅游</h2><h2 id="求职网站"><a href="#求职网站" class="headerlink" title="求职网站"></a>求职网站</h2><ul>
<li></li>
<li>
</li>
</ul>
<p>求职网站变现的三种思路：</p>
<ol>
<li>用户信息收费</li>
<li>用人企业发布广告费用</li>
<li>猎头借助平台寻找精英的数据使用费用</li>
</ol>
<p>用户增长渠道：</p>
<ul>
<li>电子邮件邀请<br>用户被动地接受信息</li>
<li>搜索<br>用户主动地获取信息</li>
</ul>
<h2 id="即时通信"><a href="#即时通信" class="headerlink" title="即时通信"></a>即时通信</h2><h3 id="陌陌"><a href="#陌陌" class="headerlink" title="陌陌"></a>陌陌</h3><ul>
<li>主推陌生人交友特性，基于地理位置的“看附近的人”是其早期引爆增长的卖点</li>
<li>陌陌内部对每天“活跃用户”的定义是“登录成功并提交地理位置一次”</li>
</ul>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul>
<li>初创公司的常见问题：<ul>
<li>如何提升转化率？</li>
<li>如何提高留存度？<br>早期进来的用户一般是核心用户，留存度相对较高；后期拉来的用户相对黏度比较低。</li>
<li>创业公司不同阶段如何用好数据？<br>早期靠直觉，后期靠科学</li>
</ul>
</li>
<li><a href="https://www.nowcoder.com/discuss/427551" target="_blank" rel="noopener">如何设置指标评价新手教程的优劣？</a><ul>
<li>从<u>用户行为角度</u><ul>
<li>查看功能介绍：页面停留时间</li>
<li>点击下一步/关闭：点击率、“跳过”率</li>
</ul>
</li>
<li>从<u>功能实现角度</u><ul>
<li>查看感兴趣内容：感兴趣模块的点击率、活跃程度（转赞评、在线时间）</li>
<li>特色功能：特色功能的使用情况</li>
</ul>
</li>
<li>从<u>用户反馈角度</u><ul>
<li>搜索建议中点击量、搜索量</li>
<li>是否在搜索引擎中搜索某个功能</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h1><h2 id="A-B-test"><a href="#A-B-test" class="headerlink" title="A/B test"></a>A/B test</h2><ul>
<li>网站Optimize.ly</li>
<li>网站Unbouce</li>
</ul>
<h2 id="应用统计分析"><a href="#应用统计分析" class="headerlink" title="应用统计分析"></a>应用统计分析</h2><p>移动应用统计分析平台：</p>
<ul>
<li>Google Analytics</li>
<li>友盟</li>
<li>Talking Data</li>
</ul>
<h1 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h1><ul>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzIyNjM2MzQyNg==&amp;mid=2247492860&amp;idx=1&amp;sn=be8a2ab72699660ccd75c458e964635a&amp;chksm=e87335b1df04bca73d9d4a403efbd7a304bdffe8dd6a9f43cd33c8ca722e7fcb384115d626ed&amp;mpshare=1&amp;scene=24&amp;srcid=&amp;sharer_sharetime=1589717960845&amp;sharer_shareid=b539221659d6ecf12200314308b58dd3&amp;key=9a2e04ae92e130129a61f75ec9474bf1430ae2335af9cff37c0a6ba3272d3feb579d6223ae5f1f7b803b691d8db05e274e4ab897649314da85a69a03c02b209edf757d93f98fb71afb6ffe1531cd1431&amp;ascene=14&amp;uin=MjAwNDUzMjgxNw%3D%3D&amp;devicetype=Windows+10+x64&amp;version=62090070&amp;lang=zh_CN&amp;exportkey=Aapk%2FjbODrD7T3k%2Fii3bwTs%3D&amp;pass_ticket=vCOnZ86B9zjbSGFnUl2pZh2C3sFfxo%2BAKXmGUdzX1teUg6KzXE86GrBP%2Fo1Z8BFC" target="_blank" rel="noopener">Kaggle知识点：数据分析思路与工具（EDA）</a></li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://cn.bing.com/images/search?view=detailV2&amp;ccid=OeAo7X3d&amp;id=8DE4FFE2C9784F70995A7259FAA0FE7BC2FDC0BD&amp;thid=OIP.OeAo7X3dW94x7RoxwI0P_AHaEU&amp;mediaurl=http%3a%2f%2fwww.appadhoc.com%2fblog%2fwp-content%2fuploads%2f2017%2f02%2fwebanalysis.png&amp;exph=350&amp;expw=600&amp;q=%e6%95%b0%e6%8d%ae%e5%88%86%e6%9e%90&amp;simid=607999727637630187&amp;selectedIndex=42" target="_blank" rel="noopener">首页缩略图</a></li>
<li><a href="http://blog.growingio.com/growth/298" target="_blank" rel="noopener">增长秘籍：互联网增长的第一本数据分析手册</a></li>
<li><a href="https://book.douban.com/subject/27593848/" target="_blank" rel="noopener">增长黑客</a></li>
<li><a href="https://mp.weixin.qq.com/s/XJPZtgA1owg7noLORLcMHw" target="_blank" rel="noopener">一套数据分析的实用方法论</a></li>
<li><a href="https://baike.baidu.com/item/%E8%AF%A2%E7%9B%98/1164917?fr=aladdin" target="_blank" rel="noopener">百度百科-询盘</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU5Mjg2OTQ1MA==&amp;mid=2247485604&amp;idx=1&amp;sn=6132243e552196c5357f7be5661a2fbc&amp;chksm=fe186981c96fe097090839cac38109670803301d3af2e6cb7e3aa1fb4dbe3643f5cdd1fc7a74&amp;mpshare=1&amp;scene=24&amp;srcid=&amp;sharer_sharetime=1589809278889&amp;sharer_shareid=b539221659d6ecf12200314308b58dd3&amp;key=61d9a55bd4b13250d9d9b72c926e31f3c963fa7004ed53af86ab53fe1f6b5801bf460986f5969cc4d9ddf3fd098c904d6f1b8f640c0d7aca9f572945246ccea42c22b5d804b881a7955b74528f2f0865&amp;ascene=14&amp;uin=MjAwNDUzMjgxNw%3D%3D&amp;devicetype=Windows+10+x64&amp;version=62090070&amp;lang=zh_CN&amp;exportkey=AYkajeOrvqQzbnEaJ%2BpPxfA%3D&amp;pass_ticket=3hFOenbHRrI0XNiw95BJRgPjuKhLFRWJBVANkKsJrq9CYNi1R7fJlSrcHa4V3zgz" target="_blank" rel="noopener">10大经典数据分析模型，你知道几个？</a></li>
</ul>
]]></content>
      <categories>
        <category>数据分析</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
        <tag>业务向</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL</title>
    <url>/SQL.html</url>
    <content><![CDATA[<center>SQL相关知识积累~</center>

<a id="more"></a>
<h1 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h1><p>SQL语言具有两种<strong>使用方式</strong>，分别为</p>
<ol>
<li><strong>交互式SQL</strong>：在终端交互方式下使用</li>
<li><strong>嵌入式SQL</strong>：嵌入在高级语言的程序中使用；这些高级语言可以是C语言、PASCAL、COBOL等，被称为宿主语言</li>
</ol>
<h2 id="交互式SQL"><a href="#交互式SQL" class="headerlink" title="交互式SQL"></a>交互式SQL</h2><h3 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h3><a href="/MySQL.html" title="MySQL">MySQL</a>
<h3 id="MS-SQL-Server"><a href="#MS-SQL-Server" class="headerlink" title="MS SQL Server"></a>MS SQL Server</h3><a href="/SQL-Server.html" title="SQL Server">SQL Server</a>
<h3 id="ACCESS"><a href="#ACCESS" class="headerlink" title="ACCESS"></a>ACCESS</h3><a href="/ACCESS.html" title="ACCESS">ACCESS</a>
<h2 id="嵌入式SQL"><a href="#嵌入式SQL" class="headerlink" title="嵌入式SQL"></a>嵌入式SQL</h2><h3 id="嵌入C语言程序"><a href="#嵌入C语言程序" class="headerlink" title="嵌入C语言程序"></a>嵌入C语言程序</h3><ul>
<li>SQL 与 C 语言处理记录的方式是不同的。当将 SQL 语句嵌入到 C 语言程序时，为协调两者而引入<strong>游标</strong>（<a href="https://www.nowcoder.com/questionTerminal/56131e315f2d4071847d6a052b47260d" target="_blank" rel="noopener">题目来源</a>）</li>
</ul>
<h1 id="SQL标准"><a href="#SQL标准" class="headerlink" title="SQL标准"></a>SQL标准</h1><ul>
<li>SQL92标准定义的最严格事务级别是：Serializable（可串行化）</li>
</ul>
<h1 id="SQL语言"><a href="#SQL语言" class="headerlink" title="SQL语言"></a>SQL语言</h1><p>SQL有四种语言（也有的说法将TCL考虑为第五种）：</p>
<ul>
<li>DDL  数据定义语言</li>
<li>DQL  数据查询语言</li>
<li>DML  数据库操纵语言</li>
<li>DCL  数据库控制语言</li>
<li>TCL  事务控制语言</li>
</ul>
<p>详情请见《<a href="/sql-sql%E8%AF%AD%E8%A8%80%E7%B1%BB%E5%9E%8B.html" title="SQL语言类型">SQL语言类型</a>》</p>
<h1 id="相关书籍"><a href="#相关书籍" class="headerlink" title="相关书籍"></a>相关书籍</h1><ul>
<li><a href="/sql-sql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A.html" title="《SQL必知必会》">《SQL必知必会》</a> </li>
<li><a href="/sql-SQL%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B.html" title="《SQL进阶教程》">《SQL进阶教程》</a></li>
<li><a href="/sql-sql%E8%A7%A3%E6%83%91.html" title="《SQL解惑》">《SQL解惑》</a>
</li>
</ul>
<h1 id="数据设计"><a href="#数据设计" class="headerlink" title="数据设计"></a>数据设计</h1><ul>
<li>在关系数据库设计中，关系模式是用来记录用户数据的<strong>二维表</strong></li>
</ul>
<h2 id="概念结构设计"><a href="#概念结构设计" class="headerlink" title="概念结构设计"></a>概念结构设计</h2><p>数据设计中的E-R模型设计是<strong>概念结构设计</strong>阶段的主要工作之一</p>
<ul>
<li>数据库的概念独立于具体的机器和DBMS</li>
</ul>
<h3 id="E-R方法"><a href="#E-R方法" class="headerlink" title="E-R方法"></a>E-R方法</h3><p>实体-联系方法（E-R，Entity-Relationship Approach），是描述现实世界概念结构模型的有效方法。</p>
<ul>
<li><strong>矩形</strong>：实体型</li>
<li><strong>椭圆</strong>：实体的属性</li>
<li><strong>菱形</strong>：实体型之间的联系</li>
</ul>
<h2 id="逻辑结构设计"><a href="#逻辑结构设计" class="headerlink" title="逻辑结构设计"></a>逻辑结构设计</h2><ul>
<li>在数据库设计中，将ER图转换为关系数据模型的过程属于<strong>逻辑设计阶段</strong></li>
</ul>
<h2 id="物理结构设计"><a href="#物理结构设计" class="headerlink" title="物理结构设计"></a>物理结构设计</h2><h1 id="键（码）"><a href="#键（码）" class="headerlink" title="键（码）"></a>键（码）</h1><p>数据库中的<strong>键</strong>（key）也可以称为<strong>码</strong>，是关系模型中的一个重要概念，它是逻辑结构，不是数据库的物理部分。</p>
<ul>
<li><strong>候选键（码）</strong>：如果关系中的某一属性组的值能唯一地标识一个元组，则称该属性组为候选码</li>
<li><strong>主键（码）</strong>：如果一个关系有多个候选码，则选定其中一个为主码</li>
<li><strong>主属性</strong>：候选码的诸属性</li>
<li><strong>非主属性</strong>：不包含在任何候选码中的属性</li>
</ul>
<h2 id="超键（码）"><a href="#超键（码）" class="headerlink" title="超键（码）"></a>超键（码）</h2><p>能唯一标识元组的属性集中的其中一个属性可以作为一个超键，多个属性组合也可以作为一个超键（Super Key）。</p>
<ul>
<li>在关系中能唯一标识元组的属性集称为关系模式的超键</li>
</ul>
<h2 id="候选键（码）"><a href="#候选键（码）" class="headerlink" title="候选键（码）"></a>候选键（码）</h2><p>候选键（码）（Candidate Key）有2个要求：</p>
<ol>
<li>始终能够唯一地标识一个元组</li>
<li>在属性集中找不出真子集能够满足条件</li>
</ol>
<ul>
<li>可以将“候选键（码）”理解为不能再“缩小”的超键（不含有多余属性的超键）</li>
</ul>
<h2 id="主键（码）"><a href="#主键（码）" class="headerlink" title="主键（码）"></a>主键（码）</h2><p>如果一个关系有多个候选键（码），则选定其中一个为主键（码）（Primary Key）</p>
<ul>
<li>在关系模式中，对应关系的主键必须是能唯一确定元组的一组属性</li>
<li>主键是唯一、不为空值的列</li>
</ul>
<h2 id="外键（码）"><a href="#外键（码）" class="headerlink" title="外键（码）"></a>外键（码）</h2><ul>
<li>在一个关系A中，有一个属性b不是关系A的主键（码）或候选键（码），但是是另一个关系B的主键，则关系A中的属性b是关系A中的外键（码）</li>
<li>在SQL语言中使用<code>FOREIGN KEY</code>时，与之配合的语句是<code>REFERENCES</code></li>
</ul>
<h2 id="全键（码）"><a href="#全键（码）" class="headerlink" title="全键（码）"></a>全键（码）</h2><ul>
<li>是候选键（码）的一种特殊情况</li>
<li>如果关系中只有一个候选键（码），且这个候选键（码）中包含了全部属性，那么称这个候选码为全键（码）</li>
</ul>
<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><p>详情请见《<a href="/sql-%E4%BA%8B%E5%8A%A1.html" title="SQL事务">SQL事务</a>》</p>
<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><p>数据库事务的四大特性（简称<strong>ACID</strong>）：</p>
<ol>
<li>原子性（Atomicity）</li>
<li>一致性（Consistency）</li>
<li>隔离性（Isolation）</li>
<li>持久性（Durability）</li>
</ol>
<h2 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h2><ol>
<li>Read Uncommitted（未提交读）</li>
<li>Read Committed（提交读）</li>
<li>Repeatable Read（可重复读）</li>
<li>Serializable（可串行化）</li>
</ol>
<ul>
<li>隔离级别依次增加</li>
<li>并发性能依次降低</li>
<li>随着隔离级别的增高，并发性能降低</li>
</ul>
<h1 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h1><ul>
<li>在视图上能够完成的操作：<ul>
<li>更新视图</li>
<li>查询</li>
<li>在视图上定义新的视图</li>
</ul>
</li>
<li>在视图上<strong>不能</strong>完成的操作是：在视图上定义新的表</li>
</ul>
<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><h1 id="通用"><a href="#通用" class="headerlink" title="通用"></a>通用</h1><ul>
<li><a href="/sql-%E8%8C%83%E5%BC%8F.html" title="范式">范式</a></li>
<li><a href="/sql-2-%E6%A8%A1%E5%BC%8F.html" title="模式">模式</a></li>
<li></li>
<li><a href="/sql-sql%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F.html" title="SQL语句执行顺序">SQL语句执行顺序</a>
</li>
</ul>
<h2 id="COALESCE"><a href="#COALESCE" class="headerlink" title="COALESCE()"></a>COALESCE()</h2><p><code>COALESCE(expression1, expression2, expression3, ...)</code>：接收一系列表达式或列，返回第一个非空的值。</p>
<ul>
<li>如果都是空值（NULL），则会报错</li>
</ul>
<h2 id="CREATE"><a href="#CREATE" class="headerlink" title="CREATE"></a>CREATE</h2><h3 id="CREATE-FUNCTION"><a href="#CREATE-FUNCTION" class="headerlink" title="CREATE FUNCTION"></a>CREATE FUNCTION</h3><p>编写函数：<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 某电器商品海关进口税征收办法，起征点为500元，超出部分按以下2级计算：</span></span><br><span class="line"><span class="comment">-- 1 、超过0至150， 税率3%</span></span><br><span class="line"><span class="comment">-- 2、 超过150元以上 ，税率10%</span></span><br><span class="line"><span class="comment">-- 商品进口税=(商品总额-500)*税率</span></span><br><span class="line"><span class="comment">-- 编写一个函数，实现输入商品的总额，返回该商品的进口税</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> goods(@total <span class="keyword">AS</span> money)</span><br><span class="line"><span class="keyword">RETURNS</span> money <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">  <span class="keyword">declare</span> @income money</span><br><span class="line">  <span class="keyword">declare</span> @tax money</span><br><span class="line"><span class="keyword">SELECT</span> @income = @total - <span class="number">500</span></span><br><span class="line"><span class="keyword">IF</span> @income &lt;= <span class="number">0</span> <span class="keyword">SET</span> @tax = <span class="number">0</span></span><br><span class="line"><span class="keyword">ELSE</span> </span><br><span class="line">  <span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">IF</span>(<span class="number">0</span> &lt; @income <span class="keyword">AND</span> @income &lt;= <span class="number">150</span>)</span><br><span class="line">      <span class="keyword">SELECT</span> @tax = @income * <span class="number">0.03</span></span><br><span class="line">    <span class="keyword">IF</span>(@income &gt; <span class="number">150</span>)</span><br><span class="line">      <span class="keyword">SELECT</span> @tax = @income * <span class="number">0.1</span></span><br><span class="line">    <span class="keyword">END</span></span><br><span class="line"><span class="keyword">RETURN</span> @tax</span><br><span class="line"><span class="keyword">END</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 或</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> goods(@total <span class="keyword">AS</span> money)</span><br><span class="line"><span class="keyword">RETURNS</span> money <span class="keyword">AS</span> </span><br><span class="line"><span class="keyword">BEGIN</span> </span><br><span class="line">  <span class="keyword">declare</span> @income money</span><br><span class="line">  <span class="keyword">declare</span> @tax money</span><br><span class="line"><span class="keyword">SET</span> @income = @total - <span class="number">500</span></span><br><span class="line"><span class="keyword">IF</span> @income &lt;= <span class="number">0</span> <span class="keyword">SET</span> @tax = <span class="number">0</span></span><br><span class="line"><span class="keyword">ELSE</span> </span><br><span class="line">  <span class="keyword">BEGIN</span> </span><br><span class="line">    <span class="keyword">IF</span>(<span class="number">0</span> &lt; @income <span class="keyword">AND</span> @income &lt;= <span class="number">150</span>)</span><br><span class="line">      <span class="keyword">SET</span> @tax = @income * <span class="number">0.03</span></span><br><span class="line">    <span class="keyword">IF</span>(@income &gt; <span class="number">150</span>)</span><br><span class="line">      <span class="keyword">SET</span> @tax = @income * <span class="number">0.1</span></span><br><span class="line">    <span class="keyword">END</span></span><br><span class="line"><span class="keyword">RETURN</span> @tax</span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure></p>
<h2 id="DATEDIFF"><a href="#DATEDIFF" class="headerlink" title="DATEDIFF()"></a>DATEDIFF()</h2><p><code>DATEDIFF(string enddate, string startdate)</code>：返回结束日期减去开始日期的天数</p>
<ul>
<li>返回值：<code>int</code></li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 计算0701-0715的区间三日留存率</span></span><br><span class="line"><span class="comment">-- 区间三日留存率：t+1、t+2、t+3任意一天有回访即算留存</span></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">	  t1.aday</span><br><span class="line">    , <span class="keyword">ROUND</span>(<span class="keyword">COUNT</span>(<span class="keyword">DISTINCT</span> t2.id) / <span class="keyword">COUNT</span>(<span class="keyword">DISTINCT</span> t1.id) ,<span class="number">4</span>)<span class="keyword">AS</span> cohort_rate</span><br><span class="line"><span class="keyword">FROM</span> cust t1 </span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> cust t2</span><br><span class="line"><span class="keyword">ON</span> t1.id = t2.id</span><br><span class="line"><span class="keyword">AND</span> (<span class="keyword">DATEDIFF</span>(t2.aday, t1.aday) =<span class="number">1</span> <span class="keyword">OR</span> <span class="keyword">DATEDIFF</span>(t2.aday, t1.aday) =<span class="number">2</span> <span class="keyword">OR</span> <span class="keyword">DATEDIFF</span>(t2.aday, t1.aday) =<span class="number">3</span>)</span><br><span class="line"><span class="keyword">WHERE</span> t1.aday <span class="keyword">BETWEEN</span> <span class="string">'2020-07-01'</span> <span class="keyword">AND</span> <span class="string">'2020-07-15'</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> </span><br><span class="line">	t1.aday;</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 计算次日、2日、3日留存率</span></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    tt1.date</span><br><span class="line">    , tt2.gap</span><br><span class="line">    , tt2.retention_num</span><br><span class="line">    , tt2.retention_num / tt1.uv_day0 <span class="keyword">AS</span> cohort_rate</span><br><span class="line"><span class="keyword">FROM</span> </span><br><span class="line">(</span><br><span class="line">    <span class="keyword">SELECT</span> </span><br><span class="line">        <span class="built_in">date</span></span><br><span class="line">        , <span class="keyword">COUNT</span>(<span class="keyword">DISTINCT</span> user_id) <span class="keyword">AS</span> uv_day0</span><br><span class="line">    <span class="keyword">FROM</span> tbl_new_users</span><br><span class="line">    <span class="keyword">WHERE</span> <span class="built_in">date</span> = <span class="string">'2020-07-01'</span></span><br><span class="line">    <span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="built_in">date</span></span><br><span class="line">) <span class="keyword">AS</span> tt1</span><br><span class="line"></span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span></span><br><span class="line">(</span><br><span class="line">    <span class="keyword">SELECT</span></span><br><span class="line">        t1.date</span><br><span class="line">        , gap</span><br><span class="line">        , <span class="keyword">COUNT</span>(*) <span class="keyword">AS</span> retention_num</span><br><span class="line">    <span class="keyword">FROM</span> </span><br><span class="line">    (</span><br><span class="line">        <span class="keyword">SELECT</span> </span><br><span class="line">            <span class="built_in">date</span></span><br><span class="line">            , user_id <span class="keyword">AS</span> uid1</span><br><span class="line">        <span class="keyword">FROM</span> tbl_new_users</span><br><span class="line">        <span class="keyword">WHERE</span> <span class="built_in">date</span> = <span class="string">'2020-07-01'</span></span><br><span class="line">    ) <span class="keyword">AS</span> t1</span><br><span class="line">    <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> </span><br><span class="line">    (</span><br><span class="line">        <span class="keyword">SELECT</span></span><br><span class="line">            user_id <span class="keyword">AS</span> uid2</span><br><span class="line">            , <span class="keyword">DATEDIFF</span>(<span class="built_in">date</span>, <span class="string">'2020-07-01'</span>) <span class="keyword">AS</span> gap</span><br><span class="line">        <span class="keyword">FROM</span> tbl_active_users</span><br><span class="line">        <span class="keyword">WHERE</span> <span class="built_in">date</span> <span class="keyword">BETWEEN</span> <span class="string">'2020-07-01'</span> <span class="keyword">AND</span> <span class="string">'2020-07-03'</span></span><br><span class="line">    ) <span class="keyword">AS</span> t2</span><br><span class="line">    <span class="keyword">ON</span> t1.uid1 = t2.uid2</span><br><span class="line">    <span class="keyword">GROUP</span> <span class="keyword">BY</span> </span><br><span class="line">        <span class="built_in">date</span></span><br><span class="line">        , gap</span><br><span class="line">) tt2</span><br><span class="line"><span class="keyword">ON</span> tt1.date = tt2.date</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> </span><br><span class="line">    tt1.date</span><br><span class="line">    , tt2.gap;</span><br></pre></td></tr></table></figure>
<h2 id="DATE-FORMAT"><a href="#DATE-FORMAT" class="headerlink" title="DATE_FORMAT()"></a>DATE_FORMAT()</h2><p>以不同的格式显示日期/时间数据<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 当月的第一天</span></span><br><span class="line">DATE_FORMAT('$&#123;date&#125;', 'yyyy-MM-01')</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 每月1号调度任务，任务涉及前一个月的所有数据</span></span><br><span class="line">pt between date_format(date_sub('$&#123;date&#125;', 1), 'yyyy-MM-01') and date_sub('$&#123;date&#125;', 1) -- 其中 $&#123;date&#125;是某月1号</span><br><span class="line"><span class="comment">-- 上上个自然月</span></span><br><span class="line">pt between date_format(date_sub(date_format(date_sub('$&#123;date&#125;', 1), 'yyyy-MM-01'), 1), 'yyyy-MM-01') and date_sub(date_format(date_sub('$&#123;date&#125;', 1), 'yyyy-MM-01'), 1)</span><br></pre></td></tr></table></figure></p>
<h2 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h2><p>删除表中数据：<code>DELETE TABLE table_name</code></p>
<ul>
<li><a href="#TRUNCATE">TRUNCATE</a>也是删除表中数据的语句<ul>
<li><code>TRUNCATE</code>比<code>DELETE</code>的速度快</li>
<li><code>TRUNCATE</code>是删除表的所有行；而<code>DELETE</code>是删除表的一行或多行（除非没有<code>WHERE</code>子句）</li>
<li>在删除时，如果遇到任何一行违反约束（主要是外键约束），则<code>TRUNCATE</code>仍然删除表中数据，但是表的结构、列、约束、索引等保持不变，而<code>DELETE</code>直接返回错误</li>
<li>对于被外键约束的表，不能使用<code>TRUNCATE</code>，而应该使用不带<code>WHERE</code>子句的<code>DELETE</code></li>
<li>如果想保留标识计数值，要用<code>DELETE</code>；因为<code>TRUNCATE</code>会对新行标识所用的计数值重置为该列的种子</li>
</ul>
</li>
</ul>
<h2 id="DROP"><a href="#DROP" class="headerlink" title="DROP"></a>DROP</h2><p>删除表：<code>DROP TABLE table_name</code></p>
<h2 id="grouping-sets"><a href="#grouping-sets" class="headerlink" title="grouping sets"></a>grouping sets</h2><p>分组集（Grouping Sets）是多个分组的并集，用于在一个查询中，按照不同的分组列对集合进行聚合运算，等价于对单个分组使用“union all”，计算多个结果集的并集。</p>
<ul>
<li>在单个分组中缺失的分组列，返回<code>null</code></li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span>  a</span><br><span class="line">        , b</span><br><span class="line">        , c</span><br><span class="line">        , <span class="keyword">count</span>(<span class="number">1</span>) <span class="keyword">as</span> cnt </span><br><span class="line">        , <span class="keyword">sum</span>(d) <span class="keyword">as</span> total_d</span><br><span class="line"><span class="keyword">from</span>    tbl</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span>  a</span><br><span class="line">          , b</span><br><span class="line">          , c</span><br><span class="line"><span class="keyword">grouping</span> <span class="keyword">sets</span> (a, (a, b), (a, b, c))</span><br><span class="line">;</span><br><span class="line"><span class="comment">-- 等价于</span></span><br><span class="line"><span class="keyword">select</span>  a</span><br><span class="line">        , <span class="literal">null</span></span><br><span class="line">        , <span class="literal">null</span></span><br><span class="line">        , <span class="keyword">count</span>(<span class="number">1</span>) <span class="keyword">as</span> cnt </span><br><span class="line">        , <span class="keyword">sum</span>(d) <span class="keyword">as</span> total_d</span><br><span class="line"><span class="keyword">from</span>    tbl</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> a</span><br><span class="line"></span><br><span class="line"><span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span>  a</span><br><span class="line">        , b</span><br><span class="line">        , <span class="literal">null</span> </span><br><span class="line">        , <span class="keyword">count</span>(<span class="number">1</span>) <span class="keyword">as</span> cnt </span><br><span class="line">        , <span class="keyword">sum</span>(d) <span class="keyword">as</span> total_d</span><br><span class="line"><span class="keyword">from</span>    tbl</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span>  a, b</span><br><span class="line"></span><br><span class="line"><span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span>  a</span><br><span class="line">        , b</span><br><span class="line">        , c</span><br><span class="line">        , <span class="keyword">count</span>(<span class="number">1</span>) <span class="keyword">as</span> cnt </span><br><span class="line">        , <span class="keyword">sum</span>(d) <span class="keyword">as</span> total_d</span><br><span class="line"><span class="keyword">from</span>    tbl</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span>  a, b, c;</span><br></pre></td></tr></table></figure>
<h2 id="IIF"><a href="#IIF" class="headerlink" title="IIF()"></a>IIF()</h2><p><code>IIF(boolean_expression, valueForTrue, valueForFalse)</code>：如果<code>boolean_expression</code>为真，则返回<code>valueForTrue</code>；否则返回<code>valueForFalse</code>。</p>
<h2 id="INTO"><a href="#INTO" class="headerlink" title="INTO"></a>INTO</h2><h2 id="ISNULL"><a href="#ISNULL" class="headerlink" title="ISNULL()"></a>ISNULL()</h2><p><code>ISNULL(expression1, expression2)</code>：如果第一个参数为<code>NULL</code>，则返回第二个参数expression2；否则，返回第一个参数expression1。等价于<code>CASE WHEN expression1 IS NULL THEN expression2 ELSE expression1 END</code>。</p>
<h2 id="LAG"><a href="#LAG" class="headerlink" title="LAG()"></a>LAG()</h2><p>滞后若干项<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 表login_log记录用户的登录行为：uid（用户id）、login_date（登陆日期）</span></span><br><span class="line"><span class="comment">-- 求连续登陆5天的用户id</span></span><br><span class="line"><span class="keyword">select</span> uid</span><br><span class="line"><span class="keyword">from</span>  </span><br><span class="line">(</span><br><span class="line">    <span class="keyword">select</span>  uid</span><br><span class="line">            , login_date <span class="comment">-- 登陆日期</span></span><br><span class="line">            , lag(login_date, <span class="number">4</span>) <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> uid <span class="keyword">order</span> <span class="keyword">by</span> login_date <span class="keyword">asc</span>) <span class="keyword">as</span> pre_5_date <span class="comment">-- 登陆日期往前4个记录</span></span><br><span class="line">    <span class="keyword">from</span>    login_log</span><br><span class="line">) a </span><br><span class="line"><span class="keyword">where</span>  date_diff(login_date, pre_5_date) = <span class="number">4</span>;</span><br></pre></td></tr></table></figure></p>
<h2 id="last-day"><a href="#last-day" class="headerlink" title="last_day()"></a>last_day()</h2><p>取某月的最后一天<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span>  <span class="keyword">last_day</span>(<span class="string">'2020-11-06'</span>);</span><br><span class="line"><span class="comment">-- 即 2020-11-30</span></span><br></pre></td></tr></table></figure></p>
<h2 id="locate"><a href="#locate" class="headerlink" title="locate()"></a>locate()</h2><p><code>LOCATE(substr, str)</code>：返回字符串str第一次出现子串substr的位置。</p>
<ul>
<li>如果substr不在str中，则返回0</li>
</ul>
<p><code>LOCATE(substr, str, pos)</code>：返回第一次出现在字符串str的子串substr的位置，从位置pos开始。</p>
<ul>
<li>如果substr不在str中，则返回0</li>
</ul>
<h2 id="MAX"><a href="#MAX" class="headerlink" title="MAX()"></a>MAX()</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 用户最近登录的日期</span></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    <span class="built_in">date</span> <span class="keyword">AS</span> d</span><br><span class="line"><span class="keyword">FROM</span> </span><br><span class="line">(</span><br><span class="line">    <span class="keyword">SELECT</span></span><br><span class="line">        user_id</span><br><span class="line">        , <span class="built_in">date</span></span><br><span class="line">        , ROW_NUMBER() <span class="keyword">OVER</span>(<span class="keyword">PARTITION</span> <span class="keyword">BY</span> user_id <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="built_in">date</span> <span class="keyword">DESC</span>) <span class="keyword">AS</span> r_num</span><br><span class="line">    <span class="keyword">FROM</span> login</span><br><span class="line">) <span class="keyword">AS</span> t</span><br><span class="line"><span class="keyword">WHERE</span> r_num = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 或</span></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    <span class="keyword">MAX</span>(<span class="built_in">date</span>)</span><br><span class="line"><span class="keyword">FROM</span> login</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> user_id</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> user_id;</span><br></pre></td></tr></table></figure>
<h2 id="MIN"><a href="#MIN" class="headerlink" title="MIN"></a>MIN</h2><ul>
<li><a href="https://www.nowcoder.com/practice/16d41af206cd4066a06a3a0aa585ad3d?tpId=82&amp;&amp;tqId=35086&amp;rp=1&amp;ru=/ta/sql&amp;qru=/ta/sql/question-ranking" target="_blank" rel="noopener">题源</a>：<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 新登录用户的次日登录成功的留存率</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    <span class="keyword">ROUND</span>(<span class="number">1.0</span> * <span class="keyword">COUNT</span>(<span class="keyword">DISTINCT</span> l1.user_id) / (<span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(<span class="keyword">DISTINCT</span> user_id) <span class="keyword">FROM</span> login), <span class="number">3</span>)</span><br><span class="line"><span class="keyword">FROM</span> login l1, login l2</span><br><span class="line"><span class="keyword">ON</span> l1.user_id = l2.user_id</span><br><span class="line"><span class="keyword">AND</span> <span class="built_in">DATE</span>(l1.date, <span class="string">'+1 day'</span>) = l2.date</span><br><span class="line"><span class="keyword">AND</span> l1.date = (<span class="keyword">SELECT</span> <span class="keyword">MIN</span>(<span class="built_in">date</span>) <span class="keyword">FROM</span> login <span class="keyword">WHERE</span> user_id = l1.user_id);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="NULLIF"><a href="#NULLIF" class="headerlink" title="NULLIF()"></a>NULLIF()</h2><p><code>NULLIF(expression1, expression2)</code>：如果两个参数相等，则返回<code>NULL</code>；否则，返回第一个参数。等价于<code>CASE WHEN expression1 = expression2 THEN NULL ELSE expression1 END</code>。</p>
<ul>
<li>可用于防止分母中出现0而报错<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">a/NULLIF(b, 0)</span><br><span class="line"><span class="comment">-- 当b为0时，该式直接返回NULL</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="ORDER-BY"><a href="#ORDER-BY" class="headerlink" title="ORDER BY"></a>ORDER BY</h2><ul>
<li>用于排序</li>
<li>默认升序<code>ASC</code>；降序需要在列名后加<code>DESC</code></li>
<li>对带有排序作用的<code>ORDER BY</code>子句的查询，<code>ORDER BY</code>返回的是一个对象，其中的行按特定的顺序组织在一起，这种对象被称为<strong>游标</strong></li>
<li><code>ORDER BY</code>子句是唯一能重用列别名的子句<ul>
<li>这是因为<code>ORDER BY</code>子句是在<code>SELECT</code>子句之后才执行的<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">(8)<span class="keyword">SELECT</span> (<span class="number">9</span>)<span class="keyword">DISTINCT</span> (<span class="number">11</span>) &lt;TOP <span class="keyword">num</span>&gt;&lt;<span class="keyword">SELECT</span> <span class="keyword">list</span>&gt;</span><br><span class="line">(<span class="number">1</span>)<span class="keyword">FROM</span> [left_table]</span><br><span class="line">(<span class="number">3</span>)&lt;JOIN_type&gt; <span class="keyword">JOIN</span> &lt;right_table&gt;</span><br><span class="line">(<span class="number">2</span>)<span class="keyword">ON</span> &lt;join_condition&gt;</span><br><span class="line">(<span class="number">4</span>)<span class="keyword">WHERE</span> &lt;where_condition&gt;</span><br><span class="line">(<span class="number">5</span>)<span class="keyword">GROUP</span> <span class="keyword">BY</span> &lt;group_by_list&gt;</span><br><span class="line">(<span class="number">6</span>)<span class="keyword">WITH</span> &lt;<span class="keyword">CUBE</span> | <span class="keyword">ROLLUP</span>&gt;</span><br><span class="line">(<span class="number">7</span>)<span class="keyword">HAVING</span> &lt;having_condition&gt;</span><br><span class="line">(<span class="number">10</span>)<span class="keyword">ORDER</span> <span class="keyword">BY</span> &lt;order_by_list&gt;;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>谨慎使用<code>ORDER BY</code>后面接数字的方式来进行排序，尽量使用<code>ORDER BY+列名</code>或<code>ORDER BY+列别名</code><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">  col_a,</span><br><span class="line">  col_b,</span><br><span class="line">  col_c</span><br><span class="line"><span class="keyword">FROM</span> table_1</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>; </span><br><span class="line"><span class="comment">-- 实际按照SELECT后的字段顺序col_a, col_b, col_c进行排序</span></span><br><span class="line"><span class="comment">-- 当查询的列发生改变时，而忘了修改ORDER BY后的数字时，可能会获得错误的查询结果</span></span><br></pre></td></tr></table></figure></li>
<li>表表达式不能使用<code>ORDER BY</code>进行排序<ul>
<li><strong>表表达式</strong>包括：<ul>
<li>视图（VIEW）</li>
<li>内联表值函数</li>
<li>派生表（子查询）</li>
<li>公用表表达式（CTE）</li>
</ul>
</li>
<li>表表达式加了<code>TOP</code>可以使用<code>ORDER BY</code><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">  col_a</span><br><span class="line">  , col_b</span><br><span class="line"><span class="keyword">FROM</span> </span><br><span class="line">(</span><br><span class="line">    <span class="keyword">SELECT</span> TOP <span class="number">5</span> *</span><br><span class="line">    <span class="keyword">FROM</span> table_1</span><br><span class="line">    <span class="keyword">ORDER</span> <span class="keyword">BY</span> col_c</span><br><span class="line">) <span class="keyword">AS</span> t1  <span class="comment">-- 实际返回的是没有固定顺序的表</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> col_a, col_b <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h2 id="REGEXP-REPLACE"><a href="#REGEXP-REPLACE" class="headerlink" title="REGEXP_REPLACE()"></a>REGEXP_REPLACE()</h2><p>正则替换</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 如何统计表tbl的字段comments中出现了多少次“何时下班”？</span></span><br><span class="line"><span class="comment">-- 同一个句话中可能会出现多个“何时下班”</span></span><br><span class="line"><span class="keyword">select</span>  <span class="keyword">sum</span>(len_1 - len_2)</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">(</span><br><span class="line">    <span class="keyword">select</span>  comments</span><br><span class="line">            , <span class="keyword">len</span>(comments) <span class="keyword">as</span> len_1</span><br><span class="line">            , <span class="keyword">len</span>(regexp_replace(comments, <span class="string">'何时下班'</span>, <span class="string">'何时下'</span>)) <span class="keyword">as</span> len_2</span><br><span class="line">    <span class="keyword">from</span>    tbl</span><br><span class="line">) a;</span><br></pre></td></tr></table></figure>
<h2 id="ROW-NUMBER"><a href="#ROW-NUMBER" class="headerlink" title="ROW_NUMBER()"></a>ROW_NUMBER()</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 给定表table_a（包含user_id, login_date），计算连续3天登录的用户id</span></span><br><span class="line"><span class="keyword">SELECT</span>  user_id</span><br><span class="line"><span class="keyword">FROM</span> </span><br><span class="line">(</span><br><span class="line">    <span class="keyword">SELECT</span>  user_id</span><br><span class="line">            , <span class="keyword">COUNT</span>(<span class="number">1</span>) <span class="keyword">AS</span> cnt</span><br><span class="line">            , <span class="keyword">DATE_SUB</span>(login_date, t.rn) flag_dt</span><br><span class="line">    <span class="keyword">FROM</span> </span><br><span class="line">    (</span><br><span class="line">        <span class="keyword">SELECT</span>  user_id</span><br><span class="line">                , login_date</span><br><span class="line">                , ROW_NUMBER() <span class="keyword">OVER</span>(<span class="keyword">PARTITION</span> <span class="keyword">BY</span> user_id <span class="keyword">ORDER</span> <span class="keyword">BY</span> login_date) <span class="keyword">AS</span> rn</span><br><span class="line">        <span class="keyword">FROM</span>    table_a</span><br><span class="line">    ) t</span><br><span class="line">    <span class="keyword">GROUP</span> <span class="keyword">BY</span>  user_id</span><br><span class="line">              , <span class="keyword">DATE_SUB</span>(login_date, t.rn)</span><br><span class="line">    <span class="keyword">HAVING</span> <span class="keyword">COUNT</span>(<span class="number">1</span>) &gt;= <span class="number">3</span></span><br><span class="line">);</span><br><span class="line"><span class="comment">-- 参考：https://www.jianshu.com/p/9a803a61a145</span></span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 给定表table_a（包含user_id, login_date），计算最近30天内，曾连续3天登录的用户数</span></span><br><span class="line"><span class="keyword">SELECT</span>  <span class="keyword">COUNT</span>(<span class="keyword">DISTINCT</span> user_id)</span><br><span class="line"><span class="keyword">FROM</span> </span><br><span class="line">(</span><br><span class="line">    <span class="keyword">SELECT</span>  user_id</span><br><span class="line">            , <span class="keyword">DATE_SUB</span>(login_date, t.rn) <span class="keyword">AS</span> flag_dt</span><br><span class="line">            , <span class="keyword">COUNT</span>(<span class="number">1</span>) <span class="keyword">AS</span> cnt</span><br><span class="line">    <span class="keyword">FROM</span> </span><br><span class="line">    (</span><br><span class="line">        <span class="keyword">SELECT</span>  user_id</span><br><span class="line">                , login_date</span><br><span class="line">                , ROW_NUMBER() <span class="keyword">OVER</span>(<span class="keyword">PARTITION</span> <span class="keyword">BY</span> user_id <span class="keyword">ORDER</span> <span class="keyword">BY</span> login_date) <span class="keyword">AS</span> rn</span><br><span class="line">        <span class="keyword">FROM</span>    table_a</span><br><span class="line">        <span class="keyword">WHERE</span>   login_date <span class="keyword">BETWEEN</span> $&#123;<span class="built_in">date</span><span class="number">-30</span>&#125; <span class="keyword">AND</span> $&#123;<span class="built_in">date</span><span class="number">-1</span>&#125;</span><br><span class="line">    ) t</span><br><span class="line">    <span class="keyword">GROUP</span> <span class="keyword">BY</span>  user_id</span><br><span class="line">              , <span class="keyword">DATE_SUB</span>(login_date, t.rn)</span><br><span class="line">    <span class="keyword">HAVING</span>    <span class="keyword">COUNT</span>(<span class="number">1</span>) &gt;= <span class="number">3</span></span><br><span class="line">) tt;</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 表login_log记录用户每天的登陆情况：uid（用户id）、date_dy（日期）、is_login（用户是否登陆，1表示当天有登陆，0表示当天未登陆）</span></span><br><span class="line"><span class="comment">-- 求用户的最大连续登陆天数</span></span><br><span class="line"><span class="keyword">select</span>  uid</span><br><span class="line">        , <span class="keyword">max</span>(cnt) <span class="keyword">as</span> max_con_login_days <span class="comment">-- 最大连续登陆天数</span></span><br><span class="line"><span class="keyword">from</span> </span><br><span class="line">(</span><br><span class="line">    <span class="keyword">select</span>  uid</span><br><span class="line">            , date_diff</span><br><span class="line">            , <span class="keyword">count</span>(<span class="number">1</span>) <span class="keyword">as</span> cnt </span><br><span class="line">    <span class="keyword">from</span>  </span><br><span class="line">    (</span><br><span class="line">        <span class="keyword">select</span>  uid</span><br><span class="line">          , date_dy</span><br><span class="line">          , <span class="keyword">datediff</span>(date_dy, <span class="keyword">num</span>) <span class="keyword">as</span> date_diff </span><br><span class="line">        <span class="keyword">from</span> </span><br><span class="line">        (</span><br><span class="line">            <span class="keyword">select</span>  uid</span><br><span class="line">                    , date_dy</span><br><span class="line">                    , row_number() <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> uid <span class="keyword">order</span> <span class="keyword">by</span> date_dy <span class="keyword">asc</span>) <span class="keyword">as</span> <span class="keyword">num</span> </span><br><span class="line">            <span class="keyword">from</span>    login_log</span><br><span class="line">            <span class="keyword">where</span>   is_login = <span class="number">1</span></span><br><span class="line">        ) a </span><br><span class="line">    ) b</span><br><span class="line">    <span class="keyword">group</span> <span class="keyword">by</span>  uid</span><br><span class="line">              , daet_diff </span><br><span class="line">) c </span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> uid;</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 连续四天看相同类别的视频的用户id及视频id</span></span><br><span class="line"><span class="keyword">SELECT</span>  user_id</span><br><span class="line">        , video_id</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">(</span><br><span class="line">    <span class="keyword">SELECT</span>  user_id</span><br><span class="line">            , video_id</span><br><span class="line">            , video_category</span><br><span class="line">            , rn_2 - rn_1 <span class="keyword">AS</span> rn</span><br><span class="line">    <span class="keyword">FROM</span> </span><br><span class="line">    (</span><br><span class="line">        <span class="keyword">SELECT</span>  user_id</span><br><span class="line">                , video_id</span><br><span class="line">                , video_category</span><br><span class="line">                , ROW_NUMBER() <span class="keyword">OVER</span>(<span class="keyword">PARTITION</span> <span class="keyword">BY</span> user_id, video_category <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="built_in">time</span>) <span class="keyword">AS</span> rn_1</span><br><span class="line">                , ROW_NUMBER() <span class="keyword">OVER</span>(<span class="keyword">PARTITION</span> <span class="keyword">BY</span> user_id <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="built_in">time</span>) <span class="keyword">AS</span> rn_2</span><br><span class="line">        <span class="keyword">FROM</span>    table_a</span><br><span class="line">    ) <span class="keyword">AS</span> t1</span><br><span class="line">    <span class="keyword">GROUP</span> <span class="keyword">BY</span>  user_id</span><br><span class="line">              , video_category</span><br><span class="line">    <span class="keyword">HAVING</span> <span class="keyword">COUNT</span>(<span class="number">1</span>) &gt;= <span class="number">4</span></span><br><span class="line">) <span class="keyword">AS</span> t2;</span><br><span class="line"><span class="comment">-- 如果连续时间看的视频类别一样，rn_2 - rn_1的差值一样</span></span><br></pre></td></tr></table></figure>
<h2 id="SUM"><a href="#SUM" class="headerlink" title="SUM"></a>SUM</h2><p>求和</p>
<ul>
<li>聚合函数之一</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 求累计薪资和</span></span><br><span class="line"><span class="keyword">SELECT</span>  emp_no</span><br><span class="line">        , salary</span><br><span class="line">        , <span class="keyword">SUM</span>(salary) <span class="keyword">OVER</span>(<span class="keyword">ORDER</span> <span class="keyword">BY</span> emp_no) <span class="keyword">AS</span> running_total</span><br><span class="line"><span class="keyword">FROM</span>    salaries</span><br><span class="line"><span class="keyword">WHERE</span>   <span class="keyword">to_date</span> = <span class="string">'9999-01-01'</span></span><br><span class="line">;</span><br></pre></td></tr></table></figure>
<p><a href="https://www.nowcoder.com/practice/e524dc7450234395aa21c75303a42b0a?tpId=82&amp;&amp;tqId=35087&amp;rp=1&amp;ru=/ta/sql&amp;qru=/ta/sql/question-ranking" target="_blank" rel="noopener">题源</a>：<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 统计每天的新用户</span></span><br><span class="line"><span class="keyword">SELECT</span>  <span class="built_in">date</span></span><br><span class="line">        , <span class="keyword">SUM</span>(<span class="keyword">CASE</span> <span class="keyword">WHEN</span> r_num = <span class="number">1</span> <span class="keyword">THEN</span> <span class="number">1</span> <span class="keyword">ELSE</span> <span class="number">0</span> <span class="keyword">END</span>) <span class="keyword">AS</span> <span class="keyword">new</span></span><br><span class="line"><span class="keyword">FROM</span> </span><br><span class="line">(</span><br><span class="line">    <span class="keyword">SELECT</span>  <span class="built_in">date</span></span><br><span class="line">            , ROW_NUMBER() <span class="keyword">OVER</span>(<span class="keyword">PARTITION</span> <span class="keyword">BY</span> user_id <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="built_in">date</span> <span class="keyword">ASC</span>) <span class="keyword">AS</span> r_num</span><br><span class="line">    <span class="keyword">FROM</span>    login</span><br><span class="line">) t1</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="built_in">date</span>;</span><br></pre></td></tr></table></figure></p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://mp.weixin.qq.com/s/5iv1z6SCf0nMyIEWavlyRQ" target="_blank" rel="noopener">ORDER BY的用法</a></li>
<li><a href="https://blog.csdn.net/xyzyhs/article/details/99438912" target="_blank" rel="noopener">数据库中的键（码）</a></li>
<li><a href="https://www.cnblogs.com/ljhdo/p/5056757.html" target="_blank" rel="noopener">TSQL 分组集（Grouping Sets）</a></li>
<li><a href="http://lxw1234.com/archives/2015/04/193.htm" target="_blank" rel="noopener">Hive分析窗口函数(五) GROUPING SETS,GROUPING__ID,CUBE,ROLLUP</a></li>
</ul>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>SQL</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown</title>
    <url>/Markdown.html</url>
    <content><![CDATA[<center></center>
<a id="more"></a>
<h1 id="标题"><a class="header-anchor" href="#标题"></a>标题</h1>
<p>井号键<code>#</code>（N个代表N级标题） +<code> </code>（空格）+ <code>标题内容</code></p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 一级标题</span></span><br><span class="line"><span class="section">## 二级标题</span></span><br><span class="line"><span class="section">### 三级标题</span></span><br></pre></td></tr></table></figure>
<h2 id="二级标题"><a class="header-anchor" href="#二级标题"></a>二级标题</h2>
<p>示范<code>## 二级标题的效果</code></p>
<h1 id="正文"><a class="header-anchor" href="#正文"></a>正文</h1>
<h2 id="加粗"><a class="header-anchor" href="#加粗"></a>加粗</h2>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="strong">**加粗的内容**</span></span><br></pre></td></tr></table></figure>
<p>效果：<strong>加粗的内容</strong></p>
<h2 id="下划线"><a class="header-anchor" href="#下划线"></a>下划线</h2>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">u</span>&gt;</span></span>需要下划线的内容<span class="xml"><span class="tag">&lt;/<span class="name">u</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>效果：<u>需要下划线的内容</u></p>
<h2 id="删除线"><a class="header-anchor" href="#删除线"></a>删除线</h2>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">~~需要加删除线的内容~~</span><br></pre></td></tr></table></figure>
<p>效果：<s>需要加删除线的内容</s></p>
<h2 id="引用"><a class="header-anchor" href="#引用"></a>引用</h2>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="quote">&gt; 引用的内容</span></span><br></pre></td></tr></table></figure>
<p>效果：</p>
<blockquote>
<p>引用的内容</p>
</blockquote>
<h2 id="超链接"><a class="header-anchor" href="#超链接"></a>超链接</h2>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">[<span class="string">显示的名称</span>](<span class="link">链接</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>点击即可跳转</p>
</blockquote>
<p>效果：<a href="https://shootingwang.github.io/" target="_blank" rel="noopener">点击即可跳转到首页</a></p>
<h1 id="公式"><a class="header-anchor" href="#公式"></a>公式</h1>
<h2 id="行内公式"><a class="header-anchor" href="#行内公式"></a>行内公式</h2>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">$...$</span><br></pre></td></tr></table></figure>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">From [<span class="string">Wiki: Lasso</span>](<span class="link">https://en.wikipedia.org/wiki/Lasso_(statistics</span>)):</span><br><span class="line">Consider a sample consisting of $N$ cases, each of which consists of $p$ covariates and a single outcome. Let $y<span class="emphasis">_&#123;i&#125;$ be the outcome and $x_</span>&#123;i&#125;:=(x<span class="emphasis">_&#123;1&#125;,x_</span>&#123;2&#125;,\ldots ,x_&#123;p&#125;)^&#123;T&#125;$ be the covariate vector for the ith case. Then the objective of lasso is to solve</span><br><span class="line">$$\min<span class="emphasis">_&#123;\beta_</span>0, \beta&#125;\left\&#123; \sum<span class="emphasis">_&#123;i=1&#125;^N(y_</span>i - \beta<span class="emphasis">_0 - x_</span>i^T\beta)^2 \right\&#125; \quad \mathrm&#123;subject to &#125; \sum<span class="emphasis">_&#123;j=1&#125;^p |\beta_</span>j|\leq t.$$</span><br></pre></td></tr></table></figure>
<p>效果：<br>
From <a href="https://en.wikipedia.org/wiki/Lasso_(statistics)" target="_blank" rel="noopener">Wiki: Lasso</a>:<br>
Consider a sample consisting of $N$ cases, each of which consists of $p$ covariates and a single outcome. Let $y_{i}$ be the outcome and $x_{i}:=(x_{1},x_{2},\ldots ,x_{p})^{T}$ be the covariate vector for the ith case. Then the objective of lasso is to solve<br>
$$\min_{\beta_0, \beta} \left{ \sum_{i=1}^N (y_i - \beta_0 - x_i^T \beta)^2 \right} \quad \mathrm{subject, to } \sum_{j=1}^p |\beta_j|\leq t.$$</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="参考资料"><a class="header-anchor" href="#参考资料"></a>参考资料</h1>
]]></content>
      <categories>
        <category>Everything</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>Variable Selection | 带惩罚函数的变量选择方法</title>
    <url>/%E7%AE%97%E6%B3%95-%E5%B8%A6%E6%83%A9%E7%BD%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%98%E9%87%8F%E9%80%89%E6%8B%A9%E6%96%B9%E6%B3%95.html</url>
    <content><![CDATA[<center></center>
<a id="more"></a>
<p>假设有$n$个样本，$p$个自变量（predictor variables）。<br>
考虑简单线性回归模型：<br>
$$y = X\beta + \varepsilon, \qquad \varepsilon \sim N(0, \sigma^2)$$<br>
其中，$y$是响应变量/因变量/被解释变量，$X$是$n\times p$维的样本（设计）矩阵，$\varepsilon$是服从方差为$\sigma^2$的正态分布的误差项。</p>
<p><strong>普通最小二乘</strong>（OLS，Ordinary Least Squares）:</p>
<ul>
<li>损失函数（Loss function）：<br>
$$L(\beta) = ||y-X\beta||^2$$</li>
<li>回归系数估计：<br>
$$\hat{\beta}_{OLS} = \left(X^\prime X \right)^{-1} X^\prime y$$</li>
</ul>
<blockquote>
<p>$L_p$范数（$L_p$-norm）：<br>
$$L_p(\vec{x}) = \parallel \vec{x} \parallel_p = \left( \sum_{i=1}^n \mid x_i \mid^p \right)^{1/p}, \qquad p\geq 1$$<br>
其中，$\vec{x} = ( x_1, x_2, \cdots, x_n )$。</p>
<ul>
<li>$p = -\infty$：<br>
$$\parallel \vec{x} \parallel_{\infty} = \lim_{p \rightarrow -\infty} \left( \sum_{i=1}^n \mid x_i \mid^p \right)^{1/p} = \min_i \mid x_i \mid $$</li>
<li>$p = 0$：（严格说，不属于范数）<br>
$$\parallel \vec{x} \parallel_0 = \sharp(i) \quad \mathrm{with} \quad x_i\neq 0 $$<br>
表示向量$\vec{x}$中非零元素的个数</li>
<li>$p = 1$：（也称<strong>曼哈顿距离</strong>）<br>
$$\parallel \vec{x} \parallel_1 = \sum_{i=1}^n \mid x_i \mid$$</li>
<li>$p = 2$：（也称<strong>欧氏距离</strong>）<br>
$$\parallel \vec{x} \parallel_2 = \sqrt{\sum_{i=1}^n \mid x_i \mid^2}$$</li>
<li>$p = +\infty$：（无穷范数/最大范数）<br>
$$\parallel \vec{x} \parallel_{\infty} = \lim_{p\rightarrow +\infty} \left( \sum_{i=1}^n \mid x_i \mid^p \right)^{1/p} = \max_i \mid x_i \mid$$</li>
</ul>
</blockquote>
<h1 id="Penalized-Least-Squares"><a class="header-anchor" href="#Penalized-Least-Squares"></a>Penalized Least Squares</h1>
<blockquote>
<p>Li F R . <a href="https://escholarship.org/content/qt8j29393d/qt8j29393d.pdf" target="_blank" rel="noopener">Variable Selection via Nonconcave Penalized Likelihood and its Oracle Properties</a>[J]. Publications of the American Statistical Association, 2001, 96(456):1348-1360.</p>
</blockquote>
<p>将设计矩阵标准化，即$X^TX = I_p$</p>
<p>目标函数：</p>
<p>\begin{equation}<br>
\begin{aligned}<br>
L(\beta) &amp;= \parallel y-X\beta \parallel_2^2 + \lambda\sum_{j=1}^p p_j(\mid \beta_j \mid) \<br>
&amp;= \sum_{i=1}^n \left(y_i - \sum_{j=1}^p x_{ij}\beta_j \right)^2 + \lambda\sum_{j=1}^p p_j(\mid \beta_j \mid) \<br>
&amp;= \sum_{i=1}^n \left(y_i - \sum_{j=1}^p x_{ij}\beta_j \right)^2 + \sum_{j=1}^p p_\lambda(\mid \beta_j \mid) \<br>
&amp;= \parallel y-X\beta \parallel_2^2 + \sum_{j=1}^p p_\lambda(\mid \beta_j \mid)\<br>
&amp;= \parallel y-X {\hat{\beta}<em>{OLS}} {\parallel_2^2} + \parallel {\hat{\beta}</em>{OLS}} - \beta \parallel^2 +<br>
\sum_{j=1}^p {p_\lambda}(\mid \beta_j \mid) \<br>
&amp;= \parallel y-X {\hat{\beta}<em>{OLS}} {\parallel_2^2} + {\sum</em>{j=1}^p} {\left{ ({\hat{\beta}<em>{oj}} - {\beta_j})^2 + {p</em>\lambda}( \mid {\beta_j} \mid) \right}} \<br>
\end{aligned}<br>
\end{equation}</p>
<ul>
<li>假设惩罚函数对所有的系数都是一样的，即$p(\mid \cdot \mid)$</li>
<li>进一步，将 $\lambda p(\mid \cdot \mid)$ 记为 $p_\lambda(\mid \cdot \mid)$</li>
<li>$\hat{\beta}<em>{OLS}$是回归方程的普通最小二乘估计，$\hat{\beta}</em>{oj}$是$\hat{\beta}<em>{OLS}$的第$j$个元素<br>
$$\hat{\beta}</em>{OLS} = \left( X^T X \right)^{-1} X^T y=X^Ty$$</li>
</ul>
<p>$\parallel y-X \hat{\beta}<em>{OLS} \parallel_2^2$对于$\beta$是常数，因此有<br>
$$\arg\min</em>{\beta_j}  \parallel y-X\beta \parallel_2^2 + p_\lambda(\mid \beta_j \mid) \Leftrightarrow \arg\min_{\beta_j}  \left{ (\hat{\beta}<em>{oj} - \beta_j)^2 + p</em>\lambda(\mid \beta_j \mid) \right} $$</p>
<p>$$\hat{\beta}<em>{j} = \arg \min</em>{\beta_j} \left{ (\hat{\beta}<em>{oj} - \beta_j)^2 + p</em>\lambda(\mid \beta_j \mid) \right}$$</p>
<ul>
<li>
<p>对于岭回归（Ridge Regression），<br>
\begin{equation}<br>
\begin{aligned}<br>
p_\lambda(\mid \beta_j \mid) &amp;= \lambda \mid\beta_j\mid^2 \<br>
\hat{\beta}<em>{j}^{Ridge}<br>
&amp;= \frac{1}{1 + \lambda}\hat{\beta}</em>{oj}<br>
\end{aligned}<br>
\end{equation}</p>
</li>
<li>
<p>对于LASSO，<br>
\begin{equation}<br>
\begin{aligned}<br>
p_\lambda(\mid \beta_j \mid) &amp;= \lambda \mid\beta_j\mid \<br>
\hat{\beta}<em>{j}^{LASSO}<br>
&amp;= \mathrm{sgn}(\hat{\beta}</em>{oj})<br>
\left( \mid \hat{\beta}<em>{oj} \mid -<br>
\frac{\lambda}{2} \right)</em>{+}<br>
\end{aligned}<br>
\end{equation}</p>
</li>
</ul>
<h2 id="Rigde-Regression-岭回归"><a class="header-anchor" href="#Rigde-Regression-岭回归"></a>Rigde Regression 岭回归</h2>
<p>当自变量个数超过样本个数 或 样本数据存在多重共线性（multicollinearity）时，使用岭回归（Ridge Regression）可以得到一个精简的模型。</p>
<blockquote>
<p>Hoerl, A., &amp; Kennard, R. (1970). <a href="https://www.jstor.org/stable/1267352?seq=1" target="_blank" rel="noopener">Ridge Regression: Applications to Nonorthogonal Problems</a>. Technometrics, 12(1), 69-82. doi:10.2307/1267352</p>
</blockquote>
<ul>
<li>ridge estimator是一种shrinkage estimator</li>
</ul>
<blockquote>
<p><strong>Shrinkage estimators</strong> theoretically produce new estimators that are shrunk closer to the ‘true’ population parameters.</p>
</blockquote>
<ul>
<li>
<p>ridge regression是Tikhivov方法的其中一种</p>
</li>
<li>
<p>ridge regression使用L2正则化（L2 Regularization）</p>
</li>
<li>
<p>目标函数：<br>
\begin{equation}<br>
\begin{aligned}<br>
L_{Ridge}(\beta) &amp;= ||y-X\beta ||^2_2 + \lambda ||\beta||^2_2\<br>
&amp;= \sum_{i=1}^n \left(y_i - \sum_{j=1}^p x_{ij}\beta_j \right)^2 + \lambda \sum_{j=1}^p \beta_j^2<br>
\end{aligned}<br>
\end{equation}</p>
</li>
<li>
<p>回归系数估计：</p>
</li>
</ul>
<p>\begin{equation}<br>
\begin{aligned}<br>
\hat{\beta}<em>{Ridge} &amp;= \arg \min</em>\beta \sum_{i=1}^n \left(y_i - \sum_{j=1}^p x_{ij}\beta_j \right)^2 \quad \mathrm{s.t.} \sum_{j=1}^p \beta_j^2 \leq s \<br>
&amp;= \left( X^\prime X+\lambda I \right)^{-1} X^\prime y<br>
\end{aligned}<br>
\end{equation}<br>
其中，$I$是单位矩阵，$\lambda$是正则惩罚参数。</p>
<ul>
<li>当$\lambda \rightarrow 0$时，有 $\hat{\beta}<em>{Ridge} \rightarrow \hat{\beta}</em>{OLS}$</li>
<li>当$\lambda \rightarrow \infty$时，有 $\hat{\beta}_{Ridge} \rightarrow 0$</li>
</ul>
<h3 id="Bias-Variance-Trade-off"><a class="header-anchor" href="#Bias-Variance-Trade-off"></a>Bias-Variance Trade-off</h3>
<p>\begin{aligned}<br>
\mathrm{Bias}(\hat{\beta}<em>{Ridge}) &amp;= -\lambda \left( X^\prime X+\lambda I \right)^{-1} \beta\<br>
\mathrm{Var}(\hat{\beta}</em>{Ridge}) &amp;= \sigma^2 \left( X^\prime X+\lambda I \right)^{-1} X^\prime X \left( X^\prime X+\lambda I \right)^{-1}<br>
\end{aligned}</p>
<h3 id="如何选择-lambda"><a class="header-anchor" href="#如何选择-lambda"></a>如何选择$\lambda$</h3>
<p>方法：</p>
<ol>
<li>最小化信息准则（Minimizing Information Criteria）：</li>
<li>交叉验证（cross-validation）</li>
</ol>
<h3 id="R实现"><a class="header-anchor" href="#R实现"></a>R实现</h3>
<p>可使用R包<code>glmnet</code></p>
<ul>
<li>注意：ridge regression假设自变量（predictors）是标准化的（standardized），且因变量是中心化的（centered）</li>
</ul>
<blockquote>
<p>标准化、中心化见《<a href="/%E7%AE%97%E6%B3%95-%E7%89%B9%E5%BE%81%E5%BD%92%E4%B8%80%E5%8C%96.html" title="Feature Engineering | 特征缩放">Feature Engineering | 特征缩放</a>》</p>
</blockquote>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="keyword">library</span>(glmnet)  <span class="comment">## 用于岭回归</span></span><br><span class="line"><span class="keyword">library</span>(dplyr)  <span class="comment">## 用于数据清洗</span></span><br><span class="line"><span class="keyword">library</span>(psych)  <span class="comment">## 使用 tr() 计算矩阵的迹</span></span><br><span class="line"></span><br><span class="line">data(<span class="string">'mtcars'</span>)  <span class="comment">## 载入数据mtcars</span></span><br><span class="line"><span class="comment">## 将y中心化</span></span><br><span class="line">y &lt;- mtcars %&gt;% select(mpg) %&gt;% </span><br><span class="line">  scale(center = <span class="literal">TRUE</span>, scale = <span class="literal">FALSE</span>) %&gt;%</span><br><span class="line">  as.matrix()</span><br><span class="line"><span class="comment">## 将X中心化</span></span><br><span class="line">X &lt;- mtcars %&gt;% select(-mpg) %&gt;%</span><br><span class="line">  scale(center = <span class="literal">TRUE</span>, scale = <span class="literal">TRUE</span>) %&gt;%  </span><br><span class="line">  as.matrix()</span><br><span class="line"><span class="comment">## X的标准化可以省略，令cv.glmnet()或glmnet()中的参数standardize = TRUE来标准化X</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 使用10折交叉验证选择最优lambda</span></span><br><span class="line">lambdas_seq &lt;- <span class="number">10</span>^seq(-<span class="number">3</span>, <span class="number">5</span>, length.out = <span class="number">100</span>)</span><br><span class="line"><span class="comment">## alpha = 0表示岭回归</span></span><br><span class="line">ridge_cv &lt;- cv.glmnet(X, y, alpha = <span class="number">0</span>, lambda = lambdas_seq,</span><br><span class="line">                      nfolds = <span class="number">10</span>)</span><br><span class="line">plot(ridge_cv)</span><br></pre></td></tr></table></figure>
<meta name="referrer" content="no-referrer">
<img src="/%E7%AE%97%E6%B3%95-%E5%B8%A6%E6%83%A9%E7%BD%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%98%E9%87%8F%E9%80%89%E6%8B%A9%E6%96%B9%E6%B3%95/RidgeRegressionCV.png" class title="岭回归-10折交叉验证">
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 使用令交叉验证预测误差均值最小的lambda</span></span><br><span class="line">rr &lt;- glmnet(X, y, alpha = <span class="number">0</span>, lambda = ridge_cv$lambda.min)</span><br><span class="line">y_hat &lt;- predict(rr, X)  <span class="comment">## y的估计值</span></span><br><span class="line">ssr &lt;- t(y - y_hat) %*% (y - y_hat)</span><br></pre></td></tr></table></figure>
<h3 id="Python实现"><a class="header-anchor" href="#Python实现"></a>Python实现</h3>
<h2 id="LASSO"><a class="header-anchor" href="#LASSO"></a>LASSO</h2>
<p>LASSO（Least Absolute Shrinkage and Selection Operator）</p>
<blockquote>
<p>Tibshirani, Robert. “<a href="https://www.jstor.org/stable/2346178?seq=1" target="_blank" rel="noopener">Regression Shrinkage and Selection via the Lasso.</a>” Journal of the Royal Statistical Society. Series B (Methodological), vol. 58, no. 1, 1996, pp. 267–288. JSTOR, <a href="http://www.jstor.org/stable/2346178" target="_blank" rel="noopener">www.jstor.org/stable/2346178</a>. Accessed 11 Feb. 2021.</p>
</blockquote>
<ul>
<li>
<p>LASSO在损失函数中加上一个L1惩罚项（L1 penalty）</p>
</li>
<li>
<p>目标函数：<br>
\begin{equation}<br>
\begin{aligned}<br>
L_{LASSO}(\beta) &amp;= ||y-X\beta ||^2_2 + \lambda ||\beta||<em>1 \<br>
&amp;= \sum</em>{i=1}^n \left(y_i - \sum_{j=1}^p x_{ij}\beta_j \right)^2 + \lambda \sum_{j=1}^p \mid \beta_j \mid<br>
\end{aligned}<br>
\end{equation}</p>
</li>
</ul>
<blockquote>
<p>Li, F. R. . (2001). <a href="https://fan.princeton.edu/papers/01/penlike.pdf" target="_blank" rel="noopener">Variable selection via nonconcave penalized likelihood and its oracle properties</a>. Publications of the American Statistical Association, 96(456), 1348-1360.</p>
<ul>
<li>标准LASSO过度惩罚了大系数（standard LASSO over-shrinks large coefficients due to the nature of $l_1$ penalty）。</li>
</ul>
</blockquote>
<h1 id="Bridge"><a class="header-anchor" href="#Bridge"></a>Bridge</h1>
<blockquote>
<p>Frank L E , Friedman J H . <a href="http://www.uwe-mortensen.de/FrankFriedmanStatViewChemometRegressionTools1993.pdf" target="_blank" rel="noopener">A Statistical View of Some Chemometrics Regression Tools</a>[J]. Technometrics, 1993, 35(2):109-135.<br>
Fu, Wenjiang J . <a href="http://www.hpc.unm.edu/~andriese/doc/ref1_fu.pdf" target="_blank" rel="noopener">Penalized Regressions: The Bridge versus the Lasso</a>[J]. Journal of Computational and Graphical Statistics, 1998, 7(3):397.</p>
</blockquote>
<ul>
<li>目标函数：<br>
$$L_{Bridge}(\beta) = \parallel y-X\beta \parallel_2 + \lambda \sum_{i=1}^p \mid \beta_i \mid^\gamma, \qquad \gamma &gt; 0 $$</li>
</ul>
<h1 id="Group-LASSO"><a class="header-anchor" href="#Group-LASSO"></a>Group LASSO</h1>
<blockquote>
<ul>
<li>Yuan, M. and Lin, Y. (2006) <a href="http://www.columbia.edu/~my2550/papers/glasso.final.pdf" target="_blank" rel="noopener">Model Selection and Estimation in Regression with Grouped Variables</a>. Journal of the Royal Statistical Society: Series B, 68, 49-67.</li>
<li>Huang, J., Breheny, P., &amp; Ma, S. (2012). <a href="https://arxiv.org/pdf/1204.6491.pdf" target="_blank" rel="noopener">A Selective Review of Group Selection in High-Dimensional Models</a>. Statistical science : a review journal of the Institute of Mathematical Statistics, 27(4), 10.</li>
</ul>
</blockquote>
<p>假设设计矩阵$X$可分为$J$个组$X_1, X_2, \cdots, X_J$，且$d_j$表示第$j$个组的大小（size），也即$\sum_{j=1}^Jd_j = p$。</p>
<p>目标函数：<br>
\begin{equation}<br>
\begin{aligned}<br>
Q(\beta | X,y) &amp;= L(\beta|X,y) + \sum_{j=1}^J \lambda_j {\parallel} \beta_j {\parallel_{K_j}} \qquad (\lambda \geq 0)\<br>
&amp;= \parallel y - \sum_{j=1}^JX_j\beta_j {\parallel_2^2} + \lambda \sum_{j=1}^J \sqrt{d_j} \parallel \beta_j {\parallel_{K_j}}<br>
\end{aligned}<br>
\end{equation}</p>
<ul>
<li>${\parallel}z{\parallel_{K_j}} = \left( z^TK_jz \right)^{1/2}$</li>
<li>为了保证对大组、小组的惩罚力度一致，可取$\lambda_j = \lambda \sqrt{d_j}$</li>
<li>当$d_j=1(1\leq j\leq J)$时，Group LASSO简化为标准LASSO，且$R_j=\frac{1}{n}\parallel X_j\parallel^2$正比于$X_j$的样本方差。</li>
</ul>
<h2 id="如何选择-K-j"><a class="header-anchor" href="#如何选择-K-j"></a>如何选择$K_j$</h2>
<p>对于标准正交的$X_j$，有<br>
$$\frac{1}{n}X_j^TX_j = I_{d_j}, \qquad j=1, 2, \cdots, J.$$</p>
<ul>
<li><a href="http://www.columbia.edu/~my2550/papers/glasso.final.pdf" target="_blank" rel="noopener">Yuan and Lin(2006)</a>建议取$K_j=I_{d_j}$</li>
</ul>
<h2 id="求解"><a class="header-anchor" href="#求解"></a>求解</h2>
<ul>
<li><a href="http://www.columbia.edu/~my2550/papers/glasso.final.pdf" target="_blank" rel="noopener">Yuan and Lin(2006)</a>：通过组坐标下降法（Group Coordinate Descent Algorithm）计算Group LASSO的解</li>
</ul>
<p>令$z=\frac{1}{n}X_j^T y$为$y=X\beta+\varepsilon$的最小二乘解，则有<br>
$$\hat{\beta}<em>{LASSO}(z;\lambda) = S(z, \lambda) = \left( 1-\frac{\lambda}{\parallel z \parallel_2} \right)</em>{+} z$$</p>
<h1 id="Group-Bridge"><a class="header-anchor" href="#Group-Bridge"></a>Group Bridge</h1>
<blockquote>
<p>Huang, J., Ma, S., Xie, H., &amp; Zhang, C. H. (2009). <a href="https://www.researchgate.net/publication/40786418_A_Group_Bridge_Approach_for_Variable_Selection" target="_blank" rel="noopener">A group bridge approach for variable selection</a>. Biometrika, 96(2), 339–355.</p>
</blockquote>
<p>目标函数：<br>
$$Q(\beta|X, y) = \parallel y-\sum_{k=1}^p x_k \beta_k \parallel_2^2 + \lambda_n \sum_{j=1}^J c_j\parallel \beta_{A_j} \parallel_1^{\gamma}, \qquad \lambda_n &gt; 0$$</p>
<ul>
<li>$A_j(j=1,2,\cdots,J)$是${1, 2, \cdots, p}$的任意子集</li>
<li>$A_j(j=1,2,\cdots,J)$可以有交集</li>
<li>允许$\cup_{j=1}^J A_j$是${1, 2, \cdots, p}$的真子集，不在$\cup_{j=1}^J A_j$中的变量不受惩罚</li>
<li>Bridge惩罚项被应用到组系数的$L_1$范数中</li>
</ul>
<h1 id="Group-MCP"><a class="header-anchor" href="#Group-MCP"></a>Group MCP</h1>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="参考资料"><a class="header-anchor" href="#参考资料"></a>参考资料</h1>
<ul>
<li><a href="https://zh.wikipedia.org/wiki/Lp%E8%8C%83%E6%95%B0" target="_blank" rel="noopener">Wiki: Lp-norm</a></li>
<li><a href="https://www.statisticshowto.com/ridge-regression/" target="_blank" rel="noopener">Ridge Regression: Simple Definition</a></li>
<li><a href="https://www.datacamp.com/community/tutorials/tutorial-ridge-lasso-elastic-net" target="_blank" rel="noopener">Regularization: Ridge, Lasso and Elastic Net</a></li>
<li><a href="http://web.math.ku.dk/~richard/download/courses/stat_learn_2007/star3.pdf" target="_blank" rel="noopener">LASSO and Bridge regression</a></li>
<li><a href="https://myweb.uiowa.edu/pbreheny/7600/s16/notes/4-27.pdf" target="_blank" rel="noopener">Group lasso</a></li>
<li><a href="https://en.wikipedia.org/wiki/Lasso_(statistics)#Group_lasso" target="_blank" rel="noopener">Wiki: Group Lasso</a></li>
</ul>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>变量选择</tag>
      </tags>
  </entry>
  <entry>
    <title>R语言 | grpreg</title>
    <url>/R%E8%AF%AD%E8%A8%80-grpreg.html</url>
    <content><![CDATA[<p><center></center><br><a id="more"></a></p>
<h1 id="grpreg包"><a href="#grpreg包" class="headerlink" title="grpreg包"></a>grpreg包</h1><p>包含</p>
<ul>
<li>组选择方法（group selection methods）：<ul>
<li>group lasso</li>
<li>group MCP</li>
<li>group SCAD</li>
</ul>
</li>
<li>双层变量选择（bi-level selection methods）：<ul>
<li>group exponential lasso</li>
<li>composite MCP</li>
<li>group bridge</li>
</ul>
</li>
</ul>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">install.package(<span class="string">'grpreg'</span>)  <span class="comment">## 安装</span></span><br></pre></td></tr></table></figure>
<p>支持以下多种惩罚函数（penalities）：</p>
<ul>
<li><code>grLasso</code>：Group Lasso（<a href="http://www.columbia.edu/~my2550/papers/glasso.final.pdf" target="_blank" rel="noopener">Yuan &amp; Lin, 2006</a>）</li>
<li><code>grMCP</code>：Group MCP</li>
<li><code>grSCAD</code>：Group SCAD</li>
<li><code>cMCP</code>：Composite MCP（<a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC2904563/" target="_blank" rel="noopener">Breheny &amp; Huang, 2009</a>）</li>
<li><code>gel</code>：Group Exponential Lasso（<a href="https://onlinelibrary.wiley.com/doi/abs/10.1111/biom.12300" target="_blank" rel="noopener">Breheny, 2015</a>）</li>
<li><code>gBridge</code>：Group Bridge（<a href="https://www.jstor.org/stable/27798828" target="_blank" rel="noopener">Huang etal., 2009</a>）</li>
</ul>
<h2 id="cv-grpreg"><a href="#cv-grpreg" class="headerlink" title="cv.grpreg()"></a>cv.grpreg()</h2><ul>
<li>使用交叉验证方法确定最优的 $\lambda$ 值</li>
</ul>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="keyword">library</span>(grpreg)</span><br></pre></td></tr></table></figure>
<h2 id="grpreg"><a href="#grpreg" class="headerlink" title="grpreg()"></a>grpreg()</h2><figure class="highlight r"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="plot-grpreg"><a href="#plot-grpreg" class="headerlink" title="plot.grpreg()"></a>plot.grpreg()</h2><figure class="highlight r"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://cran.r-project.org/web/packages/grpreg/grpreg.pdf" target="_blank" rel="noopener">Package ‘grpreg’</a></li>
</ul>
]]></content>
      <categories>
        <category>R语言</category>
      </categories>
      <tags>
        <tag>R</tag>
      </tags>
  </entry>
  <entry>
    <title>R语言 | Amelia</title>
    <url>/R%E8%AF%AD%E8%A8%80-Amelia.html</url>
    <content><![CDATA[<p><center></center><br><a id="more"></a></p>
<h1 id="Amelia包"><a href="#Amelia包" class="headerlink" title="Amelia包"></a>Amelia包</h1><p>Amelia对缺失值的假设为：</p>
<ul>
<li>缺失值是随机缺失的</li>
<li>数据中所有变量都满足多元正态分布（MVN，Multivariate Normal Distribution），可以用均值和协方差来描述数据</li>
<li>利用Bootstrap生成多组填补值</li>
</ul>
<p>可视化缺失值</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">data(iris)</span><br><span class="line">summary(iris)  <span class="comment">## 描述性统计</span></span><br><span class="line"><span class="comment"># Sepal.Length    Sepal.Width     Petal.Length    Petal.Width          Species  </span></span><br><span class="line"><span class="comment"># Min.   :4.300   Min.   :2.000   Min.   :1.000   Min.   :0.100   setosa    :50  </span></span><br><span class="line"><span class="comment"># 1st Qu.:5.100   1st Qu.:2.800   1st Qu.:1.600   1st Qu.:0.300   versicolor:50  </span></span><br><span class="line"><span class="comment"># Median :5.800   Median :3.000   Median :4.350   Median :1.300   virginica :50  </span></span><br><span class="line"><span class="comment"># Mean   :5.843   Mean   :3.057   Mean   :3.758   Mean   :1.199                  </span></span><br><span class="line"><span class="comment"># 3rd Qu.:6.400   3rd Qu.:3.300   3rd Qu.:5.100   3rd Qu.:1.800                  </span></span><br><span class="line"><span class="comment"># Max.   :7.900   Max.   :4.400   Max.   :6.900   Max.   :2.500</span></span><br><span class="line"></span><br><span class="line">install.packages(<span class="string">"dplyr"</span>)</span><br><span class="line"><span class="keyword">library</span>(dplyr)  <span class="comment">## 为了使用 %&gt;%</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 随机产生10%的缺失值</span></span><br><span class="line">set.seed(<span class="number">2021</span>)</span><br><span class="line">iris.miss &lt;- missForest::prodNA(iris, noNA = <span class="number">0.1</span>) %&gt;% </span><br><span class="line">  select(-Species)  <span class="comment">## 先去掉分类变量Species</span></span><br><span class="line">summary(iris.miss)</span><br><span class="line"><span class="comment"># Sepal.Length    Sepal.Width     Petal.Length    Petal.Width  </span></span><br><span class="line"><span class="comment"># Min.   :4.300   Min.   :2.000   Min.   :1.000   Min.   :0.10  </span></span><br><span class="line"><span class="comment"># 1st Qu.:5.100   1st Qu.:2.800   1st Qu.:1.500   1st Qu.:0.30  </span></span><br><span class="line"><span class="comment"># Median :5.700   Median :3.000   Median :4.400   Median :1.30  </span></span><br><span class="line"><span class="comment"># Mean   :5.788   Mean   :3.045   Mean   :3.744   Mean   :1.22  </span></span><br><span class="line"><span class="comment"># 3rd Qu.:6.400   3rd Qu.:3.300   3rd Qu.:5.100   3rd Qu.:1.90  </span></span><br><span class="line"><span class="comment"># Max.   :7.900   Max.   :4.200   Max.   :6.900   Max.   :2.50  </span></span><br><span class="line"><span class="comment"># NA's   :12      NA's   :9       NA's   :17      NA's   :18 </span></span><br><span class="line"></span><br><span class="line">install.packages(<span class="string">'Amelia'</span>)</span><br><span class="line"><span class="keyword">library</span>(Amelia)</span><br><span class="line"></span><br><span class="line">Amelia::missmap(iris.miss)</span><br></pre></td></tr></table></figure>
<p><meta name="referrer" content="no-referrer"><br><img src="/R%E8%AF%AD%E8%A8%80-Amelia/miss2.png" class title="可视化缺失值"></p>
<h1 id="Amelia-vs-MICE"><a href="#Amelia-vs-MICE" class="headerlink" title="Amelia vs MICE"></a>Amelia vs MICE</h1><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:left">Amelia</th>
<th style="text-align:left">MICE</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">拟合</td>
<td style="text-align:left">依赖整体数据服从“多元正态分布”的假设</td>
<td style="text-align:left">一个变量一个变量分别拟合</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:left">只能处理正态分布或者经转换后近似正态分布的变量</td>
<td style="text-align:left">可以处理多种类型数据</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:left">不能在数据子集上处理缺失值</td>
<td style="text-align:left">能在数据子集上处理缺失值</td>
</tr>
</tbody>
</table>
</div>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://jiangjun.netlify.app/post/r-missing-data/" target="_blank" rel="noopener">R 中缺失值的简单处理—— MICE 和 Amelia 篇</a></li>
</ul>
]]></content>
      <categories>
        <category>R语言</category>
      </categories>
      <tags>
        <tag>R</tag>
        <tag>缺失值</tag>
      </tags>
  </entry>
  <entry>
    <title>R语言 | MICE</title>
    <url>/R%E8%AF%AD%E8%A8%80-MICE.html</url>
    <content><![CDATA[<center>处理缺失值</center>

<a id="more"></a>
<h1 id="缺失值"><a href="#缺失值" class="headerlink" title="缺失值"></a>缺失值</h1><p>缺失值总体分为两类：</p>
<ol>
<li>随机缺失（MAR，Missing at Random）</li>
<li>非随机缺失（MNAR，Missing NOT at Random）</li>
</ol>
<blockquote>
<p>一般来说，认为缺失5%以内的缺失值可以接受。如果哪个变量或观测（样本）的缺失超过5%，可能就需要考虑将其删除。</p>
</blockquote>
<h1 id="MICE包"><a href="#MICE包" class="headerlink" title="MICE包"></a>MICE包</h1><p>全名：Multivariate Imputation by Chained Equations</p>
<ul>
<li>假定数据的缺失是MAR（随机缺失）</li>
<li>随机缺失意味着某个值的缺失可能是依赖于其他值的</li>
<li>MICE填补缺失值：使用其他变量对缺失变量$X_1$进行回归，用回归结果填补$X_1$的缺失</li>
</ul>
<p>默认情况下，对连续型数据采用线性回归进行拟合填补，对分类型变量采用逻辑回归进行拟合填补。</p>
<p>MICE使用的拟合方法：</p>
<ul>
<li>数值型变量：PMM（Predictive Mean Matching）</li>
<li>二分类变量：logreg（Logistic Regression）</li>
<li>多分类变量：polyreg（Bayesian Polytomous Regression）</li>
<li>有序分类变量：（Proportional Odds Model）</li>
</ul>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">install.packages(<span class="string">"mice"</span>)  <span class="comment">## 安装</span></span><br></pre></td></tr></table></figure>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">install.packages(<span class="string">'mice'</span>)</span><br><span class="line"><span class="keyword">library</span>(mice)</span><br><span class="line"></span><br><span class="line">install.packages(<span class="string">'missForest'</span>)</span><br><span class="line"><span class="keyword">library</span>(missForest)</span><br><span class="line"></span><br><span class="line">data(iris)</span><br><span class="line">summary(iris)  <span class="comment">## 描述性统计</span></span><br><span class="line"><span class="comment"># Sepal.Length    Sepal.Width     Petal.Length    Petal.Width          Species  </span></span><br><span class="line"><span class="comment"># Min.   :4.300   Min.   :2.000   Min.   :1.000   Min.   :0.100   setosa    :50  </span></span><br><span class="line"><span class="comment"># 1st Qu.:5.100   1st Qu.:2.800   1st Qu.:1.600   1st Qu.:0.300   versicolor:50  </span></span><br><span class="line"><span class="comment"># Median :5.800   Median :3.000   Median :4.350   Median :1.300   virginica :50  </span></span><br><span class="line"><span class="comment"># Mean   :5.843   Mean   :3.057   Mean   :3.758   Mean   :1.199                  </span></span><br><span class="line"><span class="comment"># 3rd Qu.:6.400   3rd Qu.:3.300   3rd Qu.:5.100   3rd Qu.:1.800                  </span></span><br><span class="line"><span class="comment"># Max.   :7.900   Max.   :4.400   Max.   :6.900   Max.   :2.500</span></span><br><span class="line"></span><br><span class="line">install.packages(<span class="string">"dplyr"</span>)</span><br><span class="line"><span class="keyword">library</span>(dplyr)  <span class="comment">## 为了使用 %&gt;%</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 随机产生10%的缺失值</span></span><br><span class="line">set.seed(<span class="number">2021</span>)</span><br><span class="line">iris.miss &lt;- missForest::prodNA(iris, noNA = <span class="number">0.1</span>) %&gt;% </span><br><span class="line">  select(-Species)  <span class="comment">## 先去掉分类变量Species</span></span><br><span class="line">summary(iris.miss)</span><br><span class="line"><span class="comment"># Sepal.Length    Sepal.Width     Petal.Length    Petal.Width  </span></span><br><span class="line"><span class="comment"># Min.   :4.300   Min.   :2.000   Min.   :1.000   Min.   :0.10  </span></span><br><span class="line"><span class="comment"># 1st Qu.:5.100   1st Qu.:2.800   1st Qu.:1.500   1st Qu.:0.30  </span></span><br><span class="line"><span class="comment"># Median :5.700   Median :3.000   Median :4.400   Median :1.30  </span></span><br><span class="line"><span class="comment"># Mean   :5.788   Mean   :3.045   Mean   :3.744   Mean   :1.22  </span></span><br><span class="line"><span class="comment"># 3rd Qu.:6.400   3rd Qu.:3.300   3rd Qu.:5.100   3rd Qu.:1.90  </span></span><br><span class="line"><span class="comment"># Max.   :7.900   Max.   :4.200   Max.   :6.900   Max.   :2.50  </span></span><br><span class="line"><span class="comment"># NA's   :12      NA's   :9       NA's   :17      NA's   :18 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 可视化缺失</span></span><br><span class="line">md.pattern(iris.miss)</span><br></pre></td></tr></table></figure>
<p><meta name="referrer" content="no-referrer"><br><img src="/R%E8%AF%AD%E8%A8%80-MICE/miss1.png" class title="可视化缺失值"></p>
<blockquote>
<ul>
<li>每一行是一种缺失模式</li>
<li>左边的数字表示有多少个样本是这种缺失模式</li>
<li>下方的数字表示每列（每个变量）的缺失值个数</li>
<li>右边的数字表示每行（每个样本）的缺失值个数</li>
</ul>
</blockquote>
<h2 id="mice"><a href="#mice" class="headerlink" title="mice"></a>mice</h2><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">data_imputed &lt;- mice(iris.miss, m = <span class="number">5</span>, maxit = <span class="number">50</span>, method = <span class="string">'pmm'</span>, seed = <span class="number">206</span>)</span><br><span class="line"><span class="comment">## m = 5：生成5个填补好的数据</span></span><br><span class="line"><span class="comment">## maxit = 50：每次产生填补数据的迭代次数为50次</span></span><br><span class="line"><span class="comment">## method = 'pmm'：填补方式选择Predictive Mean Matching</span></span><br><span class="line">summary(data_imputed)</span><br><span class="line"><span class="comment"># Class: mids</span></span><br><span class="line"><span class="comment"># Number of multiple imputations:  5 </span></span><br><span class="line"><span class="comment"># Imputation methods:</span></span><br><span class="line"><span class="comment">#   Sepal.Length  Sepal.Width Petal.Length  Petal.Width </span></span><br><span class="line"><span class="comment"># "pmm"        "pmm"        "pmm"        "pmm" </span></span><br><span class="line"><span class="comment"># PredictorMatrix:</span></span><br><span class="line"><span class="comment">#   Sepal.Length Sepal.Width Petal.Length Petal.Width</span></span><br><span class="line"><span class="comment"># Sepal.Length            0           1            1           1</span></span><br><span class="line"><span class="comment"># Sepal.Width             1           0            1           1</span></span><br><span class="line"><span class="comment"># Petal.Length            1           1            0           1</span></span><br><span class="line"><span class="comment"># Petal.Width             1           1            1           0</span></span><br><span class="line"></span><br><span class="line">data_imputed$imp$Sepal.Width <span class="comment">## 生成的Sepal.Width值</span></span><br><span class="line"><span class="comment"># 1   2   3   4   5</span></span><br><span class="line"><span class="comment"># 5   3.4 3.8 3.0 2.7 3.4</span></span><br><span class="line"><span class="comment"># 14  3.8 2.5 2.9 2.8 3.1</span></span><br><span class="line"><span class="comment"># 16  3.8 3.9 3.5 4.2 4.2</span></span><br><span class="line"><span class="comment"># 38  3.1 3.4 3.0 3.0 3.6</span></span><br><span class="line"><span class="comment"># 41  3.4 3.5 3.7 3.7 3.5</span></span><br><span class="line"><span class="comment"># 42  3.1 2.9 2.9 3.4 3.2</span></span><br><span class="line"><span class="comment"># 124 3.4 2.5 2.5 2.8 3.3</span></span><br><span class="line"><span class="comment"># 144 2.6 2.5 2.9 3.0 2.7</span></span><br><span class="line"><span class="comment"># 150 3.0 3.1 3.2 3.9 3.3</span></span><br><span class="line">dim(data_imputed$imp$Sepal.Width)</span><br><span class="line"><span class="comment"># [1] 9 5</span></span><br><span class="line"><span class="comment"># Sepal.Width有9个缺失，这里生成了5组数据</span></span><br><span class="line"></span><br><span class="line">data_complete &lt;- mice::complete(data_imputed, <span class="number">3</span>)</span><br><span class="line"><span class="comment">## 取5组中的第3组</span></span><br><span class="line">sum(is.na(data_complete))</span><br><span class="line"><span class="comment"># [1] 0</span></span><br><span class="line"></span><br><span class="line">head(data_complete)</span><br><span class="line"><span class="comment"># Sepal.Length Sepal.Width Petal.Length Petal.Width</span></span><br><span class="line"><span class="comment"># 1          5.1         3.5          1.4         0.2</span></span><br><span class="line"><span class="comment"># 2          4.9         3.0          1.4         0.1</span></span><br><span class="line"><span class="comment"># 3          4.7         3.2          1.3         0.2</span></span><br><span class="line"><span class="comment"># 4          4.6         3.1          1.5         0.2</span></span><br><span class="line"><span class="comment"># 5          5.0         3.0          1.4         0.2</span></span><br><span class="line"><span class="comment"># 6          5.4         3.9          1.7         0.2</span></span><br></pre></td></tr></table></figure>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://jiangjun.netlify.app/post/r-missing-data/" target="_blank" rel="noopener">R 中缺失值的简单处理—— MICE 和 Amelia 篇</a></li>
</ul>
]]></content>
      <categories>
        <category>R语言</category>
      </categories>
      <tags>
        <tag>R</tag>
        <tag>缺失值</tag>
      </tags>
  </entry>
  <entry>
    <title>Word论文排版</title>
    <url>/Word%E8%AE%BA%E6%96%87%E6%8E%92%E7%89%88.html</url>
    <content><![CDATA[<p><center></center><br><a id="more"></a></p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul>
<li><strong>自定义目录，并填充省略号等引导符</strong>：输入章节文字，全选，单击右键，选择【段落】——【制表位】<ul>
<li>【制表位】 填写页码右侧的制表位，可填写34.26字符，可根据效果调整数值</li>
<li>【对齐方式】 选择“右”</li>
<li>【引导符】 一般选择第3种或第5种</li>
</ul>
</li>
<li><strong>自定义目录，插入页码</strong>：将鼠标定位在前一步骤产生的引导符后，点击【引用】——【交叉引用】<ul>
<li>【引用类型】 选择“标题”</li>
<li>【引用内容】 选择“页码”</li>
<li>点击【插入】——【关闭】即可</li>
</ul>
</li>
</ul>
<h1 id="章节"><a href="#章节" class="headerlink" title="章节"></a>章节</h1><ul>
<li><strong>新章从奇数页开始</strong>：将鼠标定位在上一章的结尾，点击【布局】——【分隔符】——【奇数页】（插入分节符并在下一奇数页上开始新节）</li>
</ul>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><ul>
<li>通常情况下，表格上下方与正文均需隔一行空行</li>
<li><strong>插入表标题</strong>：选中表格，点击【引用】——【插入题注】<ul>
<li>【标签】选择需要的标题前缀，如“表格”、“公式”、“图表”等，如果不存在想要的标签，可以点击【新建标签】新建标签</li>
<li>【位置】选择标题置于表格上方或下方，一般选择“所选项目上方”</li>
<li>【编号】设置表格编号的格式</li>
</ul>
</li>
<li><strong>切分表格第一个单元格</strong>：选择第一个单元格，点击【开始】——【边框】选择“斜下框线”，然后在该单元格 先“右对齐”输入列标题，然后回车，“左对齐”输入行标题</li>
</ul>
<h2 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h2><ul>
<li><strong>插入脚注</strong>：将鼠标定位到要插入脚注的地方，点击【引用】——【插入脚注】，即可。</li>
<li><strong>修改脚注格式</strong>：右键点击脚注内容，选择【脚注】，修改脚注的【编号格式】、【起始编号】、【应用更改】（确定该更改应用的范围）等</li>
</ul>
<h2 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h2><h2 id="插入公式"><a href="#插入公式" class="headerlink" title="插入公式"></a>插入公式</h2><p>【插入】——【公式】——编辑公式</p>
<ul>
<li>快捷键：Ctrl + <code>+=</code></li>
</ul>
<h3 id="自动编号"><a href="#自动编号" class="headerlink" title="自动编号"></a>自动编号</h3><p>将光标置于<strong>公式内</strong>的末尾，输入<code>#()</code>，然后将光标置于括号内，点击【插入】——【插入域】：</p>
<ul>
<li>【类别】选择“编号”</li>
<li>【域名】选择“AutoNum”</li>
<li>【选项】选择目标数字格式<br>点击【确认】即可。</li>
</ul>
<h1 id="页眉"><a href="#页眉" class="headerlink" title="页眉"></a>页眉</h1><ul>
<li><strong>去掉页眉中的横线</strong>：全选页眉的文字或换行符，点击【开始】——边框选择“无框线”</li>
<li><strong>偶数页页眉显示论文标题</strong>：</li>
<li><strong>奇数页页眉显示当前章节标题</strong>：双击奇数页页眉的位置，勾选【奇偶页不同】，点击【域】，【域名】中选中“StyleRef”，点击【选项】——【样式】——选择【标题1】——【添加到域】，单击【确认】即可</li>
</ul>
<h1 id="页码"><a href="#页码" class="headerlink" title="页码"></a>页码</h1><ul>
<li><strong>插入页码</strong>：点击【插入】——【页码】</li>
</ul>
<h1 id="导出为pdf"><a href="#导出为pdf" class="headerlink" title="导出为pdf"></a>导出为pdf</h1><h2 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h2><p>单击【文件】——【导出】——【创建PDF\XPS文档】——【创建PDF\XPS】，命名，保存即可</p>
<h2 id="MacOS"><a href="#MacOS" class="headerlink" title="MacOS"></a>MacOS</h2><p>单击【文件】——【另存为】——【文件格式】选择（导出格式）“PDF”，命名，保存即可</p>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><blockquote>
<p>推荐使用<a href="https://www.endnote.com/" target="_blank" rel="noopener">EndNote</a>进行参考文献的插入、管理</p>
</blockquote>
<h1 id="EndNote"><a href="#EndNote" class="headerlink" title="EndNote"></a>EndNote</h1><h2 id="引用格式"><a href="#引用格式" class="headerlink" title="引用格式"></a>引用格式</h2><h2 id="下载引用文本"><a href="#下载引用文本" class="headerlink" title="下载引用文本"></a>下载引用文本</h2><p>如何下载引用文本：</p>
<ul>
<li><a href="https://xueshu.baidu.com" target="_blank" rel="noopener">百度学术</a>：搜索目标文献，点击【引用】，选择引用格式，点击【导入链接】中的“EndNote”，即可下载.enw格式的引用文本</li>
<li>知网：点击【引用】——【更多引用格式】——【文献导出格式】选择“EndNote”——【导出】，即可下载.txt格式的引用文本</li>
</ul>
<h2 id="导入引用文本"><a href="#导入引用文本" class="headerlink" title="导入引用文本"></a>导入引用文本</h2><p>点击【File】——【Import】，选择前面下载的引用文本文件，单击【Options】，修改【Import Options】，然后点击“Import”即可。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">引用文本文件格式</th>
<th style="text-align:left"><code>Import Options</code>选项设置</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">.txt</td>
<td style="text-align:left">Tab Delimited</td>
</tr>
<tr>
<td style="text-align:center">.enw</td>
<td style="text-align:left">EndNote Import</td>
</tr>
<tr>
<td style="text-align:center">.ris</td>
<td style="text-align:left">Reference Manager(RIS)</td>
</tr>
</tbody>
</table>
</div>
<h2 id="同步Library"><a href="#同步Library" class="headerlink" title="同步Library"></a>同步Library</h2><p>单击图标“循环转圈圈”【Sync Library】，同步本地内容到online</p>
<h2 id="Attach-PDF"><a href="#Attach-PDF" class="headerlink" title="Attach PDF"></a>Attach PDF</h2><p>将PDF与Reference连接到一起，便于根据Reference列表查找、阅读文献。鼠标选中目标Reference条目，单击“回形针”图标【Attach PDF】，选择本地PDF文件，即可将PDF绑定到相应的Reference条目。</p>
<blockquote>
<ul>
<li>记得保存 并 及时Sync 哦~</li>
<li>在EndNote中阅读文件，可以使用编辑工具进行高亮注释、添加文本注释等，非常方便呢</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>Everything</category>
      </categories>
  </entry>
  <entry>
    <title>LaTeX</title>
    <url>/LaTeX.html</url>
    <content><![CDATA[<p><center></center><br><a id="more"></a></p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h2 id="MacOS"><a href="#MacOS" class="headerlink" title="MacOS"></a>MacOS</h2><p>在MacOS可以安装MacTeX，但是完整版较大，安装后显示为TeXShop；可以安装较小的<a href="http://www.tug.org/mactex/morepackages.html" target="_blank" rel="noopener">BasicTeX</a>，并安装编辑器TeXStudio（博主打不开官网）。</p>
<ul>
<li>TeXShop默认编码不是Unicode，需点击TeXShop——偏好设置，将编码改为“Unicode（UTF-8）”，以便能够支持中文编译。</li>
</ul>
<h2 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h2><p>安装<a href="http://www.ctex.org/HomePage" target="_blank" rel="noopener">CTEX</a>，Windows对应的是<a href="https://miktex.org/" target="_blank" rel="noopener">MiKTeX</a>。</p>
<h1 id="自定义命令"><a href="#自定义命令" class="headerlink" title="自定义命令"></a>自定义命令</h1><ul>
<li><code>\newcommand{新命令}[参数个数]{原命令}</code></li>
<li><code>\newcommand*{新命令}[参数个数]{原命令}</code></li>
<li><code>\renewcommand{新命令}[参数个数]{原命令}</code></li>
<li><p><code>\renewcommand*{新命令}[参数个数]{原命令}</code></p>
</li>
<li><p>参数个数不能超过9个</p>
</li>
<li>带星号的称为“短命令”（不能出现段落）</li>
<li>LATEX编译时用原命令内容替换新命令，同时将相应的参数代入</li>
<li>自定义命令本质上就是命令替换</li>
</ul>
<p>自定义命令的作用范围：</p>
<ol>
<li>如果放在导言区，则全局有效</li>
<li>如果放在正文中的某个环境或分组中定义，则仅在其所在环境或分组内部有效</li>
</ol>
<h1 id="表格tabular"><a href="#表格tabular" class="headerlink" title="表格tabular"></a>表格tabular</h1><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;tabular&#125;</span><span class="string">[竖向位置]</span><span class="string">&#123;列格式&#125;</span></span></span><br><span class="line">第一行 <span class="tag">\<span class="name">\</span></span></span><br><span class="line">... <span class="tag">\<span class="name">\</span></span></span><br><span class="line">第末行 <span class="tag">\<span class="name">\</span></span></span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;tabular&#125;</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>竖向位置：表格在竖直方向与外部文本行的相对位置，取值可以是t或b，缺省为居中</li>
<li>表格每行由若干列组成，列与列之间用&amp;分隔，每行必须用 <code>\\</code> 结束</li>
<li>列格式：由若干项组成，用于指定各列的格式，如<code>\begin{tabular}{|c|c|c|}</code><ul>
<li><code>l</code>：左对齐</li>
<li><code>c</code>：居中</li>
<li><code>r</code>：右对齐</li>
<li><code>|</code>：边界线</li>
</ul>
</li>
<li>横线：<ul>
<li><code>\hline</code>：与表格同宽的水平线</li>
<li><code>\cline{m-n}</code>：从第m列开始到第n列结束的水平线</li>
</ul>
</li>
<li>竖线：<ul>
<li><code>\vline</code>：在当前位置画一与行等高的竖线</li>
</ul>
</li>
<li>合并相邻多列：<code>\multicolumn{列数}{列格式}{文本内容}</code><ul>
<li>当列数=1时，可以改变当前列的对齐方式</li>
<li>改变各行之间的间隔（改变行高）：<code>\\[长度]</code></li>
</ul>
</li>
</ul>
<h1 id="幻灯片Beamer"><a href="#幻灯片Beamer" class="headerlink" title="幻灯片Beamer"></a>幻灯片Beamer</h1><p>MacOS可以从“文件”中的“从模板新建”中选择“Beamer”新建幻灯片模板。</p>
<p>主题超市：</p>
<ul>
<li><a href="https://deic-web.uab.cat/~iblanes/beamer_gallery/" target="_blank" rel="noopener">Beamer theme gallery</a></li>
<li><a href="https://www.overleaf.com/gallery/tagged/presentation#.Wv7RVIiFPIU" target="_blank" rel="noopener">OverLeaf Beamer主题Gallery</a></li>
</ul>
<h1 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h1><h2 id="摘要Abstract"><a href="#摘要Abstract" class="headerlink" title="摘要Abstract"></a>摘要Abstract</h2><ul>
<li>在 <code>\maketitle</code> 之后用 <code>abstract</code> 环境生成</li>
</ul>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;abstract&#125;</span></span></span><br><span class="line">摘要内容</span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;abstract&#125;</span></span></span><br></pre></td></tr></table></figure>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><h3 id="导引线"><a href="#导引线" class="headerlink" title="导引线"></a>导引线</h3><ul>
<li><code>\dotfill</code>：省略号导引线</li>
<li><code>\hrulefill</code></li>
</ul>
<h2 id="脚注footnote"><a href="#脚注footnote" class="headerlink" title="脚注footnote"></a>脚注footnote</h2><p><code>\footnote{脚注内容}</code></p>
<ul>
<li>该脚注命令应紧接在需要注释的文字后面，排版后会在所在处显示一个脚注标记，并将脚注内容显示在当前页的底部，并带有相同的脚注标记</li>
<li>脚注标记是上标形式的数字，并自动编号</li>
<li>在<code>article</code>文档类中，整篇文章的脚注统一编号</li>
<li>在<code>book</code>和<code>report</code>文档类中，每章的脚注统一编号</li>
<li>脚注只能位于普通文本中，不能位于数学模式，表格，LR盒子等中</li>
</ul>
<h1 id="页面布局"><a href="#页面布局" class="headerlink" title="页面布局"></a>页面布局</h1><h2 id="页高度"><a href="#页高度" class="headerlink" title="页高度"></a>页高度</h2><p>增加当前页高度：有时可以避免难看的分页</p>
<ol>
<li><code>\enlargethispage{尺寸}</code> ：可增加的最大高度</li>
<li><code>\enlargethispage*{尺寸}</code> ：严格指定增加高度</li>
</ol>
<h2 id="分段"><a href="#分段" class="headerlink" title="分段"></a>分段</h2><h2 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h2><ul>
<li>自动分页</li>
<li>强制分页：<code>\newpage</code></li>
<li>建议分页：<ul>
<li><code>\pagebreak[n]</code></li>
<li><code>\nopagebreak[n]</code></li>
</ul>
</li>
</ul>
<h1 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h1><h2 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h2><p>行间公式：</p>
<ul>
<li>独占一行（单行公式）或多行（多行公式）</li>
<li>行间公式可以编号，也可以不编号</li>
<li>编号可以人工编号，也可以自动编号</li>
<li>行间公式中不能出现空行</li>
</ul>
<p>单行公式</p>
<ol>
<li>不带编号：<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;displaymath&#125;</span></span></span><br><span class="line">...</span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;displaymath&#125;</span></span></span><br></pre></td></tr></table></figure></li>
<li>上面的简化形式:<code>\[...\]</code></li>
<li>自动编号：<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;equation&#125;</span></span></span><br><span class="line">...</span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;equation&#125;</span></span></span><br></pre></td></tr></table></figure></li>
<li>不自动编号：$$$…$$$；可使用<code>\eqno</code>或<code>leqno</code>人工编号</li>
</ol>
<h3 id="equation环境"><a href="#equation环境" class="headerlink" title="equation环境"></a>equation环境</h3><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;equation&#125;</span></span></span><br><span class="line">...</span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;equation&#125;</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>公式自动编号</li>
<li>equation环境中的公式可以是普通的<strong>单行公式</strong>，也可以是作为一个整体处理的<strong>环境或盒子</strong></li>
<li>若要改变公式自动编号的值，可在公式前插入<code>\setcounter{equation}{整数}</code>，这里的equation为公式计数器，其后面的公式的编号自动为计数器的值加1</li>
<li>标记：<code>\label{公式标记}</code>，公式标志唯一</li>
<li>引用：<code>\ref{公式标记}</code>和<code>\eqref{公式标记}</code></li>
</ul>
<h3 id="eqnarray环境"><a href="#eqnarray环境" class="headerlink" title="eqnarray环境"></a>eqnarray环境</h3><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="comment">%% 自动编号</span></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;equation&#125;</span></span></span><br><span class="line">...</span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;equation&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 不自动编号</span></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;equation*&#125;</span></span></span><br><span class="line">...</span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;equation*&#125;</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>eqnarray环境中每行公式都自动编号</li>
<li>若某行公式无需编号，可在该行公式后面的换行符前插入<code>\nonumber</code></li>
<li>eqnarray环境中每行的格式为<code>左边公式 &amp; 中间公式 &amp; 右边公式</code><ul>
<li>总是按三列排版公式，每行至多三列</li>
<li>三列的对齐方式分别为：左对齐，居中，右对齐</li>
<li>同一行中各列之间用 &amp; 隔开</li>
</ul>
</li>
<li>eqnarray环境内部修改计数器equation的值</li>
<li>紧跟在行间公式后面的文本不会自动缩进</li>
<li>每行公式以 <code>\\</code> 结束（最后一行除外）</li>
<li>修改单个行间距：<code>\\[高度]</code></li>
</ul>
<h2 id="角标"><a href="#角标" class="headerlink" title="角标"></a>角标</h2><ul>
<li>上标：<code>^{...}</code></li>
<li>下标：<code>_{...}</code></li>
<li>上标、小标角标命令必须在数学模式中使用</li>
<li>多层角标需要使用分组符号</li>
<li>一级角标字体大小约7pt，二级及以上角标字体大小约为5pt</li>
<li><strong>中文角标</strong>要放入盒子，并指定字体大小<script type="math/tex">x^{\mbox{\scriptsize 平方}}</script></li>
<li>可以根据需要手工改变角标字体大小或层次</li>
</ul>
<h2 id="常用数学符号"><a href="#常用数学符号" class="headerlink" title="常用数学符号"></a>常用数学符号</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">符号</th>
<th style="text-align:left">TeX</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">导数符号</td>
<td style="text-align:left">\prime 或 单引号</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>求和：<ul>
<li>带上下限：位于符号右侧，或符号头顶和脚下</li>
<li>在行内公式和行间公式中取不同的尺寸</li>
<li><code>\sum_{ }^{ }</code>，求和上下标在右边。如：<code>\sum_{i=1}^{100}</code>即$\sum_{i=1}^{100}$</li>
<li>可以人工指定上下限的位置： <code>\limits</code>、<code>\nolimits</code></li>
<li><code>\sum\nolimits{ }\limits{ }</code>：求和上下标在求和符号上下方</li>
</ul>
</li>
</ul>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="长度单位"><a href="#长度单位" class="headerlink" title="长度单位"></a>长度单位</h2><p>常用的长度单位：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">单位</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">mm</td>
<td style="text-align:left">毫米</td>
</tr>
<tr>
<td style="text-align:center">cm</td>
<td style="text-align:left">厘米</td>
</tr>
<tr>
<td style="text-align:center">in</td>
<td style="text-align:left">英寸</td>
</tr>
<tr>
<td style="text-align:center">pt</td>
<td style="text-align:left">点</td>
</tr>
<tr>
<td style="text-align:center">em</td>
<td style="text-align:left">大写字母M的宽度</td>
</tr>
<tr>
<td style="text-align:center">ex</td>
<td style="text-align:left">小写字母x的高度</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>TeX长度由十进制小数加长度单位表示</li>
<li>em、ex与当前字体尺寸相关</li>
<li>1 in = 2.54 cm = 72.27 pt</li>
</ul>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1>]]></content>
      <categories>
        <category>Everything</category>
      </categories>
      <tags>
        <tag>LaTeX</tag>
      </tags>
  </entry>
  <entry>
    <title>Python | Seaborn</title>
    <url>/python-seaborn.html</url>
    <content><![CDATA[<p><center></center><br><a id="more"></a></p>
<blockquote>
<p><a href="http://seaborn.pydata.org/tutorial.html" target="_blank" rel="noopener">seaborn官方文档</a></p>
</blockquote>
<h1 id="Seaborn"><a href="#Seaborn" class="headerlink" title="Seaborn"></a>Seaborn</h1><p>Seaborn是Python中一个基于Matplotlib的数据可视化库。</p>
<p>功能：</p>
<ul>
<li>面向数据集的API，用于检查多个变量之间的关系。</li>
<li>支持使用分类变量来显示样本或汇总统计数据。</li>
<li>可使用单变量或而二分量来比较数据子集。</li>
<li>针对不同类型的因变量进行线性回归模型的估计和绘制。</li>
<li>便于观察复杂数据集的整体结构。</li>
<li>用于构建多网格绘图，便于创造复杂的可视化图形。</li>
<li>简洁地控制matplotlib图形样式和内置主题。</li>
<li>可以选择调色板。</li>
</ul>
<p>安装：（在Anaconda Prompt中运行安装命令）<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip install seaborn</span><br></pre></td></tr></table></figure></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 一个简单的例子：</span></span><br><span class="line"><span class="comment">##该例中，以“total_bill”为横坐标，“tip”为纵坐标，“time”为分面依据，“smoker”为形状依据，“size”为大小依据。</span></span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns   <span class="comment">## 加载seaborn库</span></span><br><span class="line">sns.set()      <span class="comment">## 应用默认的seaborn主题、缩放、调色板</span></span><br><span class="line">tips = sns.load_dataset(<span class="string">"tips"</span>)  <span class="comment">##载入需要的数据tips</span></span><br><span class="line"></span><br><span class="line">%matplotlib inline  </span><br><span class="line"><span class="comment">##为了使图片在jupyter中显示</span></span><br><span class="line"><span class="comment">##绘制简单的分面散点图</span></span><br><span class="line">sns.relplot(x=<span class="string">"total_bill"</span>, y=<span class="string">"tip"</span>, col=<span class="string">"time"</span>,</span><br><span class="line">            hue=<span class="string">"smoker"</span>, style=<span class="string">"smoker"</span>, size=<span class="string">"size"</span>,</span><br><span class="line">            data=tips)</span><br><span class="line"><span class="comment">## 如果要保存图片：</span></span><br><span class="line"><span class="comment">#fig = sns.relplot(x="total_bill", y="tip", col="time",</span></span><br><span class="line"><span class="comment">#            hue="smoker", style="smoker", size="size",</span></span><br><span class="line"><span class="comment">#            data=tips)</span></span><br><span class="line"><span class="comment">#fig.savefig('分面散点图.png', dpi=400)</span></span><br><span class="line"><span class="comment">## dpi：每英寸点数 dots per inch</span></span><br></pre></td></tr></table></figure>
<p><meta name="referrer" content="no-referrer"><br><img src="/python-seaborn/%E5%88%86%E9%9D%A2%E6%95%A3%E7%82%B9%E5%9B%BE.png" class title="分面散点图"></p>
<h1 id="高级函数"><a href="#高级函数" class="headerlink" title="高级函数"></a>高级函数</h1><p>seaborn四大高级绘图函数：</p>
<ol>
<li>catplot()</li>
<li>distplot()</li>
<li>lmplot()</li>
<li>relplot()</li>
</ol>
<h2 id="catplot"><a href="#catplot" class="headerlink" title="catplot()"></a>catplot()</h2><p><code>catplot()</code> ：分类数据分布图（categorical）。<br><code>catplot(x=None, y=None, hue=None, data=None, row=None, 
    col=None, col_wrap=None, estimator=&lt;function mean at 0x000001AB0E436EA0&gt;, 
    ci=95, n_boot=1000, units=None, order=None, 
    hue_order=None, row_order=None, col_order=None, 
    kind=&#39;strip&#39;, height=5, aspect=1, orient=None, 
    color=None, palette=None, legend=True, 
    legend_out=True, sharex=True, sharey=True, 
    margin_titles=False, facet_kws=None, **kwargs)</code></p>
<ul>
<li>参数 <code>kind</code> 可取值有：<ul>
<li><code>strip</code>：散点图，默认</li>
<li><code>swarm</code>：分簇散点图</li>
<li><code>violin</code>：小提琴图</li>
<li><code>box</code>：箱线图</li>
<li><code>boxen</code>：增强箱型图</li>
<li><code>point</code>：点图</li>
<li><code>bar</code>：条形图</li>
<li><code>count</code>：计数条形图</li>
</ul>
</li>
<li><code>strip</code>和<code>swarm</code>之间存在细微差异（见下面的例子），swarm图会区分位置较为相近的点（使点不重叠）。</li>
<li>参数 <code>aspect</code>：控制坐标轴的横纵比，默认为1</li>
<li>参数 <code>col_wrap</code>：表示输出的图形中每行panel的个数</li>
<li><code>.add_legend(title=&#39;&#39;)</code>：添加图例，并修改图例的标题</li>
<li><code>.set_axis_labels(&quot;横轴标签&quot;, &quot;纵轴标签&quot;)</code>：修改横纵轴标签；若为空字符串，表示不显示轴标签</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ex = sns.load_dataset(<span class="string">"exercise"</span>)</span><br><span class="line">ex.head()</span><br><span class="line"></span><br><span class="line">sns.catplot(x=<span class="string">"time"</span>, y=<span class="string">"pulse"</span>, hue=<span class="string">"kind"</span>,</span><br><span class="line">           col=<span class="string">"diet"</span>, data=ex)</span><br></pre></td></tr></table></figure>
<p><meta name="referrer" content="no-referrer"><br><img src="/python-seaborn/%E9%BB%98%E8%AE%A4strip%E6%95%A3%E7%82%B9%E5%9B%BE.png" class title="默认strip散点图"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 参数 aspect：控制坐标轴的横纵比，默认为1</span></span><br><span class="line"><span class="comment">## 若参数aspect=0.8（改变的是坐标轴的横纵轴比）：</span></span><br><span class="line">sns.catplot(x=<span class="string">"time"</span>, y=<span class="string">"pulse"</span>, hue=<span class="string">"kind"</span>,</span><br><span class="line">           col=<span class="string">"diet"</span>, data=ex, aspect=<span class="number">0.8</span>)</span><br></pre></td></tr></table></figure>
<p><meta name="referrer" content="no-referrer"><br><img src="/python-seaborn/%E4%BF%AE%E6%94%B9%E5%9D%90%E6%A0%87%E8%BD%B4%E6%A8%AA%E7%BA%B5%E6%AF%94-%E9%BB%98%E8%AE%A4strip%E6%95%A3%E7%82%B9%E5%9B%BE.png" class title="修改坐标轴横纵比-默认strip散点图"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ex = sns.load_dataset(<span class="string">"exercise"</span>)</span><br><span class="line">sns.catplot(x=<span class="string">"time"</span>, y=<span class="string">"pulse"</span>, hue=<span class="string">"kind"</span>,</span><br><span class="line">           col=<span class="string">"kind"</span>, data=ex)</span><br></pre></td></tr></table></figure>
<p><meta name="referrer" content="no-referrer"><br><img src="/python-seaborn/%E6%95%A3%E7%82%B9%E5%9B%BE.png" class title="散点图"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 参数 col_wrap：表示输出的图形中每行panel的个数</span></span><br><span class="line">ex = sns.load_dataset(<span class="string">"exercise"</span>)</span><br><span class="line">sns.catplot(x=<span class="string">"time"</span>, y=<span class="string">"pulse"</span>, hue=<span class="string">"kind"</span>,</span><br><span class="line">           col=<span class="string">"kind"</span>, data=ex, col_wrap=<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p><meta name="referrer" content="no-referrer"><br><img src="/python-seaborn/%E9%99%90%E5%88%B6%E6%AF%8F%E8%A1%8Cpanel%E7%9A%84%E4%B8%AA%E6%95%B0-%E6%95%A3%E7%82%B9%E5%9B%BE.png" class title="限制每行panel的个数-散点图"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 自定义图形的属性：</span></span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">%matplotlib inline</span><br><span class="line"></span><br><span class="line">tips = sns.load_dataset(<span class="string">"tips"</span>)    <span class="comment">## 导入数据</span></span><br><span class="line">g = sns.catplot(x=<span class="string">"total_bill"</span>, y=<span class="string">"day"</span>, hue=<span class="string">"time"</span>, </span><br><span class="line">               height=<span class="number">4</span>, aspect=<span class="number">1.5</span>, kind=<span class="string">"box"</span>,</span><br><span class="line">               legend=<span class="literal">False</span>, data=tips)</span><br><span class="line"><span class="comment">##加上图例，并修改图例的标题</span></span><br><span class="line">g.add_legend(title=<span class="string">"Meal"</span>)</span><br><span class="line"><span class="comment">##设置横轴和纵轴的标签</span></span><br><span class="line">g.set_axis_labels(<span class="string">"Total bill($)"</span>, <span class="string">""</span>)</span><br><span class="line"><span class="comment">##设置x轴的取值范围、y轴的刻度标签</span></span><br><span class="line">g.set(xlim=(<span class="number">0</span>, <span class="number">60</span>), </span><br><span class="line">      yticklabels=[<span class="string">"Tuesday"</span>, <span class="string">"Friday"</span>, <span class="string">"Saturday"</span>, <span class="string">"Sunday"</span>])</span><br><span class="line"><span class="comment">##设置图片尺寸（单位：英寸）</span></span><br><span class="line">g.fig.set_size_inches(<span class="number">6.5</span>, <span class="number">3.5</span>)</span><br><span class="line">g.ax.set_xticks([<span class="number">5</span> ,<span class="number">15</span>, <span class="number">25</span>, <span class="number">35</span>, <span class="number">45</span>, <span class="number">55</span>], minor=<span class="literal">True</span>);</span><br><span class="line">plt.setp(g.ax.get_yticklabels(), rotation=<span class="number">30</span>);</span><br></pre></td></tr></table></figure>
<p><meta name="referrer" content="no-referrer"><br><img src="/python-seaborn/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9B%BE%E5%BD%A2%E5%B1%9E%E6%80%A7.png" class title="自定义图形属性"></p>
<h3 id="散点图strip"><a href="#散点图strip" class="headerlink" title="散点图strip"></a>散点图strip</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## catplot绘制默认strip：</span></span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"></span><br><span class="line">tips = sns.load_dataset(<span class="string">"tips"</span>)   <span class="comment">## 加载数据</span></span><br><span class="line">%matplotlib inline</span><br><span class="line">sns.catplot(x=<span class="string">"day"</span>, y=<span class="string">"total_bill"</span>, hue=<span class="string">"smoker"</span>,</span><br><span class="line">           data=tips)</span><br></pre></td></tr></table></figure>
<p><meta name="referrer" content="no-referrer"><br><img src="/python-seaborn/%E6%95%A3%E7%82%B9%E5%9B%BEstrip.png" class title="散点图strip"></p>
<h3 id="散点图swarm"><a href="#散点图swarm" class="headerlink" title="散点图swarm"></a>散点图swarm</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## catplot绘制swarm：</span></span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"></span><br><span class="line">tips = sns.load_dataset(<span class="string">"tips"</span>)</span><br><span class="line">%matplotlib inline</span><br><span class="line">sns.catplot(x=<span class="string">"day"</span>, y=<span class="string">"total_bill"</span>, hue=<span class="string">"smoker"</span>,</span><br><span class="line">           kind=<span class="string">"swarm"</span>, data=tips)</span><br></pre></td></tr></table></figure>
<p><meta name="referrer" content="no-referrer"><br><img src="/python-seaborn/%E6%95%A3%E7%82%B9%E5%9B%BEswarm.png" class title="散点图swarm"></p>
<h3 id="小提琴图violin"><a href="#小提琴图violin" class="headerlink" title="小提琴图violin"></a>小提琴图violin</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 绘制violin（小提琴图）：</span></span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"></span><br><span class="line">tips = sns.load_dataset(<span class="string">"tips"</span>)</span><br><span class="line">%matplotlib inline</span><br><span class="line">sns.catplot(x=<span class="string">"day"</span>, y=<span class="string">"total_bill"</span>, hue=<span class="string">"smoker"</span>,</span><br><span class="line">           data=tips, kind=<span class="string">"violin"</span>)</span><br></pre></td></tr></table></figure>
<p><meta name="referrer" content="no-referrer"><br><img src="/python-seaborn/%E5%B0%8F%E6%8F%90%E7%90%B4%E5%9B%BE.png" class title="小提琴图"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 参数split为真，表示</span></span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"></span><br><span class="line">tips = sns.load_dataset(<span class="string">"tips"</span>)</span><br><span class="line">%matplotlib inline</span><br><span class="line">sns.catplot(x=<span class="string">"day"</span>, y=<span class="string">"total_bill"</span>, hue=<span class="string">"smoker"</span>,</span><br><span class="line">           data=tips, kind=<span class="string">"violin"</span>, split=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<p><meta name="referrer" content="no-referrer"><br><img src="/python-seaborn/%E5%B0%8F%E6%8F%90%E7%90%B4%E5%9B%BEsplit.png" class title="小提琴图split"></p>
<h3 id="箱线图box"><a href="#箱线图box" class="headerlink" title="箱线图box"></a>箱线图box</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## catplot绘制box（箱线图）：</span></span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"></span><br><span class="line">tips = sns.load_dataset(<span class="string">"tips"</span>)</span><br><span class="line">%matplotlib inline</span><br><span class="line">sns.catplot(x=<span class="string">"day"</span>, y=<span class="string">"total_bill"</span>, hue=<span class="string">"smoker"</span>,</span><br><span class="line">           data=tips, kind=<span class="string">"box"</span>)</span><br></pre></td></tr></table></figure>
<p><meta name="referrer" content="no-referrer"><br><img src="/python-seaborn/%E7%AE%B1%E7%BA%BF%E5%9B%BE.png" class title="箱线图"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## catplot绘制boxen（增强箱型图/箱线图）：</span></span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"></span><br><span class="line">tips = sns.load_dataset(<span class="string">"tips"</span>)</span><br><span class="line">%matplotlib inline</span><br><span class="line">sns.catplot(x=<span class="string">"day"</span>, y=<span class="string">"total_bill"</span>, hue=<span class="string">"smoker"</span>,</span><br><span class="line">           data=tips, kind=<span class="string">"boxen"</span>)</span><br></pre></td></tr></table></figure>
<p><meta name="referrer" content="no-referrer"><br><img src="/python-seaborn/%E5%A2%9E%E5%BC%BA%E7%AE%B1%E7%BA%BF%E5%9B%BE.png" class title="增强箱线图"></p>
<h2 id="distplot"><a href="#distplot" class="headerlink" title="distplot()"></a>distplot()</h2><p><code>distplot()</code> ：数据集分布图（distribution）。</p>
<p><code>distplot(a, bins=None, hist=True, kde=True, rug=False, 
    fit=None, hist_kws=None, kde_kws=None, rug_kws=None, 
    fit_kws=None, color=None, vertical=False, 
    norm_hist=False, axlabel=None, label=None, ax=None)</code></p>
<ul>
<li><code>distplot</code>是hist（直方图）、rugplot（地毯图）、kdeplot（核密度估计图）的高级封装。</li>
<li>参数<code>fit</code> ：指定拟合相应的分布（可缺省）。</li>
</ul>
<h3 id="直方图"><a href="#直方图" class="headerlink" title="直方图"></a>直方图</h3><h3 id="地毯图"><a href="#地毯图" class="headerlink" title="地毯图"></a>地毯图</h3><h3 id="核密度估计图"><a href="#核密度估计图" class="headerlink" title="核密度估计图"></a>核密度估计图</h3><h2 id="lmplot"><a href="#lmplot" class="headerlink" title="lmplot()"></a>lmplot()</h2><p><code>lmplot()</code> ：回归曲线图。<br><code>lmplot(x, y, data, hue=None, col=None, row=None,
    palette=None, col_wrap=None, height=5, aspect=1, 
    markers=&#39;o&#39;, sharex=True, sharey=True, hue_order=None, 
    col_order=None, row_order=None, legend=True, 
    legend_out=True, x_estimator=None, x_bins=None, 
    x_ci=&#39;ci&#39;, scatter=True, fit_reg=True, ci=95, 
    n_boot=1000, units=None, order=1, logistic=False, 
    lowess=False, robust=False, logx=False, 
    x_partial=None, y_partial=None, truncate=False, 
    x_jitter=None, y_jitter=None, scatter_kws=None, 
    line_kws=None, size=None)</code></p>
<ul>
<li>与<code>regplot()</code>的区别是：<code>lmplot()</code>必须指定<code>data</code>参数</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 使用数据tips绘制回归拟合曲线图并绘制置信区间：</span></span><br><span class="line">tips = sns.load_dataset(<span class="string">"tips"</span>)</span><br><span class="line"></span><br><span class="line">sns.lmplot(x=<span class="string">"total_bill"</span>, y=<span class="string">"tip"</span>, col=<span class="string">"time"</span>, hue=<span class="string">"smoker"</span>,</span><br><span class="line">           data=tips)</span><br></pre></td></tr></table></figure>
<h2 id="relplot"><a href="#relplot" class="headerlink" title="relplot()"></a>relplot()</h2><p><code>relplot()</code> ：可视化变量间的关系（relationship）。可绘制散点图和曲线图。</p>
<ul>
<li>参数 <code>hue</code> ：分组变量</li>
<li>参数 <code>style</code> ：在某一维度上，用线的不同表现形式区分</li>
<li>参数 <code>size</code> ：控制数据点的大小或线条的粗细</li>
<li>参数 <code>facet_kws</code>：设置坐标是否共享</li>
</ul>
<h3 id="散点图"><a href="#散点图" class="headerlink" title="散点图"></a>散点图</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">relplot(x=<span class="literal">None</span>, y=<span class="literal">None</span>, hue=<span class="literal">None</span>, size=<span class="literal">None</span>, style=<span class="literal">None</span>, </span><br><span class="line"> data=<span class="literal">None</span>, row=<span class="literal">None</span>, col=<span class="literal">None</span>, col_wrap=<span class="literal">None</span>, </span><br><span class="line"> row_order=<span class="literal">None</span>, col_order=<span class="literal">None</span>, palette=<span class="literal">None</span>, hue_order=<span class="literal">None</span>,</span><br><span class="line"> hue_norm=<span class="literal">None</span>, sizes=<span class="literal">None</span>, size_order=<span class="literal">None</span>, size_norm=<span class="literal">None</span>, </span><br><span class="line">    markers=<span class="literal">None</span>, dashes=<span class="literal">None</span>, style_order=<span class="literal">None</span>, legend=<span class="string">'brief'</span>,</span><br><span class="line">    kind=<span class="string">'scatter'</span>,      <span class="comment">## 散点图</span></span><br><span class="line">    height=<span class="number">5</span>, aspect=<span class="number">1</span>, facet_kws=<span class="literal">None</span>, **kwargs)</span><br></pre></td></tr></table></figure>
<h3 id="曲线图"><a href="#曲线图" class="headerlink" title="曲线图"></a>曲线图</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">relplot(x=<span class="literal">None</span>, y=<span class="literal">None</span>, hue=<span class="literal">None</span>, size=<span class="literal">None</span>, style=<span class="literal">None</span>, </span><br><span class="line"> data=<span class="literal">None</span>, row=<span class="literal">None</span>, col=<span class="literal">None</span>, col_wrap=<span class="literal">None</span>, </span><br><span class="line"> row_order=<span class="literal">None</span>, col_order=<span class="literal">None</span>, palette=<span class="literal">None</span>, hue_order=<span class="literal">None</span>, </span><br><span class="line"> hue_norm=<span class="literal">None</span>, sizes=<span class="literal">None</span>, size_order=<span class="literal">None</span>, size_norm=<span class="literal">None</span>, </span><br><span class="line">    markers=<span class="literal">None</span>, dashes=<span class="literal">None</span>, style_order=<span class="literal">None</span>, legend=<span class="string">'brief'</span>, </span><br><span class="line">    kind=<span class="string">'line'</span>,        <span class="comment">## 曲线图</span></span><br><span class="line">    height=<span class="number">5</span>, aspect=<span class="number">1</span>, facet_kws=<span class="literal">None</span>, **kwargs)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 使用数据dots绘制曲线图：</span></span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"></span><br><span class="line">dots = sns.load_dataset(<span class="string">"dots"</span>)</span><br><span class="line">dots.head()</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sns.relplot(x=<span class="string">"time"</span>, y=<span class="string">"firing_rate"</span>, col=<span class="string">"align"</span>,</span><br><span class="line">           hue=<span class="string">"choice"</span>, size=<span class="string">"coherence"</span>, style=<span class="string">"choice"</span>,</span><br><span class="line">           facet_kws=dict(sharex=<span class="literal">False</span>), kind=<span class="string">"line"</span>,</span><br><span class="line">           legend=<span class="string">"full"</span>, data=dots)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sns.relplot(x=<span class="string">"time"</span>, y=<span class="string">"firing_rate"</span>, col=<span class="string">"align"</span>,</span><br><span class="line">            hue=<span class="string">"choice"</span>, size=<span class="string">"coherence"</span>, style=<span class="string">"choice"</span>,</span><br><span class="line">            height=<span class="number">4.5</span>, aspect=<span class="number">2</span> / <span class="number">3</span>,</span><br><span class="line">            facet_kws=dict(sharex=<span class="literal">False</span>),</span><br><span class="line">            kind=<span class="string">"line"</span>, legend=<span class="string">"full"</span>, data=dots)</span><br><span class="line"><span class="comment">##参数aspect控制横纵比</span></span><br><span class="line"><span class="comment">##参数facet_kws设置坐标是否共享</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 使用数据fmri绘制曲线图，并且绘制置信区间：</span></span><br><span class="line">fmri = sns.load_dataset(<span class="string">"fmri"</span>)</span><br><span class="line">sns.relplot(x=<span class="string">"timepoint"</span>, y=<span class="string">"signal"</span>, col=<span class="string">"region"</span>,</span><br><span class="line">            hue=<span class="string">"event"</span>, style=<span class="string">"event"</span>,</span><br><span class="line">            kind=<span class="string">"line"</span>, data=fmri);</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sns.relplot(x=<span class="string">"total_bill"</span>, y=<span class="string">"tip"</span>, col=<span class="string">"time"</span>,</span><br><span class="line">            hue=<span class="string">"size"</span>, style=<span class="string">"smoker"</span>, size=<span class="string">"size"</span>,</span><br><span class="line">            palette=<span class="string">"YlGnBu"</span>, markers=[<span class="string">"D"</span>, <span class="string">"o"</span>], sizes=(<span class="number">10</span>, <span class="number">125</span>),</span><br><span class="line">            edgecolor=<span class="string">".2"</span>, linewidth=<span class="number">.5</span>, alpha=<span class="number">.75</span>,</span><br><span class="line">            data=tips)</span><br></pre></td></tr></table></figure>
<h1 id="其他绘图函数"><a href="#其他绘图函数" class="headerlink" title="其他绘图函数"></a>其他绘图函数</h1><h2 id="FacetGrid"><a href="#FacetGrid" class="headerlink" title="FacetGrid()"></a>FacetGrid()</h2><p>绘制分面图</p>
<ul>
<li>可与绘图函数、<code>map()</code>函数结合使用</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## http://seaborn.pydata.org/examples/many_facets.html</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">sns.set_theme(style=<span class="string">"ticks"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">## 使用随机游走（random walk）创建数据</span></span><br><span class="line">rs = np.random.RandomState(<span class="number">4</span>)</span><br><span class="line">pos = rs.randint(<span class="number">-1</span>, <span class="number">2</span>, (<span class="number">20</span>, <span class="number">5</span>)).cumsum(axis=<span class="number">1</span>)  <span class="comment">## 生成-1到2之间的维度为20*5的数据</span></span><br><span class="line">pos -= pos[:, <span class="number">0</span>, np.newaxis]</span><br><span class="line">step = np.tile(range(<span class="number">5</span>), <span class="number">20</span>)    <span class="comment">## 在列方向上重复[0, 1, 2, 3, 4]20次，行方向默认1次</span></span><br><span class="line">walk = np.repeat(range(<span class="number">20</span>), <span class="number">5</span>)  <span class="comment">## 将[0, 1, ..., 19]重复5次</span></span><br><span class="line">df = pd.DataFrame(np.c_[pos.flat, step, walk],</span><br><span class="line">                  columns=[<span class="string">"position"</span>, <span class="string">"step"</span>, <span class="string">"walk"</span>])</span><br><span class="line">df.head()</span><br><span class="line"><span class="comment">#  position step walk</span></span><br><span class="line"><span class="comment"># 0 0   0  0</span></span><br><span class="line"><span class="comment"># 1 1   1  0</span></span><br><span class="line"><span class="comment"># 2 1   2  0</span></span><br><span class="line"><span class="comment"># 3 1   3  0</span></span><br><span class="line"><span class="comment"># 4 0   4  0</span></span><br><span class="line"></span><br><span class="line">grid = sns.FacetGrid(df, col=<span class="string">"walk"</span>, hue=<span class="string">"walk"</span>, palette=<span class="string">"tab20c"</span>,</span><br><span class="line">                     col_wrap=<span class="number">4</span>, height=<span class="number">1.5</span>)  <span class="comment">## col_wrap列维度限制</span></span><br><span class="line">grid.map(plt.axhline, y=<span class="number">0</span>, ls=<span class="string">":"</span>, c=<span class="string">".5"</span>)</span><br><span class="line"><span class="comment">## plt.axhline：绘制平行于x轴的水平参考线</span></span><br><span class="line"><span class="comment">## ls参数：linestyle</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 绘制折线图，展示随机游走的路径</span></span><br><span class="line">grid.map(plt.plot, <span class="string">"step"</span>, <span class="string">"position"</span>, marker=<span class="string">"o"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">## 调整x轴刻度、y轴刻度，x轴、y轴坐标轴取值范围</span></span><br><span class="line">grid.set(xticks=np.arange(<span class="number">5</span>), yticks=[<span class="number">-3</span>, <span class="number">3</span>],</span><br><span class="line">         xlim=(<span class="number">-.5</span>, <span class="number">4.5</span>), ylim=(<span class="number">-3.5</span>, <span class="number">3.5</span>))</span><br><span class="line"></span><br><span class="line">grid.fig.tight_layout(w_pad=<span class="number">1</span>)</span><br><span class="line">grid.savefig(<span class="string">'分面折线图.png'</span>, dpi=<span class="number">400</span>)</span><br></pre></td></tr></table></figure>
<p><meta name="referrer" content="no-referrer"><br><img src="/python-seaborn/%E5%88%86%E9%9D%A2%E6%8A%98%E7%BA%BF%E5%9B%BE.png" class title="分面折线图"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"></span><br><span class="line">tips = sns.load_dataset(<span class="string">"tips"</span>)  <span class="comment">## 载入数据</span></span><br><span class="line">g = sns.FacetGrid(tips, col=<span class="string">"day"</span>, height=<span class="number">4</span>, aspect=<span class="number">.5</span>)   <span class="comment">## 以day为分面的列</span></span><br><span class="line">g.map(sns.barplot, <span class="string">"sex"</span>, <span class="string">"total_bill"</span>, order=[<span class="string">"Male"</span>, <span class="string">"Female"</span>])  <span class="comment">## 绘制直方图</span></span><br><span class="line">g.savefig(<span class="string">'分面直方图.png'</span>, dpi=<span class="number">400</span>)</span><br></pre></td></tr></table></figure>
<p><meta name="referrer" content="no-referrer"><br><img src="/python-seaborn/%E5%88%86%E9%9D%A2%E7%9B%B4%E6%96%B9%E5%9B%BE.png" class title="分面直方图"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## http://seaborn.pydata.org/examples/kde_ridgeplot.html</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">sns.set_theme(style=<span class="string">"white"</span>, rc=&#123;<span class="string">"axes.facecolor"</span>: (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构造数据</span></span><br><span class="line">rs = np.random.RandomState(<span class="number">2021</span>)</span><br><span class="line">x = rs.randn(<span class="number">500</span>)  <span class="comment">## 随机生成500个数据</span></span><br><span class="line">g = np.tile(list(<span class="string">"ABCDEFGHIJ"</span>), <span class="number">50</span>)  <span class="comment">## 按列重复[A,B,...,I,J]50次</span></span><br><span class="line">df = pd.DataFrame(dict(x=x, g=g))</span><br><span class="line">m = df.g.map(ord)</span><br><span class="line">df[<span class="string">"x"</span>] += m</span><br><span class="line">df.head()</span><br><span class="line"><span class="comment">#  x   g</span></span><br><span class="line"><span class="comment"># 0 66.488609 A</span></span><br><span class="line"><span class="comment"># 1 66.676011 B</span></span><br><span class="line"><span class="comment"># 2 66.581549 C</span></span><br><span class="line"><span class="comment"># 3 67.193479 D</span></span><br><span class="line"><span class="comment"># 4 69.555876 E</span></span><br><span class="line"></span><br><span class="line">pal = sns.cubehelix_palette(n_colors=<span class="number">10</span>, rot=<span class="number">-.25</span>, light=<span class="number">.7</span>)  <span class="comment">## 生成序列调色盘；light：最浅颜色的强度</span></span><br><span class="line">pp = sns.FacetGrid(df, row=<span class="string">"g"</span>, hue=<span class="string">"g"</span>, aspect=<span class="number">15</span>, height=<span class="number">.5</span>, palette=pal)</span><br><span class="line">pp.map(sns.kdeplot, <span class="string">"x"</span>,</span><br><span class="line">       bw_adjust=<span class="number">.5</span>, clip_on=<span class="literal">False</span>,</span><br><span class="line">       fill=<span class="literal">True</span>, alpha=<span class="number">1</span>, linewidth=<span class="number">1.5</span>)</span><br><span class="line">pp.map(sns.kdeplot, <span class="string">"x"</span>, clip_on=<span class="literal">False</span>, color=<span class="string">"w"</span>, lw=<span class="number">2</span>, bw_adjust=<span class="number">.5</span>)</span><br><span class="line">pp.map(plt.axhline, y=<span class="number">0</span>, lw=<span class="number">2</span>, clip_on=<span class="literal">False</span>)  <span class="comment">## plt.axhline：绘制平行于x轴的水平参考线</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">label</span><span class="params">(x, color, label)</span>:</span>  <span class="comment">## 用于添加x轴刻度文本</span></span><br><span class="line">    ax = plt.gca()</span><br><span class="line">    ax.text(<span class="number">0</span>, <span class="number">.2</span>, label, fontweight=<span class="string">"bold"</span>, color=color,</span><br><span class="line">            ha=<span class="string">"left"</span>, va=<span class="string">"center"</span>, transform=ax.transAxes)</span><br><span class="line"></span><br><span class="line">pp.map(label, <span class="string">"x"</span>)</span><br><span class="line"></span><br><span class="line">pp.fig.subplots_adjust(hspace=<span class="number">-.25</span>)  <span class="comment">## 调整子图以重叠</span></span><br><span class="line">pp.set_titles(<span class="string">""</span>)  <span class="comment">## 去除轴标题</span></span><br><span class="line">pp.set(yticks=[])  <span class="comment">## 去除y轴刻度线</span></span><br><span class="line">pp.despine(bottom=<span class="literal">True</span>, left=<span class="literal">True</span>)  <span class="comment">## 去除底部、左边的坐标脊</span></span><br><span class="line">pp.savefig(<span class="string">'重叠分面密度曲线图.png'</span>, dpi=<span class="number">400</span>)</span><br></pre></td></tr></table></figure>
<p><meta name="referrer" content="no-referrer"><br><img src="/python-seaborn/%E9%87%8D%E5%8F%A0%E5%88%86%E9%9D%A2%E5%AF%86%E5%BA%A6%E6%9B%B2%E7%BA%BF%E5%9B%BE.png" class title="重叠分面密度曲线图"></p>
<h2 id="heatmap"><a href="#heatmap" class="headerlink" title="heatmap()"></a>heatmap()</h2><p>绘制热力图。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> string <span class="keyword">import</span> ascii_letters</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment">## 生成数据</span></span><br><span class="line">rs = np.random.RandomState(<span class="number">33</span>)</span><br><span class="line">dat = pd.DataFrame(data=rs.normal(size=(<span class="number">100</span>, <span class="number">26</span>)),</span><br><span class="line">                  columns=list(ascii_letters[<span class="number">26</span>:]))</span><br><span class="line"></span><br><span class="line"><span class="comment">## 计算相关系数矩阵</span></span><br><span class="line">corr = dat.corr()</span><br><span class="line"></span><br><span class="line">mask = np.triu(np.ones_like(corr, dtype=bool))</span><br><span class="line"></span><br><span class="line">f, ax = plt.subplots(figsize=(<span class="number">11</span>, <span class="number">9</span>))</span><br><span class="line"><span class="comment">## 设置颜色</span></span><br><span class="line">cmap = sns.diverging_palette(<span class="number">230</span>, <span class="number">20</span>, as_cmap=<span class="literal">True</span>)</span><br><span class="line">fig = sns.heatmap(corr, mask=mask, cmap=cmap, vmax=<span class="number">.3</span>, center=<span class="number">0</span>, square=<span class="literal">True</span>, </span><br><span class="line">                 linewidths=<span class="number">.5</span>, cbar_kws=&#123;<span class="string">'shrink'</span>: <span class="number">.5</span>&#125;)</span><br><span class="line">fig.savefig(<span class="string">'相关系数矩阵图.png'</span>)</span><br></pre></td></tr></table></figure></p>
<p><meta name="referrer" content="no-referrer"><br></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## http://seaborn.pydata.org/examples/spreadsheet_heatmap.html</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line">sns.set_theme()</span><br><span class="line"></span><br><span class="line">flights_long = sns.load_dataset(<span class="string">"flights"</span>)  <span class="comment">## 载入数据</span></span><br><span class="line">flights_long.head()</span><br><span class="line"><span class="comment">#  year month passengers</span></span><br><span class="line"><span class="comment"># 0 1949 Jan  112</span></span><br><span class="line"><span class="comment"># 1 1949 Feb  118</span></span><br><span class="line"><span class="comment"># 2 1949 Mar  132</span></span><br><span class="line"><span class="comment"># 3 1949 Apr  129</span></span><br><span class="line"><span class="comment"># 4 1949 May  121</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 变换数据形式</span></span><br><span class="line">flights = flights_long.pivot(<span class="string">"month"</span>, <span class="string">"year"</span>, <span class="string">"passengers"</span>)</span><br><span class="line">flights.head()</span><br><span class="line"><span class="comment"># year 1949 1950 1951 1952 1953 1954 1955 1956 1957 1958 1959 1960</span></span><br><span class="line"><span class="comment"># month            </span></span><br><span class="line"><span class="comment"># Jan 112 115 145 171 196 204 242 284 315 340 360 417</span></span><br><span class="line"><span class="comment"># Feb 118 126 150 180 196 188 233 277 301 318 342 391</span></span><br><span class="line"><span class="comment"># Mar 132 141 178 193 236 235 267 317 356 362 406 419</span></span><br><span class="line"><span class="comment"># Apr 129 135 163 181 235 227 269 313 348 348 396 461</span></span><br><span class="line"><span class="comment"># May 121 125 172 183 229 234 270 318 355 363 420 472</span></span><br><span class="line">f, ax = plt.subplots(figsize=(<span class="number">9</span>, <span class="number">6</span>))</span><br><span class="line">g = sns.heatmap(flights, annot=<span class="literal">True</span>, fmt=<span class="string">"d"</span>, linewidths=<span class="number">.5</span>, ax=ax)</span><br><span class="line">fig = g.get_figure()</span><br><span class="line">fig.savefig(<span class="string">'热力图.png'</span>, dpi=<span class="number">400</span>)</span><br></pre></td></tr></table></figure>
<p><meta name="referrer" content="no-referrer"><br><img src="/python-seaborn/%E7%83%AD%E5%8A%9B%E5%9B%BE.png" class title="热力图"></p>
<h2 id="柱状图histplot"><a href="#柱状图histplot" class="headerlink" title="柱状图histplot()"></a>柱状图histplot()</h2><p>绘制柱状图</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## http://seaborn.pydata.org/examples/histogram_stacked.html</span></span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"><span class="keyword">import</span> matplotlib <span class="keyword">as</span> mpl</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">sns.set_theme(style=<span class="string">"ticks"</span>)</span><br><span class="line"></span><br><span class="line">diamonds = sns.load_dataset(<span class="string">"diamonds"</span>)  <span class="comment">## 载入数据</span></span><br><span class="line">diamonds.head()</span><br><span class="line"><span class="comment">#  carat cut color clarity depth table price x y z</span></span><br><span class="line"><span class="comment"># 0 0.23 Ideal E SI2 61.5 55.0 326 3.95 3.98 2.43</span></span><br><span class="line"><span class="comment"># 1 0.21 Premium E SI1 59.8 61.0 326 3.89 3.84 2.31</span></span><br><span class="line"><span class="comment"># 2 0.23 Good E VS1 56.9 65.0 327 4.05 4.07 2.31</span></span><br><span class="line"><span class="comment"># 3 0.29 Premium I VS2 62.4 58.0 334 4.20 4.23 2.63</span></span><br><span class="line"><span class="comment"># 4 0.31 Good J SI2 63.3 58.0 335 4.34 4.35 2.75</span></span><br><span class="line"></span><br><span class="line">f, ax = plt.subplots(figsize=(<span class="number">7</span>, <span class="number">5</span>))</span><br><span class="line">sns.despine(f)  <span class="comment">## 移除上部、右边的坐标脊</span></span><br><span class="line"></span><br><span class="line">g = sns.histplot(</span><br><span class="line">    diamonds,</span><br><span class="line">    x=<span class="string">"price"</span>, hue=<span class="string">"cut"</span>,  <span class="comment">## 根据cut区分颜色</span></span><br><span class="line">    multiple=<span class="string">"stack"</span>,</span><br><span class="line">    palette=<span class="string">"light:m_r"</span>,   <span class="comment">## 调色盘</span></span><br><span class="line">    edgecolor=<span class="string">".3"</span>,        <span class="comment">## 柱状边的颜色</span></span><br><span class="line">    linewidth=<span class="number">.5</span>,          <span class="comment">## 线条宽度</span></span><br><span class="line">    log_scale=<span class="literal">True</span>,        <span class="comment">## Set a log scale on the data axis</span></span><br><span class="line">)</span><br><span class="line">ax.xaxis.set_major_formatter(mpl.ticker.ScalarFormatter())  <span class="comment">## 设置x轴主刻度格式</span></span><br><span class="line">ax.set_xticks([<span class="number">500</span>, <span class="number">1000</span>, <span class="number">2000</span>, <span class="number">5000</span>, <span class="number">10000</span>])  <span class="comment">## 设置x轴刻度文本</span></span><br><span class="line"></span><br><span class="line">fig = g.get_figure()</span><br><span class="line">fig.savefig(<span class="string">'柱状图.png'</span>, dpi=<span class="number">400</span>)</span><br></pre></td></tr></table></figure>
<p><meta name="referrer" content="no-referrer"><br><img src="/python-seaborn/%E6%9F%B1%E7%8A%B6%E5%9B%BE.png" class title="柱状图"></p>
<h2 id="JointGrid"><a href="#JointGrid" class="headerlink" title="JointGrid()"></a>JointGrid()</h2><p>两个变量的关系+单变量边际分布</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## http://seaborn.pydata.org/examples/marginal_ticks.html</span></span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line">sns.set_theme(style=<span class="string">"white"</span>, color_codes=<span class="literal">True</span>)  <span class="comment">## 设置主题</span></span><br><span class="line">mpg = sns.load_dataset(<span class="string">"mpg"</span>)  <span class="comment">## 载入数据mpg</span></span><br><span class="line">mpg.head()</span><br><span class="line"><span class="comment">#  mpg cylinders displacement horsepower weight acceleration model_year origin name</span></span><br><span class="line"><span class="comment"># 0 18.0 8 307.0 130.0 3504 12.0 70 usa chevrolet chevelle malibu</span></span><br><span class="line"><span class="comment"># 1 15.0 8 350.0 165.0 3693 11.5 70 usa buick skylark 320</span></span><br><span class="line"><span class="comment"># 2 18.0 8 318.0 150.0 3436 11.0 70 usa plymouth satellite</span></span><br><span class="line"><span class="comment"># 3 16.0 8 304.0 150.0 3433 12.0 70 usa amc rebel sst</span></span><br><span class="line"><span class="comment"># 4 17.0 8 302.0 140.0 3449 10.5 70 usa ford torino</span></span><br><span class="line"></span><br><span class="line">g = sns.JointGrid(data=mpg, x=<span class="string">"mpg"</span>, y=<span class="string">"acceleration"</span>, space=<span class="number">0</span>, ratio=<span class="number">17</span>)</span><br><span class="line">g.plot_joint(sns.scatterplot, size=mpg[<span class="string">"horsepower"</span>], sizes=(<span class="number">30</span>, <span class="number">120</span>),  <span class="comment">## 根据horsepower调整散点的大小</span></span><br><span class="line">             color=<span class="string">"g"</span>, alpha=<span class="number">.6</span>, legend=<span class="literal">False</span>)</span><br><span class="line">g.savefig(<span class="string">'0104散点图.png'</span>, dpi=<span class="number">400</span>)</span><br></pre></td></tr></table></figure>
<p><meta name="referrer" content="no-referrer"><br><img src="/python-seaborn/0104%E6%95%A3%E7%82%B9%E5%9B%BE.png" class title="散点图"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">g = sns.JointGrid(data=mpg, x=<span class="string">"mpg"</span>, y=<span class="string">"acceleration"</span>, space=<span class="number">0</span>, ratio=<span class="number">17</span>)</span><br><span class="line">g.plot_joint(sns.scatterplot, size=mpg[<span class="string">"horsepower"</span>], sizes=(<span class="number">30</span>, <span class="number">120</span>),</span><br><span class="line">             color=<span class="string">"g"</span>, alpha=<span class="number">.6</span>, legend=<span class="literal">False</span>)</span><br><span class="line">g.plot_marginals(sns.rugplot, height=<span class="number">1</span>, color=<span class="string">"g"</span>, alpha=<span class="number">.6</span>)</span><br><span class="line">g.savefig(<span class="string">'散点图+刻度线.png'</span>, dpi=<span class="number">400</span>)</span><br></pre></td></tr></table></figure>
<p><meta name="referrer" content="no-referrer"><br><img src="/python-seaborn/%E6%95%A3%E7%82%B9%E5%9B%BE+%E5%88%BB%E5%BA%A6%E7%BA%BF.png" class title="散点图+刻度线"></p>
<h2 id="jointplot"><a href="#jointplot" class="headerlink" title="jointplot()"></a>jointplot()</h2><p>在图形边上绘制单变量的直方分布图</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## http://seaborn.pydata.org/examples/regression_marginals.html</span></span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line">sns.set_theme(style=<span class="string">"darkgrid"</span>)  <span class="comment">## 设置主题</span></span><br><span class="line"></span><br><span class="line">tips = sns.load_dataset(<span class="string">"tips"</span>)  <span class="comment">## 载入数据 tips</span></span><br><span class="line">g = sns.jointplot(x=<span class="string">"total_bill"</span>, y=<span class="string">"tip"</span>, data=tips,</span><br><span class="line">                  kind=<span class="string">"reg"</span>, truncate=<span class="literal">False</span>,  <span class="comment">## 画回归线</span></span><br><span class="line">                  xlim=(<span class="number">0</span>, <span class="number">60</span>), ylim=(<span class="number">0</span>, <span class="number">12</span>),</span><br><span class="line">                  color=<span class="string">"m"</span>, height=<span class="number">7</span>)</span><br><span class="line">g.savefig(<span class="string">'jointplot边际直方分布图.png'</span>, dpi=<span class="number">400</span>)</span><br></pre></td></tr></table></figure>
<p><meta name="referrer" content="no-referrer"><br><img src="/python-seaborn/jointplot%E8%BE%B9%E9%99%85%E7%9B%B4%E6%96%B9%E5%88%86%E5%B8%83%E5%9B%BE.png" class title="jointplot边际直方分布图"></p>
<h2 id="核密度估计图kdeplot"><a href="#核密度估计图kdeplot" class="headerlink" title="核密度估计图kdeplot()"></a>核密度估计图kdeplot()</h2><p>核密度估计图</p>
<ul>
<li>可以比较直观地看出数据样本本身的分布特征</li>
<li>参数<code>cumulative</code>：是否绘制累积分布，默认False</li>
<li>参数<code>shade</code>：是否绘制曲线下的阴影区域</li>
<li>参数<code>color</code>：控制曲线、阴影的颜色（曲线颜色比阴影颜色深）</li>
<li>参数<code>vertical</code>：以X轴进行绘制还是以Y轴进行绘制（已弃用），将数据赋给<code>y</code>即可</li>
<li>参数<code>cbar</code>：当绘制二维核密度估计图且<code>shade=True</code>时，令<code>cbar=True</code>则图片显示色阶</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns </span><br><span class="line"></span><br><span class="line">x=np.random.randn(<span class="number">100</span>)  <span class="comment">#随机生成100个符合正态分布的数</span></span><br><span class="line">g = sns.kdeplot(x)  <span class="comment">## 简单的一维核密度估计图</span></span><br><span class="line">fig = g.get_figure()</span><br><span class="line">fig.savefig(<span class="string">'简单的一维核密度估计图.png'</span>, dpi=<span class="number">400</span>)</span><br></pre></td></tr></table></figure>
<p><meta name="referrer" content="no-referrer"><br><img src="/python-seaborn/%E7%AE%80%E5%8D%95%E7%9A%84%E4%B8%80%E7%BB%B4%E6%A0%B8%E5%AF%86%E5%BA%A6%E4%BC%B0%E8%AE%A1%E5%9B%BE.png" class title="简单的一维核密度估计图"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">g = sns.kdeplot(x, cumulative=<span class="literal">True</span>)</span><br><span class="line">fig = g.get_figure()</span><br><span class="line">fig.savefig(<span class="string">'一维核密度估计累积图.png'</span>, dpi=<span class="number">400</span>)</span><br></pre></td></tr></table></figure>
<p><meta name="referrer" content="no-referrer"><br><img src="/python-seaborn/%E4%B8%80%E7%BB%B4%E6%A0%B8%E5%AF%86%E5%BA%A6%E4%BC%B0%E8%AE%A1%E7%B4%AF%E7%A7%AF%E5%9B%BE.png" class title="一维核密度估计累积图"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">g = sns.kdeplot(x, shade=<span class="literal">True</span>, color=<span class="string">'g'</span>)  <span class="comment">## 颜色为绿色 green</span></span><br><span class="line">fig = g.get_figure()</span><br><span class="line">fig.savefig(<span class="string">'一维核密度估计图-绘制阴影.png'</span>, dpi=<span class="number">400</span>)</span><br></pre></td></tr></table></figure>
<p><meta name="referrer" content="no-referrer"><br><img src="/python-seaborn/%E4%B8%80%E7%BB%B4%E6%A0%B8%E5%AF%86%E5%BA%A6%E4%BC%B0%E8%AE%A1%E5%9B%BE-%E7%BB%98%E5%88%B6%E9%98%B4%E5%BD%B1.png" class title="一维核密度估计图-绘制阴影"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">g = sns.kdeplot(y=x)  <span class="comment">## 以y轴进行绘制</span></span><br><span class="line">fig = g.get_figure()</span><br><span class="line">fig.savefig(<span class="string">'一维核密度估计图-以y轴进行绘制.png'</span>, dpi=<span class="number">400</span>)</span><br></pre></td></tr></table></figure>
<p><meta name="referrer" content="no-referrer"><br><img src="/python-seaborn/%E4%B8%80%E7%BB%B4%E6%A0%B8%E5%AF%86%E5%BA%A6%E4%BC%B0%E8%AE%A1%E5%9B%BE-%E4%BB%A5y%E8%BD%B4%E8%BF%9B%E8%A1%8C%E7%BB%98%E5%88%B6.png" class title="一维核密度估计图-以y轴进行绘制"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = np.random.randn(<span class="number">100</span>)</span><br><span class="line">y = np.random.randn(<span class="number">100</span>)</span><br><span class="line">g = sns.kdeplot(x, y, shade=<span class="literal">True</span>, cbar=<span class="literal">True</span>)</span><br><span class="line">fig = g.get_figure()</span><br><span class="line">fig.savefig(<span class="string">'二维核密度估计图.png'</span>, dpi=<span class="number">400</span>)</span><br></pre></td></tr></table></figure>
<p><meta name="referrer" content="no-referrer"><br><img src="/python-seaborn/%E4%BA%8C%E7%BB%B4%E6%A0%B8%E5%AF%86%E5%BA%A6%E4%BC%B0%E8%AE%A1%E5%9B%BE.png" class title="二维核密度估计图"></p>
<h2 id="lineplot"><a href="#lineplot" class="headerlink" title="lineplot()"></a>lineplot()</h2><p>绘制曲线图</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## http://seaborn.pydata.org/examples/wide_data_lineplot.html</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line">sns.set_theme(style=<span class="string">"whitegrid"</span>)</span><br><span class="line"></span><br><span class="line">rs = np.random.RandomState(<span class="number">365</span>)</span><br><span class="line">values = rs.randn(<span class="number">365</span>, <span class="number">4</span>).cumsum(axis=<span class="number">0</span>)  <span class="comment">## 随机生成365*4的数据</span></span><br><span class="line">dates = pd.date_range(<span class="string">"1 1 2020"</span>, periods=<span class="number">365</span>, freq=<span class="string">"D"</span>)  <span class="comment">## 从2020.01.01开始、按天分配日期</span></span><br><span class="line">data = pd.DataFrame(values, dates, columns=[<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>, <span class="string">"D"</span>])</span><br><span class="line">data.head()</span><br><span class="line"><span class="comment">#     A   B   C   D</span></span><br><span class="line"><span class="comment"># 2020-01-01 0.167921 0.523505 0.817376 1.703846</span></span><br><span class="line"><span class="comment"># 2020-01-02 -1.979026 1.237704 0.057230 2.743267</span></span><br><span class="line"><span class="comment"># 2020-01-03 -2.945478 1.094025 1.628355 2.359988</span></span><br><span class="line"><span class="comment"># 2020-01-04 -2.307479 0.749367 1.624072 2.518347</span></span><br><span class="line"><span class="comment"># 2020-01-05 -3.270573 0.333310 1.867085 2.866550</span></span><br><span class="line">data = data.rolling(<span class="number">7</span>).mean()</span><br><span class="line">g = sns.lineplot(data=data, palette=<span class="string">"tab10"</span>, linewidth=<span class="number">2.5</span>)</span><br><span class="line">fig = g.get_figure()</span><br><span class="line">fig.savefig(<span class="string">'线形图.png'</span>, dpi=<span class="number">400</span>)</span><br></pre></td></tr></table></figure>
<p><meta name="referrer" content="no-referrer"><br><img src="/python-seaborn/%E7%BA%BF%E5%BD%A2%E5%9B%BE.png" class title="线形图"></p>
<h2 id="pairplot"><a href="#pairplot" class="headerlink" title="pairplot()"></a>pairplot()</h2><p>绘制变量两两之间的散点图</p>
<ul>
<li>对角线绘制变量的分布图</li>
<li>非对角线绘制两两变量的散点图</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## http://seaborn.pydata.org/examples/scatterplot_matrix.html</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">url = <span class="string">'https://raw.githubusercontent.com/mwaskom/seaborn-data/master/penguins.csv'</span></span><br><span class="line"></span><br><span class="line">df = pd.read_csv(url, error_bad_lines=<span class="literal">False</span>)  <span class="comment">## 加载penguins数据</span></span><br><span class="line">df.head()</span><br><span class="line"><span class="comment">#  species island bill_length_mm bill_depth_mm flipper_length_mm body_mass_g sex</span></span><br><span class="line"><span class="comment"># 0 Adelie Torgersen 39.1 18.7 181.0 3750.0 MALE</span></span><br><span class="line"><span class="comment"># 1 Adelie Torgersen 39.5 17.4 186.0 3800.0 FEMALE</span></span><br><span class="line"><span class="comment"># 2 Adelie Torgersen 40.3 18.0 195.0 3250.0 FEMALE</span></span><br><span class="line"><span class="comment"># 3 Adelie Torgersen NaN NaN NaN NaN NaN</span></span><br><span class="line"><span class="comment"># 4 Adelie Torgersen 36.7 19.3 193.0 3450.0 FEMALE</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"></span><br><span class="line">sns.set_style(<span class="string">'ticks'</span>)  <span class="comment">## 设置主题；set_theme()函数已弃用</span></span><br><span class="line">fig = sns.pairplot(df, hue=<span class="string">"species"</span>)  <span class="comment">## species决定色彩</span></span><br><span class="line">fig.savefig(<span class="string">'两两配对散点图.png'</span>, dpi=<span class="number">400</span>)</span><br></pre></td></tr></table></figure>
<p><meta name="referrer" content="no-referrer"><br><img src="/python-seaborn/%E4%B8%A4%E4%B8%A4%E9%85%8D%E5%AF%B9%E6%95%A3%E7%82%B9%E5%9B%BE.png" class title="两两配对散点图"></p>
<h1 id="其他函数"><a href="#其他函数" class="headerlink" title="其他函数"></a>其他函数</h1><h2 id="axes-style"><a href="#axes-style" class="headerlink" title="axes_style()"></a>axes_style()</h2><p>坐标轴属性设置</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"></span><br><span class="line">sns.axes_style()  <span class="comment">## 查看目前的各属性定义</span></span><br><span class="line"><span class="comment"># &#123;'axes.facecolor': 'white',</span></span><br><span class="line"><span class="comment">#  'axes.edgecolor': '.15',</span></span><br><span class="line"><span class="comment">#  'axes.grid': False,</span></span><br><span class="line"><span class="comment">#  'axes.axisbelow': True,</span></span><br><span class="line"><span class="comment">#  'axes.labelcolor': '.15',   ## 轴标签颜色</span></span><br><span class="line"><span class="comment">#  'figure.facecolor': 'white',  ## 画布颜色</span></span><br><span class="line"><span class="comment">#  'grid.color': '.8',    ## 网格颜色</span></span><br><span class="line"><span class="comment">#  'grid.linestyle': '-',   ## 网格线型</span></span><br><span class="line"><span class="comment">#  'text.color': '.15',</span></span><br><span class="line"><span class="comment">#  'xtick.color': '.15',   ## x轴刻度颜色</span></span><br><span class="line"><span class="comment">#  'ytick.color': '.15',     ## y轴刻度颜色</span></span><br><span class="line"><span class="comment">#  'xtick.direction': 'out',    ## x轴刻度方向</span></span><br><span class="line"><span class="comment">#  'ytick.direction': 'out',    ## y轴刻度方向</span></span><br><span class="line"><span class="comment">#  'lines.solid_capstyle': 'round',</span></span><br><span class="line"><span class="comment">#  'patch.edgecolor': 'w',</span></span><br><span class="line"><span class="comment">#  'patch.force_edgecolor': True,</span></span><br><span class="line"><span class="comment">#  'image.cmap': 'rocket',</span></span><br><span class="line"><span class="comment">#  'font.family': ['sans-serif'],  ## 字体类型</span></span><br><span class="line"><span class="comment">#  'font.sans-serif': ['Arial',</span></span><br><span class="line"><span class="comment">#   'DejaVu Sans',</span></span><br><span class="line"><span class="comment">#   'Liberation Sans',</span></span><br><span class="line"><span class="comment">#   'Bitstream Vera Sans',</span></span><br><span class="line"><span class="comment">#   'sans-serif'],</span></span><br><span class="line"><span class="comment">#  'xtick.bottom': False,</span></span><br><span class="line"><span class="comment">#  'xtick.top': False,</span></span><br><span class="line"><span class="comment">#  'ytick.left': False,</span></span><br><span class="line"><span class="comment">#  'ytick.right': False,</span></span><br><span class="line"><span class="comment">#  'axes.spines.left': True,   ## 左边坐标脊</span></span><br><span class="line"><span class="comment">#  'axes.spines.bottom': True,  ## 底部坐标脊</span></span><br><span class="line"><span class="comment">#  'axes.spines.right': True,  ## 右边坐标脊</span></span><br><span class="line"><span class="comment">#  'axes.spines.top': True&#125;     ## 顶部坐标脊</span></span><br></pre></td></tr></table></figure>
<h2 id="despine"><a href="#despine" class="headerlink" title="despine()"></a>despine()</h2><p>去除坐标脊</p>
<ul>
<li>对<code>white</code>和<code>ticks</code>风格有效</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">sns.set_style(<span class="string">'white'</span>)</span><br><span class="line"></span><br><span class="line">f = plt.figure(figsize=(<span class="number">6</span>, <span class="number">4</span>))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sinplot</span><span class="params">(flip=<span class="number">1</span>)</span>:</span></span><br><span class="line">    x = np.linspace(<span class="number">0</span>, <span class="number">14</span>, <span class="number">100</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">7</span>):</span><br><span class="line">        plt.plot(x, np.sin(x + i * <span class="number">.5</span>) * (<span class="number">7</span> - i) * flip)</span><br><span class="line"></span><br><span class="line">sinplot()</span><br><span class="line">sns.despine()</span><br><span class="line">f.savefig(<span class="string">'去除坐标脊.png'</span>, dpi=<span class="number">400</span>)</span><br></pre></td></tr></table></figure>
<p><meta name="referrer" content="no-referrer"><br><img src="/python-seaborn/%E5%8E%BB%E9%99%A4%E5%9D%90%E6%A0%87%E8%84%8A.png" class title="去除坐标脊"></p>
<h2 id="set-context"><a href="#set-context" class="headerlink" title="set_context()"></a>set_context()</h2><p>设置情境的size</p>
<ul>
<li>可选项：<code>paper</code>、<code>talk</code>、<code>poster</code>、<code>notebook</code></li>
<li>参数<code>font_scale</code>：控制字体的size倍数</li>
<li>参数<code>rc</code>：如<code>rc={&quot;lines.linewidth&quot;: 5.0}</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sns.set_context(<span class="string">"notebook"</span>, font_scale=<span class="number">5.0</span>, rc=&#123;<span class="string">"lines.linewidth"</span>: <span class="number">5.0</span>&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="set-theme"><a href="#set-theme" class="headerlink" title="set_theme()"></a>set_theme()</h2><p>修改主题</p>
<ul>
<li>如果提示<code>AttributeError: module &#39;seaborn&#39; has no attribute &#39;set_theme&#39;</code>，则表明当前的seaborn版本过低，应使用<code>pip install seaborn==0.11.0</code>或<code>pip install seaborn==0.11.1</code>安装0.11版本的seaborn</li>
<li>查看当前的seaborn版本：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> seaborn</span><br><span class="line">seaborn.__version__</span><br><span class="line"><span class="comment">#'0.11.0'</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="set-style"><a href="#set-style" class="headerlink" title="set_style()"></a>set_style()</h2><p>调整绘图style。</p>
<ul>
<li>第一个参数是整体风格，第二个参数是具体某个element的参数，如：<code>sns.set_style(&quot;darkgrid&quot;, {&quot;axes.facecolor&quot;: &quot;.2&quot;})</code>。可使用<code>axes_style()</code>查看目前的elements定义</li>
</ul>
<p>有5种预设的style：</p>
<ul>
<li><code>darkgrid</code></li>
<li><code>whitegrid</code></li>
<li><code>dark</code></li>
<li><code>white</code></li>
<li><code>ticks</code></li>
</ul>
<h1 id="调色板"><a href="#调色板" class="headerlink" title="调色板"></a>调色板</h1><h2 id="choose-colorbrewer-palette"><a href="#choose-colorbrewer-palette" class="headerlink" title="choose_colorbrewer_palette()"></a>choose_colorbrewer_palette()</h2><p>从Color Brewer中选择调色板。<br><code>choose_colorbrewer_palette(data_type, as_cmap=False)</code></p>
<ul>
<li>该函数只能在Jupyter Notebook中使用</li>
<li>参数 <code>data_type</code> ：可选值有’sequential’, ‘diverging’, ‘qualitative’</li>
<li>其中 <code>Set</code> 可选择不同的调色板</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sns.palplot(sns.choose_colorbrewer_palette(data_type=<span class="string">"qualitative"</span>))</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sns.palplot(sns.choose_colorbrewer_palette(data_type=<span class="string">"diverging"</span>))</span><br></pre></td></tr></table></figure>
<h2 id="choose-cubehelix-palette"><a href="#choose-cubehelix-palette" class="headerlink" title="choose_cubehelix_palette()"></a>choose_cubehelix_palette()</h2><p><code>choose_cubehelix_palette(as_cmap=False)</code></p>
<ul>
<li><code>cubehelix()</code>函数对应的交互式小部件</li>
<li>该函数只能在Jupyter Notebook中使用</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sns.palplot(sns.choose_cubehelix_palette())</span><br></pre></td></tr></table></figure>
<h2 id="choose-dark-palette"><a href="#choose-dark-palette" class="headerlink" title="choose_dark_palette()"></a>choose_dark_palette()</h2><p><code>choose_dark_palette(input=&#39;husl&#39;, as_cmap=False)</code></p>
<ul>
<li><code>dark_palette()</code>函数对应的交互式小部件</li>
<li>该函数只能在Jupyter Notebook中使用</li>
<li>参数 <code>input</code> ：可选值有<code>husl</code>, <code>hls</code>, <code>rgb</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sns.palplot(sns.choose_dark_palette())</span><br></pre></td></tr></table></figure>
<h2 id="choose-diverging-palette"><a href="#choose-diverging-palette" class="headerlink" title="choose_diverging_palette()"></a>choose_diverging_palette()</h2><p><code>choose_diverging_palette(as_cmap=False)</code></p>
<ul>
<li><code>diverging_palette()</code>函数对应的交互式小部件</li>
<li><code>center</code>部件可选择：light或dark</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sns.palplot(sns.choose_diverging_palette())</span><br></pre></td></tr></table></figure>
<h2 id="choose-light-palette"><a href="#choose-light-palette" class="headerlink" title="choose_light_palette()"></a>choose_light_palette()</h2><p><code>choose_light_palette(input=&#39;husl&#39;, as_cmap=False)</code></p>
<ul>
<li><code>light_palette()</code>函数对应的交互式小部件</li>
<li>参数 <code>input</code> ：可选值有<code>husl</code>, <code>hls</code>, <code>rgb</code></li>
<li>该函数只能在Jupyter Notebook中使用</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sns.palplot(sns.choose_light_palette())</span><br></pre></td></tr></table></figure>
<h2 id="color-palette"><a href="#color-palette" class="headerlink" title="color_palette()"></a>color_palette()</h2><p>调色板</p>
<ul>
<li>seaborn有6种不同的默认主题：deep，muted，pastel，bright，dark，colorblind</li>
<li>若有任意类别的变量，但不突出任何一个类别时，可使用连续均匀间隔的颜色。</li>
<li>分类调色板：Color Brewer</li>
<li>可见<a href="http://seaborn.pydata.org/generated/seaborn.color_palette.html#seaborn.color_palette" target="_blank" rel="noopener">seaborn.color_palette</a>，有颜色示例。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## seaborn默认调色盘</span></span><br><span class="line">current_palette = sns.color_palette()</span><br><span class="line">sns.palplot(current_palette)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 默认调色板（muted）</span></span><br><span class="line">sns.palplot(sns.color_palette(<span class="string">"muted"</span>))</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 默认调色板（deep）</span></span><br><span class="line">sns.palplot(sns.color_palette(<span class="string">"deep"</span>))</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 默认调色板（pastel）</span></span><br><span class="line">sns.palplot(sns.color_palette(<span class="string">"pastel"</span>))</span><br></pre></td></tr></table></figure>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="http://seaborn.pydata.org/" target="_blank" rel="noopener">seaborn主页</a></li>
<li><a href="http://seaborn.pydata.org/examples/index.html" target="_blank" rel="noopener">seaborn Example Gallery</a></li>
<li><a href="http://seaborn.pydata.org/examples/distplot_options.html" target="_blank" rel="noopener">displot例子</a></li>
<li><a href="http://seaborn.pydata.org/examples/anscombes_quartet.html" target="_blank" rel="noopener">lmplot例子</a></li>
<li><a href="https://blog.csdn.net/weixin_42468475/article/details/109556785" target="_blank" rel="noopener">python绘图-seaborn(sns)的主题风格</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/33977558" target="_blank" rel="noopener">Seaborn5分钟入门(一)——kdeplot和distplot</a></li>
</ul>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python | Set 集合</title>
    <url>/python-%E9%9B%86%E5%90%88.html</url>
    <content><![CDATA[<p><center></center><br><a id="more"></a></p>
<h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">set((<span class="string">"Rank"</span>))</span><br><span class="line"><span class="comment">#&#123;'R', 'a', 'k', 'n'&#125;</span></span><br><span class="line">set(<span class="string">"Rank"</span>)</span><br><span class="line"><span class="comment">#&#123;'R', 'a', 'k', 'n'&#125;</span></span><br><span class="line">set([<span class="string">"Rank"</span>])</span><br><span class="line"><span class="comment">#&#123;'Rank'&#125;</span></span><br></pre></td></tr></table></figure>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="add"><a href="#add" class="headerlink" title=".add()"></a>.add()</h2><p>往集合中添加元素<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = set([<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line">s</span><br><span class="line"><span class="comment">#&#123;1, 2, 'a', 'b'&#125;</span></span><br><span class="line"></span><br><span class="line">s.add((<span class="string">'c'</span>, <span class="string">'a'</span>))</span><br><span class="line">s</span><br><span class="line"><span class="comment">#&#123;('c', 'a'), 1, 2, 'a', 'b'&#125;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="difference"><a href="#difference" class="headerlink" title=".difference()"></a>.difference()</h2><p>求差集<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">b = &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;</span><br><span class="line">a.difference(b)</span><br><span class="line"><span class="comment">#&#123;1, 2, 3&#125;</span></span><br><span class="line"></span><br><span class="line">a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">b = &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;</span><br><span class="line">b.difference(a)</span><br><span class="line"><span class="comment">#&#123;5, 6, 7, 8&#125;</span></span><br><span class="line"></span><br><span class="line">a.difference(b) == b.difference(a)</span><br><span class="line"><span class="comment">#False</span></span><br><span class="line"></span><br><span class="line">a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line"></span><br><span class="line">b = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">a.difference(b) == b.difference(a)</span><br><span class="line"><span class="comment">#True</span></span><br></pre></td></tr></table></figure></p>
<h2 id="difference-update"><a href="#difference-update" class="headerlink" title=".difference_update()"></a>.difference_update()</h2><p>取差集，并更新原集合</p>
<ul>
<li>等价于<code>-=</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s1 = set(<span class="string">"Hello"</span>)</span><br><span class="line">s2 = set(<span class="string">"World"</span>)</span><br><span class="line">s1.difference(s2)  <span class="comment">## 不改变s1、s2</span></span><br><span class="line"><span class="comment">#&#123;'H', 'e'&#125;</span></span><br><span class="line">s1</span><br><span class="line"><span class="comment">#&#123;'H', 'e', 'l', 'o'&#125;</span></span><br><span class="line">s1.difference_update(s2)</span><br><span class="line">s1</span><br><span class="line"><span class="comment">#&#123;'H', 'e'&#125;</span></span><br><span class="line"></span><br><span class="line">s1 = set(<span class="string">"Hello"</span>)</span><br><span class="line">s2 = set(<span class="string">"World"</span>)</span><br><span class="line">s1 -= s2</span><br><span class="line">s1</span><br><span class="line"><span class="comment">#&#123;'H', 'e'&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="discard"><a href="#discard" class="headerlink" title=".discard()"></a>.discard()</h2><p>从集合中剔除元素</p>
<ul>
<li>如果元素不存在，则无变化（不会报错）<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s</span><br><span class="line"><span class="comment">#&#123;('c', 'a'), 1, 2, 3, 4, 5, 6, 7, 'a', 'b'&#125;</span></span><br><span class="line"></span><br><span class="line">s.discard(<span class="number">6</span>)</span><br><span class="line">s</span><br><span class="line"><span class="comment">#&#123;('c', 'a'), 1, 2, 3, 4, 5, 7, 'a', 'b'&#125;</span></span><br><span class="line"></span><br><span class="line">s.discard(<span class="number">8</span>) <span class="comment">## 删除不存在的元素，无事发生</span></span><br><span class="line"><span class="comment"># 没有报错</span></span><br><span class="line">s</span><br><span class="line"><span class="comment">#&#123;('c', 'a'), 1, 2, 3, 4, 5, 7, 'a', 'b'&#125;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="intersection"><a href="#intersection" class="headerlink" title=".intersection()"></a>.intersection()</h2><p>求交集</p>
<ul>
<li>等价于<code>&amp;</code></li>
<li>不改变集合本身</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">b = &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;</span><br><span class="line">a.intersection(b)</span><br><span class="line"><span class="comment">#&#123;4&#125;</span></span><br><span class="line"></span><br><span class="line">a.intersection(b) == b.intersection(a)</span><br><span class="line"><span class="comment">#True</span></span><br><span class="line"></span><br><span class="line">s = set(<span class="string">"Rank"</span>)</span><br><span class="line">s</span><br><span class="line"><span class="comment">#&#123;'R', 'a', 'k', 'n'&#125;</span></span><br><span class="line">s.intersection(<span class="string">"Hacker"</span>)</span><br><span class="line"><span class="comment">#&#123;'a', 'k'&#125;</span></span><br><span class="line"><span class="comment">## 等价于</span></span><br><span class="line">s &amp; set(<span class="string">"Hacker"</span>)</span><br><span class="line"><span class="comment">#&#123;'a', 'k'&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="intersection-update"><a href="#intersection-update" class="headerlink" title=".intersection_update()"></a>.intersection_update()</h2><ul>
<li>等价于<code>&amp;=</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s1 = set(<span class="string">"Hello"</span>)</span><br><span class="line">s2 = set(<span class="string">"World"</span>)</span><br><span class="line">s1.intersection_update(s2)</span><br><span class="line">s1</span><br><span class="line"><span class="comment">#&#123;'l', 'o'&#125;</span></span><br><span class="line"></span><br><span class="line">s1 = set(<span class="string">"Hello"</span>)</span><br><span class="line">s2 = set(<span class="string">"World"</span>)</span><br><span class="line">s1 &amp;= s2</span><br><span class="line">s1</span><br><span class="line"><span class="comment">#&#123;'l', 'o'&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="pop"><a href="#pop" class="headerlink" title=".pop()"></a>.pop()</h2><p>从集合中随意删除并返回一个元素</p>
<ul>
<li>如果集合为空，则会报错</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = set([<span class="string">'a'</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="string">'b'</span>])</span><br><span class="line">s</span><br><span class="line"><span class="comment">#&#123;1, 2, 3, 5, 'a', 'b'&#125;</span></span><br><span class="line">s.pop()</span><br><span class="line"><span class="comment">#1</span></span><br><span class="line">s</span><br><span class="line"><span class="comment">#&#123;2, 3, 5, 'a', 'b'&#125;</span></span><br><span class="line"></span><br><span class="line">s2 = set()</span><br><span class="line">s2.pop()</span><br><span class="line"><span class="comment">#KeyError: 'pop from an empty set'</span></span><br></pre></td></tr></table></figure>
<h2 id="remove"><a href="#remove" class="headerlink" title=".remove()"></a>.remove()</h2><p>从集合中剔除元素</p>
<ul>
<li>如果元素不存在，则会报错<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s</span><br><span class="line"><span class="comment">#&#123;('c', 'a'), 1, 2, 3, 4, 5, 7, 'a', 'b'&#125;</span></span><br><span class="line">s.remove(<span class="string">'b'</span>)</span><br><span class="line">s</span><br><span class="line"><span class="comment">#&#123;('c', 'a'), 1, 2, 3, 4, 5, 7, 'a'&#125;</span></span><br><span class="line"></span><br><span class="line">s.remove(<span class="number">10</span>) <span class="comment">## 删除不存在的元素，会报错</span></span><br><span class="line"><span class="comment">#KeyError: 10</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="symmetric-difference"><a href="#symmetric-difference" class="headerlink" title=".symmetric_difference()"></a>.symmetric_difference()</h2><p>对称差</p>
<ul>
<li>不改变集合本身</li>
<li>等价于<code>^</code></li>
<li><code>s1.symmetric_difference(s2)</code>等价于<code>s1 ^ s2</code> 或 <code>(s1 - s2).union(s2 - s1)</code> 或 <code>(s1 - s2) | (s2 - s1)</code> 或 <code>s2.symmetric_difference(s1)</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s1 = set(<span class="string">"Hello"</span>)</span><br><span class="line">s2 = set(<span class="string">"World"</span>)</span><br><span class="line">s1.symmetric_difference(s2)</span><br><span class="line"><span class="comment">#&#123;'H', 'W', 'd', 'e', 'r'&#125;</span></span><br><span class="line"></span><br><span class="line">s2.symmetric_difference(s1)</span><br><span class="line"><span class="comment">#&#123;'H', 'W', 'd', 'e', 'r'&#125;</span></span><br><span class="line"></span><br><span class="line">(s1 - s2).union(s2 - s1)</span><br><span class="line"><span class="comment">#&#123;'H', 'W', 'd', 'e', 'r'&#125;</span></span><br><span class="line"></span><br><span class="line">(s1 - s2) | (s2 - s1)</span><br><span class="line"><span class="comment">#&#123;'H', 'W', 'd', 'e', 'r'&#125;</span></span><br><span class="line"></span><br><span class="line">s1 ^ s2</span><br><span class="line"><span class="comment">#&#123;'H', 'W', 'd', 'e', 'r'&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="symmetric-difference-update"><a href="#symmetric-difference-update" class="headerlink" title=".symmetric_difference_update()"></a>.symmetric_difference_update()</h2><p>取对称差，并更新原集合</p>
<ul>
<li>等价于<code>^=</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s1 = set(<span class="string">"Hello"</span>)</span><br><span class="line">s2 = set(<span class="string">"World"</span>)</span><br><span class="line">s1.symmetric_difference(s2)</span><br><span class="line"><span class="comment">#&#123;'H', 'W', 'd', 'e', 'r'&#125;</span></span><br><span class="line">s1</span><br><span class="line"><span class="comment">#&#123;'H', 'e', 'l', 'o'&#125;</span></span><br><span class="line">s1.symmetric_difference_update(s2)</span><br><span class="line">s1</span><br><span class="line"><span class="comment">#&#123;'H', 'W', 'd', 'e', 'r'&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="union"><a href="#union" class="headerlink" title=".union()"></a>.union()</h2><p>合并集合</p>
<ul>
<li>等价于<code>|</code></li>
<li>不改变集合本身</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">b = &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;</span><br><span class="line">a.union(b)</span><br><span class="line"><span class="comment">#&#123;1, 2, 3, 4, 5, 6, 7, 8&#125;</span></span><br><span class="line">a</span><br><span class="line"><span class="comment">#&#123;1, 2, 3, 4&#125;</span></span><br><span class="line">b</span><br><span class="line"><span class="comment">#&#123;4, 5, 6, 7, 8&#125;</span></span><br><span class="line"></span><br><span class="line">a.union(b) == b.union(a)</span><br><span class="line"><span class="comment">#True</span></span><br><span class="line"></span><br><span class="line">set1 = set([<span class="string">'apple'</span>, <span class="string">'banana'</span>, <span class="string">'tomato'</span>])</span><br><span class="line">set2 = set([<span class="string">'banana'</span>, <span class="string">'tomato'</span>, <span class="string">'carrots'</span>])</span><br><span class="line">set1 | set2  <span class="comment">## 并集</span></span><br><span class="line"><span class="comment"># &#123;'apple', 'banana', 'carrots', 'tomato'&#125;</span></span><br><span class="line"></span><br><span class="line">s = set(<span class="string">"Rank"</span>)</span><br><span class="line">s</span><br><span class="line"><span class="comment">#&#123;'R', 'a', 'k', 'n'&#125;</span></span><br><span class="line">s.union(<span class="string">"Hello"</span>)</span><br><span class="line"><span class="comment">#&#123;'H', 'R', 'a', 'e', 'k', 'l', 'n', 'o'&#125;</span></span><br><span class="line"></span><br><span class="line">s = set(<span class="string">"Rank"</span>)</span><br><span class="line">s</span><br><span class="line"><span class="comment">#&#123;'R', 'a', 'k', 'n'&#125;</span></span><br><span class="line">s.union(enumerate([<span class="string">'H'</span>, <span class="string">'e'</span>, <span class="string">'l'</span>, <span class="string">'l'</span>, <span class="string">'o'</span>]))</span><br><span class="line"><span class="comment">#&#123;(0, 'H'), (1, 'e'), (2, 'l'), (3, 'l'), (4, 'o'), 'R', 'a', 'k', 'n'&#125;</span></span><br><span class="line"></span><br><span class="line">s = set(<span class="string">"Rank"</span>)</span><br><span class="line">s</span><br><span class="line"><span class="comment">#&#123;'R', 'a', 'k', 'n'&#125;</span></span><br><span class="line">s.union(&#123;<span class="string">"Hello"</span>:<span class="number">1</span>&#125;)</span><br><span class="line"><span class="comment">#&#123;'Hello', 'R', 'a', 'k', 'n'&#125;</span></span><br><span class="line">s.union(&#123;<span class="string">"Hello"</span>:<span class="number">2</span>&#125;)</span><br><span class="line"><span class="comment">#&#123;'Hello', 'R', 'a', 'k', 'n'&#125;</span></span><br><span class="line"></span><br><span class="line">s = set(<span class="string">"Rank"</span>)</span><br><span class="line">s</span><br><span class="line"><span class="comment">#&#123;'R', 'a', 'k', 'n'&#125;</span></span><br><span class="line">s | set(<span class="string">"Hello"</span>) <span class="comment">##等价于 s.union("Hello")</span></span><br><span class="line"><span class="comment">#&#123;'H', 'R', 'a', 'e', 'k', 'l', 'n', 'o'&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="update"><a href="#update" class="headerlink" title=".update()"></a>.update()</h2><p>批量往集合中添加元素（要求可迭代）；对集合取并集，并改变原集合</p>
<ul>
<li>等价于<code>|=</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s</span><br><span class="line"><span class="comment">#&#123;('c', 'a'), 1, 2, 'a', 'b'&#125;</span></span><br><span class="line">s.update([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>])</span><br><span class="line">s</span><br><span class="line"><span class="comment">#&#123;('c', 'a'), 1, 2, 3, 4, 5, 6, 7, 'a', 'b'&#125;</span></span><br><span class="line"></span><br><span class="line">s1 = set(<span class="string">"Hello"</span>)</span><br><span class="line">s2 = set(<span class="string">"World"</span>)</span><br><span class="line">s1.union(s2)</span><br><span class="line"><span class="comment">#&#123;'H', 'W', 'd', 'e', 'l', 'o', 'r'&#125;</span></span><br><span class="line">s1</span><br><span class="line"><span class="comment">#&#123;'H', 'e', 'l', 'o'&#125;</span></span><br><span class="line">s2</span><br><span class="line"><span class="comment">#&#123;'W', 'd', 'l', 'o', 'r'&#125;</span></span><br><span class="line">s1.update(s2)</span><br><span class="line">s1</span><br><span class="line"><span class="comment">#&#123;'H', 'W', 'd', 'e', 'l', 'o', 'r'&#125;</span></span><br><span class="line"></span><br><span class="line">s1 = set(<span class="string">"Hello"</span>)</span><br><span class="line">s2 = set(<span class="string">"World"</span>)</span><br><span class="line">s1 |= s2</span><br><span class="line">s1</span><br><span class="line"><span class="comment">#&#123;'H', 'W', 'd', 'e', 'l', 'o', 'r'&#125;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python | String 字符串</title>
    <url>/python-%E5%AD%97%E7%AC%A6%E4%B8%B2.html</url>
    <content><![CDATA[<p><center></center><br><a id="more"></a></p>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="center"><a href="#center" class="headerlink" title=".center()"></a>.center()</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">width = <span class="number">20</span></span><br><span class="line">print(<span class="string">'HackerRank'</span>.center(width,<span class="string">'-'</span>))</span><br><span class="line"><span class="comment">#-----HackerRank-----</span></span><br></pre></td></tr></table></figure>
<h2 id="endswith"><a href="#endswith" class="headerlink" title=".endswith()"></a>.endswith()</h2><p>判断字符串是否以指定字符或子字符串结尾，常用于判断文件类型<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">str1 = <span class="string">'Hello, world'</span></span><br><span class="line">str2 = <span class="string">'rld'</span></span><br><span class="line">str1.endswith(str2)  <span class="comment">## str1是否以str2结尾</span></span><br><span class="line"><span class="comment"># True</span></span><br><span class="line"></span><br><span class="line">str1.endswith(<span class="string">'wor'</span>, <span class="number">3</span>)  <span class="comment">## （从左数）从索引为3的字符开始检测是否以"wor"结尾</span></span><br><span class="line"><span class="comment"># False</span></span><br><span class="line"></span><br><span class="line">str1.endswith(<span class="string">'wor'</span>, <span class="number">3</span>, <span class="number">10</span>)  </span><br><span class="line"><span class="comment">## （从左数）从索引为3的字符开始、到索引为10(不包括10)检测是否以"wor"结尾</span></span><br><span class="line"><span class="comment">## str1中逗号后含空格（算一个字符）</span></span><br><span class="line"><span class="comment"># True</span></span><br><span class="line"></span><br><span class="line">str1.endswith((<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'d'</span>))  <span class="comment">## 匹配元组，只要有一个满足就行</span></span><br><span class="line"><span class="comment"># True</span></span><br></pre></td></tr></table></figure></p>
<h2 id="islower"><a href="#islower" class="headerlink" title=".islower()"></a>.islower()</h2><p>字符串是否都是小写字母</p>
<h2 id="isupper"><a href="#isupper" class="headerlink" title=".isupper()"></a>.isupper()</h2><p>字符串是否都是大写字母</p>
<h2 id="ljust"><a href="#ljust" class="headerlink" title=".ljust()"></a>.ljust()</h2><p>将字符串按左对齐并填充字符直到字符串达到目标长度<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">width = <span class="number">20</span></span><br><span class="line">print(<span class="string">'HackerRank'</span>.ljust(width,<span class="string">'-'</span>))</span><br><span class="line"><span class="comment">#HackerRank----------</span></span><br></pre></td></tr></table></figure></p>
<h2 id="lower"><a href="#lower" class="headerlink" title=".lower()"></a>.lower()</h2><p>将字符转换为小写</p>
<h2 id="rjust"><a href="#rjust" class="headerlink" title=".rjust()"></a>.rjust()</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">width = <span class="number">20</span></span><br><span class="line">print(<span class="string">'HackerRank'</span>.rjust(width,<span class="string">'-'</span>))</span><br><span class="line"><span class="comment">#----------HackerRank</span></span><br></pre></td></tr></table></figure>
<h2 id="str"><a href="#str" class="headerlink" title="str()"></a>str()</h2><h2 id="upper"><a href="#upper" class="headerlink" title=".upper()"></a>.upper()</h2><p>将字符转换为大写</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 将字符串s中的字母大小写互换</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">swap_case</span><span class="params">(s)</span>:</span></span><br><span class="line">    s1 = [i.upper() <span class="keyword">if</span> i.islower() <span class="keyword">else</span> i.lower() <span class="keyword">for</span> i <span class="keyword">in</span> s]</span><br><span class="line">    <span class="keyword">return</span> <span class="string">""</span>.join(s1)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python | List 列表</title>
    <url>/python-%E5%88%97%E8%A1%A8.html</url>
    <content><![CDATA[<p><center></center><br><a id="more"></a></p>
<p>统计列表中重复项出现的次数：</p>
<ol>
<li><code>collections.Counter()</code></li>
<li><code>list.count()</code></li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"></span><br><span class="line">lst = [<span class="string">'a'</span>, <span class="string">'a'</span>, <span class="string">'v'</span>, <span class="string">'c'</span>, <span class="string">'b'</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'b'</span>]</span><br><span class="line">Counter(lst)</span><br><span class="line"><span class="comment"># Counter(&#123;'a': 3, 'v': 1, 'c': 2, 'b': 3&#125;)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">lst = [<span class="string">'a'</span>, <span class="string">'a'</span>, <span class="string">'v'</span>, <span class="string">'c'</span>, <span class="string">'b'</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'b'</span>]</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> set(lst):</span><br><span class="line">    print(<span class="string">'the %s appears %d times'</span> %(item, lst.count(item)))</span><br><span class="line"><span class="comment">#the c appears 2 times</span></span><br><span class="line"><span class="comment">#the v appears 1 times</span></span><br><span class="line"><span class="comment">#the a appears 3 times</span></span><br><span class="line"><span class="comment">#the b appears 3 times</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python | cmath</title>
    <url>/python-cmath.html</url>
    <content><![CDATA[<p><center></center><br><a id="more"></a></p>
<h1 id="cmath"><a href="#cmath" class="headerlink" title="cmath"></a>cmath</h1><p>进行复数相关的计算</p>
<p>复数：</p>
<script type="math/tex; mode=display">z = x + y \mathrm{i}</script><ul>
<li>$x$：实部（real part）</li>
<li>$y$：虚部（imaginary part）</li>
</ul>
<p>复数$z$可以写成：</p>
<script type="math/tex; mode=display">z = r(\cos \phi+\mathrm{i}\sin \phi)</script><ul>
<li>模（modulus）$r = |z| = \sqrt{x^2 + y^2}$</li>
<li>辐角$\phi$（记作$\mathrm{Arg}(z)$）<ul>
<li>任意一个不为零的复数$z = x + y \mathrm{i}$的辐角有无限多个值，且这些值相差$k\cdot 2\pi$（$k$为任意整数）</li>
</ul>
</li>
<li>辐角主值$\mathrm{arg}(z)$：在区间$[-\pi, \pi]$的辐角。<ul>
<li>辐角的主值是唯一的</li>
</ul>
</li>
</ul>
<p>复数还可写为指数形式：</p>
<script type="math/tex; mode=display">z = r(\cos \phi+\mathrm{i}\sin \phi) = re^{\mathrm{i}\phi}</script><h2 id="abs"><a href="#abs" class="headerlink" title="abs()"></a>abs()</h2><p>计算复数的模<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">abs(complex(<span class="number">-1</span>, <span class="number">0</span>))</span><br><span class="line"><span class="comment">#1.0</span></span><br></pre></td></tr></table></figure></p>
<h2 id="phase"><a href="#phase" class="headerlink" title="phase()"></a>phase()</h2><p>计算辐角</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cmath</span><br><span class="line"></span><br><span class="line">cmath.phase(complex(<span class="number">-1</span>, <span class="number">0</span>))  <span class="comment">## 辐角为pi</span></span><br><span class="line"><span class="comment">#3.141592653589793</span></span><br></pre></td></tr></table></figure>
<h2 id="polar"><a href="#polar" class="headerlink" title="polar()"></a>polar()</h2><p>计算复数的模、辐角</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cmath</span><br><span class="line"></span><br><span class="line">cmath.polar(complex(<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line"><span class="comment">#(2.23606797749979, 1.1071487177940904)</span></span><br><span class="line">print(*cmath.polar(complex(<span class="number">1</span>, <span class="number">2</span>)), sep=<span class="string">'\n'</span>)</span><br><span class="line"><span class="comment">#2.23606797749979</span></span><br><span class="line"><span class="comment">#1.1071487177940904</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python | String</title>
    <url>/python-string.html</url>
    <content><![CDATA[<p><center></center><br><a id="more"></a></p>
<h1 id="string"><a href="#string" class="headerlink" title="string"></a>string</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> string</span><br></pre></td></tr></table></figure>
<h2 id="ascii-lowercase"><a href="#ascii-lowercase" class="headerlink" title="ascii_lowercase()"></a>ascii_lowercase()</h2><p>26个小写字母<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">alpha = string.ascii_lowercase</span><br><span class="line">alpha</span><br><span class="line"><span class="comment">#'abcdefghijklmnopqrstuvwxyz'</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1>]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python | TextWrap</title>
    <url>/python-textwrap.html</url>
    <content><![CDATA[<p><center></center><br><a id="more"></a></p>
<h1 id="TextWrap"><a href="#TextWrap" class="headerlink" title="TextWrap"></a>TextWrap</h1><p>文本自动换行与填充<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> textwrap <span class="keyword">as</span> tw</span><br></pre></td></tr></table></figure></p>
<h2 id="dedent"><a href="#dedent" class="headerlink" title="dedent()"></a>dedent()</h2><p>移除 text 中每一行的任何相同前缀空白符。</p>
<h2 id="fill"><a href="#fill" class="headerlink" title="fill()"></a>fill()</h2><h2 id="indent"><a href="#indent" class="headerlink" title="indent()"></a>indent()</h2><h2 id="wrap"><a href="#wrap" class="headerlink" title="wrap()"></a>wrap()</h2><p><code>textwrap.wrap(text, width=70, **kwargs)</code>：对 text (字符串) 中的单独段落自动换行以使每行长度最多为 width 个字符。 返回由输出行组成的列表，行尾不带换行符。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://docs.python.org/zh-cn/3.7/library/textwrap.html#textwrap.wrap" target="_blank" rel="noopener">textwrap —- 文本自动换行与填充</a></li>
</ul>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>数据分析 ｜ 数据包络分析</title>
    <url>/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90-%E6%95%B0%E6%8D%AE%E5%8C%85%E7%BB%9C%E5%88%86%E6%9E%90.html</url>
    <content><![CDATA[<p><center>DEA</center><br><a id="more"></a></p>
<h1 id="数据包络分析"><a href="#数据包络分析" class="headerlink" title="数据包络分析"></a>数据包络分析</h1><p>数据包络分析是针对多投入和多产出的问题，利用线性规划的方法，对具有可比性的同类型单位进行相对有效性评价的一种数量分析方法。是A.Charnes，W.W.Copper和E.Rhodes在1978年提出的评价多指标输入输出、衡量系统有效性的方法。</p>
<ul>
<li>数据包络分析（DEA）可以用于解决<strong>多指标问题</strong>。</li>
</ul>
<p>一些概念：</p>
<ul>
<li>决策单元（DMU）：效率评价的对象，可以理解为一个将一定“投入”转化为一定“产出”的实体</li>
<li>技术效率：在保持决策单元投入不变的情况下，实际产出同理想产出的比值</li>
<li>规模报酬：<ul>
<li>规模报酬不变（-）：生产要素同时增加一倍，产量的增加也正好是一倍</li>
<li>规模报酬递增（irs）：生产要素同时增加一倍，产量的增加多于一倍</li>
<li>规模报酬递减（drs）：生产要素同时增加一倍，产品的增加少于一倍</li>
</ul>
</li>
<li><strong>DEA强有效</strong>：<ul>
<li>任何一项投入的数量都无法减少，除非减少产出的数量或增加其他至少一种投入的数量</li>
<li>任何一项产出的数量都无法增加，除非增加投入的数量或减少其他至少一种产出的数量</li>
</ul>
</li>
<li><strong>DEA弱有效</strong>：<ul>
<li>无法等比例减少各项投入的数量，除非减少产出的数量</li>
<li>无法等比例增加各项产出的数量，除非增加投入的数量</li>
<li>这种情况下，虽然不能等比例减少投入或增加产出，但某一项或某几项（非全部）投入可能减少</li>
</ul>
</li>
<li>生产前沿面：对于给定的生产要素和产出价格，选择要素投入的最优组合和产出的最优组合，即投入成本最小、产出收益最大的组合，其所对应的生产函数所描述的生产可能性边界就是生产前沿面<blockquote>
<p>设$\omega&gt;0, \mu&gt;0, L=\left\{(X,Y)|\mu^TX-\omega^TY=0 \right\}$满足$T\subset \left\{(X,Y)|\mu^TX-\omega^TY\geq 0 \right\}$，$L\cap T\neq \emptyset$，则称$L$为生产可能集$T$的有效面，称$L\cap T$为生产前沿面。</p>
</blockquote>
</li>
<li>$T$不一定等于$L$，$T\leq L$</li>
</ul>
<p>假设共有$n$个决策单元（DMU），每个决策单元都有$m$种输入和$r$种输出。</p>
<ul>
<li>$X_j=\left(x_{j1}, \cdots, x_{ji}, \cdots, x_{jm}\right)^T$为第$j$个DMU的输入向量。其中，$x_{ji}$表示第$j$个DMU的第$i$种输入。</li>
<li>$Y_j=\left(y_{j1}, \cdots, y_{js}, \cdots, y_{jr}\right)^T$为第$j$个DMU的输出向量。其中，$y_{js}$表示第$j$个DMU的第$s$种输出。</li>
<li>$u=(u_1,u_2,\cdots,u_m)$为投入的权值向量</li>
<li>$v=(v_1,v_2,\cdots,v_r)$为产出的权值向量</li>
</ul>
<p>数据包络分析有多种模式：</p>
<ul>
<li>CCR模式</li>
<li>BCC模式</li>
<li>交叉模式</li>
<li>A&amp;P模式</li>
</ul>
<h2 id="效益分析"><a href="#效益分析" class="headerlink" title="效益分析"></a>效益分析</h2><ul>
<li><strong>综合技术效益</strong>（OE，Overall Efficiency）：反映决策单元在一定投入要素的生产效率，是对决策单元的资源配置能力、资源使用效率等多方面能力的综合衡量与评价<ul>
<li>OE = 1：表示该决策单元的投入产出是综合有效的，即同时技术有效和规模有效</li>
</ul>
</li>
<li><strong>技术效益</strong>（TE，Technical Efficiency）：企业由于管理和技术等因素影响的生产效率</li>
<li><strong>规模效益</strong>（SE，Scale Efficiency）：由于企业规模因素影响的生产效率<ul>
<li>TE = 1 且 SE &lt; 1：表示在目前的技术水平上，其投入资源的使用是有效的，未能达到综合有效的根本原因在于其规模无效，因此其改革的重点在于如何更好地发挥其规模效益</li>
</ul>
</li>
</ul>
<p>三者满足以下关系：</p>
<script type="math/tex; mode=display">OE = TE \times SE</script><ul>
<li>CCR模式得到的是OE</li>
<li>BCC模式得到的是TE</li>
</ul>
<h1 id="CCR模型"><a href="#CCR模型" class="headerlink" title="CCR模型"></a>CCR模型</h1><p>CCR模型是最早被提出来的数据包络分析方法</p>
<ul>
<li>本质：线性规划</li>
<li>CCR分别代表三个作者的名字首字母</li>
<li><p>CCR模式下DEA效率评估模型所得到的最优解$OE_k$是第$k$个决策单元的“综合技术效益”</p>
<div class="note warning">
            <p>定义：第$k$个决策单元的效益评价指数为</p><script type="math/tex; mode=display">e_k=\frac{u^TX_k}{v^TY_k}</script><p>$k = 1, 2, \cdots, n$.</p>
          </div>
</li>
</ul>
<p>从投入资源的角度来看，在当前产出的水准下，比较投入资源的使用情况，以此作为效益评价的依据，此种模式称为<strong>投入导向模式</strong>。</p>
<p>CCR模式的数学模型可表示为：对$k=1,2,\cdots,n$，有<br>\begin{aligned}<br>\max &amp;\quad \frac{v^TY_k}{u^TX_k} \\<br>s.t. &amp; \quad \left\{<br>\begin{array}{ll}<br>\frac{v^TY_j}{u^TX_j} \leq 1 &amp; ,\quad j=1,2,\cdots,n.\\<br>u&gt;0,v&gt;0 &amp;<br>\end{array}<br>\right.<br>\end{aligned}</p>
<ul>
<li>因为现实中的任何一项技术都不能使得输入全部转化为输出，所以$\frac{v^TY_j}{u^TX_j} \leq 1$</li>
<li>分式规划的缺点：解释不唯一——如果$u,v$是解，则$ku,kv$也是解（$k$是任意非零常数）<ul>
<li>为了解决这个问题，通常令目标函数的分母$u^TX_k=1$或者通过Charnes-Cooper变换将分式规划变为线性规划</li>
</ul>
</li>
</ul>
<p>Charnes-Cooper变换：<br>令$ \mu = tu, \omega = tv, t = \frac{1}{u^TX_k}$，则上述数学模型变为：<br>\begin{aligned}<br>\max &amp; \quad \omega^TY_k \\<br>s.t. &amp; \quad \left\{<br>\begin{array}{ll}<br>\mu^TX_k - \omega^TY_k \geq 0 &amp; ,\quad j=1,2,\cdots,n.\\<br>\mu^TX_k = 1 &amp; \\<br>\mu &gt; 0, \omega &gt; 0 &amp;<br>\end{array}<br>\right.<br>\end{aligned}</p>
<blockquote>
<p>详细过程如下：<br>因为$\mu = tu &gt; 0, \omega = tv &gt; 0, t = \frac{1}{u^TX_k} \Rightarrow \mu^T = tu^T, \omega^T = tv^T, tu^TX_k = 1$，则</p>
<script type="math/tex; mode=display">\max\quad \frac{v^TY_k}{u^TX_k} \Rightarrow \max \quad \frac{tv^TY_k}{tu^TX_k} \Rightarrow \max \quad \omega^TY_k</script><p>\begin{aligned}<br>&amp; \quad \frac{v^TY_k}{u^TX_k}\leq 1\\<br>\Rightarrow &amp; \quad u^TX_k - v^TY_k \geq 0\\<br>\Rightarrow &amp; \quad \frac{1}{t}\mu^TX_k - \frac{1}{t}\omega^TY_K \geq 0\\<br>\Rightarrow &amp; \quad \mu^TX_k - \omega^TY_k \geq 0<br>\end{aligned}<br>因为$t=\frac{1}{u^TX_k}$，则</p>
<script type="math/tex; mode=display">t=\frac{1}{u^TX_k} \Rightarrow tu^TX_k = 1 \Rightarrow \mu^TX_k = 1</script></blockquote>
<div class="note default">
            <p>对于任何一个线性规划模型，都存在一个等价的对偶模型。<br>原始模型：<br>\begin{aligned}<br>\max &amp; \quad c^Tx^\prime\\<br>s.t. &amp; \quad \left\{<br>\begin{array}{l}<br>Ax^\prime\leq b\\<br>x^\prime \geq 0<br>\end{array}<br>\right.<br>\end{aligned}<br>对偶模型：<br>\begin{aligned}<br>\min &amp; \quad b^Ty^\prime\\<br>s.t. &amp; \quad \left\{<br>\begin{array}{l}<br>A^Ty^\prime \geq c\\<br>y^\prime \geq 0<br>\end{array}<br>\right.<br>\end{aligned}</p>
          </div>
<p>记<br>\begin{aligned}<br>c_{(m+r)\times1} &amp;= \left(0,\cdots,0, y_{k1}, \cdots, y_{kr} \right)^T \\<br>x^\prime_{(m+r)\times1} &amp;= \left(\mu_1,\cdots,\mu_m, \omega_1,\cdots,\omega_r \right)^T\\<br>A_{(n+1)\times(m+r)} &amp;= \left(<br>\begin{array}{cccccc}<br>-x_{11} &amp; \cdots &amp; -x_{1m} &amp; y_{11} &amp; \cdots &amp; y_{1r} \\<br>\vdots &amp; \ddots &amp; \vdots &amp; \vdots  &amp; \ddots &amp; \vdots  \\<br>-x_{n1} &amp; \cdots &amp; -x_{nm} &amp; y_{n1} &amp; \cdots &amp; y_{nr} \\<br>x_{k1}&amp; \cdots &amp; x_{km}&amp; 0       &amp; \cdots &amp; 0<br>\end{array}<br>\right) \\<br>b_{(n+1)\times1} &amp;= \left(0,\cdots,0,1\right)^T \\<br>y^\prime &amp;= \left(\lambda_1,\cdots,\lambda_n, \theta \right)^T<br>\end{aligned}</p>
<p>则</p>
<script type="math/tex; mode=display">\max \quad c^Tx^\prime \Rightarrow \max \quad \omega^TY_k</script><script type="math/tex; mode=display">Ax^\prime \leq b \Rightarrow -\mu^TX_k + \omega^TY_k \leq 0, \mu^TX_k = 1</script><script type="math/tex; mode=display">\min \quad b^Ty^\prime \Rightarrow \min\quad \theta</script><p>\begin{aligned}<br>&amp; \quad A^Ty^\prime \geq c \\<br>\Rightarrow &amp; \quad \left\{<br>\begin{array}{l}<br>\lambda_1x_{11} + \lambda_2x_{21} + \cdots + \lambda_nx_{n1} \leq \theta x_{k1}\\<br>\vdots\\<br>\lambda_1x_{1m} + \lambda_2x_{2m} + \cdots + \lambda_nx_{nm} \leq \theta x_{km}\\<br>\lambda_1y_{11} + \lambda_2y_{21} + \cdots + \lambda_ny_{n1} \geq y_{k1}\\<br>\vdots\\<br>\lambda_1y_{1r} + \lambda_2y_{2r} + \cdots + \lambda_ny_{nr} \geq y_{kr}<br>\end{array}<br>\right.<br>\end{aligned}</p>
<p>则CCR模式的数学模型的对偶形式如下：<br>\begin{aligned}<br>\min &amp; \quad \theta \\<br>s.t. &amp; \left\{<br>\begin{array}{l}<br>\sum_{j=1}^n \lambda_jX_j \leq \theta X_k\\<br>\sum_{j=1}^n \lambda_jY_j \leq Y_k\\<br>\lambda_j \geq 0, \quad j = 1,2,\cdots,n.<br>\end{array}<br>\right.<br>\end{aligned}</p>
<h1 id="BCC模式"><a href="#BCC模式" class="headerlink" title="BCC模式"></a>BCC模式</h1><h1 id="交叉模式"><a href="#交叉模式" class="headerlink" title="交叉模式"></a>交叉模式</h1><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://blog.csdn.net/qq_41228463/article/details/108310361" target="_blank" rel="noopener">数据包络分析—CCR模型</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/73096903" target="_blank" rel="noopener">数据包络分析法（DEA）——CCR</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/60853027" target="_blank" rel="noopener">DEA (数据包络分析)介绍及 python3 实现</a></li>
</ul>
]]></content>
      <categories>
        <category>数据分析</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
      </tags>
  </entry>
  <entry>
    <title>数据分析 | 指标体系</title>
    <url>/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90-%E6%8C%87%E6%A0%87%E4%BD%93%E7%B3%BB.html</url>
    <content><![CDATA[<p><center></center><br><a id="more"></a></p>
<h1 id="指标"><a href="#指标" class="headerlink" title="指标"></a>指标</h1><p>指标：在一定条件和时间下反映某种现象的规模和比例，由指标名称和数值构成</p>
<p>常用的数据指标可分成：</p>
<ul>
<li>用户数据：新增、日活、留存等</li>
<li>行为数据：访问深度、转化率等</li>
<li>业务数据：反映业务大盘的情况，如GMV、ARPU值等</li>
</ul>
<h1 id="数据指标体系"><a href="#数据指标体系" class="headerlink" title="数据指标体系"></a>数据指标体系</h1><ul>
<li>指标是单一的，指标体系是完整的，是可以表示业务之间的相关性和结构性的</li>
</ul>
<p>优质的指标体系可反映出：</p>
<ul>
<li>what happen 描述性分析：结果性指标反映</li>
<li>why did it happen 诊断性分析：过程性指标辅助反映</li>
<li>what’s likely happen 预测型分析：如果这种结果发展下去，会有什么样的趋势</li>
<li>what’s should I do 策略分析：可以根据指标体系的结果描述和过程去进行问题定位，思考业务问题的解决方式</li>
</ul>
<p>构建完整的指标体系的搭建步骤，以及需要合作的同事：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">序号</th>
<th style="text-align:left">步骤</th>
<th style="text-align:left">合作方</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:left">明确产品各业务线目的</td>
<td style="text-align:left">相关业务线产品经理</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:left">明确指标体系的建设规划模型方案</td>
<td style="text-align:left">分析师和相关业务线的产品经理拉齐</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:left">明确指标对应的埋点和存储逻辑</td>
<td style="text-align:left">各业务线产品经理、埋点研发人员</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:left">梳理指标的准确性，取数校验</td>
<td style="text-align:left">分析师</td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:left">指标迭代更新和删减</td>
<td style="text-align:left">分析师、产品经理</td>
</tr>
<tr>
<td style="text-align:center">6</td>
<td style="text-align:left">数据指标体系平台建设和迭代</td>
<td style="text-align:left">分析师、产品经理、研发</td>
</tr>
</tbody>
</table>
</div>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>规划数据指标体系的3种方法：</p>
<ol>
<li>OSM模型（Object-Strategy-Measure）<ul>
<li>业务目标（Object）：我们的业务、产品甚至是其中的一个小的功能存在的目的是什么、能够解决用户什么问题、满足用户的什么需求</li>
<li>业务策略（strategy）：清楚业务目标后，为了达成上述目标，应该采取什么业务策略</li>
<li>业务度量（measure）：用于衡量策略是否有效，用于反映目标的达成情况<ul>
<li>KPI：用于直接衡量策略的有效性</li>
<li>Target：预先给出的目标值，用于判断是否达到预期</li>
</ul>
</li>
</ul>
</li>
<li>UJM模型（User Journey Map，用户路径地图模型）：在设计一款产品的过程种，必须要去梳理的用户生命路径<ul>
<li>拆解用户所处的每一个路径阶段</li>
<li>了解每个阶段种用户的行为</li>
<li>明确每个阶段中产品的目标</li>
<li>发现各阶段中产品与用户的接触点</li>
<li>最终从接触点里找到产品的痛点和机会点</li>
</ul>
</li>
</ol>
<p>选取目标时要注意4个原则（DUMB）：</p>
<ol>
<li>切实可行（Doable）</li>
<li>易于理解（Understandable）</li>
<li>可干预可管理（Manageable）</li>
<li>正向的有益的（Beneficial）</li>
</ol>
<h2 id="三级指标体系"><a href="#三级指标体系" class="headerlink" title="三级指标体系"></a>三级指标体系</h2><p>可以针对不同的指标，分不同的层级</p>
<ol>
<li><p>一级指标（Tier 1 Metrics）</p>
</li>
<li><p>二级指标（Tier 2 Metrics）</p>
</li>
<li><p>三级指标（Tier 3 Metrics）</p>
</li>
</ol>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://mp.weixin.qq.com/s/RGEsQ08nWu1AXyzr-Zul0g" target="_blank" rel="noopener">从留存率业务案例谈0-1的数据指标体系</a></li>
<li><a href="https://www.growingio.com/ebook/metric-and-track" target="_blank" rel="noopener">GrowingIO：指标体系和数据采集</a></li>
</ul>
]]></content>
      <categories>
        <category>数据分析</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
      </tags>
  </entry>
  <entry>
    <title>Python | jieba</title>
    <url>/python-jieba.html</url>
    <content><![CDATA[<p><center>分词</center><br><a id="more"></a></p>
<h1 id="jieba"><a href="#jieba" class="headerlink" title="jieba"></a>jieba</h1><p>jieba支持三种分词模式：</p>
<ul>
<li>精确模式：试图将句子最精确地切开，适合文本分析</li>
<li>全模式：把句子中所有的可以成词的词语都扫描出来<ul>
<li>速度非常快</li>
<li>但是不能解决歧义</li>
</ul>
</li>
<li>搜索引擎模式：在精确模式的基础上，对长词再次切分，提高召回率，适合用于搜索引擎分词</li>
</ul>
<p>此外，jieba还支持</p>
<ul>
<li>繁体分词</li>
<li>自定义词典</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装</span></span><br><span class="line">pip install jieba</span><br></pre></td></tr></table></figure>
<h2 id="analyse"><a href="#analyse" class="headerlink" title=".analyse"></a>.analyse</h2><h3 id="extract-tags"><a href="#extract-tags" class="headerlink" title="extract_tags()"></a>extract_tags()</h3><p><code>jieba.analyse.extract_tags(sentence, topK=20, withWeight=False, allowPOS=())</code>：基于TF-IDF算法的关键词抽取</p>
<ul>
<li><code>sentence</code>：待提取的文本</li>
<li><code>topK</code>：返回K个TF-IDF权重最大的关键词</li>
<li><code>withWeight</code>：是否一并返回关键词权重值</li>
<li><code>allowPOS</code>：仅包括指定词性的词。默认为空，表示不筛选</li>
</ul>
<h3 id="set-idf-path"><a href="#set-idf-path" class="headerlink" title="set_idf_path()"></a>set_idf_path()</h3><p>可以将关键词提取所使用逆向文本频率（IDF）文本语料库切换成自定义语料库的路径</p>
<h3 id="set-stop-words"><a href="#set-stop-words" class="headerlink" title="set_stop_words()"></a>set_stop_words()</h3><p>可以将关键词提取所使用停用词（stop words）文本语料库切换成自定义语料库的路径</p>
<h3 id="textrank"><a href="#textrank" class="headerlink" title="textrank()"></a>textrank()</h3><p>基于TextRank算法的关键词提取</p>
<h3 id="TextRank"><a href="#TextRank" class="headerlink" title="TextRank()"></a>TextRank()</h3><p>新建自定义TextRank实例</p>
<h3 id="TFIDF"><a href="#TFIDF" class="headerlink" title="TFIDF()"></a>TFIDF()</h3><p>新建TFIDF实例</p>
<h2 id="cut"><a href="#cut" class="headerlink" title="cut()"></a>cut()</h2><p>分词</p>
<ul>
<li><code>cut_all</code>：是否采用全模式</li>
<li><code>HMM</code>：是否使用HMM模型</li>
<li>返回的结构都是一个可迭代的generator，可以使用<code>for</code>循环来获得分词后得到的每一个词语</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> jieba</span><br><span class="line"></span><br><span class="line">df[<span class="string">'cut'</span>] = df[<span class="string">'comment'</span>].apply(<span class="keyword">lambda</span> x: list(jieba.cut(x)))</span><br><span class="line"><span class="comment">## 若要将字符串中的符号去除再分词</span></span><br><span class="line">df[<span class="string">'cut'</span>] = df[<span class="string">'name'</span>].apply(<span class="keyword">lambda</span> x: list(jieba.cut(re.sub(<span class="string">r"[0-9\s+\.\!\/_,$%^*()?;；:-【】+\"\']+|[+——！，;:。？、~@#￥%……&amp;*（）]+"</span>, <span class="string">""</span>, <span class="string">" "</span>.join(x)))))</span><br></pre></td></tr></table></figure>
<h2 id="cut-for-search"><a href="#cut-for-search" class="headerlink" title="cut_for_search()"></a>cut_for_search()</h2><ul>
<li><code>HMM</code>：是否使用HMM模型</li>
<li>适合用于搜索引擎构建倒排索引的分词，粒度比较细</li>
<li>返回的结构都是一个可迭代的generator，可以使用<code>for</code>循环来获得分词后得到的每一个词语</li>
</ul>
<h2 id="disable-parallel"><a href="#disable-parallel" class="headerlink" title="disable_parallel()"></a>disable_parallel()</h2><p>关闭并行分词模式</p>
<h2 id="enable-parallel"><a href="#enable-parallel" class="headerlink" title="enable_parallel()"></a>enable_parallel()</h2><p>开启并行分词模式，参数为并行进程数</p>
<h2 id="lcut"><a href="#lcut" class="headerlink" title="lcut()"></a>lcut()</h2><p>分词</p>
<ul>
<li>返回结果是列表</li>
</ul>
<h2 id="lcut-for-search"><a href="#lcut-for-search" class="headerlink" title="lcut_for_search()"></a>lcut_for_search()</h2><ul>
<li>返回结果是列表</li>
</ul>
<h2 id="load-userdict"><a href="#load-userdict" class="headerlink" title="load_userdict()"></a>load_userdict()</h2><p><code>load_userdict(file_name)</code>：添加自定义词典，载入词典</p>
<ul>
<li><code>file_name</code>：文件类对象或自定义词典的路径。若为路径或二进制方式打开的文件，则文件必须为UTF-8编码</li>
<li>词典格式：<ul>
<li>一个词占一行</li>
<li>每一行分三部分：词语、词频（可省略）、词性（可省略）。用空格隔开，顺序不可颠倒</li>
</ul>
</li>
</ul>
<h2 id="posseg"><a href="#posseg" class="headerlink" title=".posseg"></a>.posseg</h2><h3 id="dt"><a href="#dt" class="headerlink" title="dt()"></a>dt()</h3><p>默认词性标注分词器</p>
<h3 id="POSTokenizer"><a href="#POSTokenizer" class="headerlink" title="POSTokenizer()"></a>POSTokenizer()</h3><p><code>jieba.posseg.POSTokenizer(tokenizer=None)</code>：新建自定义分词器</p>
<ul>
<li><code>tokenizer</code>可以指定为内部使用的<code>jieba.Tokenizer</code>分词器</li>
</ul>
<h2 id="tokenize"><a href="#tokenize" class="headerlink" title="tokenize()"></a>tokenize()</h2><p>返回词语在原文的起止位置</p>
<ul>
<li>输入参数只接受unicode</li>
<li><code>mode</code>：可选值有<code>search</code>（搜索模式）</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> jieba</span><br><span class="line">result = jieba.tokenize(<span class="string">u'数据结构与算法'</span>)  <span class="comment">## 默认模式</span></span><br><span class="line"><span class="keyword">for</span> tk <span class="keyword">in</span> result:</span><br><span class="line"> print(<span class="string">"word %s \t\t start: %d \t\t end: %d"</span> %(tk[<span class="number">0</span>], tk[<span class="number">1</span>], tk[<span class="number">2</span>]))</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://www.jianshu.com/p/7ad0cd33005e" target="_blank" rel="noopener">Python中文分词及词频统计</a></li>
<li><a href="https://www.cnblogs.com/jackchen-net/p/8207009.html" target="_blank" rel="noopener">python 结巴分词(jieba)详解</a></li>
</ul>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>数据分析 | 因果推断</title>
    <url>/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90-%E5%9B%A0%E6%9E%9C%E6%8E%A8%E6%96%AD.html</url>
    <content><![CDATA[<p><center>未完待续</center><br><a id="more"></a></p>
<h1 id="因果推断"><a href="#因果推断" class="headerlink" title="因果推断"></a>因果推断</h1><p>关联——&gt;干预——&gt;反事实</p>
<ul>
<li>核心思想：寻找合适的对照组</li>
</ul>
<h1 id="研究方法"><a href="#研究方法" class="headerlink" title="研究方法"></a>研究方法</h1><h2 id="实验性研究Field-experiment"><a href="#实验性研究Field-experiment" class="headerlink" title="实验性研究Field experiment"></a>实验性研究Field experiment</h2><p>分配机制已知<br>eg：AB实验</p>
<h2 id="观测性研究Observation-studies"><a href="#观测性研究Observation-studies" class="headerlink" title="观测性研究Observation studies"></a>观测性研究Observation studies</h2><p>分配机制未知</p>
<ul>
<li>因果图模型</li>
<li>潜在结果框架</li>
</ul>
<h1 id="潜在结果框架"><a href="#潜在结果框架" class="headerlink" title="潜在结果框架"></a>潜在结果框架</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul>
<li>单元：</li>
<li>处理Treatment</li>
<li>结果</li>
<li>潜在结果</li>
<li>反事实</li>
</ul>
<p>Rubin’s potential outcome framework：个体$i$的因果效应$\tau_i=Y_i(1)-Y_i(0)$，其中只有$Y_i(1)$或$Y_i(0)$可以被观测到。</p>
<h2 id="处理效应Treatment-Effect"><a href="#处理效应Treatment-Effect" class="headerlink" title="处理效应Treatment Effect"></a>处理效应Treatment Effect</h2><p>平均处理效应（ATE，Average Treatment Effect）<br>（ATT，Average Treatment Effect on the Treated）<br>（ATC，）</p>
<h2 id="假设条件"><a href="#假设条件" class="headerlink" title="假设条件"></a>假设条件</h2><ul>
<li>个体处理稳定性假设</li>
<li>分配机制与潜在结果无关</li>
<li>正值假设</li>
</ul>
<h1 id="断点回归"><a href="#断点回归" class="headerlink" title="断点回归"></a>断点回归</h1><p>断点回归/断点回归设计（RDD，Regression Discontinuity Design）的一般步骤：</p>
<ol>
<li>图形分析</li>
<li>因果效应分析</li>
<li>稳健性检验</li>
</ol>
<p>断点回归分为2类：</p>
<ol>
<li>精确断点回归：断点x=c处，个体得到处理的概率从0跳跃到1</li>
<li>模糊断点回归：断点x=c处，个体得到处理的概率从a跳跃到b，其中$0 &lt; a &lt; b &lt; 1$。</li>
</ol>
<h2 id="精确断点回归"><a href="#精确断点回归" class="headerlink" title="精确断点回归"></a>精确断点回归</h2><p>精确断点回归（SRD，Sharp Regression Discontinuity）</p>
<p>局部平均处理效应（LATE，Local Average Treatment Effect）</p>
<h2 id="模糊断点回归"><a href="#模糊断点回归" class="headerlink" title="模糊断点回归"></a>模糊断点回归</h2><div class="note warning">
            <p><strong>协变量</strong>：在实验的设计中，协变量是一个独立变量（解释变量），不为实验者所操纵，但仍影响实验结果。 协变量（Covariate）在心理学、行为科学中，是指与因变量有线性相关并在探讨自变量与因变量关系时通过统计技术加以控制的变量。常用的协变量包括因变量的前测分数、人口统计学指标以及与因变量明显不同的个人特征等。</p>
          </div>
<h1 id="双重差分"><a href="#双重差分" class="headerlink" title="双重差分"></a>双重差分</h1><p>双重差分法（DID，Difference in Difference）</p>
<ul>
<li>解决内生性问题的因果分析方法</li>
<li>政策干预发生与否的虚拟变量+前后两个时间段的面板数据+不可观测的个体固定效应</li>
</ul>
<p><strong>基本假设</strong>：</p>
<ol>
<li>共同趋势假设/平行趋势假定</li>
<li></li>
</ol>
<script type="math/tex; mode=display">Y_{it}=\alpha_i + \lambda_t + D_{it}\beta + \varepsilon_{it}</script><p>其中，</p>
<ul>
<li>$\alpha_i$：不可观测的个体固定效应</li>
<li>$D_{it}$：干预是否发生的虚拟变量<script type="math/tex; mode=display">D_{it}=\left\{
\begin{array}{ll}
1, & 干预发生\\
0, & 干预不发生
\end{array}
\right.</script></li>
<li>通过差分消除固定效应$\hat{\beta}$<script type="math/tex; mode=display">\hat{\beta} = \hat{Y}_{post}^{treatment}-\hat{Y}_{pre}^{treatment}-\left(\hat{Y}_{post}^{control} - \hat{Y}_{pre}^{control} \right)</script></li>
</ul>
<h1 id="工具变量"><a href="#工具变量" class="headerlink" title="工具变量"></a>工具变量</h1><p>工具变量（IV，Instrumental Variable）</p>
<h1 id="重加权算法"><a href="#重加权算法" class="headerlink" title="重加权算法"></a>重加权算法</h1><p>避免“辛普森悖论”</p>
<h1 id="分层算法"><a href="#分层算法" class="headerlink" title="分层算法"></a>分层算法</h1><h1 id="匹配法"><a href="#匹配法" class="headerlink" title="匹配法"></a>匹配法</h1><ul>
<li>去除隐藏变量造成的选择性偏差，使得实验组和对照组进行更合理的比较</li>
<li>适合一些特殊场景（如：渗透率低的场景）的因果分析</li>
</ul>
<h2 id="倾向评分匹配PSM"><a href="#倾向评分匹配PSM" class="headerlink" title="倾向评分匹配PSM"></a>倾向评分匹配PSM</h2><p>倾向评分匹配/倾向性得分匹配（PSM，Propensity Score Matching）</p>
<ul>
<li>通过观测变量对实验组的预测概率进行匹配</li>
</ul>
<p>适用情形：</p>
<ol>
<li>在观察研究中，对照组与实验组中可直接比较的个体数量很少</li>
<li>由于衡量个体特征的参数很多，所以想从对照组中选出一个跟实验组在各项参数上都相同或相近的子集作对比变得非常困难</li>
</ol>
<ul>
<li>干预$T$</li>
<li>样本属性$X$</li>
<li>观测结果$Y$</li>
</ul>
<div class="note warning">
            <p><strong>倾向性得分</strong>：一个用户/样本属于实验组的“倾向性”。</p><script type="math/tex; mode=display">e(x)=P\left(T=1|X=x\right)</script>
          </div>
<p>相关文献：</p>
<ul>
<li><a href="https://onlinelibrary.wiley.com/doi/10.1111/j.1467-6419.2007.00527.x" target="_blank" rel="noopener">Caliendo M, Kopeinig S. Some practical guidance for the implementation of propensity score matching[J]. Journal of economic surveys, 2008, 22(1): 31-72.</a></li>
</ul>
<h2 id="广义精确匹配CEM"><a href="#广义精确匹配CEM" class="headerlink" title="广义精确匹配CEM"></a>广义精确匹配CEM</h2><p>广义精确匹配（CEM，Coarsened Exact Matching）：通过给特征分桶进行匹配</p>
<h1 id="合成控制法"><a href="#合成控制法" class="headerlink" title="合成控制法"></a>合成控制法</h1><p>合成控制法（SCM，Synthetic Control Method）</p>
<ul>
<li>当某个干预施加在某一类群体（或地区）上，虽然找不到单一的最佳对照组，但是可以构造一个虚拟的对照组</li>
</ul>
<h1 id="固定效应模型"><a href="#固定效应模型" class="headerlink" title="固定效应模型"></a>固定效应模型</h1><ul>
<li>适用于面板数据</li>
</ul>
<p>模型为：</p>
<script type="math/tex; mode=display">y_{it} = \alpha_i + x_{it}^T\beta + \varepsilon_{it}</script><p>或</p>
<script type="math/tex; mode=display">y_{it} = \alpha_i + x_{it}^T\beta + d_t + \varepsilon_{it}</script><p>其中，$i=1,2,\cdots,N$，$t=1,2,\cdots,T$。</p>
<h1 id="矩阵补全"><a href="#矩阵补全" class="headerlink" title="矩阵补全"></a>矩阵补全</h1><ul>
<li>合成控制法的扩展</li>
<li>合成控制法（SCM）的局限性：只有一个实验干预组（政策干预开始时间是在某个统一的时间段）</li>
<li>矩阵补全<strong>适用于</strong>：多个实验干预，干预时间不一致。如：<ul>
<li>一个AB实验下的策略是逐渐放量的过程，如何评估策略对用户的影响？</li>
<li>产品新版本更新了UI界面，但是用户更新版本的时间不一致，如何评估新界面对用户使用时长的影响？</li>
</ul>
</li>
<li>矩阵补全法：通过一定的方法将一个含有缺失值的矩阵恢复为一个完全的矩阵（通过求解一个凸优化问题，实现将一个低秩矩阵恢复），从而估计因果效应</li>
</ul>
<script type="math/tex; mode=display">Y(0)=\left(
\begin{array}{ccccc}
? & ? & \Checkmark & \cdots & ? \\
\Checkmark & ? & \Checkmark & \cdots & \Checkmark \\
\vdots & \vdots & \vdots & \ddots & \vdots \\
? & \Checkmark & \Checkmark & \cdots & \Checkmark
\end{array}
\right)</script><script type="math/tex; mode=display">
Y(1)=\left(
\begin{array}{ccccc}
$\Checkmark$ & \Checkmark & ? & \cdots & \Checkmark \\
? & \Checkmark & ? & \cdots & ? \\
\vdots & \vdots & \vdots & \ddots & \vdots \\
\Checkmark & ? & ? & \cdots & ?
\end{array}
\right)</script><p>且</p>
<script type="math/tex; mode=display">W_{it}=\left\{
\begin{array}{ll}
0, & Y_{it}(0)被观察到\\
1, & Y_{it}(1)被观察到
\end{array}
  \right.</script><p>则因果效应为</p>
<script type="math/tex; mode=display">\tau = \frac{\sum_{i,t}W_{it}\left(Y_{it}(1)-Y_{it}(0) \right)}{\sum_{i,t}W_{it}}</script><h1 id="混淆变量"><a href="#混淆变量" class="headerlink" title="混淆变量"></a>混淆变量</h1><h2 id="双重选择Double-Selection"><a href="#双重选择Double-Selection" class="headerlink" title="双重选择Double Selection"></a>双重选择Double Selection</h2><h2 id="双重机器学习DML"><a href="#双重机器学习DML" class="headerlink" title="双重机器学习DML"></a>双重机器学习DML</h2><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://www.douban.com/group/topic/138765167/" target="_blank" rel="noopener">断点回归设计RDD分类与操作案例</a></li>
<li><a href="https://cosx.org/2013/08/causality6-instrumental-variable/" target="_blank" rel="noopener">因果推断简介之六：工具变量（instrumental variable）</a></li>
<li><a href="https://dango.rocks/blog/2019/01/20/Causal-Inference-Introduction2-Propensity-Score-Matching/" target="_blank" rel="noopener">因果推断漫谈（二）：倾向性得分匹配介绍</a></li>
<li><a href="https://mp.weixin.qq.com/s?t=pages/video_detail_new&amp;scene=1&amp;vid=wxv_1670066067622199305&amp;__biz=Mzg3NzUxMjUyMQ==&amp;mid=2247492966&amp;idx=1&amp;sn=13dc5964de23ff43c9994b0788afe7fe&amp;vidsn=&amp;key=734336bd97b20ca726a8dcbad2455e5477a0f2d609b6b35a29f2c418f4c438b67b7c34571e81dee060f26cd7f1bf7db31dc40559014ac19aef1a10d7a70f9cdcbaff4765ac1f9033c089495f6ab5cdc1de9fa5cf0eda0c80b53db3853cf9a81e8ff93b92e6a38dc2a79d8ee4a6e4b87aa7ecf8b1e07bed5da05f8ed79a7b07c1&amp;ascene=1&amp;uin=Mjk4NDY5NTQ4&amp;devicetype=Windows+10+x64&amp;version=6300002f&amp;lang=zh_CN&amp;exportkey=AQ4nRk5qBTXgmnHtUOo%2FpWc%3D&amp;pass_ticket=LCBT0Lt4dWW6xAtluQSk5SCaP6e1U7FD%2BwUktAuHYAqLXxZmVITup4Jw748qaYRF&amp;wx_header=0" target="_blank" rel="noopener">因果推断工具在快手的应用</a><ul>
<li>将机器学习与因果分析结合：双重机器学习、基于决策树/随机森林的异质性的因果效应估计</li>
</ul>
</li>
<li><a href="https://blog.csdn.net/deephub/article/details/105290843" target="_blank" rel="noopener">Python实现固定效应回归模型实现因果关系推断</a></li>
<li><a href="https://www.zhihu.com/question/47716840" target="_blank" rel="noopener">矩阵补全（matrix completion）的经典算法有哪些？</a></li>
</ul>
]]></content>
      <categories>
        <category>数据分析</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
      </tags>
  </entry>
  <entry>
    <title>Aha Moment</title>
    <url>/Aha-Moment.html</url>
    <content><![CDATA[<p><center>奇妙智力题积累~</center><br><a id="more"></a></p>
<p>积累奇妙的题目 &amp; 碎碎念</p>
<h1 id="至少几次"><a href="#至少几次" class="headerlink" title="至少几次"></a>至少几次</h1><div class="note default">
            <p>有 6 枚硬币，它们的重量分别为 1 克、 2 克、 3 克、 4 克、 5 克、 6 克。它们看上去完全相同，只是上面的标签不一样。每一枚硬币上都标有 {1, 2, 3, 4, 5, 6} 中的一个数，它代表这枚硬币的重量。只用两次天平，如何判断出这些标签是否都是正确的？<br>2种方案：</p><ol><li>首先检验 1 + 2 + 3 = 6 ，然后检验 1 + 6 &lt; 3 + 5 。</li><li>首先检验 1 + 2 + 5 &lt; 3 + 6 ，然后检验 1 + 3 &lt; 5 。</li></ol><p><a href="http://www.matrix67.com/blog/archives/5330" target="_blank" rel="noopener">参考资料</a></p>
          </div>
<p>发现一个神奇的网站→ <a href="http://www.matrix67.com/blog/" target="_blank" rel="noopener">Matrix67: The Aha Moments</a>，记录了若干奇妙的“知识点”。虽然这个网站最新的更新也“远”在2016年了，但是其中的内容仍能让人不由得“Aha”一声惊呼。</p>
]]></content>
  </entry>
  <entry>
    <title>SQL | 事务</title>
    <url>/sql-%E4%BA%8B%E5%8A%A1.html</url>
    <content><![CDATA[<p><center>Transaction</center><br><a id="more"></a></p>
<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><ul>
<li>一个数据库事务可以包含多个查询、修改、删除、插入等数据库动作，它们要么作为一个整体完全得到确认，要么完全失败（原子性）</li>
<li>事务提交（commit）之后就不能回滚了</li>
<li>一个事务只能包含对一个数据库实例的数据操作，不允许跨多个数据库实例，跨多个数据库实例需要分布式事务支持</li>
<li>数据库事务会给数据库带来并发操作带来一定影响，会降低系统的并发能力</li>
</ul>
<h1 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h1><p>数据库事务的四大特性（简称<strong>ACID</strong>）：</p>
<ol>
<li><a href="#原子性">原子性</a>（Atomicity）</li>
<li><a href="#一致性">一致性</a>（Consistency）</li>
<li><a href="#隔离性">隔离性</a>（Isolation）</li>
<li><a href="#持久性">持久性</a>（Durability）</li>
</ol>
<h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><p>不可分割的操作单元，事务中的所有操作，要么全部完成，要么全部不完成；不可能停滞在中间某个环节。</p>
<ul>
<li>事务在执行过程中若发生错误，会被回滚（rollback）到事务开始前的状态。</li>
</ul>
<h2 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h2><p>在事务开始之前和结束之后，数据库的完整性约束没有被破坏。<br>或：如果在执行事务之前数据库是一致的，那么在执行事务之后数据库也还是一致的。</p>
<ul>
<li>进行数据库提交操作时使用事务（Transaction）是为了保证数据一致性</li>
</ul>
<h2 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性"></a>隔离性</h2><p>事务操作之间彼此独立和透明，互不影响；事务独立运行；通常使用锁来实现。一个事务处理后的结果，影响了其他事务，那么其他事务会撤回。</p>
<h2 id="持久性"><a href="#持久性" class="headerlink" title="持久性"></a>持久性</h2><p>事务一旦提交，其结果就是永久的；即使发生系统故障，也能恢复。<br>或：在事务完成后，该事务对数据库所作的更改便持久地保存在数据库中，并不会被回滚。</p>
<ul>
<li>持久性通过数据库备份和恢复来保证</li>
</ul>
<h1 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h1><ol>
<li>Read Uncommitted（未提交读）</li>
<li>Read Committed（提交读）</li>
<li>Repeatable Read（可重复读）</li>
<li>Serializable（可串行化）</li>
</ol>
<ul>
<li>隔离级别依次增加</li>
<li>并发性能依次降低</li>
<li>随着隔离级别的增高，并发性能降低</li>
</ul>
<h2 id="Read-Uncommitted"><a href="#Read-Uncommitted" class="headerlink" title="Read Uncommitted"></a>Read Uncommitted</h2><p>可以读取其他事务修改但未提交的数据</p>
<ul>
<li>会导致“脏读”、“幻读”和“不可重复读取”</li>
</ul>
<h2 id="Read-Committed"><a href="#Read-Committed" class="headerlink" title="Read Committed"></a>Read Committed</h2><p>只能读取其他事务修改并已经提交的数据</p>
<ul>
<li>避免了“脏读”</li>
<li>不能避免“幻读”、“不可重复读取”</li>
<li>提交读是大多数主流数据库的默认事务等级</li>
</ul>
<h2 id="Repeatable-Read"><a href="#Repeatable-Read" class="headerlink" title="Repeatable Read"></a>Repeatable Read</h2><p>锁定已经读取的数据，当前事务提前其他事务不允许修改。</p>
<ul>
<li>避免了“脏读”、“不可重复读取”</li>
<li>不能避免“幻读”</li>
<li>带来了更多的性能损失</li>
</ul>
<h2 id="Serializable"><a href="#Serializable" class="headerlink" title="Serializable"></a>Serializable</h2><p>读取前锁定所有要读取的数据，当前事务提交前，其他事务不允许修改</p>
<ul>
<li>最严格的级别</li>
<li>事务串行执行，资源消耗最大</li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://www.cnblogs.com/badboy200800/p/12860162.html" target="_blank" rel="noopener">SQL标准定义的四个事务隔离级别</a></li>
</ul>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>SQL</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库</title>
    <url>/%E6%95%B0%E6%8D%AE%E5%BA%93.html</url>
    <content><![CDATA[<p><center></center><br><a id="more"></a></p>
<h1 id="数据库系统"><a href="#数据库系统" class="headerlink" title="数据库系统"></a>数据库系统</h1><p>数据库系统可分为3种类型：</p>
<ol>
<li>层次</li>
<li>网状</li>
<li>关系</li>
</ol>
<h1 id="完整性"><a href="#完整性" class="headerlink" title="完整性"></a>完整性</h1><a href="/sql-%E6%95%B0%E6%8D%AE%E5%AE%8C%E6%95%B4%E6%80%A7.html" title="SQL | 数据完整性">SQL | 数据完整性</a>
<ol>
<li>域完整性：指列的值域的完整性，如数据类型、格式、值域范围、是否允许空值等</li>
<li>实体完整性（Entity Integrity）：指表中行的完整性，关系的主关键字不能重复也不能取空值。</li>
<li>参照完整性（引用完整性，Referential Integrity）：基于外键与被引用主键之间的关系，确保键值在所有表中的一致性；是定义建立关系之间联系的主关键字与外部关键字引用的约束条件。</li>
<li>用户完整性（User Defined Integrity）：根据应用环境的要求和实际的需要，对某一具体应用所涉及的数据提出约束性条件。<ul>
<li>用户定义完整性主要包括：字段有效性约束、记录有效性</li>
</ul>
</li>
</ol>
<div class="note default">
            <p>要求主表中没有相关记录就不能将记录添加到相关表中，则应该在表关系中设置<strong>参照完整性</strong>。</p>
          </div>
<h1 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h1><ul>
<li>数据库管理系统的主要作用：实现数据的统一管理以及对数据库数据的一切操作</li>
</ul>
<h1 id="关系型数据库"><a href="#关系型数据库" class="headerlink" title="关系型数据库"></a>关系型数据库</h1><h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><h2 id="SQL-Server"><a href="#SQL-Server" class="headerlink" title="SQL Server"></a>SQL Server</h2><h2 id="Oracle"><a href="#Oracle" class="headerlink" title="Oracle"></a>Oracle</h2><h1 id="非关系型数据库-NoSQL"><a href="#非关系型数据库-NoSQL" class="headerlink" title="非关系型数据库 NoSQL"></a>非关系型数据库 NoSQL</h1><h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><h2 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h2><div class="note default">
            <p>与数据库管理相关的技术：</p><ul><li>RDBMS：关系型数据库管理系统</li><li>NoSQL：非关系型数据库</li><li>NewSQL：新型关系型数据库</li><li>HBase：是一个分布式的面向列的数据库</li></ul><p>与数据库管理无关的技术：</p><ul><li>Ngnix：是一个高性能的HTTP和反向<em>*</em>web服务器，同时也提供了IMAP/POP3/SMTP服务</li><li>ActiveMQ：Apache下的一个中间件</li></ul>
          </div>
<h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><ul>
<li>索引对数据插入的效率有一定的影响</li>
<li>对于数据重复度高，值范围有限的列如果建索引建议使用位图索引</li>
<li>可以在多个列上建立<strong>联合索引</strong></li>
<li>当用户查询索引字段时，索引可以快速地执行检索操作，借助索引，在执行查询的时候不需要扫描整个表就可以快速地找到所需要的数据</li>
<li>创建索引和维护索引要耗费时间、空间，当对表中的数据进行增加、删除和修改的时候，会降低数据的维护速度</li>
<li>建立索引是为了让检索查询的过程更快捷方便</li>
</ul>
<div class="note default">
            <p>适合建立索引的字段：</p><ul><li>外键字段</li><li>主键字段</li><li>在where子句中的字段</li></ul>
          </div>
<p>在一个表中，可以建立：</p>
<ul>
<li>多个普通索引</li>
<li>多个唯一索引</li>
<li>多个候选索引</li>
<li>一个主索引</li>
</ul>
<h2 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h2><ul>
<li>通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性</li>
<li>MySQL中一张表可以有多个唯一索引</li>
<li>唯一性索引并不一定是主键；唯一性索引列允许空值，而主键列不允许为空值</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:left">唯一索引</th>
<th style="text-align:left">主键</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">本质</td>
<td style="text-align:left">索引</td>
<td style="text-align:left">约束</td>
</tr>
<tr>
<td style="text-align:center">数目</td>
<td style="text-align:left">可以有多个</td>
<td style="text-align:left">只能有一个</td>
</tr>
<tr>
<td style="text-align:center">关系</td>
<td style="text-align:left">唯一性索引并不一定就是主键</td>
<td style="text-align:left">主键一定包含一个唯一性索引</td>
</tr>
<tr>
<td style="text-align:center">引用</td>
<td style="text-align:left">不能被其他表引用为外键</td>
<td style="text-align:left">可以被其他表引用为外键</td>
</tr>
</tbody>
</table>
</div>
<h2 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h2><ul>
<li>B+树的最低层用的是双向链表结构</li>
</ul>
<div class="note default">
            <p>为什么B+树适合数据库索引？</p><ul><li>B+树的磁盘读写代价更低</li><li>B+树的内部结点没有指向关键字具体信息的指针，因此其内部结点相对B树更小</li><li>B+树的查询效率更加稳定</li></ul>
          </div>
<p>为什么不用红黑树、B树、Hash表来做索引？</p>
<ul>
<li>红黑树虽然是一棵自平衡树，且性能优秀，但随着数据量的急速增加，树的高度也在激素地增加。每一层加载判断会先进行IO操作，IO非常耗时，因此不用红黑树来做数据库的索引</li>
<li>B树虽然可以控制层数（即IO操作的次数），但其将数据都存储在了结点上，这样大大增加了一次IO读取数据的数量（一般一次为16k一个结点 效率是最高的）。而且B树不能进行范围查找</li>
<li>Hash表的查找很优秀，增删改查时间复杂度都可以在常数时间内去完成（时间复杂度为$O(1)$），对于查找单个数据操作的Hash表性能是优秀的，但Hash表不适合用于范围查找</li>
</ul>
<div class="note default">
            <p>关于数据库索引，以下说法错误的是？</p><ul><li>针对某些字段建立索引，能够有效的减少相关数据库表的磁盘空间占用（×）</li><li>针对某些字段建立索引，能够有效的提升相关字段的读与写的效率（×）</li><li>常见数据库管理系统，通常使用hash表来存储索引（×，应该是B+树）</li><li>索引是为了提高查询效率的，通过建立索引查询效率会得到提高（×）</li><li>唯一索引是一种特殊的索引，表中的行的物理顺序与索引顺序一致，且不允许两行数据在索引列上有相同的值（×，唯一索引的列的物理顺序并不和索引顺序一致，只有聚集索引列的物理顺序和逻辑顺序一致，一个表也只能有一个聚集索引）</li><li>数据库索引的存在，可能导致相关字段删除的效率降低（√，因为删除相关字段需要动态维护索引）</li></ul>
          </div>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1>]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL Server</title>
    <url>/SQL-Server.html</url>
    <content><![CDATA[<p><center>SQL Server相关知识</center><br><a id="more"></a></p>
<h1 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h1><h2 id="INTO"><a href="#INTO" class="headerlink" title="INTO"></a>INTO</h2><p><code>SELECT INTO FROM ...</code>和<code>INSERT INTO SELECT ... FROM ...</code>都是用于复制表，但二者存在区别：</p>
<ul>
<li><code>SELECT INTO FROM</code>要求目标表不存在<ul>
<li>若目标表已存在，则会提示错误</li>
<li>若目标表不存在，则语句执行成功，并在目标表中将原有的标识列自动设为标识列</li>
</ul>
</li>
<li><code>INSERT INTO FROM</code>要求目标表存在</li>
</ul>
<blockquote>
<p>MySQL不支持<code>SELECT INTO FROM</code></p>
</blockquote>
<ul>
<li><a href="https://www.nowcoder.com/questionTerminal/5d6b5a80e83b4328938352423e7123c8" target="_blank" rel="noopener">相关题目</a></li>
</ul>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>ACCESS</title>
    <url>/ACCESS.html</url>
    <content><![CDATA[<p><center>ACCESS相关知识</center><br><a id="more"></a></p>
<h1 id="窗体控件"><a href="#窗体控件" class="headerlink" title="窗体控件"></a>窗体控件</h1><ul>
<li><strong>文本框</strong>：用来输入或编辑数据</li>
<li><strong>标签</strong>：用来显示一些说明文字</li>
<li><strong>图形</strong>：用来显示指定的图形</li>
<li><strong>命令按钮</strong>：用来提供给用户单击的按钏型控件</li>
</ul>
<h1 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h1><p>ACCESS窗体的视图有：</p>
<ul>
<li>窗体视图</li>
<li>数据表视图</li>
<li>设计视图</li>
<li>数据透视表视图</li>
<li>数据透视图视图</li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1>]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Feature Engineering | 特征缩放</title>
    <url>/%E7%AE%97%E6%B3%95-%E7%89%B9%E5%BE%81%E5%BD%92%E4%B8%80%E5%8C%96.html</url>
    <content><![CDATA[<p><center>Feature Sacling</center><br><a id="more"></a></p>
<h1 id="特征缩放"><a href="#特征缩放" class="headerlink" title="特征缩放"></a>特征缩放</h1><p>特征缩放（Feature Scaling）：将自变量或特征归一化的方法；通常属于数据挖掘中的数据预处理部分。</p>
<p>包括4种方法：</p>
<ol>
<li>Rescaling （min-max normalization，最大最小归一化）</li>
<li>Mean normalization（均值归一化）</li>
<li>Standardization 标准化（Z-score normalization，Z-分值归一化）</li>
<li>Scaling to unit length（缩放成单位长度）</li>
</ol>
<h1 id="归一化-标准化"><a href="#归一化-标准化" class="headerlink" title="归一化/标准化"></a>归一化/标准化</h1><p>对数值类型的特征做归一化可以将所有的特征都统一到一个大致相同的数值区间内。</p>
<h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ol>
<li>把数据变为 [0,1] 之间的小数</li>
<li>把有量纲表达式变为无量纲表达式</li>
</ol>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>最常用的方法主要有：</p>
<ol>
<li>线性函数归一化（min-max normalization，最大最小归一化）</li>
<li>零均值标准化</li>
</ol>
<h3 id="线性函数归一化"><a href="#线性函数归一化" class="headerlink" title="线性函数归一化"></a>线性函数归一化</h3><p>线性函数归一化（min-max normalization，最大最小归一化）：对原始数据进行线性变换，使结果映射到[0, 1]的范围，实现对原始数据的等比缩放。</p>
<script type="math/tex; mode=display">x^* = \frac{x-x_{min}}{x_{max}-x_{min}}</script><p>其中：</p>
<ul>
<li>$x$是原始数据</li>
<li>$x^*$是归一化后的数据</li>
<li>$x_{max}$是原始数据的最大值</li>
<li>$x_{min}$是原始数据的最小值</li>
</ul>
<p>如果将数据“归一化”转换为任意区间 [a,b] 的数据，则相应的转换公式如下：</p>
<script type="math/tex; mode=display">x^* = a + \frac{x-x_{min}}{x_{max}-x_{min}}\times(b-a)</script><p>此时，$\max{(x^{*})}=b$ 且 $\min{(x^{*})}=a$。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Python</span></span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> MinMaxScaler()</span><br><span class="line"></span><br><span class="line"><span class="comment">## 变换后的数据，最小值为0，最大值为1</span></span><br><span class="line">min_max_scaler = MinMaxScaler()</span><br><span class="line">data_minmax = min_max_scaler.fit_transform(original_data)</span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">normalization</span><span class="params">(data)</span>:</span></span><br><span class="line">    _range = np.max(data) - np.min(data)</span><br><span class="line">    <span class="keyword">return</span> (data - np.min(data)) / _range</span><br><span class="line"></span><br><span class="line"><span class="comment">## 变换后的数据，最小值为a，最大值为b</span></span><br><span class="line">min_max_scaler = MinMaxScaler(feature_range=(a, b))</span><br><span class="line">data_minmax = min_max_scaler.fit_transform(original_data)</span><br><span class="line"><span class="comment">## 等价于</span></span><br><span class="line"><span class="comment">## data_std = (data - data.min(axis=0)) / (data.max(axis=0) - data.min(axis=0))</span></span><br><span class="line"><span class="comment">## data_scaled = a + data_std * (b - a)</span></span><br></pre></td></tr></table></figure>
<h3 id="零均值标准化"><a href="#零均值标准化" class="headerlink" title="零均值标准化"></a>零均值标准化</h3><p>零均值归一化（Z-score standardization）：将数据缩放到均值为0、方差为1的数据。</p>
<script type="math/tex; mode=display">z=\frac{x-\mu}{\sigma}</script><p>其中：</p>
<ul>
<li>$x$是原始数据</li>
<li>$\mu$是原始数据的均值</li>
<li>$\sigma$是原始数据的标准差</li>
</ul>
<p>这种归一化方法要求原始数据近似服从高斯分布。</p>
<p>对任意数据，标准化后的数据的分布并不一定是标准正态分布；标准化后的数据取决于原始数据是什么分布</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Python</span></span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> scale</span><br><span class="line">data_scaled = scale(data)</span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> StandardScaler</span><br><span class="line">scaler = StandardScaler(copy=<span class="literal">True</span>, with_mean=<span class="literal">True</span>, with_std=<span class="literal">True</span>).fit(data)</span><br><span class="line">data_scaled = scaler.transform(data)</span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">standardization</span><span class="params">(data)</span>:</span></span><br><span class="line">    mu = np.mean(data, axis=<span class="number">0</span>)</span><br><span class="line">    sigma = np.std(data, axis=<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> (data - mu) / sigma</span><br></pre></td></tr></table></figure>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment">## R语言</span></span><br><span class="line">scale(data, center = <span class="literal">T</span>, scale = <span class="literal">T</span>)</span><br><span class="line"><span class="comment">## center默认为T（True），表示数据中心化</span></span><br><span class="line"><span class="comment">## scale默认为T（True），表示数据标准化</span></span><br></pre></td></tr></table></figure>
<h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><ol>
<li>提升模型的收敛速度<blockquote>
<p>如梯度下降法中，步长不至于太大，提高迭代速度</p>
</blockquote>
</li>
<li>提升模型的精度<ul>
<li>在一些涉及到距离计算的算法中效果显著。</li>
<li>如某算法涉及欧式距离的计算，归一化后的数据取值范围较小，其计算出来的距离对结果的影响比归一化之前的距离对结果的影响更小，提高模型的精度</li>
</ul>
</li>
<li>归一化可以让不同维度之间的特征在数值上具有一定可比性</li>
</ol>
<h2 id="需要归一化-标准化的情况"><a href="#需要归一化-标准化的情况" class="headerlink" title="需要归一化/标准化的情况"></a>需要归一化/标准化的情况</h2><ol>
<li>有些模型在各个维度进行不均匀伸缩后，最优解与原来不等价<ul>
<li><a href="/%E7%AE%97%E6%B3%95-SVM.html" title="SVM（支持向量机）">SVM（支持向量机）</a></li>
</ul>
</li>
<li>有些模型在各个维度进行不均匀伸缩后，最优解与原来等价；但是归一化有助于加快<strong>梯度下降法</strong>的迭代速度、加快收敛速度，所以最好也事先将数据归一化/标准化<ul>
<li><a href="/%E7%AE%97%E6%B3%95-%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92.html" title="线性回归">线性回归</a></li>
<li><a href="/%E7%AE%97%E6%B3%95-LogisticRegression.html" title="逻辑回归">逻辑回归</a></li>
<li>神经网络</li>
</ul>
</li>
<li>效果强烈依赖于特征是否归一化的模型/优化方法<ul>
<li><a href="/%E7%AE%97%E6%B3%95-SVM.html" title="SVM（支持向量机）">SVM（支持向量机）</a></li>
<li>神经网络</li>
<li>SGD（Stochastic Gradient Descent，随机梯度下降）</li>
<li>PCA（主成分分析）</li>
</ul>
</li>
</ol>
<h2 id="不需要归一化-标准化的情况"><a href="#不需要归一化-标准化的情况" class="headerlink" title="不需要归一化/标准化的情况"></a>不需要归一化/标准化的情况</h2><ol>
<li>0/1取值的特征<ul>
<li>归一化会破坏0/1取值特征的稀疏性</li>
</ul>
</li>
<li>不受归一化影响的模型/方法<ul>
<li><a href="/%E7%AE%97%E6%B3%95-DecisionTree.html" title="决策树（Decision Tree）">决策树（Decision Tree）</a></li>
<li>最小二乘法OLS（基于平方损失）</li>
</ul>
</li>
</ol>
<div class="note default">
            <p>归一化对决策树模型并不适用。<br>以C4.5为例，决策树在进行节点分裂时，主要依据数据集D关于特征a的信息增益比，而信息增益比跟特征是否经过归一化是无关的，因为归一化并不会改变样本在特征a上的信息增益。</p>
          </div>]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>特征</tag>
      </tags>
  </entry>
  <entry>
    <title>TED | How to Outsmart the Prisoner&#39;s Dilemma</title>
    <url>/TED-HowToOutsmart.html</url>
    <content><![CDATA[<p><center></center><br><a id="more"></a></p>
<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>TED栏目初衷 → <a href="/TED-TrySomethingNewfor30days.html" title="Try Something New for 30 Days">Try Something New for 30 Days</a></p>
<p>原计划每周听2~3个TED视频，奈何三次元太忙了，无限鸽……<br>就争取每周听1个吧~</p>
<p>Last → <a href="/TED-5WaystoCreateStrongerConnections.html" title="5 Ways to Create Stronger Connections">5 Ways to Create Stronger Connections</a></p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<h1 id="How-to-Outsmart-the-Prisoner’s-Dilemma"><a href="#How-to-Outsmart-the-Prisoner’s-Dilemma" class="headerlink" title="How to Outsmart the Prisoner’s Dilemma"></a>How to Outsmart the Prisoner’s Dilemma</h1><ul>
<li><a href="https://www.ted.com/talks/lucas_husted_how_to_outsmart_the_prisoner_s_dilemma/transcript#t-7138" target="_blank" rel="noopener">How to Outsmart the Prisoner’s Dilemma</a></li>
<li>2020.09.02</li>
</ul>
<p>Two perfectly rational <strong>gingerbread</strong>(姜饼) men, Crispy and Chewy, are out <strong>strolling</strong> when they caught by a fox. Seeing how happy they are, he decides that, instead <strong>of</strong> simply eating them, he<strong>‘ll</strong> put their friendship <del>into</del> <strong>to the</strong> <del>a</del> test with a cruel dilemma. He<strong>‘ll</strong> ask<del>s</del> each <strong>gingerbread</strong> man whether he<strong>‘d opt</strong> <del>ask</del> to spare or scarifice the other. They can discuss, but neither will know that the other chose until their decisions are locked in.</p>
<p>If both choose to spare the other, the fox will eat just one of each of their legs. If one choose<strong>s</strong> to spare while the other sacrifices, the sparer will fully eaten while the <strong>traitor</strong> will run away with all his limbs <del>intack</del> <strong>intact</strong>(完整的). Finally, if both choose to scarifice, <del>then</del> the fox will eat three limbs from each. </p>
<p>In game theory, the scenario is called Prisoner’s Dilemma. To figure out how these <strong>gingerbread men will</strong> act their perfect <del>way</del> <strong>rationality</strong>, we can map <del>these</del> <strong>the</strong> outcomes of each decision. The rows represents Crispy’s choices, <strong>and</strong> the columns are Chewys’. Meanwhile, the number<strong>s</strong> in each cell represent<del>s</del> outcomes of their decisions, as measured in the number of limbs each <del>will</del> <strong>would</strong> keep. So, do we expect their friendship to last the game?</p>
<p>First, let’s consider Chewy’s options. If Crispy spares him, Chewy can run away <del>scar free</del> <strong>scot-free</strong> by sacrificing Crispy. But if Crispy <del>sacrificing</del> <strong>scacrifes</strong> him, Chewy can keep one of his limbs if he also scarifices Crispy. No matter what Crispy decides, Chewy always experiences the best outcome by choosing <strong>to</strong> sacrifice his companion. The same is true for Crispy. </p>
<p>This is the standard conclusion of <strong>the</strong> Prisoner’s Dilemma: the <strong>two characters</strong> will betray one the other. Their strategy to <strong>unconditionally</strong> scarifice their companion is what game <del>theory</del> <strong>theorists</strong> called the Nash Equilibrium, meaning that neither can gain by deviating from it. </p>
<p>Crispy and Chewy act accordingly, and the <del>smart</del> <strong>smug</strong>(沾沾自喜的，自满的) fox runs off <strong>with a belly full of gingerbread,</strong> <del>the</del> leaving the two former friends with just one leg to stand <del>off</del> <strong>on</strong>.</p>
<p>Normally, this is where the story would end, but a wizard(巫师) happen<strong>ed</strong> to <strong>be</strong> watch<strong>ing</strong> the whold <strong>mess</strong> unfold. He tells Crispy and Chewy <strong>that</strong>, as punishment for betray<strong>ing</strong> each other, they<strong>‘re doomed</strong> to repeat this dilemma for the rest of their lives, starting with all <del>full</del> <strong>four</strong> limbs at each sunrise. Now what happens?</p>
<p>This called <del>the</del> <strong>an</strong> Infinite Prisoner’s Dilemma. And it is a <del>little</del> <strong>literal game changer</strong> , that<strong>‘s</strong> because <del>of</del> the <strong>gingerbread</strong> men  <strong>can</strong> now use their future decisions as bargaining <strong>chips</strong> <del>chess</del> for the present <strong>ones</strong> <del>points</del>. Consider this strategy: both agree to spare each other everyday. If one <strong>ever</strong> chooses to scarifice, the other will <strong>retaliate</strong> <del>entirely eat</del> by <strong>choosing</strong> <del>the</del> scarifice<del>r</del> for the rest of <del>the</del> <strong>eternity</strong>(来世，来生) . So is that enough to get <del>this</del> <strong>these</strong> poor <strong>sentient</strong>(有意识的，有感情的) goods to agree to cooperate?</p>
<p>To figure that out, we have to <strong>factor in</strong> another consideration: the <strong>gingerbread</strong> men probably care about the future less than they care about the present. In other words, they might discount how much they care about their future limbs by some number<del>s</del>, which we’ll call delta. This is similiar to the idea of inflation <del>you rolling you of your</del> <strong>eroding the value of</strong> money. If delta is one half, on day 1, they care about day 2 limbs half as much as day 1 limbs, day 3 limbs one quarter as much as day 1 limbs, and so on. </p>
<p>A delta of zero means <strong>that</strong> they don’t care about their future limbs at all, so <del>that would</del> <strong>they’ll</strong> repeat their initial choice<del>s</del> of mutual scarifice endlessly. But as delta approaches 1, they’ll do anything possible to avoid <strong>the</strong> pain of infinite trible limbs consumption, which means they will choose to spare each other. At some point in between, they would go either way. We can find out where that point is by <del>write</del> <strong>writing</strong> the <del>theory</del> <strong>infinite series that</strong> represents each strategy, setting them equal to each other and solve for delta. </p>
<p>That <del>is</del> <strong>yields</strong> one third, meaning that <strong>as long as</strong> Crispy and Chewy care about tomorrow at leat one third as much as today, <strong>it’s</strong> <del>is</del> optimal for them to spare and cooperate forever.</p>
<p>This analysis isn’t <strong>unique</strong> to cookies and wizards, you see it play out in real-life situations, like trade negotiations <strong>and</strong> international politics. Rational leader<strong>s</strong> must assume<del>d,</del> <strong>that</strong> the decision<strong>s</strong> they make today will impact those <strong>of their adversaries</strong> <del>they</del>  tomorrow. <del>Scarifice</del> <strong>Selfishness</strong> may <del>be for</del> <strong>win out in the short-term</strong> <del>shorten</del>, but with <del>probable incentence</del> <strong>with the proper incentives</strong>, <strong>peaceful</strong> cooperation is not only possible but <strong>demonstrably</strong> and mathematical<strong>ly</strong> idea<strong>l</strong>. </p>
<p>As for the <strong>gingerbread</strong> men, <del>they will</del> <strong>their eternity</strong> maybe pretty <strong>crumby,</strong> but <strong>so long as</strong> they go out on a limb, their friendship will never again be half-baked.</p>
]]></content>
      <categories>
        <category>Everything</category>
      </categories>
      <tags>
        <tag>TED</tag>
        <tag>English</tag>
      </tags>
  </entry>
  <entry>
    <title>Data Scientist | Spark 数据源</title>
    <url>/Spark-%E6%95%B0%E6%8D%AE%E6%BA%90.html</url>
    <content><![CDATA[<p><center>data source</center><br><a id="more"></a></p>
<h1 id="数据源"><a href="#数据源" class="headerlink" title="数据源"></a>数据源</h1><h2 id="核心数据源"><a href="#核心数据源" class="headerlink" title="核心数据源"></a>核心数据源</h2><p>Spark的6大核心数据源：</p>
<ul>
<li>CSV</li>
<li>JSON</li>
<li>Parquet</li>
<li>ORC</li>
<li>JDBC/ODBC连接</li>
<li>纯文本文件</li>
</ul>
<h2 id="由社区创建的数据源"><a href="#由社区创建的数据源" class="headerlink" title="由社区创建的数据源"></a>由社区创建的数据源</h2><ul>
<li>Cassandra</li>
<li>HBase</li>
<li>MongoDB</li>
<li>AWS Redshift</li>
<li>XML</li>
<li>其他</li>
</ul>
<h1 id="数据源API"><a href="#数据源API" class="headerlink" title="数据源API"></a>数据源API</h1><h2 id="Read-API"><a href="#Read-API" class="headerlink" title="Read API"></a>Read API</h2><p>读取数据的核心结构：<code>DataFrameReader.format(...).option(&quot;key&quot;, &quot;value&quot;).schema(...).load()</code></p>
<ul>
<li><code>format()</code>：可选，默认情况下Spark将使用Parquet格式</li>
<li><code>option()</code>：配置键值对来参数化读取数据的方式</li>
</ul>
<p>Spark数据读取使用<code>DataFrameReader</code>，通过SparkSession的read属性得到<br><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="module-access"><span class="module"><span class="identifier">Spark</span>.</span></span>read</span><br></pre></td></tr></table></figure></p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 例子</span></span><br><span class="line"><span class="selector-tag">spark</span><span class="selector-class">.read</span><span class="selector-class">.format</span>(“csv")</span><br><span class="line">    <span class="selector-class">.option</span>(“mode<span class="string">", “FAILFAST"</span>)  <span class="comment">// 读取模式</span></span><br><span class="line">    <span class="selector-class">.option</span>(“inferSchema<span class="string">", “true"</span>)  <span class="comment">// 使用模式推理</span></span><br><span class="line">    <span class="selector-class">.option</span>(“path<span class="string">", “path/to/file(s)"</span>)  <span class="comment">// 设置路径</span></span><br><span class="line">    <span class="selector-class">.schema</span>(someSchema)  <span class="comment">// 模式</span></span><br><span class="line">    <span class="selector-class">.load</span>()</span><br></pre></td></tr></table></figure>
<h3 id="读取模式"><a href="#读取模式" class="headerlink" title="读取模式"></a>读取模式</h3><p>读取模式指定当Spark遇到错误格式的记录时应采取的操作</p>
<ul>
<li>默认是<code>permissive</code></li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">读取模式</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>permissive</code></td>
<td style="text-align:left">遇到错误格式的记录时，将所有字段设置为null并将所有错误格式的记录放在名为<code>_corrupt_record</code>字符串列中</td>
</tr>
<tr>
<td style="text-align:center"><code>dropMalformed</code></td>
<td style="text-align:left">删除包含错误格式记录的行</td>
</tr>
<tr>
<td style="text-align:center"><code>failFast</code></td>
<td style="text-align:left">遇到错误格式的记录后，立即返回失败</td>
</tr>
</tbody>
</table>
</div>
<h2 id="Write-API"><a href="#Write-API" class="headerlink" title="Write API"></a>Write API</h2><p>写数据的核心结构：<br><code>DataFrameWriter.format(...).option(...).partitionBy(...).bucketBy(...).sortBy(...).save()</code></p>
<ul>
<li><code>format()</code>：可选，默认情况下Spark将使用Parquet格式</li>
<li><code>option()</code>：配置写出数据的方式</li>
<li><code>PartitionBy</code>、<code>bucketBy</code>、<code>sortBy</code>仅适用基于文件的数据源</li>
</ul>
<p>Spark的写数据使用<code>DataFrameWriter</code>，通过DataFrame的write属性来获取DataFrameWriter：<br><figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">dataFrame.<span class="built_in">write</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in Scala</span></span><br><span class="line"><span class="comment">// in Scala</span></span><br><span class="line">dataframe.write.format(“<span class="string">csv")</span></span><br><span class="line"><span class="string">    .option(“mode"</span>, “<span class="type">OVERWRITE</span><span class="string">")  // 保存模式</span></span><br><span class="line"><span class="string">    .option(“dateFormat"</span>, “yyyy-<span class="type">MM</span>-<span class="string">dd")</span></span><br><span class="line"><span class="string">    .option(“path"</span>, “path/to/file(s)<span class="string">")</span></span><br><span class="line"><span class="string">    .save()</span></span><br></pre></td></tr></table></figure>
<h3 id="保存模式"><a href="#保存模式" class="headerlink" title="保存模式"></a>保存模式</h3><p>保存模式指明如果Spark在指定目标路径发现有其他数据占用时应采取的操作。</p>
<ul>
<li>默认是<code>errorIfExists</code></li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">保存模式</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>append</code></td>
<td style="text-align:left">将输出文件追加到目标路径已存在的文件上或目录的文件列表</td>
</tr>
<tr>
<td style="text-align:center"><code>overwrite</code></td>
<td style="text-align:left">将完全覆盖目标路径中已存在的任何数据</td>
</tr>
<tr>
<td style="text-align:center"><code>errorIfExists</code></td>
<td style="text-align:left">如果目标路径已存在数据或文件，则抛出错误并返回写入操作失败</td>
</tr>
<tr>
<td style="text-align:center"><code>Ignore</code></td>
<td style="text-align:left">如果目标路径已存在数据或文件，则不执行任何操作</td>
</tr>
</tbody>
</table>
</div>
<h1 id="核心数据源-1"><a href="#核心数据源-1" class="headerlink" title="核心数据源"></a>核心数据源</h1><h2 id="CSV"><a href="#CSV" class="headerlink" title="CSV"></a>CSV</h2><p>逗号分隔值（CSV，comma-separated values），一种常见的文本文件格式；每行表示一条记录，用逗号分隔记录中的每个字段</p>
<ul>
<li>是最难处理的文件格式之一</li>
</ul>
<p><strong>CSV数据源选项</strong>：</p>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: center;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: center;">
      <th>读取/写入</th>
      <th>Key</th>
      <th>取值范围</th>
      <th>默认值</th>
      <th>说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="5">Read</th>
      <td>escapeQuotes</td>
      <td>true, false</td>
      <td>true</td>
      <td>声明Spark是否应该转义在行中找到的引号</td>
    </tr>
    <tr>
      <td>maxColumns</td>
      <td>任意整数</td>
      <td>20480</td>
      <td>声明文件中的最大列数</td>
    </tr>
    <tr>
      <td>maxCharsPerColumn</td>
      <td>任意整数</td>
      <td>1000000</td>
      <td>声明列中的最大字符数</td>
    </tr>
    <tr>
      <td>maxMalformedLogPerPartition</td>
      <td>任意整数</td>
      <td>10</td>
      <td>设置Spark将为每个分区记录错误格式的行的最大数目，超出此数目的格式错误的记录将被忽略</td>
    </tr>
    <tr>
      <td>multiline</td>
      <td>true, false</td>
      <td>false</td>
      <td>此选项用于读取多行CSV文件，其中CSV文件中的每个逻辑行可能跨越文件本身中的多行</td>
    </tr>
    <tr>
      <th>Write</th>
      <td>quoteAll</td>
      <td>true, false</td>
      <td>false</td>
      <td>指定是否将所有值括在引号中，而不是仅转义具有引号字符的值</td>
    </tr>
    <tr>
      <th rowspan="13">Read & Write</th>
      <td>Compression 或 codec</td>
      <td>None, uncompressed, bzip2, deflate, gzip, lz4, snappy</td>
      <td>none</td>
      <td>声明Spark应该使用什么压缩编码器来读取或写入文件</td>
    </tr>
    <tr>
      <td>dateFormat</td>
      <td>任何符合Java的SimpleDataFormat式的字符串或字符</td>
      <td>yyyy-MM-dd</td>
      <td>日期类型的列的日期格式</td>
    </tr>
    <tr>
      <td>escape</td>
      <td>任意字符串字符</td>
      <td>\</td>
      <td>用于转义的字符</td>
    </tr>
    <tr>
      <td>header</td>
      <td>true, false</td>
      <td>false</td>
      <td>声明文件中的第一行是否为列的名称</td>
    </tr>
    <tr>
      <td>ignoreLeadingWhiteSpace</td>
      <td>true, false</td>
      <td>false</td>
      <td>声明是否应跳过读取值中的前导空格</td>
    </tr>
    <tr>
      <td>ignoreTrailingWhiteSpace</td>
      <td>true, false</td>
      <td>false</td>
      <td>声明是否应跳过读取值中的尾部空格</td>
    </tr>
    <tr>
      <td>inferSchema</td>
      <td>true, false</td>
      <td>false</td>
      <td>指定在读取文件时Spark是否自动推断列类型</td>
    </tr>
    <tr>
      <td>nanValue</td>
      <td>任意字符串字符</td>
      <td>NaN</td>
      <td>声明在CSV文件中表示NaN或缺失字符的字符</td>
    </tr>
    <tr>
      <td>negativeInf</td>
      <td>任意字符串或字符</td>
      <td>-Inf</td>
      <td>声明什么字符表示负无穷大</td>
    </tr>
    <tr>
      <td>nullValue</td>
      <td>任意字符串字符</td>
      <td>""</td>
      <td>声明在文件中表示null值的字符</td>
    </tr>
    <tr>
      <td>positiveInf</td>
      <td>任意字符串或字符</td>
      <td>Inf</td>
      <td>声明什么字符表示正无穷大</td>
    </tr>
    <tr>
      <td>sep</td>
      <td>任意单个字符串字符</td>
      <td>,</td>
      <td>用作每个字段和值的分隔符的单个字符</td>
    </tr>
    <tr>
      <td>timestampFormat</td>
      <td>任何符合Java的SimpleDataFormat的字符串或字符</td>
      <td>MMdd HH:mm:ss.SSSZZ</td>
      <td>时间戳类型时间戳格式</td>
    </tr>
    <tr>
  </tr></tbody>
</table>
</div>

<ul>
<li>通常，Spark只会在作业执行而不是DataFrame定义时发生失败</li>
</ul>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in Scala </span></span><br><span class="line"><span class="comment">// 读取CSV文件</span></span><br><span class="line">spark.read.format(<span class="string">"csv"</span>)  <span class="comment">// 指定format格式为csv</span></span><br><span class="line">  .option(<span class="string">"header"</span>, <span class="string">"true"</span>)</span><br><span class="line">  .option(<span class="string">"mode"</span>, <span class="string">"FALIFAST"</span>)</span><br><span class="line">  .option(<span class="string">"inferSchema"</span>, <span class="string">"true"</span>)</span><br><span class="line">  .load(<span class="string">"some/path/to/file.csv"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以创建schema以确保文件符合我们所期望的数据</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.sql.types.&#123;<span class="type">StructField</span>, <span class="type">StructType</span>, <span class="type">StringType</span>, <span class="type">LongType</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> myManualSchema = <span class="keyword">new</span> <span class="type">StructType</span>(<span class="type">Array</span>(</span><br><span class="line">  <span class="keyword">new</span> <span class="type">StructField</span>(<span class="string">"DEST_COUNTRY_NAME"</span>, <span class="type">StringType</span>, <span class="literal">true</span>),</span><br><span class="line">  <span class="keyword">new</span> <span class="type">StructField</span>(<span class="string">"ORIGIN_COUNTRY_NAME"</span>, <span class="type">StringType</span>, <span class="literal">true</span>),</span><br><span class="line">  <span class="keyword">new</span> <span class="type">StructField</span>(<span class="string">"count"</span>, <span class="type">LongType</span>, <span class="literal">false</span>)</span><br><span class="line">))</span><br><span class="line">spark.read.format(<span class="string">"csv"</span>)</span><br><span class="line">  .option(<span class="string">"header"</span>, <span class="string">"true"</span>)</span><br><span class="line">  .option(<span class="string">"mode"</span>, <span class="string">"FAILFAST"</span>)</span><br><span class="line">  .option(myManualSchema)</span><br><span class="line">  .load(<span class="string">"some/path/to/file.csv"</span>)</span><br><span class="line">  .show(<span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in Scala </span></span><br><span class="line"><span class="comment">// 读取CSV文件</span></span><br><span class="line"><span class="keyword">val</span> csvFile = spark.read.format(“<span class="string">csv")</span></span><br><span class="line"><span class="string">  .option(“header"</span>, “<span class="string">true").option(“mode"</span>, “<span class="type">FAILFAST</span><span class="string">").schema(myManualSchema)</span></span><br><span class="line"><span class="string">  .load(“/data/flight-data/csv/2010-summary.csv"</span>)</span><br><span class="line"><span class="comment">// 将CSV文件内容写入TSV文件</span></span><br><span class="line">csvFile.write.format(<span class="string">"csv"</span>)</span><br><span class="line">  .mode(<span class="string">"overwrite"</span>)</span><br><span class="line">  .option(<span class="string">"sep"</span>, <span class="string">"\t"</span>)</span><br><span class="line">  .save(<span class="string">"/tmp/my-tsv-file.tsv"</span>)</span><br><span class="line"><span class="comment">// my-tsv-file.tsv实际是一个包含大量文件的文件夹</span></span><br></pre></td></tr></table></figure>
<p><strong>制表符分隔值</strong>（TSV，Tab-separated values）</p>
<ul>
<li>每一行储存一条记录</li>
<li>每条记录的各个字段间以制表符作为分隔</li>
</ul>
<h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><p>JSON（JavaScript Object Notation）</p>
<ul>
<li>Spark中的JSON文件指的是换行符分隔的JSON，每行必须包含一个单独的、独立的有效JSON对象</li>
<li>使用换行符分隔的JSON可以在文件末尾追加新记录</li>
<li>JSON对象具有结构化信息</li>
<li>当<code>multiLine</code>为<code>true</code>时，可以将整个JSON文件作为一个JSON对象读取</li>
</ul>
<p><strong>JSON数据源选项</strong>：</p>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: center;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: center;">
      <th>读取/写入</th>
      <th>Key</th>
      <th>取值范围</th>
      <th>默认值</th>
      <th>说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="3">Read & Write</th>
      <td>Compression 或 codec</td>
      <td>None, uncompressed, bzip2, deflate, gzip, lz4, snappy</td>
      <td>none</td>
      <td>声明Spark应该使用什么压缩编码器来读取或写入文件</td>
    </tr>
    <tr>
      <td>dateFormat</td>
      <td>任何符合Java的SimpleDataFormat式的字符串或字符</td>
      <td>yyyy-MM-dd</td>
      <td>日期类型的列的日期格式</td>
    </tr>
    <tr>
      <td>timestampFormat</td>
      <td>任何符合Java的SimpleDataFormat的字符串或字符</td>
      <td>MMdd HH:mm:ss.SSSZZ</td>
      <td>时间戳类型时间戳格式</td>
    </tr>
    <tr>
      <th rowspan="8">Read</th>
      <td>allowComments</td>
      <td>true, false</td>
      <td>false</td>
      <td>忽略JSON记录中的Java/C++样式注释</td>
    </tr>
    <tr>
      <td>allowBackslashEscAPIngAny</td>
      <td>true, false</td>
      <td>false</td>
      <td>是否允许反斜杠机制接收所有字符</td>
    </tr>
    <tr>
      <td>allowNumericLeadingZeros</td>
      <td>true, false</td>
      <td>false</td>
      <td>是否允许数字中存在前导零</td>
    </tr>
    <tr>
      <td>allowSingleQuotes</td>
      <td>true, false</td>
      <td>true</td>
      <td>除双引号外，是否允许使用单引号</td>
    </tr>
    <tr>
      <td>allowUnquotedFieldNames</td>
      <td>true, false</td>
      <td>false</td>
      <td>允许不带引号的JSON字段名</td>
    </tr>
    <tr>
      <td>columnNameOfCorruptRecord</td>
      <td>任意字符串或字符</td>
      <td>spark.sql.column & NameOfCorruptRecord</td>
      <td>允许重命名permissive模式下添加的新字段，会覆盖重写</td>
    </tr>
    <tr>
      <td>multiLine</td>
      <td>true, false</td>
      <td>false</td>
      <td>允许读取非换行符分隔的JSON文件</td>
    </tr>
    <tr>
      <td>primitiveAsString</td>
      <td>true, false</td>
      <td>false</td>
      <td>将所有原始值推断为字符串类型</td>
    </tr>
    <tr>
  </tr></tbody>
</table>
</div>

<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in Scala </span></span><br><span class="line"><span class="comment">// 读取换行符分隔的JSON文件</span></span><br><span class="line">spark.read.format(<span class="string">"json"</span>)</span><br><span class="line"></span><br><span class="line">spark.read.format(“<span class="string">json")</span></span><br><span class="line"><span class="string">  .option(“mode"</span>, “<span class="type">FAILFAST</span><span class="string">")</span></span><br><span class="line"><span class="string">  .schema(myManualSchema)</span></span><br><span class="line"><span class="string">  .load(“/data/flight-data/json/2010-summary.json"</span>).show(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将CSV文件内容写入JSON文件</span></span><br><span class="line">csvFile.write.format(“<span class="string">json")</span></span><br><span class="line"><span class="string">  .mode(“overwrite"</span>)</span><br><span class="line">  .save(“/tmp/my-json-file.<span class="string">json")</span></span><br></pre></td></tr></table></figure>
<ul>
<li>将DataFrame写入JSON文件：每个数据分片作为一个文件写出，整个DataFrame将输出到一个文件夹；文件中的每行仍代表一个JSON对象</li>
</ul>
<h2 id="Parquet文件"><a href="#Parquet文件" class="headerlink" title="Parquet文件"></a>Parquet文件</h2><p>Parquet是一种开源的面向列的数据存储格式</p>
<ul>
<li>提供了各种存储优化，尤其适合数据分析</li>
<li>提供列压缩，从而节省空间</li>
<li>支持按列读取而非读取整个文件</li>
<li>是Spark的默认文件格式</li>
<li>从Parquet文件读取比从JSON或CSV文件效率更高</li>
<li><p>支持复杂类型：列是一个数组、map映射、struct结构体，都可以正常读取和写入；而CSV文件无法存储数组列</p>
</li>
<li><p>Parquet在存储数据时执行本身的schema</p>
</li>
<li>一般在读取的时候使用默认的schema</li>
</ul>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in Scala </span></span><br><span class="line">spark.read.format(“<span class="string">parquet")</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">spark.read.format(“parquet"</span>)</span><br><span class="line">  .load(“/data/flight-data/parquet/<span class="number">2010</span>-summary.<span class="string">parquet").show(5)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>Parquet只有很少的可选项</li>
</ul>
<p><strong>Parquet数据源选项</strong>：</p>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: center;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: center;">
      <th>读取/写入</th>
      <th>Key</th>
      <th>取值范围</th>
      <th>默认值</th>
      <th>说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>Read & Write</th>
      <td>Compression 或 codec</td>
      <td>None, uncompressed, bzip2, deflate, gzip, lz4, snappy</td>
      <td>none</td>
      <td>声明Spark应该使用什么压缩编码器来读取或写入文件</td>
    </tr>
    <tr>
      <th>Read</th>
      <td>mergeSchema</td>
      <td>true, false</td>
      <td>配置值spark.sql.par.quet.mergeSchema</td>
      <td>增量地添加列到同一表/文件夹中的Parquet文件里；此选项用于启用或禁用此功能</td>
    </tr>
  </tbody>
</table>
</div>

<ul>
<li>写Parquet文件和读取Parquet文件，都只需指定文件的位置即可</li>
</ul>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in Scala </span></span><br><span class="line"><span class="comment">// 写Parquet文件</span></span><br><span class="line">csvFile.write.format(“<span class="string">parquet")</span></span><br><span class="line"><span class="string">  .mode(“overwrite"</span>)</span><br><span class="line">  .save(“/tmp/my-parquet-file.<span class="string">parquet")</span></span><br></pre></td></tr></table></figure>
<h2 id="ORC文件"><a href="#ORC文件" class="headerlink" title="ORC文件"></a>ORC文件</h2><p>ORC文件是为Hadoop作业设计的自描述、类型感知的列存储文件格式</p>
<ul>
<li>针对大型流式数据读取进行优化</li>
<li>读取ORC文件数据时没有可选项</li>
</ul>
<p><strong>ORC和Parquet有何区别？</strong></p>
<ul>
<li>在大多数情况下，二者非常相似</li>
<li>本质区别：<ul>
<li>Parquet针对Spark进行优化</li>
<li>ORC针对Hive进行优化</li>
</ul>
</li>
</ul>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in Scala </span></span><br><span class="line"><span class="comment">// 读取ORC文件</span></span><br><span class="line">spark.read.format(<span class="string">"orc"</span>)</span><br><span class="line">  .load(<span class="string">"/data/flight-data/orc/2010-summary.orc"</span>).show(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写ORC文件</span></span><br><span class="line">csvFile.write.format(<span class="string">"orc"</span>)</span><br><span class="line">  .mode(<span class="string">"overwrite"</span>)</span><br><span class="line">  .save(<span class="string">"/tmp/my-json-file.orc"</span>)</span><br></pre></td></tr></table></figure>
<h2 id="JDBC-ODBC连接"><a href="#JDBC-ODBC连接" class="headerlink" title="JDBC/ODBC连接"></a>JDBC/ODBC连接</h2><p>即从数据库读写数据</p>
<p><strong>JDBC数据源选项</strong>：</p>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: center;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: center;">
      <th>读取/写入</th>
      <th>Key</th>
      <th>取值范围</th>
      <th>默认值</th>
      <th>说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="4">Read & Write</th>
      <td>dbtable</td>
      <td>可以使用SQL查询的FROM子句中的任何有效内容</td>
      <td></td>
      <td>表示要读取的JDBC表</td>
    </tr>
    <tr>
      <td>driver</td>
      <td></td>
      <td></td>
      <td>用于连接到此URL的JDBC驱动器的类名</td>
    </tr>
    <tr>
      <td>numPartitions</td>
      <td></td>
      <td></td>
      <td>在读取和写入数据表时，数据表可用于并行的最大分区数（决定了并发JDBC连接的最大数目）</td>
    </tr>
    <tr>
      <td>url</td>
      <td></td>
      <td></td>
      <td>表明要连接的JDBC URL，可以在URL中指定特定源的连接属性<br>如：`jdbc:postgresql://localhost/test?user=fred&password=secret`</td>
    </tr>
    <tr>
      <th rowspan="5">Read</th>
      <td>batchsize</td>
      <td></td>
      <td>1000</td>
      <td>表示JDBC批处理大小，用于指定每次写入多少条记录。</td>
    </tr>
    <tr>
      <td>createTableColumnTypes</td>
      <td>有效的Spark SQL数据类型</td>
      <td></td>
      <td>表示创建表时使用的数据库列数据类型，而不使用默认值。<br>应该使用与`CREATE TABLE`列语法相同的格式来指定数据类型信息，指定的类型应是有效的Spark SQL数据类型</td>
    </tr>
    <tr>
      <td>createTableOptions</td>
      <td></td>
      <td></td>
      <td>用于在创建表时设置特定数据库的表和分区选项</td>
    </tr>
    <tr>
      <td>isolationLevel</td>
      <td>NONE, READ_COMMITED, READ_UNCOMMITTED, REPEATABLE_READ, SERIALIZABLE</td>
      <td>READ_UNCOMMITTED</td>
      <td>表示数据库的事务隔离级别（适用于当前连接）。<br>可取值分别对应于JDBC的Connection对象定义的标准事务隔离级别。</td>
    </tr>
    <tr>
      <td>truncate</td>
      <td>true, false</td>
      <td>false</td>
      <td>待补充</td>
    </tr>
    <tr>
      <th rowspan="2">Write</th>
      <td>fetchsize</td>
      <td></td>
      <td></td>
      <td>表示JDBC每次读取多少条记录</td>
    </tr>
    <tr>
      <td>partitionColumn<br>lowerBound<br>upperBound</td>
      <td></td>
      <td></td>
      <td>如果指定了其中一个选项，则必须设置其他所有选项；此外，还必须指定`numPartitions`。<br>这些属性描述了如何在从多个worker并行读取时对表格进行划分。<br>`partitionColumn`是要分区的列，必须是整数类型。<br>`lowerBound`和`upperBound`仅用于确定分区跨度，而不用于过滤表中的行（因此表中的所有行都将被划分并返回）。</td>
    </tr>
  </tbody>
</table>
</div>

<p>从数据库读取文件：先指定格式（format）和选项，然后加载数据</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in Scala </span></span><br><span class="line"><span class="keyword">val</span> driver = <span class="string">"org.sqlite.JDBC"</span></span><br><span class="line"><span class="keyword">val</span> path = <span class="string">"/data/flight-data/jdbc/my-sqlite.db"</span></span><br><span class="line"><span class="keyword">val</span> url = <span class="string">s"jdbc:sqlite:/<span class="subst">$&#123;path&#125;</span>"</span></span><br><span class="line"><span class="keyword">val</span> tablename = <span class="string">"flight_info"</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># in Python </span></span><br><span class="line">driver = <span class="string">"org.sqlite.JDBC"</span></span><br><span class="line">path = <span class="string">"/data/flight-data/jdbc/my-sqlite.db"</span></span><br><span class="line">url = <span class="string">"jdbc:sqlite:"</span> + path</span><br><span class="line">tablename = <span class="string">"flight_info"</span></span><br></pre></td></tr></table></figure>
<ul>
<li>SQLite与其他数据库不同，SQLite只是计算机上的一个文件</li>
<li><p>如果是其他数据库，需要测试连接：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in Scala </span></span><br><span class="line"><span class="comment">// 测试连接</span></span><br><span class="line"><span class="keyword">import</span> java.sql.<span class="type">DriverManager</span></span><br><span class="line"><span class="keyword">val</span> connection = <span class="type">DriverManager</span>.getConnection(url)</span><br><span class="line">connection.isClosed()</span><br><span class="line">connection.close()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果连接成功，则可继续执行下一步</span></span><br><span class="line"><span class="comment">// 从SQL表中读取DataFrame</span></span><br><span class="line"><span class="keyword">val</span> dbDataFrame = spark.read.format(<span class="string">"jdbc"</span>)</span><br><span class="line">  .option(<span class="string">"url"</span>, url)</span><br><span class="line">  .option(<span class="string">"dbtable"</span>, tablename)</span><br><span class="line">  .option(<span class="string">"driver"</span>, driver)</span><br><span class="line">  .load()</span><br></pre></td></tr></table></figure>
</li>
<li><p>SQLite需要的配置很简单，而其他数据库需要配置更多的参数</p>
</li>
</ul>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in Scala </span></span><br><span class="line"><span class="keyword">val</span> pgDF = spark.read</span><br><span class="line">  .format(<span class="string">"jdbc"</span>)</span><br><span class="line">  .option(<span class="string">"driver"</span>, <span class="string">"org.postgresql.Driver"</span>)</span><br><span class="line">  .option(<span class="string">"url"</span>, <span class="string">"jdbc:postgresql://database_server"</span>)</span><br><span class="line">  .option(<span class="string">"dbtable"</span>, <span class="string">"schema.tablename"</span>)</span><br><span class="line">  .option(<span class="string">"user"</span>, <span class="string">"username"</span>)</span><br><span class="line">  .option(<span class="string">"password"</span>,<span class="string">"my-secret-password"</span>).load()</span><br></pre></td></tr></table></figure>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in Scala </span></span><br><span class="line"><span class="keyword">val</span> props = <span class="keyword">new</span> java.util.<span class="type">Properties</span></span><br><span class="line">props.setProperty(<span class="string">"driver"</span>, <span class="string">"org.sqlite.JDBC"</span>)</span><br><span class="line"><span class="keyword">val</span> predicates = <span class="type">Array</span>(</span><br><span class="line">  <span class="string">"DEST_COUNTRY_NAME = 'Sweden' OR ORIGIN_COUNTRY_NAME = 'Sweden'"</span>,</span><br><span class="line">  <span class="string">"DEST_COUNTRY_NAME = 'Anguilla' OR ORIGIN_COUNTRY_NAME = 'Anguilla'"</span>)</span><br><span class="line">spark.read.jdbc(url, tablename, predicates, props).show()  <span class="comment">// 读取JDBC</span></span><br><span class="line">spark.read.jdbc(url, tablename, predicates, props)</span><br><span class="line">  .rdd.getNumPartitions  <span class="comment">// 查看最大分区数</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># in Python </span></span><br><span class="line">props = &#123;<span class="string">"driver"</span>:<span class="string">"org.sqlite.JDBC"</span>&#125;</span><br><span class="line">predicates = [</span><br><span class="line">  <span class="string">"DEST_COUNTRY_NAME = 'Sweden' OR ORIGIN_COUNTRY_NAME = 'Sweden'"</span>,</span><br><span class="line">  <span class="string">"DEST_COUNTRY_NAME = 'Anguilla' OR ORIGIN_COUNTRY_NAME = 'Anguilla'"</span>]</span><br><span class="line">spark.read.jdbc(url, tablename, predicates=predicates, properties=props).show()</span><br><span class="line">spark.read.jdbc(url,tablename,predicates=predicates,properties=props)\</span><br><span class="line">  .rdd.getNumPartitions()</span><br></pre></td></tr></table></figure>
<p>写入SQL数据库，只需指定URL并指定写入模式。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in Scala </span></span><br><span class="line"><span class="keyword">val</span> newPath = <span class="string">"jdbc:sqlite://tmp/my-sqlite.db"</span></span><br><span class="line">csvFile.write.mode(<span class="string">"overwrite"</span>)</span><br><span class="line">  .jdbc(newPath, tablename, props)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看写入结果</span></span><br><span class="line">spark.read.jdbc(newPath, tablename, props).count()</span><br><span class="line"><span class="comment">// 追加新表</span></span><br><span class="line">csvFile.write.mode(<span class="string">"append"</span>).jdbc(newPath, tablename, props)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># in Python </span></span><br><span class="line">newPath = <span class="string">"jdbc:sqlite://tmp/my-sqlite.db"</span></span><br><span class="line">csvFile.write.jdbc(newPath, tablename, mode=<span class="string">"overwrite"</span>, properties=props)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看写入结果</span></span><br><span class="line">spark.read.jdbc(newPath, tablename, properties=props).count()</span><br><span class="line"><span class="comment"># 追加新表</span></span><br><span class="line">csvFile.write.jdbc(newPath, tablename, mode=<span class="string">"append"</span>, properties=props)</span><br></pre></td></tr></table></figure>
<h2 id="文本文件"><a href="#文本文件" class="headerlink" title="文本文件"></a>文本文件</h2><ul>
<li>文本文件中的每一行将被解析为DataFrame中的一条记录，然后根据要求进行转换</li>
<li>文本文件能够充分利用原生类型（native type）的灵活性，因此很适合作为Dataset API的输入</li>
<li>读取文本文件时，只需指定类型为<code>textFile</code>即可</li>
<li>写文本文件时，需确保仅有一个字符串类型的列写出；否则，写操作将失败</li>
<li>如果在执行写操作时，同时执行某些数据分片操作，则可以写入更多的列（这些列将在要写入的文件夹中显示为目录，而不是在每个文件中存在多列）</li>
</ul>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in Scala</span></span><br><span class="line"><span class="comment">// 读取文本文件 </span></span><br><span class="line">spark.read.textFile(<span class="string">"/data/flight-data/csv/2010-summary.csv"</span>)</span><br><span class="line">  .selectExpr(<span class="string">"split(value, ',') as rows"</span>).show()</span><br></pre></td></tr></table></figure>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><ul>
<li>可以通过在写入之前空值数据分片来控制写入文件的并行度</li>
<li><p>可以通过控制数据分桶（bucketing）和数据划分（partitioning）来控制特定的数据布局方式</p>
</li>
<li><p>如果使用的是Hadoop分布式文件系统（HDFS），则如果该文件包含多个文件块，分割文件可进一步优化提高性能。同时需要进行压缩管理</p>
</li>
<li><p>并非所有的压缩格式都是可分割的</p>
</li>
<li><p>推荐采用gzip压缩格式的Parquet文件格式</p>
</li>
<li><p>多个执行器不能同时读取同一文件，但可同时读取不同的文件</p>
<ul>
<li>当从包含多个文件的文件夹中读取时，每个文件都将被视为DataFrame的一个分片，并由执行器并行读取，多余的文件会进入读取队列等候</li>
</ul>
</li>
<li><p>写数据涉及的文件数量取决于DataFrame的分区数</p>
<ul>
<li>默认情况：每个数据分片都会有一定的数据写入</li>
</ul>
</li>
</ul>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">csvFile</span><span class="selector-class">.repartition</span>(<span class="number">5</span>)<span class="selector-class">.write</span><span class="selector-class">.format</span>(<span class="string">"csv"</span>)<span class="selector-class">.save</span>(<span class="string">"/tmp/multiple.csv"</span>)</span><br><span class="line"><span class="comment">// 会生成包含5个文件的文件夹</span></span><br></pre></td></tr></table></figure>
<ul>
<li>使用<code>partitionBy</code>进行数据划分，可以在后续读取时跳过大量的数据，只读入与问题相关的数据<ul>
<li>基于日期来划分数据最常见</li>
</ul>
</li>
</ul>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in Scala</span></span><br><span class="line">csvFile.limit(<span class="number">10</span>).write.mode(<span class="string">"overwrite"</span>)</span><br><span class="line">  .partitionBy(<span class="string">"DEST_COUNTRY_NAME"</span>)</span><br><span class="line">  .save(<span class="string">"/tmp/partitioned-files.parquet"</span>)</span><br></pre></td></tr></table></figure>
<p><strong>数据分桶</strong>：具有相同桶ID（哈希分桶的ID）的数据将放置到一个物理分区中；可以避免在后续读取数据时进行shuffle</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in Scala </span></span><br><span class="line"><span class="keyword">val</span> numberBuckets = <span class="number">10</span></span><br><span class="line"><span class="keyword">val</span> columnToBucketBy = <span class="string">"count"</span></span><br><span class="line"></span><br><span class="line">csvFile.write.format(<span class="string">"parquet"</span>).mode(<span class="string">"overwrite"</span>)</span><br><span class="line">  .bucketBy(numberBuckets, columnToBucketBy)</span><br><span class="line">  .saveAsTable(<span class="string">"bucketedFiles"</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>数据分桶仅支持Spark管理的表</li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://book.douban.com/subject/30449649/" target="_blank" rel="noopener">Spark权威指南</a></li>
</ul>
]]></content>
      <categories>
        <category>Data Scientist</category>
      </categories>
      <tags>
        <tag>Data Scientist</tag>
      </tags>
  </entry>
  <entry>
    <title>Data Scientist | Spark Learning</title>
    <url>/Spark-Learning.html</url>
    <content><![CDATA[<p><center></center><br><a id="more"></a></p>
<h1 id="Spark"><a href="#Spark" class="headerlink" title="Spark"></a>Spark</h1><p>Spark包括SQL和处理结构化数据的库（Spark SQL）、机器学习库（MLlib）、流处理库（Spark Streaming和较新的结构化流式处理），以及图分析（GraphX）的库。</p>
<p>此外还有数百种开源外部库：</p>
<ul>
<li>用于各种存储系统的连接器</li>
<li>机器学习算法</li>
<li>……</li>
</ul>
<p><a href="https://spark-packages.org/" target="_blank" rel="noopener">spark-package.org</a>提供了外部库的索引。</p>
<p>Spark支持：</p>
<ul>
<li>批处理应用程序（基于函数式编程的API）</li>
<li>交互式数据处理和即席（ad-hoc）查询（将Scala解释器插入Spark，可以提供一个高可用的交互式系统，用于在数百台机器上运行查询）</li>
<li>Shark系统：可以在Spark上运行SQL查询并满足分析师与数据科学家的交互式应用的引擎</li>
</ul>
<h2 id="Spark四大组件"><a href="#Spark四大组件" class="headerlink" title="Spark四大组件"></a>Spark四大组件</h2><h3 id="Spark-Streaming"><a href="#Spark-Streaming" class="headerlink" title="Spark Streaming"></a>Spark Streaming</h3><p>Spark Streaming是Spark平台上针对实时数据进行流式计算的组件，提供了丰富的处理数据流的API</p>
<h3 id="Spark-SQL"><a href="#Spark-SQL" class="headerlink" title="Spark SQL"></a>Spark SQL</h3><p>Spark SQL是Spark用来操作结构化数据的组件</p>
<ul>
<li>通过Spark SQL，用户可以使用SQL或者Apache Hive版本的SQL语言（HQL）来查询数据</li>
<li>Spark SQL支持多种数据源类型，例如Hive表、Parquet以及JSON等</li>
<li>用户可以在单个的应用中同时进行SQL查询和复杂的数据分析</li>
</ul>
<h3 id="GraphX"><a href="#GraphX" class="headerlink" title="GraphX"></a>GraphX</h3><p>GraphX是Spark面向图计算提供的框架与算法库。</p>
<h3 id="MLlib"><a href="#MLlib" class="headerlink" title="MLlib"></a>MLlib</h3><p>MLlib是Spark提供的一个机器学习算法库，其中包含了多种经典、常见的机器学习算法，主要有分类、回归、聚类、协同过滤等。</p>
<h1 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h1><ul>
<li>可以使用Python、Java、Scala、R或SQL等语言来运行Spark</li>
<li>Spark本身是用Scala编写的，并且运行在Java虚拟机（JVM）上</li>
</ul>
<p>可以使用2种方法来运行Spark：</p>
<ol>
<li>在电脑上下载并安装Apache Spark<ol>
<li>安装Java、Python</li>
<li>在<a href="http://spark.apache.org/downloads.html" target="_blank" rel="noopener">官网</a>选择“Pre-built for Hadoop 3.2 and later”，单击“Download Spark”</li>
<li>解压下载的文件</li>
</ol>
</li>
<li>在Databricks Community Edition<sup><a href="#fn_1" id="reffn_1">1</a></sup>上运行基于Web的版本<ol>
<li>按照<a href="https://github.com/databricks/Spark-The-Definitive-Guide">Spark:The Definitive Guide</a>中的操作说明，通过Web界面使用Scala、Python、SQL或R来运行Spark程序，还可以将得到的处理结果可视化</li>
</ol>
</li>
</ol>
<h1 id="交互式控制台"><a href="#交互式控制台" class="headerlink" title="交互式控制台"></a>交互式控制台</h1><p>Spark支持不同编程语言的交互式控制台：</p>
<ul>
<li>Python</li>
<li>Scala</li>
<li>SQL</li>
</ul>
<h2 id="Python控制台"><a href="#Python控制台" class="headerlink" title="Python控制台"></a>Python控制台</h2><ul>
<li>需要安装Python 2或Python 3</li>
<li>在Spark的主目录下运行：<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./bin/pyspark</span><br></pre></td></tr></table></figure>
然后输入<code>spark</code>并按回车键，将看到打印的<code>SparkSession</code>对象。</li>
</ul>
<h2 id="Scala控制台"><a href="#Scala控制台" class="headerlink" title="Scala控制台"></a>Scala控制台</h2><ul>
<li>在Spark的主目录下运行：<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./bin/spark-shell</span><br></pre></td></tr></table></figure>
然后输入<code>spark</code>并按回车键，将看到打印的<code>SparkSession</code>对象。</li>
</ul>
<h2 id="SQL控制台"><a href="#SQL控制台" class="headerlink" title="SQL控制台"></a>SQL控制台</h2><ul>
<li>在Spark的主目录下运行：<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./bin/spark-sql</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="基本架构"><a href="#基本架构" class="headerlink" title="基本架构"></a>基本架构</h1><ul>
<li>Spark是一种管理和协调跨多台计算机的计算任务的软件框架</li>
</ul>
<h2 id="应用程序"><a href="#应用程序" class="headerlink" title="应用程序"></a>应用程序</h2><p>Spark应用程序由<u>一个驱动器进程</u>和<u>一组执行器进程</u>组成</p>
<ol>
<li><strong>一个驱动器进程</strong><ul>
<li>驱动器进程运行<code>main()</code>函数，位于集群中的一个节点上，负责：<ul>
<li>维护Spark应用程序的相关信息</li>
<li>回应用户的程序或输入</li>
<li>分析任务并分发给若干执行器进行处理</li>
</ul>
</li>
<li>驱动器是Spark应用程序的核心，在应用程序执行的整个生命周期中维护着所有相关信息</li>
</ul>
</li>
<li><strong>一组执行器进程</strong><ul>
<li>执行器负责执行驱动器分配的实际计算工作</li>
<li>每个执行器只负责两件事：<ul>
<li>执行由驱动器分配给它的代码</li>
<li>并将该执行器的计算状态报告给运行驱动器的节点</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>page 19的插图</p>
<ul>
<li>用户可以配置指定每个节点上运行多少个执行器</li>
<li>Spark还可本地运行，此时，驱动器和执行器只是简单的进程，可以位于同一台机器或不同的机器上</li>
<li>Spark使用一个集群管理器来跟踪可用的资源；集群管理器可以是3个核心集群管理器中的任意一个：<ul>
<li>独立集群管理器</li>
<li>YARN</li>
<li>Mesos</li>
</ul>
</li>
</ul>
<h1 id="Spark-API"><a href="#Spark-API" class="headerlink" title="Spark API"></a>Spark API</h1><p>Spark有两套基本的API：</p>
<ul>
<li>低级“非结构化”API</li>
<li>更高级别的结构化API</li>
</ul>
<h2 id="多语言支持"><a href="#多语言支持" class="headerlink" title="多语言支持"></a>多语言支持</h2><p>Spark API支持多种编程语言：</p>
<ul>
<li>Scala：Spark主要用Scala编写，Scala是Spark的默认语言</li>
<li>Java</li>
<li>Python：Python几乎支持所有Scala支持的结构</li>
<li>SQL：Spark支持ANSI SQL 2003标准的一个子集</li>
<li>R：Spark有两个常用的R库<ol>
<li>SparkR：是Spark核心之一</li>
<li>sparklyr：R语言开源社区维护的包</li>
</ol>
</li>
</ul>
<p>page 21的插图</p>
<h2 id="SparkSession"><a href="#SparkSession" class="headerlink" title="SparkSession"></a>SparkSession</h2><p>可以通过名为SparkSession的驱动器来控制Spark应用程序，需要创建一个SparkSession实例用来在集群中执行用户定义的操作</p>
<ul>
<li>每一个Spark应用程序都需要一个SparkSession与之对应</li>
<li>在Scala和Python中，启动控制台时，SparkSession就被实例化为一个名叫<code>spark</code>的对象</li>
</ul>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in scala</span></span><br><span class="line">spark</span><br><span class="line"></span><br><span class="line">res0: org.apache.spark.sql.<span class="type">SparkSession</span> = org.apache.spark.sql.<span class="type">SparkSession</span>@...</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## in python</span></span><br><span class="line">spark</span><br><span class="line"></span><br><span class="line"><span class="comment">## 返回</span></span><br><span class="line">&lt;pyspark.sql.session.SparkSession at <span class="number">0x7efda4c1ccd0</span>&gt;</span><br></pre></td></tr></table></figure>
<p>转换操作和动作操作的逻辑结构是DataFrame和Datset，执行一次转换操作都会创建一个新的DataFrame或Dataset，而动作操作则会触发计算，或将DataFrame和Dataset转换成本地语言类型。</p>
<h2 id="转换操作"><a href="#转换操作" class="headerlink" title="转换操作"></a>转换操作</h2><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in scala</span></span><br><span class="line"><span class="comment">// 查找当前DataFrame中的所有偶数</span></span><br><span class="line"><span class="keyword">val</span> divisBy2 = myRange.where(<span class="string">"number % 2 = 0"</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## in python</span></span><br><span class="line"><span class="comment">## 查找当前DataFrame中的所有偶数</span></span><br><span class="line">divisBy2 = myRange.where(<span class="string">"number % 2 = 0"</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>这些转换并没有实际输出，只是抽象转换</li>
<li><strong>转换操作</strong>是使用Spark表达业务逻辑的核心</li>
</ul>
<p>有两类转换操作：</p>
<ol>
<li><strong>窄转换</strong>：指定窄依赖关系（narrow dependency）的转换操作<ul>
<li>一对一映射</li>
<li>每个输入分区仅决定一个输出分区的转换</li>
<li>Spark将自动执行流水线处理——如果在DataFrame上指定了多个过滤操作，它们将全部在内存中执行</li>
<li>补充24页 插图</li>
</ul>
</li>
<li><strong>宽转换</strong>：指定宽依赖关系（wide dependency）的转换操作<ul>
<li>一对多映射</li>
<li>每个输入分区决定了多个输出分区</li>
<li>也被称为<strong>洗牌（shuffle）操作</strong>，会在整个集群中执行互相交换分区数据的功能</li>
<li>当执行shuffle操作时，Spark将结果写入磁盘</li>
</ul>
</li>
</ol>
<h3 id="惰性评估"><a href="#惰性评估" class="headerlink" title="惰性评估"></a>惰性评估</h3><p><strong>惰性评估</strong>（lazy evaluation）：等到绝对需要时才执行计算</p>
<p>在Spark中，当用户表达一些对数据的操作时，不是立即修改数据，而是建立一个作用到原始数据的转换计划。Spark首先会将这个计划编译为可以在集群中高效运行的流水线式的物理执行计划，然后等待，直到最后时刻才开始执行代码。</p>
<ul>
<li>可以优化整个从输入端到输出端的数据流</li>
</ul>
<blockquote>
<p>如：DataFrame的谓词下推（predicate pushdown）：假设构建了一个含有多个转换操作的Spark作业，并在最后指定了一个过滤操作，且这个过滤操作只需要数据源中的某一行数据，则最有效的方法就是在最开始仅访问我们需要的单个记录，Spark会通过自动下推这个过滤操作来优化整个物理执行计划</p>
</blockquote>
<h2 id="动作操作"><a href="#动作操作" class="headerlink" title="动作操作"></a>动作操作</h2><ul>
<li>运行一个动作操作（action）以触发计算</li>
<li>一个动作指示Spark在一系列转换操作后计算一个结果</li>
</ul>
<p>最简单的动作操作是：<code>count()</code>，计算一个DataFrame中的记录总数<br><figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">divisBy2.<span class="built_in">count</span>()</span><br></pre></td></tr></table></figure></p>
<p>动作有三类：</p>
<ul>
<li>在控制台中查看数据的动作</li>
<li>在某个语言中将数据汇集为原生对象的动作</li>
<li>写入输出数据源的动作</li>
</ul>
<h2 id="Spark用户接口"><a href="#Spark用户接口" class="headerlink" title="Spark用户接口"></a>Spark用户接口</h2><p>可以通过Spark的Web UI监控一个作业的进度</p>
<ul>
<li>Spark UI占用驱动器节点的4040端口</li>
<li>如果在本地模式下运行，可以通过<a href="http://localhost:4040" target="_blank" rel="noopener">http://localhost:4040</a> 访问Spark Web UI</li>
<li>Spark UI上显示了Spark作业的运行状态、执行环境和群集状态等信息</li>
</ul>
<p>一个Spark作业包含一系列转换操作，并由一个动作操作触发，并可以通过Spark UI监视该作业。</p>
<p>Spark的核心抽象：</p>
<ul>
<li>DataFrame</li>
<li>Dataset</li>
<li>SQL表</li>
<li>弹性分布式数据集（RDD，Resident Distributed Datasets）</li>
</ul>
<p>这些不同的抽象都表示分布式数据集合，其中最简单、最有效的是DataFrame，它支持所有语言。</p>
<h1 id="结构化API"><a href="#结构化API" class="headerlink" title="结构化API"></a>结构化API</h1><p>结构化API指以下三种核心分布式集合类型的API：</p>
<ol>
<li>（类型化的）Dataset类型</li>
<li>（非类型化的）DataFrame类型</li>
<li>SQL表和视图</li>
</ol>
<ul>
<li>大多数结构化API均适用于批处理和流处理</li>
<li>使用结构化API编写代码时，可以从批处理程序转换为流处理程序，反之亦然</li>
<li>结构化API是在编写大部分数据处理程序时会用到的基础抽象概念</li>
<li>Spark类型直接映射到不同语言API，并且针对Scala、Java、Python、SQL和R语言，都有一个对应的API查找表</li>
<li>即使通过Python或R语言来使用Spark结构化API，大多数情况下也是操作Spark类型而非Python类型</li>
</ul>
<p>DataFrame和Dataset是具有行和列类似于（分布式）数据表的集合类型。</p>
<ul>
<li>所有列的函数相同（可以用null来指定缺省值），并且某一列的类型必须在所有行中保持一致</li>
<li>Spark中的DataFrame和Dataset代表不可变的数据集合，可以通过它指定对特殊位置数据的操作（操作将以惰性评估方式执行）</li>
</ul>
<p><strong>行</strong>（Row）：一行对应一个数据记录</p>
<ul>
<li>DataFrame中的每条记录都必须是Row类型</li>
<li>可以通过SQL手动创建、从弹性分布式数据集（RDD）提取、从数据源手动创建这些行</li>
</ul>
<p><strong>列</strong>：表示一个简单类型（eg：整数、字符串），或者一个复杂类型（eg：数组、map映射），或者空值null</p>
<h2 id="核心对象"><a href="#核心对象" class="headerlink" title="核心对象"></a>核心对象</h2><h3 id="DataFrame"><a href="#DataFrame" class="headerlink" title="DataFrame"></a>DataFrame</h3><p>DataFrame是最常见的结构化API，是包含行和列的数据表</p>
<ul>
<li>说明DataFrame的列和列类型的规则被称为<strong>模式</strong>（schema）</li>
<li>DataFrame与电子表格不同<ul>
<li>电子表格位于一台计算机上，而Spark DataFrame可以跨越数千台计算机</li>
</ul>
</li>
<li>R DataFrame和Python DataFrame存在于一台机器上，而不是多台机器上</li>
<li>Spark可以将Python DataFrame或R DataFrame转换为Spark DataFrame</li>
<li>DataFrame实际是有类型的，只是Spark完全负责维护它们的类型，仅在运行时检查这些类型是否与schema中指定的类型一致</li>
<li>在Scala版本的Spark中，DataFrame是一些Row类型的Dataset的集合<ul>
<li>Row类型：是Spark用于支持内存计算而优化的数据格式</li>
</ul>
</li>
</ul>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in scala</span></span><br><span class="line"><span class="comment">// 创建一组固定范围的数字</span></span><br><span class="line"><span class="comment">// DataFrame</span></span><br><span class="line"><span class="keyword">val</span> myRange = spark.range(<span class="number">1000</span>).toDF(<span class="string">"number"</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## in python</span></span><br><span class="line"><span class="comment">## 创建一组固定范围的数字</span></span><br><span class="line"><span class="comment">## DataFrame</span></span><br><span class="line">myRange = spark.range(<span class="number">1000</span>).toDF(<span class="string">"number"</span>)</span><br></pre></td></tr></table></figure>
<h3 id="Dataset"><a href="#Dataset" class="headerlink" title="Dataset"></a>Dataset</h3><ul>
<li>类型安全的结构化API，用于在Java和Scala中编写静态类型的代码</li>
<li>在Dataset上调用<code>collect</code>或<code>take</code>函数时，将会收集Dataset中合适类型的对象，而不是DataFrame的Row对象</li>
<li>Dataset仅适用于基于Java虚拟机（JVM）的语言（如Scala和Java），并通过case类或Java beans指定类型</li>
<li>Python版本和R语言版本的Spark并不支持Dataset，所有东西都是DataFrame</li>
</ul>
<h3 id="SQL表和视图"><a href="#SQL表和视图" class="headerlink" title="SQL表和视图"></a>SQL表和视图</h3><p>表和视图与DataFrame基本相同，所以通常在DataFrame上执行SQL操作，而不是用DataFrame专用的执行代码</p>
<h2 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h2><p>结构化API执行过程<br>61页<br>待补充</p>
<h3 id="逻辑计划"><a href="#逻辑计划" class="headerlink" title="逻辑计划"></a>逻辑计划</h3><h3 id="物理计划"><a href="#物理计划" class="headerlink" title="物理计划"></a>物理计划</h3><h1 id="Spark类型"><a href="#Spark类型" class="headerlink" title="Spark类型"></a>Spark类型</h1><h2 id="Java类型"><a href="#Java类型" class="headerlink" title="Java类型"></a>Java类型</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用正确的Java类型</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.sql.types.DataTypes;</span><br><span class="line">ByteType x = DataTypes.ByteType;</span><br></pre></td></tr></table></figure>
<p>Java类型参考表：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">数据类型</th>
<th style="text-align:left">值类型</th>
<th style="text-align:left">获取或创建数据类型的API</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">ByteType</td>
<td style="text-align:left">byte或Byte</td>
<td style="text-align:left"><code>DataTypes.ByteType</code></td>
</tr>
<tr>
<td style="text-align:left">ShortType</td>
<td style="text-align:left">short或Short</td>
<td style="text-align:left"><code>DataTypes.ShortType</code></td>
</tr>
<tr>
<td style="text-align:left">IntegerType</td>
<td style="text-align:left">int或Integer</td>
<td style="text-align:left"><code>DataTypes.IntegerType</code></td>
</tr>
<tr>
<td style="text-align:left">LongType</td>
<td style="text-align:left">long或Long</td>
<td style="text-align:left"><code>DataTypes.LongType</code></td>
</tr>
<tr>
<td style="text-align:left">FloatType</td>
<td style="text-align:left">float或Float</td>
<td style="text-align:left"><code>DataTypes.FloatType</code></td>
</tr>
<tr>
<td style="text-align:left">DoubleType</td>
<td style="text-align:left">double或Double</td>
<td style="text-align:left"><code>DataTypes.DoubleType</code></td>
</tr>
<tr>
<td style="text-align:left">DecimalType</td>
<td style="text-align:left">java.math.BigDecimal</td>
<td style="text-align:left"><code>DataTypes.createDecimalType()</code></td>
</tr>
<tr>
<td style="text-align:left">StringType</td>
<td style="text-align:left">String</td>
<td style="text-align:left"><code>DataTypes.StringType</code></td>
</tr>
<tr>
<td style="text-align:left">BinaryType</td>
<td style="text-align:left">byte[]</td>
<td style="text-align:left"><code>DataTypes.BinaryType</code></td>
</tr>
<tr>
<td style="text-align:left">BooleanType</td>
<td style="text-align:left">boolean或Boolean</td>
<td style="text-align:left"><code>DataTypes.BooleanType</code></td>
</tr>
<tr>
<td style="text-align:left">TimestampType</td>
<td style="text-align:left">java.sql.TimeStamp</td>
<td style="text-align:left"><code>DataTypes.TimestampType</code></td>
</tr>
<tr>
<td style="text-align:left">DateType</td>
<td style="text-align:left">java.sql.Date</td>
<td style="text-align:left"><code>DataTypes.DateType</code></td>
</tr>
<tr>
<td style="text-align:left">ArrayType</td>
<td style="text-align:left">java.util.List</td>
<td style="text-align:left"><code>DataTypes.createArrayType(elementType [, containsNull])</code><br>containsNull的默认值为True</td>
</tr>
<tr>
<td style="text-align:left">MapType</td>
<td style="text-align:left">java.util.Map</td>
<td style="text-align:left"><code>DataTypes.createMapType(keyType, valueType, [valueContainsNull])</code><br>valueContainsNull的默认值为True</td>
</tr>
<tr>
<td style="text-align:left">StructType</td>
<td style="text-align:left">org.apache.spark.sql.Row</td>
<td style="text-align:left"><code>DataTypes.createStructType(fields)</code><br><code>field</code>是一个包含多个StructFile的Array，并且任意两个StructField不能同名</td>
</tr>
<tr>
<td style="text-align:left">StructField</td>
<td style="text-align:left">该字段对应Scala数据类型<br>eg：int是IntegerType的StructField</td>
<td style="text-align:left"><code>DataTypes.createStructField(name, dataType, [nullable])</code><br><code>nullable</code>指定该field是否可以为空值，默认值为True</td>
</tr>
</tbody>
</table>
</div>
<h2 id="Python类型"><a href="#Python类型" class="headerlink" title="Python类型"></a>Python类型</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 使用正确的Python类型</span></span><br><span class="line"><span class="keyword">from</span> pyspark.sql.types <span class="keyword">import</span> *</span><br><span class="line">b = ByteType()</span><br></pre></td></tr></table></figure>
<p>Python类型参考表：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">数据类型</th>
<th style="text-align:left">值类型</th>
<th style="text-align:left">获取或创建数据类型的API</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">ByteType</td>
<td style="text-align:left">int或long<br>1. 数字在运行时转换为1字节的带符号整数<br>2. 数字范围为-128~127，即$-2^7~2^7-1$</td>
<td style="text-align:left"><code>ByteType()</code></td>
</tr>
<tr>
<td style="text-align:left">ShortType</td>
<td style="text-align:left">int或long<br>1. 数字在运行时将转换为2字节带符号的整数<br>2. 数字范围为-32768~32767，即$-2^{15}~2^{15}-1$</td>
<td style="text-align:left"><code>ShortType()</code></td>
</tr>
<tr>
<td style="text-align:left">IntegerType</td>
<td style="text-align:left">int或long<br>若使用IntegerType()，则太大的数字将被Spark SQL拒绝，则最好使用LongType()</td>
<td style="text-align:left"><code>IntegerType()</code></td>
</tr>
<tr>
<td style="text-align:left">LongType</td>
<td style="text-align:left">long<br>1. 数字在运行时将转换为8字节带符号整数<br>2. 数字范围为$-9223372036854775808~9223372036854775807$，即$-2^{63}~2^{63}-1$</td>
<td style="text-align:left"><code>LongType()</code></td>
</tr>
<tr>
<td style="text-align:left">FloatType</td>
<td style="text-align:left">float<br>数字在运行时将转换为4字节的单精度浮点数</td>
<td style="text-align:left"><code>FloatType()</code></td>
</tr>
<tr>
<td style="text-align:left">DoubleType</td>
<td style="text-align:left">float</td>
<td style="text-align:left"><code>DoubleType()</code></td>
</tr>
<tr>
<td style="text-align:left">DecimalType</td>
<td style="text-align:left">decimal.Decimal</td>
<td style="text-align:left"><code>DecimalType()</code></td>
</tr>
<tr>
<td style="text-align:left">StringType</td>
<td style="text-align:left">string</td>
<td style="text-align:left"><code>StringType()</code></td>
</tr>
<tr>
<td style="text-align:left">BinaryType</td>
<td style="text-align:left">bytearray</td>
<td style="text-align:left"><code>BinaryType()</code></td>
</tr>
<tr>
<td style="text-align:left">BooleanType</td>
<td style="text-align:left">bool</td>
<td style="text-align:left"><code>BooleanType()</code></td>
</tr>
<tr>
<td style="text-align:left">TimestampType</td>
<td style="text-align:left">datetime.datetime</td>
<td style="text-align:left"><code>TimestampType()</code></td>
</tr>
<tr>
<td style="text-align:left">DateType</td>
<td style="text-align:left">datetime.date</td>
<td style="text-align:left"><code>DateType()</code></td>
</tr>
<tr>
<td style="text-align:left">ArrayType</td>
<td style="text-align:left">list, tuple, array</td>
<td style="text-align:left"><code>ArrayType(elementType, [containsNull])</code><br>containsNull的默认值为True</td>
</tr>
<tr>
<td style="text-align:left">MapType</td>
<td style="text-align:left">字典</td>
<td style="text-align:left"><code>MapType(keyType, valueType, [valueContainsNull])</code><br>valueContainsNull的默认值为True</td>
</tr>
<tr>
<td style="text-align:left">StructType</td>
<td style="text-align:left">列表或元组</td>
<td style="text-align:left"><code>StructType(fields)</code><br><code>field</code>是一个包含多个StructFile的list，并且任意两个StructField不能同名</td>
</tr>
<tr>
<td style="text-align:left">StructField</td>
<td style="text-align:left">该字段对应Python数据类型<br>eg：int是IntegerType的StructField</td>
<td style="text-align:left"><code>StructField(name, dataType, [nullable])</code><br><code>nullable</code>指定该field是否可以为空值，默认值为True</td>
</tr>
</tbody>
</table>
</div>
<h2 id="Scala类型"><a href="#Scala类型" class="headerlink" title="Scala类型"></a>Scala类型</h2><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可使用正确的Scala类型</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.sql.types._val</span><br><span class="line">b = <span class="type">ByteType</span></span><br></pre></td></tr></table></figure>
<p>Scala类型参考表：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">数据类型</th>
<th style="text-align:left">值类型</th>
<th style="text-align:left">获取或创建数据类型的API</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">ByteType</td>
<td style="text-align:left">Byte</td>
<td style="text-align:left"><code>ByteType</code></td>
</tr>
<tr>
<td style="text-align:left">ShortType</td>
<td style="text-align:left">Short</td>
<td style="text-align:left"><code>ShortType</code></td>
</tr>
<tr>
<td style="text-align:left">IntegerType</td>
<td style="text-align:left">Int</td>
<td style="text-align:left"><code>IntegerType</code></td>
</tr>
<tr>
<td style="text-align:left">LongType</td>
<td style="text-align:left">Long</td>
<td style="text-align:left"><code>LongType</code></td>
</tr>
<tr>
<td style="text-align:left">FloatType</td>
<td style="text-align:left">Float</td>
<td style="text-align:left"><code>FloatType</code></td>
</tr>
<tr>
<td style="text-align:left">DoubleType</td>
<td style="text-align:left">Double</td>
<td style="text-align:left"><code>DoubleType</code></td>
</tr>
<tr>
<td style="text-align:left">DecimalType</td>
<td style="text-align:left">java.math.BigDecimal</td>
<td style="text-align:left"><code>DecimalType</code></td>
</tr>
<tr>
<td style="text-align:left">StringType</td>
<td style="text-align:left">String</td>
<td style="text-align:left"><code>StringType</code></td>
</tr>
<tr>
<td style="text-align:left">BinaryType</td>
<td style="text-align:left">Array[Type]</td>
<td style="text-align:left"><code>BinaryType</code></td>
</tr>
<tr>
<td style="text-align:left">BooleanType</td>
<td style="text-align:left">Boolean</td>
<td style="text-align:left"><code>BooleanType</code></td>
</tr>
<tr>
<td style="text-align:left">TimestampType</td>
<td style="text-align:left">java.sql.TimeStamp</td>
<td style="text-align:left"><code>TimestampType</code></td>
</tr>
<tr>
<td style="text-align:left">DateType</td>
<td style="text-align:left">java.sql.Date</td>
<td style="text-align:left"><code>DateType</code></td>
</tr>
<tr>
<td style="text-align:left">ArrayType</td>
<td style="text-align:left">scala.collection.Seq</td>
<td style="text-align:left"><code>ArrayType(elementType, [containsNull])</code><br>containsNull的默认值为True</td>
</tr>
<tr>
<td style="text-align:left">MapType</td>
<td style="text-align:left">scala.collection.Map</td>
<td style="text-align:left"><code>MapType(keyType, valueType, [valueContainsNull])</code><br>valueContainsNull的默认值为True</td>
</tr>
<tr>
<td style="text-align:left">StructType</td>
<td style="text-align:left">org.apache.spark.sql.Row</td>
<td style="text-align:left"><code>StructType(fields)</code><br><code>field</code>是一个包含多个StructFile的Array，并且任意两个StructField不能同名</td>
</tr>
<tr>
<td style="text-align:left">StructField</td>
<td style="text-align:left">该字段对应Scala数据类型<br>eg：int是IntegerType的StructField</td>
<td style="text-align:left"><code>StructField(name, dataType, [nullable])</code><br><code>nullable</code>指定该field是否可以为空值，默认值为True</td>
</tr>
</tbody>
</table>
</div>
<h1 id="DataFrame-1"><a href="#DataFrame-1" class="headerlink" title="DataFrame"></a>DataFrame</h1><p>DataFrame由记录（record）组成</p>
<ul>
<li>record是Row类型</li>
<li>一条record由多列组成</li>
<li><strong>分区</strong>定义了DataFrame以及Dataset在集群上的物理分布</li>
<li><strong>划分模式</strong>定义了partition的分配方式</li>
<li>当使用DataFrame时，向驱动器请求行的命令总是返回一个或多个Row类型的行数据</li>
</ul>
<h2 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h2><p>模式（schema）定义了DataFrame列的名称以及列的数据类型，可以由数据源来定义模式（即读时模式，schema-on-read），也可以由我们自己来显式定义。</p>
<p>实际应用场景决定了定义Schema的方式：</p>
<ul>
<li>当应用于即席（Ad-hoc）分析时，使用读时模式<ul>
<li>在处理如csv和json等纯文本（无类型）时速度较慢</li>
</ul>
</li>
<li>当使用Spark进行生产级别ETL（Extract提取、Transform转换、Load加载）时，使用显示定义</li>
</ul>
<p>一个模式是由许多字段（StructField）构成的StructType；这些字段是StructField，具有名称、类型、布尔标志（指定该列是否可以包含缺失值或空值），且用户可指定与该列关联的元数据（metadata）。</p>
<ul>
<li>如果在运行时，数据的类型与定义的Schema模式不匹配，Spark将抛出一个错误</li>
<li>通过<code>printSchema()</code>函数查询DataFrame的模式</li>
<li>只有DataFrame具有模式，行对象本身没有模式</li>
</ul>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in scala</span></span><br><span class="line"><span class="comment">// 创建DataFrame并指定模式</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.sql.types.&#123;<span class="type">StructField</span>, <span class="type">StructType</span>, <span class="type">StringType</span>, <span class="type">LongType</span>&#125;</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.sql.types.<span class="type">Metadata</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> myManualSchema = <span class="type">StructType</span>(<span class="type">Array</span>(</span><br><span class="line">   <span class="type">StructField</span>(<span class="string">"DEST_COUNTRY_NAME"</span>, <span class="type">StringType</span>, <span class="literal">true</span>),</span><br><span class="line">   <span class="type">StructField</span>(<span class="string">"ORIGIN_COUNTRY_NAME"</span>, <span class="type">StringType</span>, <span class="literal">true</span>),</span><br><span class="line">   <span class="type">StructField</span>(<span class="string">"count"</span>, <span class="type">LongType</span>, <span class="literal">false</span>, </span><br><span class="line">   <span class="type">Metadata</span>.fromJason(<span class="string">"&#123;\"hello\":\"world\"&#125;"</span>))</span><br><span class="line">))</span><br><span class="line"><span class="keyword">val</span> df = spark.read.format(<span class="string">"json"</span>).schema(myManualSchema)</span><br><span class="line">   .load(<span class="string">"/data/flight-data/json/2015-summary.json"</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># in python</span></span><br><span class="line"><span class="comment"># 创建DataFrame并指定模式</span></span><br><span class="line"><span class="keyword">from</span> pyspark.sql.types <span class="keyword">import</span> StructField, StructType, StringType, LongType</span><br><span class="line"></span><br><span class="line">myManualSchema = StructType([</span><br><span class="line">   StructField(<span class="string">"DEST_COUNTRY_NAME"</span>, StringType(), <span class="literal">True</span>),</span><br><span class="line">   StructField(<span class="string">"ORIGIN_COUNTRY_NAME"</span>, StringType(), <span class="literal">True</span>),</span><br><span class="line">   StructField(<span class="string">"count"</span>, LongType(), <span class="literal">False</span>, metadata=&#123;<span class="string">"hello"</span>:<span class="string">"world"</span>&#125;)</span><br><span class="line">])</span><br><span class="line">df = spark.read.format(<span class="string">"json"</span>).schema(myManualSchema)\</span><br><span class="line">   .load(<span class="string">"/data/flight-data/json/2015-summary.json"</span>)</span><br></pre></td></tr></table></figure>
<h2 id="列"><a href="#列" class="headerlink" title="列"></a>列</h2><p>Spark中的列与电子表格、R dataframe、pandas DataFrame中的列类似，可以对DataFrame中的列进行选择、转换操作和删除，并将这些操作表示为<strong>表达式</strong>。</p>
<p>对Spark来说，列是逻辑结构，只是表示根据表达式为每个记录计算出的值。</p>
<ul>
<li>可通过<code>col</code>函数、<code>column</code>函数构造和引用列</li>
<li>列和数据表的解析在分析器阶段发生</li>
<li>Scala还可使用下列表达式创建列<ul>
<li>符号<code>$</code>将字符串指定为表达式</li>
<li>符号<code>&#39;</code>指定一个symbol，是Scala引用标识符的特殊结构<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">$<span class="string">"myColumn"</span></span><br><span class="line"><span class="symbol">'myColumn</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>显示应用列：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 引用某DataFrame的某一列</span></span><br><span class="line"> df.col(<span class="string">"columnName"</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="行"><a href="#行" class="headerlink" title="行"></a>行</h2><ul>
<li>只有DataFrame具有模式，行（Row）对象本身没有模式</li>
<li>手动创建Row对象，必须按照该行所属的DataFrame的列顺序来初始化Row对象</li>
</ul>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in scala</span></span><br><span class="line"><span class="comment">// 创建Row对象</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.sql.<span class="type">Row</span></span><br><span class="line"><span class="keyword">val</span> myRow = <span class="type">Row</span>(<span class="string">"Hello"</span>, <span class="literal">null</span>, <span class="number">1</span>, <span class="literal">false</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># in python</span></span><br><span class="line"><span class="comment"># 创建Row对象</span></span><br><span class="line"><span class="keyword">from</span> pyspark.sql <span class="keyword">import</span> Row</span><br><span class="line">myRow = Row(<span class="string">"Hello"</span>, <span class="literal">None</span>, <span class="number">1</span>, <span class="literal">False</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>使用Scala或Java访问行时，需要使用辅助方法或显式地指定值类型</li>
<li>使用Python或R访问行时，访问行时，值被自动转化为正确的类型</li>
</ul>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in scala</span></span><br><span class="line"><span class="comment">// 访问Row对象</span></span><br><span class="line">myRow(<span class="number">0</span>)  <span class="comment">// 任意类型</span></span><br><span class="line">myRow(<span class="number">0</span>).asInstanceOf[<span class="type">String</span>]  <span class="comment">// 字符串</span></span><br><span class="line">myRow.getString(<span class="number">0</span>)  <span class="comment">// 字符串</span></span><br><span class="line">myRow.getInt(<span class="number">2</span>)  <span class="comment">// 整型</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 访问Row对象</span></span><br><span class="line">myRow[<span class="number">0</span>]</span><br><span class="line">myRow[<span class="number">2</span>]</span><br></pre></td></tr></table></figure>
<h2 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h2><p>表达式（expression）是对一个DataFrame中某一个记录的一个或多个值的一组转换操作。</p>
<ul>
<li>最简单的表达式：通过<code>expr</code>函数创建的表达式，仅仅是一个DataFrame列的引用。即，<code>expr(&quot;someCol&quot;)</code>等同于<code>col(someCol)</code>。</li>
<li><code>expr</code>函数可以将字符串解析成转换操作和列引用，也可以在之后将其传递到下一步的转换操作<blockquote>
<p><code>expr(&quot;someCol - 5&quot;)</code>与<code>col(&quot;someCol&quot;) - 5</code>、<code>expr(&quot;someCol&quot;) - 5</code>，都是相同的转换操作，Spark将它们编译为表示操作顺序的逻辑树</p>
</blockquote>
</li>
</ul>
<ol>
<li>列只是表达式</li>
<li>列与对这些列的转换操作被编译后生成的逻辑计划，与解析后的表达式的逻辑计划是一样的</li>
</ol>
<h2 id="转换操作-1"><a href="#转换操作-1" class="headerlink" title="转换操作"></a>转换操作</h2><p>图<br>70页<br>待补充</p>
<ul>
<li>创建DataFrame：<code>createDataFrame()</code></li>
<li><p>在Scala中，可以利用Spark的隐式方法（使用<code>implicit</code>关键字），对Seq类型执行<code>toDF</code>函数来实现</p>
<ul>
<li>但是该方法对<code>null</code>类型的支持并不稳定，并不推荐在实际生产中使用<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> myDF = <span class="type">Seq</span>((<span class="string">"Hello"</span>, <span class="number">2</span>, <span class="number">1</span>L)).toDF(<span class="string">"col1"</span>, <span class="string">"col2"</span>, <span class="string">"col3"</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><code>select</code>、<code>selectExpr</code>支持在DataFrame上执行类似数据表的SQL查询</p>
</li>
<li><code>select</code>：处理列或表达式</li>
<li><code>selectExpr</code>：处理字符串表达式</li>
</ul>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="apply"><a href="#apply" class="headerlink" title="apply()"></a>apply()</h2><p>获取指定字段</p>
<ul>
<li>返回对象为Column类型</li>
<li>只能获取一个字段</li>
<li>而<code>col</code>、<code>column</code>可以获取多个指定字段</li>
</ul>
<h2 id="cast"><a href="#cast" class="headerlink" title="cast()"></a>cast()</h2><p>用于更改列的类型（来转换数据类型）</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">df.withColumn(<span class="string">"count"</span>, col(<span class="string">"count"</span>).cast(<span class="string">"long"</span>))</span><br></pre></td></tr></table></figure>
<p>等价于<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *, <span class="keyword">CAST</span>(<span class="keyword">count</span> <span class="keyword">AS</span> <span class="keyword">LONG</span>) <span class="keyword">AS</span> count2 <span class="keyword">FROM</span> dfTable;</span><br></pre></td></tr></table></figure></p>
<h2 id="coalesce"><a href="#coalesce" class="headerlink" title="coalesce()"></a>coalesce()</h2><p>合并操作</p>
<ul>
<li>不会导致数据的全面洗牌，但是会尝试合并分区</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># in scala or Python</span></span><br><span class="line">df.repartition(<span class="number">5</span>, col(<span class="string">"DEST_COUNTRY_NAME"</span>)).coalesce(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<h2 id="collectAsList"><a href="#collectAsList" class="headerlink" title="collectAsList()"></a>collectAsList()</h2><p>获取所有数据到List</p>
<h2 id="columns"><a href="#columns" class="headerlink" title="columns"></a>columns</h2><p>使用属性<code>columns</code>查询DataFrame的所有列</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in Scala</span></span><br><span class="line">spark.read.format(<span class="string">"json"</span>).load(<span class="string">"/data/flight-data/json/2015-summary.json"</span>).columns</span><br></pre></td></tr></table></figure>
<h2 id="contains"><a href="#contains" class="headerlink" title="contains()"></a>contains()</h2><p>检查在某列上是否存在某字符串</p>
<ul>
<li>Scala函数</li>
<li>返回Boolean值</li>
<li>在Python和SQL中，应使用<code>instr</code>函数</li>
</ul>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in Scala</span></span><br><span class="line"><span class="keyword">val</span> containsBlack = col(<span class="string">"Description"</span>).contains(<span class="string">"BLACK"</span>)</span><br><span class="line"><span class="keyword">val</span> containsWhite = col(<span class="string">"DESCRIPTION"</span>).contains(<span class="string">"WHITE"</span>)</span><br><span class="line">df.withColumn(<span class="string">"hasSimpleColor"</span>, containsBlack.or(containsWhite))</span><br><span class="line">  .where(<span class="string">"hasSimpleColor"</span>)</span><br><span class="line">  .select(<span class="string">"Description"</span>).show(<span class="number">3</span>, <span class="literal">false</span>)</span><br></pre></td></tr></table></figure>
<h2 id="createDataFrame"><a href="#createDataFrame" class="headerlink" title="createDataFrame()"></a>createDataFrame()</h2><p>创建DataFrame</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in Scala</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.sql.<span class="type">Row</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.sql.types.&#123;<span class="type">StructField</span>, <span class="type">StructType</span>, <span class="type">StringType</span>, <span class="type">LongType</span>&#125;</span><br><span class="line"><span class="keyword">val</span> myManualSchema = <span class="keyword">new</span> <span class="type">StructType</span>(<span class="type">Array</span>(</span><br><span class="line">   <span class="keyword">new</span> <span class="type">StructField</span>(<span class="string">"some"</span>, <span class="type">StringType</span>, <span class="literal">true</span>),</span><br><span class="line">   <span class="keyword">new</span> <span class="type">StructField</span>(<span class="string">"col"</span>, <span class="type">StringType</span>, <span class="literal">true</span>),</span><br><span class="line">   <span class="keyword">new</span> <span class="type">StructField</span>(<span class="string">"names"</span>, <span class="type">LongType</span>, <span class="literal">false</span>)))</span><br><span class="line"><span class="keyword">val</span> myRows = <span class="type">Seq</span>(<span class="type">Row</span>(<span class="string">"Hello"</span>, <span class="literal">null</span>, <span class="number">1</span>L))</span><br><span class="line"><span class="keyword">val</span> myRDD = spark.sparkContext.parallelize(myRows)</span><br><span class="line"><span class="keyword">val</span> myDf = spark.createDataFrame(myRDD, myManualSchema)</span><br><span class="line">myDf.show()</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># in Python</span></span><br><span class="line"><span class="keyword">from</span> pyspark.sql <span class="keyword">import</span> Row</span><br><span class="line"><span class="keyword">from</span> pyspark.sql.types <span class="keyword">import</span> StructField, StructType, StringType, LongType</span><br><span class="line"></span><br><span class="line">myManualSchema = StructType([</span><br><span class="line">   StructField(<span class="string">"some"</span>, StringType(), <span class="literal">True</span>),</span><br><span class="line">   StructField(<span class="string">"col"</span>, StringType(), <span class="literal">True</span>),</span><br><span class="line">   StructField(<span class="string">"names"</span>, LongType(), <span class="literal">False</span>)</span><br><span class="line">])</span><br><span class="line">myRow = Row(<span class="string">"Hello"</span>, <span class="literal">None</span>, <span class="number">1</span>)</span><br><span class="line">myDf = spark.createDataFrame([myRow], myManualSchema)</span><br><span class="line">myDf.show()</span><br></pre></td></tr></table></figure>
<h2 id="createOrReplaceTempView"><a href="#createOrReplaceTempView" class="headerlink" title="createOrReplaceTempView()"></a>createOrReplaceTempView()</h2><p>创建临时视图，便于用SQL访问</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in Scala</span></span><br><span class="line"><span class="keyword">val</span> df = spark.read.format(<span class="string">"json"</span>)</span><br><span class="line">   .load(<span class="string">"/data/flight-data/json/2015-summary.json"</span>)</span><br><span class="line">df.createOrReplaceTempView(<span class="string">"dfTable"</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># in Python</span></span><br><span class="line">df = spark.read.format(<span class="string">"json"</span>).load(<span class="string">"/data/flight-data/json/2015-summary.json"</span>)</span><br><span class="line">df.createOrReplaceTempView(<span class="string">"dfTable"</span>)</span><br></pre></td></tr></table></figure>
<h2 id="def"><a href="#def" class="headerlink" title="def"></a>def</h2><p>自定义函数</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in Scala</span></span><br><span class="line"><span class="keyword">val</span> udfExampleDF = spark.range(<span class="number">5</span>).toDF(<span class="string">"num"</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">power3</span></span>(number:<span class="type">Double</span>):</span><br><span class="line">    <span class="type">Double</span> = number * number * number</span><br><span class="line">power3(<span class="number">2.0</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># in Python</span></span><br><span class="line">udfExampleDF = spark.range(<span class="number">5</span>).toDF(<span class="string">"num"</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">power3</span><span class="params">(double_value)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> double_value ** <span class="number">3</span></span><br><span class="line">power3(<span class="number">2.0</span>)</span><br></pre></td></tr></table></figure>
<p>目前到115页</p>
<h2 id="distinct"><a href="#distinct" class="headerlink" title="distinct()"></a>distinct()</h2><p>去重</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># in Python</span></span><br><span class="line">df.select(<span class="string">"ORIGIN_COUNTRY_NAME"</span>, <span class="string">"DEST_COUNTRY_NAME"</span>).distinct().count()</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- in SQL</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(<span class="keyword">DISTINCT</span>(ORIGIN_COUNTRY_NAME, DEST_COUNTRY_NAME)) <span class="keyword">FROM</span> dfTable;</span><br></pre></td></tr></table></figure>
<h2 id="drop"><a href="#drop" class="headerlink" title="drop()"></a>drop()</h2><p>删除列；可以通过传入多个列作为参数来同事删除多个列</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.drop(<span class="string">"ORIGIN_COUNTRY_NAME"</span>)</span><br></pre></td></tr></table></figure>
<h2 id="eqNullSafe"><a href="#eqNullSafe" class="headerlink" title="eqNullSafe()"></a>eqNullSafe()</h2><h2 id="euqalTo"><a href="#euqalTo" class="headerlink" title="euqalTo()"></a>euqalTo()</h2><p>Scala中的“等于”，等价于<code>===</code></p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in Scala</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.sql.functions.col</span><br><span class="line">df.where(col(<span class="string">"InvoiceNo"</span>).equalTo(<span class="number">536365</span>))</span><br><span class="line">   .select(<span class="string">"InvoiceNo"</span>, <span class="string">"Description"</span>)</span><br><span class="line">   .show(<span class="number">5</span>, <span class="literal">false</span>)</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line">df.where(col(<span class="string">"InvoiceNo"</span>) === <span class="number">536365</span>)</span><br><span class="line">   .select(<span class="string">"InvoiceNo"</span>, <span class="string">"Description"</span>)</span><br><span class="line">   .show(<span class="number">5</span>, <span class="literal">false</span>)</span><br></pre></td></tr></table></figure>
<h2 id="explain"><a href="#explain" class="headerlink" title="explain()"></a>explain()</h2><ul>
<li>可以通过<code>explain</code>函数观察到Spark是如何执行查询操作的</li>
<li>调用某个DataFrame的<code>explain</code>操作会显示DataFrame的来源</li>
</ul>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"># in scala</span><br><span class="line">flightData.sort(<span class="string">"count"</span>).explain()</span><br><span class="line">==<span class="type">Physical</span> <span class="type">Plan</span>==</span><br><span class="line">*<span class="type">Sort</span> [count#<span class="number">195</span> <span class="type">ASC</span> <span class="type">NULLS</span> <span class="type">FIRST</span>], <span class="literal">true</span>, <span class="number">0</span></span><br><span class="line">+- <span class="type">Exchange</span> rangepartitioning(count#<span class="number">195</span> <span class="type">ASC</span> <span class="type">NULLS</span> <span class="type">FIRST</span>, <span class="number">200</span>)</span><br><span class="line">   +- <span class="type">FileScan</span> csv [<span class="type">DEST_COUNTRY_NAME</span>#<span class="number">193</span>, <span class="type">ORIGIN_COUNTRY_NAME</span>#<span class="number">194</span>, count#<span class="number">195</span>] ...</span><br></pre></td></tr></table></figure>
<h2 id="first"><a href="#first" class="headerlink" title="first()"></a>first()</h2><p>在DataFrame上调用<code>first()</code>查看一行（获取第一行记录）<br><figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">df.<span class="keyword">first</span>()</span><br></pre></td></tr></table></figure></p>
<h2 id="groupBy"><a href="#groupBy" class="headerlink" title="groupBy()"></a>groupBy()</h2><h2 id="head"><a href="#head" class="headerlink" title="head()"></a>head()</h2><ul>
<li><code>head</code>：获取第一行记录</li>
<li><code>head(n: Int)</code>：获取前n行记录</li>
</ul>
<h2 id="leq"><a href="#leq" class="headerlink" title="leq()"></a>leq()</h2><p>小于等于</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in Scala</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.sql.functions.&#123;expr, not, col&#125;</span><br><span class="line">df.withColumn(<span class="string">"isExpensive"</span>, not(col(<span class="string">"UnitPrice"</span>).leq(<span class="number">250</span>)))</span><br><span class="line">  .filter(<span class="string">"isExpensive"</span>)</span><br><span class="line">  .select(<span class="string">"Description"</span>, <span class="string">"UnitPrice"</span>).show(<span class="number">5</span>)</span><br><span class="line">df.withColumn(<span class="string">"isExpensive"</span>, expr(<span class="string">"NOT UnitPrice &lt;= 250"</span>))</span><br><span class="line">  .filter(<span class="string">"isExpensive"</span>)</span><br><span class="line">  .select(<span class="string">"Description"</span>, <span class="string">"UnitPrice"</span>).show(<span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<h2 id="limit"><a href="#limit" class="headerlink" title="limit()"></a>limit()</h2><p>限制提取的记录数目</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in Scala or Python</span></span><br><span class="line">df.limit(<span class="number">5</span>).show()</span><br><span class="line">df.orderBy(expr(<span class="string">"count desc"</span>)).limit(<span class="number">6</span>).show()</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- in SQL</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> dfTable <span class="keyword">LIMIT</span> <span class="number">6</span>;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> dfTable <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">count</span> <span class="keyword">desc</span> <span class="keyword">LIMIT</span> <span class="number">6</span>;</span><br></pre></td></tr></table></figure>
<h2 id="na"><a href="#na" class="headerlink" title="na"></a>na</h2><h3 id="drop-1"><a href="#drop-1" class="headerlink" title="drop()"></a>drop()</h3><p>删除包含NULL的行</p>
<ul>
<li>参数<code>any</code>：当存在一个值是<code>NULL</code>时，就删除该行</li>
<li>参数<code>all</code>：当所有的值为<code>NULL</code>或<code>NaN</code>时，才删除该行</li>
<li>也可指定某几列，对这些列进行删除空值操作</li>
</ul>
<figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line">df.na.<span class="built_in">drop</span>()</span><br><span class="line">df.na.<span class="built_in">drop</span>(<span class="string">"any"</span>)</span><br><span class="line">df.na.<span class="built_in">drop</span>(<span class="string">"all"</span>)</span><br><span class="line">df.na.<span class="built_in">drop</span>(<span class="string">"all"</span>, Seq(<span class="string">"StockCode"</span>, <span class="string">"InvoiceNo"</span>))  <span class="comment">// in Scala</span></span><br><span class="line">df.na.<span class="built_in">drop</span>(<span class="string">"all"</span>, subset = [<span class="string">"StockCode"</span>, <span class="string">"InvoiceNo"</span>])  <span class="meta"># in Python</span></span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 在SQL中需要逐列删除包含NULL的行</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> dfTable <span class="keyword">WHERE</span> Description <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>
<h3 id="fill"><a href="#fill" class="headerlink" title="fill()"></a>fill()</h3><p>可以通过指定一个映射（用一个特定值和一组列），用一组值填充一列或多列</p>
<ul>
<li>可以使用Scala的Map映射实现针对不同的列指定不同的映射方案</li>
</ul>
<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line">df.<span class="literal">na</span>.fill(<span class="string">"All Null values become this string"</span>) <span class="comment">// 用字符串替换列中的所有NULL值</span></span><br><span class="line">df.<span class="literal">na</span>.fill(<span class="number">5</span>:<span class="keyword">Integer</span>)  <span class="comment">// 用5填充Integer类型的列中的NULL值</span></span><br><span class="line">df.<span class="literal">na</span>.fill(<span class="number">5</span>:Double)  <span class="comment">// 用5填充Double类型的列中的NULL值</span></span><br><span class="line">df.<span class="literal">na</span>.fill(<span class="number">5</span>， Seq(<span class="string">"StockCode"</span>， <span class="string">"InvoiceNo"</span>))  <span class="comment">// 指定多列</span></span><br><span class="line"></span><br><span class="line">val fillColValues = Map(<span class="string">"StockCode"</span> -&gt; <span class="number">5</span> ， <span class="string">"Description"</span> -&gt; <span class="string">"No Value"</span>)  <span class="comment">// 指定不同的替换值</span></span><br><span class="line">df.<span class="literal">na</span>.fill(fillColValues)</span><br></pre></td></tr></table></figure>
<h3 id="replace"><a href="#replace" class="headerlink" title="replace()"></a>replace()</h3><p>根据当前值，替换掉某列中的所有值</p>
<ul>
<li>要求替换值与原始值的类型相同</li>
</ul>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in Scala</span></span><br><span class="line">df.na.replace(<span class="string">"Description"</span>， <span class="type">Map</span>(<span class="string">""</span> -&gt; <span class="string">"UNKNOWN"</span>))</span><br><span class="line"><span class="comment">// 将Description列中的空值替换为"UNKNOWN"</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># in Python</span></span><br><span class="line">df.na.replace([<span class="string">""</span>]， [<span class="string">"UNKNOWN"</span>]， <span class="string">"Description"</span>)</span><br></pre></td></tr></table></figure>
<h2 id="or"><a href="#or" class="headerlink" title="or()"></a>or()</h2><p>或</p>
<ul>
<li><code>or</code>语句需要在同一个语句中指定</li>
</ul>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in Scala</span></span><br><span class="line"><span class="keyword">val</span> priceFilter = col(<span class="string">"UnitPrice"</span>) &gt; <span class="number">600</span>  <span class="comment">// 筛选条件1</span></span><br><span class="line"><span class="keyword">val</span> descripFilter = col(<span class="string">"Description"</span>).contains(<span class="string">"POSTAGE"</span>)  <span class="comment">// 筛选条件2</span></span><br><span class="line">df.where(col(<span class="string">"StockCode"</span>).isin(<span class="string">"DOT"</span>)).where(priceFilter.or(descripFilter))</span><br><span class="line">   .show()</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># in Python</span></span><br><span class="line"><span class="keyword">from</span> pyspark.sql.functions <span class="keyword">import</span> instr</span><br><span class="line">priceFilter = col(<span class="string">"UnitPrice"</span>) &gt; <span class="number">600</span></span><br><span class="line">descripFilter = instr(df.Description, <span class="string">"POSTAGE"</span>) &gt;= <span class="number">1</span></span><br><span class="line">df.where(df.StockCode.isin(<span class="string">"DOT"</span>)).where(priceFilter | descripFilter).show()  <span class="comment">## Python的“或”为“|”</span></span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- in SQL</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> dfTable <span class="keyword">WHERE</span> StockCode <span class="keyword">in</span> (<span class="string">"DOT"</span>) <span class="keyword">AND</span>(UnitPrice &gt; <span class="number">600</span> <span class="keyword">OR</span> <span class="keyword">instr</span>(Description, <span class="string">"POSTAGE"</span>) &gt;= <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<h2 id="orderBy"><a href="#orderBy" class="headerlink" title="orderBy()"></a>orderBy()</h2><p>对DataFrame的值进行排序</p>
<ul>
<li><code>sort</code>和<code>orderBy</code>是等价的，均接收列表达式、字符串，以及多个列</li>
<li>默认按升序（asc）排序</li>
<li>如果要指定降序排序，则需使用<code>desc()</code>函数</li>
</ul>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in Scala</span></span><br><span class="line">df.sort(<span class="string">"count"</span>).show(<span class="number">5</span>)</span><br><span class="line">df.orderBy(<span class="string">"count"</span>, <span class="string">"DEST_COUNTRY_NAME"</span>).show(<span class="number">5</span>)</span><br><span class="line">df.orderBy(col(<span class="string">"count"</span>), col(<span class="string">"DEST_COUNTRY_NAME"</span>)).show(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.sql.functions.&#123;desc, asc&#125;</span><br><span class="line">df.orderBy(expr(<span class="string">"count desc"</span>)).show(<span class="number">2</span>)  <span class="comment">// 指定降序排序</span></span><br><span class="line">df.orderBy(desc(<span class="string">"count"</span>), asc(<span class="string">"DEST_COUNTRY_NAME"</span>)).show(<span class="number">2</span>)  <span class="comment">// 分别指定降序、升序排序</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># in Python</span></span><br><span class="line">df.sort(<span class="string">"count"</span>).show(<span class="number">5</span>)</span><br><span class="line">df.orderBy(<span class="string">"count"</span>, <span class="string">"DEST_COUNTRY_NAME"</span>).show(<span class="number">5</span>)</span><br><span class="line">df.orderBy(col(<span class="string">"count"</span>), col(<span class="string">"DEST_COUNTRY_NAME"</span>)).show(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># in Python</span></span><br><span class="line"><span class="keyword">from</span> pyspark.sql.functions <span class="keyword">import</span> desc, asc</span><br><span class="line">df.orderBy(expr(<span class="string">"count desc"</span>)).show(<span class="number">2</span>)</span><br><span class="line">df.orderBy(col(<span class="string">"count"</span>).desc(), col(<span class="string">"DEST_COUNTRY_NAME"</span>).asc()).show(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- in SQL</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> dfTable <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">count</span> <span class="keyword">DESC</span>, DEST_COUNTRY_NAME <span class="keyword">ASC</span> <span class="keyword">LIMIT</span> <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>可以指定空值在排序列表中的位置<ul>
<li><code>asc_nulls_first</code>指示空值排在升序排列之前</li>
<li><code>desc_nulls_first</code>指示空值排在降序排列之前</li>
<li><code>asc_nulls_last</code>指示空值排在升序排列后面</li>
</ul>
</li>
</ul>
<h2 id="printSchema"><a href="#printSchema" class="headerlink" title="printSchema()"></a>printSchema()</h2><p>查询DataFrame的模式（schema）<br><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in scala</span></span><br><span class="line"><span class="keyword">val</span> df = spark.read.format(<span class="string">"json"</span>)</span><br><span class="line">   .load(<span class="string">"/data/flight-data/json/2015-summary.json"</span>)</span><br><span class="line"><span class="comment">// 查询DataFrame的模式</span></span><br><span class="line">df.printSchema()</span><br></pre></td></tr></table></figure></p>
<h2 id="randomSplit"><a href="#randomSplit" class="headerlink" title="randomSplit()"></a>randomSplit()</h2><p>随机分割</p>
<ul>
<li>需要设置分割比例</li>
<li>如果分割比例的和不为1，则比例参数会被归一化</li>
</ul>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将DataFrame按25%和75%的比例分割</span></span><br><span class="line"><span class="keyword">val</span> dataFrames = df.randomSplit(<span class="type">Array</span>(<span class="number">0.25</span>, <span class="number">0.75</span>), <span class="number">8</span>)  <span class="comment">// 其中8为seed参数</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># in Python</span></span><br><span class="line">dataFrames = df.randomSplit([<span class="number">0.25</span>, <span class="number">0.75</span>], <span class="number">8</span>)</span><br></pre></td></tr></table></figure>
<h2 id="range"><a href="#range" class="headerlink" title="range()"></a>range()</h2><h2 id="read"><a href="#read" class="headerlink" title="read"></a>read</h2><p>读取数据</p>
<ul>
<li>是一种转换操作</li>
<li>窄依赖</li>
<li>也是一种惰性操作——Spark并没有马上读取数据，直到在DataFrame上调用动作操作后才会真正读取数据</li>
</ul>
<p><code>option</code>参数：</p>
<ul>
<li><code>inferSchema=true</code>：模式推理，让Spark猜测DataFrame的模式</li>
<li><code>header=true</code>：指定文件的第一行为文件头</li>
</ul>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in scala</span></span><br><span class="line"><span class="keyword">val</span> flightData = spark</span><br><span class="line">   .read</span><br><span class="line">   .option(<span class="string">"inferSchema"</span>, <span class="string">"true"</span>)</span><br><span class="line">   .option(<span class="string">"header"</span>, <span class="string">"true"</span>)</span><br><span class="line">   .csv(<span class="string">"/data/flight-data/csv/summary.csv"</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># in python</span></span><br><span class="line">flightData = spark\</span><br><span class="line">   .read\</span><br><span class="line">   .option(<span class="string">"inferSchema"</span>, <span class="string">"true"</span>)\</span><br><span class="line">   .option(<span class="string">"header"</span>, <span class="string">"true"</span>)\</span><br><span class="line">   .csv(<span class="string">"/data/flight-data/csv/summary.csv"</span>)</span><br><span class="line"><span class="comment"># 注意：python换行的话，行末需要加转义</span></span><br></pre></td></tr></table></figure>
<h2 id="repartition"><a href="#repartition" class="headerlink" title="repartition()"></a>repartition()</h2><p>重新分区</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in Scala or Python</span></span><br><span class="line">df.repartition(<span class="number">5</span>)  <span class="comment">// 设置分区数为5</span></span><br><span class="line">df.repartition(col(<span class="string">"DEST_COUNTRY_NAME"</span>))  <span class="comment">// 按照某列DEST_COUNTRY_NAME进行分区</span></span><br><span class="line">df.repartition(<span class="number">5</span>, col(<span class="string">"DEST_COUNTRY_NAME"</span>))  <span class="comment">// 指定分区数和列</span></span><br></pre></td></tr></table></figure>
<h2 id="sample"><a href="#sample" class="headerlink" title="sample()"></a>sample()</h2><p>随机抽样；按一定比例从DataFrame中随机抽取一部分行</p>
<ul>
<li>参数<code>withReplacement</code>指定是否放回抽样<ul>
<li><code>true</code>为有放回抽样/有重复抽样</li>
<li><code>false</code>为无放回抽样/无重复抽样 </li>
</ul>
</li>
</ul>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in scala</span></span><br><span class="line"><span class="keyword">val</span> seed = <span class="number">5</span></span><br><span class="line"><span class="keyword">val</span> withReplacement = <span class="literal">false</span> <span class="comment">// 无重复抽样</span></span><br><span class="line"><span class="keyword">val</span> fraction = <span class="number">0.5</span> <span class="comment">// 抽取50%</span></span><br><span class="line">df.sample(withReplacement, fraction, seed).count()</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># in Python</span></span><br><span class="line">seed = <span class="number">5</span></span><br><span class="line">withReplacement = <span class="literal">False</span></span><br><span class="line">fraction = <span class="number">0.5</span></span><br><span class="line">df.sample(withReplacement, fraction, seed).count()</span><br></pre></td></tr></table></figure>
<h2 id="select"><a href="#select" class="headerlink" title="select()"></a>select()</h2><p>处理列或表达式</p>
<ul>
<li>将待处理的列名字符串作为参数传递</li>
<li>添加多个列名字符串，可以选择多个列</li>
<li>不能混淆使用Column对象和字符串</li>
</ul>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in Scala</span></span><br><span class="line">df.select(<span class="string">"DEST_COUNTRY_NAME"</span>).show(<span class="number">2</span>)</span><br><span class="line"><span class="comment">// 选择多个列</span></span><br><span class="line">df.select(<span class="string">"DEST_COUNTRY_NAME"</span>, <span class="string">"ORIGIN_COUNTRY_NAME"</span>).show(<span class="number">2</span>)</span><br><span class="line"><span class="comment">// 可以通过多种不同的方式引用列</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.sql.functions.&#123;expr, col, column&#125;</span><br><span class="line">df.select(</span><br><span class="line">   df.col(<span class="string">"DEST_COUNTRY_NAME"</span>),</span><br><span class="line">      col(<span class="string">"DEST_COUNTRY_NAME"</span>),</span><br><span class="line">      column(<span class="string">"DEST_COUNTRY_NAME"</span>),</span><br><span class="line">      <span class="symbol">'DEST_COUNTRY_NAME</span>,</span><br><span class="line">      $<span class="string">"DEST_COUNTRY_NAME"</span>,</span><br><span class="line">      expr(<span class="string">"DEST_COUNTRY_NAME"</span>))</span><br><span class="line">   .show(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># in Python</span></span><br><span class="line">df.select(<span class="string">"DEST_COUNTRY_NAME"</span>).show(<span class="number">2</span>)</span><br><span class="line"><span class="comment"># 选择多个列</span></span><br><span class="line">df.select(<span class="string">"DEST_COUNTRY_NAME"</span>, <span class="string">"ORIGIN_COUNTRY_NAME"</span>).show(<span class="number">2</span>)</span><br><span class="line"><span class="comment"># 可以通过多种不同的方式引用列</span></span><br><span class="line"><span class="keyword">from</span> pyspark.sql.functions <span class="keyword">import</span> expr, col, column</span><br><span class="line">df.select(</span><br><span class="line">   expr(<span class="string">"DEST_COUNTRY_NAME"</span>),</span><br><span class="line">   col(<span class="string">"DEST_COUNTRY_NAME"</span>),</span><br><span class="line">   column(<span class="string">"DEST_COUNTRY_NAME"</span>))\</span><br><span class="line">.show(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- in SQL</span></span><br><span class="line"><span class="keyword">SELECT</span> DEST_COUNTRY_NAME <span class="keyword">FROM</span> dfTable <span class="keyword">LIMIT</span> <span class="number">2</span></span><br><span class="line"><span class="comment">-- 选择多个列</span></span><br><span class="line"><span class="keyword">SELECT</span> DEST_COUNTRY_NAME, ORIGIN_COUNTRY_NAME <span class="keyword">FROM</span> dfTable <span class="keyword">LIMIT</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>
<h2 id="selectExpr"><a href="#selectExpr" class="headerlink" title="selectExpr()"></a>selectExpr()</h2><p>可以用于构造复杂表达式来创建DataFrame</p>
<ul>
<li>是常用的接口之一</li>
<li>可以添加任何不包含聚合操作的有效SQL语句</li>
<li>可以使用系统预定义的聚合函数来指定在整个DataFrame上的聚合操作</li>
</ul>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in scala</span></span><br><span class="line">df.selectExpr(</span><br><span class="line">   <span class="string">"*"</span>, <span class="comment">// 包含所有原始表中的列</span></span><br><span class="line">   <span class="string">"(DEST_COUNTRY_NAME = ORIGIN_COUNTRY_NAME) as withinCountry"</span>  <span class="comment">// 增加新列withinCountry</span></span><br><span class="line">   )</span><br><span class="line">.show(<span class="number">2</span>)</span><br><span class="line"><span class="comment">// 使用系统预定义的聚合函数来指定在整个DataFrame上的聚合操作</span></span><br><span class="line">df.selectExpr(<span class="string">"avg(count)"</span>, <span class="string">"count(distinct(DEST_COUNTRY_NAME))"</span>).show(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># in Python</span></span><br><span class="line">df.selectExpr(</span><br><span class="line">   <span class="string">"*"</span>, <span class="comment"># 包含所有原始表中的列</span></span><br><span class="line">   <span class="string">"(DEST_COUNTRY_NAME = ORIGIN_COUNTRY_NAME) as withinCountry"</span>)\</span><br><span class="line">.show(<span class="number">2</span>)</span><br><span class="line"><span class="comment"># 使用系统预定义的聚合函数来指定在整个DataFrame上的聚合操作</span></span><br><span class="line">df.selectExpr(<span class="string">"avg(count)"</span>, <span class="string">"count(distinct(DEST_COUNTRY_NAME))"</span>).show(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- in SQL</span></span><br><span class="line"><span class="keyword">SELECT</span> *, (DEST_COUNTRY_NAME = ORIGIN_COUNTRY_NAME) <span class="keyword">as</span> withinCountry</span><br><span class="line"><span class="keyword">FROM</span> dfTable</span><br><span class="line"><span class="keyword">LIMIT</span> <span class="number">2</span>;</span><br><span class="line"><span class="comment">-- 使用系统预定义的聚合函数来指定在整个DataFrame上的聚合操作</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">AVG</span>(<span class="keyword">count</span>), <span class="keyword">COUNT</span>(<span class="keyword">distinct</span>(DEST_COUNTRY_NAME)) <span class="keyword">FROM</span> dfTable <span class="keyword">LIMIT</span> <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<h2 id="show"><a href="#show" class="headerlink" title="show()"></a>show()</h2><ul>
<li><code>show</code>：默认显示DataFrame的前20条记录</li>
<li><code>show(numRows: Int)</code>：显示numRows条记录</li>
<li><code>show(truncate: Boolean)</code>：是否每列最多只显示20个字符，默认为true <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.show(true)  <span class="comment"># 空格也算一个字符</span></span><br><span class="line">df.show(false)</span><br></pre></td></tr></table></figure></li>
<li><code>show(numRows: Int, truncate: Boolean)</code>：显示numRows条记录，且每列是否最多显示20个字符</li>
</ul>
<h2 id="sort"><a href="#sort" class="headerlink" title="sort()"></a>sort()</h2><ul>
<li>宽依赖(因为行之间需要相互比较和交换)</li>
<li>不会修改DataFrame，通过转换DataFrame来返回新的DataFrame</li>
</ul>
<h2 id="sql"><a href="#sql" class="headerlink" title="sql()"></a>sql()</h2><p>使用<code>spark.sql()</code>函数在SQL中查询数据，返回新的DataFrame</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in scala</span></span><br><span class="line"><span class="keyword">val</span> sqlWay = spark.sql(<span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">   SELECT DEST_COUNTRY_NAME, count(1)</span></span><br><span class="line"><span class="string">   FROM flight_data</span></span><br><span class="line"><span class="string">   GROUP BY DEST_COUNTRY_NAME</span></span><br><span class="line"><span class="string">"</span><span class="string">""</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> <span class="type">DataFrameWay</span> = flightData</span><br><span class="line">   .groupby(<span class="symbol">'DEST_COUNTRY_NAM</span>E')</span><br><span class="line">   .count()</span><br><span class="line"></span><br><span class="line">sqlWay.explain()</span><br><span class="line">== <span class="type">Physical</span> <span class="type">Plan</span> ==</span><br><span class="line">*<span class="type">HashAggregate</span>(keys=[<span class="type">DEST_COUNTRY_NAME</span>#<span class="number">182</span>], functions=[count(<span class="number">1</span>)])</span><br><span class="line">+- <span class="type">Exchange</span> hashpartitioning(<span class="type">DEST_COUNTRY_NAME</span>#<span class="number">182</span>, <span class="number">5</span>)</span><br><span class="line">   +- *<span class="type">HashAggregate</span>(keys=[<span class="type">DEST_COUNTRY_NAME</span>#<span class="number">182</span>], functions=[partial_count(<span class="number">1</span>)])</span><br><span class="line">      +- *<span class="type">FileScan</span> csv [<span class="type">DEST_COUNTRY_NAME</span>#<span class="number">182</span>] ...</span><br><span class="line"></span><br><span class="line"><span class="type">DataFrameWay</span>.explain()</span><br><span class="line">== <span class="type">Physical</span> <span class="type">Plan</span> ==</span><br><span class="line">*<span class="type">HashAggregate</span>(keys=[<span class="type">DEST_COUNTRY_NAME</span>#<span class="number">182</span>], functions=[count(<span class="number">1</span>)])</span><br><span class="line">+- <span class="type">Exchange</span> hashpartitioning(<span class="type">DEST_COUNTRY_NAME</span>#<span class="number">182</span>, <span class="number">5</span>)</span><br><span class="line">   +- *<span class="type">HashAggregate</span>(keys=[<span class="type">DEST_COUNTRY_NAME</span>#<span class="number">182</span>], functions=[partial_count(<span class="number">1</span>)])</span><br><span class="line">      +- *<span class="type">FileScan</span> csv [<span class="type">DEST_COUNTRY_NAME</span>#<span class="number">182</span>] ...</span><br></pre></td></tr></table></figure>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in scala</span></span><br><span class="line"><span class="keyword">val</span> maxSql = spark.sql(<span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">   SELECT DEST_COUNTRY_NAME, sum(count) AS destination_total</span></span><br><span class="line"><span class="string">   FROM flight_data</span></span><br><span class="line"><span class="string">   GOURP BY DEST_COUNTRY_NAME</span></span><br><span class="line"><span class="string">   ORDER BY sum(count) DESC</span></span><br><span class="line"><span class="string">   LIMIT 5</span></span><br><span class="line"><span class="string">"</span><span class="string">""</span>)</span><br><span class="line">maxSql.show()</span><br></pre></td></tr></table></figure>
<h2 id="take"><a href="#take" class="headerlink" title="take()"></a>take()</h2><p><code>take(n: Int)</code>：获取前n行数据</p>
<ul>
<li><code>take</code>和<code>takeAsList</code>会将获得的数据返回到Driver端，使用时应注意数据量，以免Driver发生<code>OutOfMemoryError</code></li>
</ul>
<h2 id="takeAsList"><a href="#takeAsList" class="headerlink" title="takeAsList()"></a>takeAsList()</h2><p>获取前n行数据，并以List形式展现</p>
<ul>
<li><code>take</code>和<code>takeAsList</code>会将获得的数据返回到Driver端，使用时应注意数据量，以免Driver发生<code>OutOfMemoryError</code></li>
</ul>
<h2 id="toDF"><a href="#toDF" class="headerlink" title="toDF()"></a>toDF()</h2><h2 id="toLocalIterator"><a href="#toLocalIterator" class="headerlink" title="toLocalIterator()"></a>toLocalIterator()</h2><p>该函数是一个迭代器，将每个分区的数据返回给驱动器</p>
<ul>
<li>允许以串行的方式一个一个分区地迭代整个数据集</li>
<li>使用该函数，且分区很大时，很容易使驱动器节点崩溃并丢失应用程序的状态，代价很大</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># in Python</span></span><br><span class="line">collectDF = df.limit(<span class="number">10</span>)</span><br><span class="line">collectDF.toLocalIterator()</span><br></pre></td></tr></table></figure>
<h2 id="union"><a href="#union" class="headerlink" title="union()"></a>union()</h2><p>连接/拼接两个DataFrame</p>
<ul>
<li>被连接的两个DataFrame需要具有完全相同的模式和列数</li>
</ul>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in Scala</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.sql.<span class="type">Row</span></span><br><span class="line"><span class="keyword">val</span> schema = df.schema</span><br><span class="line"><span class="keyword">val</span> newRows = <span class="type">Seq</span>(</span><br><span class="line">   <span class="type">Row</span>(<span class="string">"New Country"</span>, <span class="string">"Other Country"</span>, <span class="number">5</span>L),</span><br><span class="line">   <span class="type">Row</span>(<span class="string">"New Country 2"</span>, <span class="string">"Other Country 3"</span>, <span class="number">1</span>L)</span><br><span class="line">)</span><br><span class="line"><span class="keyword">val</span> parallelizedRows = spark.sparkContext.parallelize(newRows)</span><br><span class="line"><span class="keyword">val</span> newDF = spark.createDataFrame(parallelizedRows, schema)</span><br><span class="line">df.union(newDF)</span><br><span class="line">   .where(<span class="string">"count = 1"</span>)</span><br><span class="line">   .where($<span class="string">"ORIGIN_COUNTRY_NAME"</span> =!= <span class="string">"United States"</span>)</span><br><span class="line">   .show()</span><br></pre></td></tr></table></figure>
<h2 id="where"><a href="#where" class="headerlink" title="where()"></a>where()</h2><p>过滤行，与<code>filter()</code>等价</p>
<ul>
<li>Spark同时执行所有过滤操作（不论过滤条件的先后顺序）</li>
</ul>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">df.filter(col(<span class="string">"count"</span>) &lt; <span class="number">2</span>).show(<span class="number">2</span>)</span><br><span class="line"><span class="comment">// 在Scala和Python中等价于</span></span><br><span class="line">df.where(<span class="string">"count &lt; 2"</span>).show(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p>等价于<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> dfTable <span class="keyword">WHERE</span> <span class="keyword">count</span> &lt; <span class="number">2</span> <span class="keyword">LIMIT</span> <span class="number">2</span>;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in scala</span></span><br><span class="line">df.where(col(<span class="string">"count"</span>) &lt; <span class="number">2</span>).where(col(<span class="string">"ORIGIN_COUNTRY_NAME"</span>) =!= <span class="string">"Croatia"</span>)</span><br><span class="line">   .show(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># in python</span></span><br><span class="line">df.where(col(<span class="string">"count"</span>) &lt; <span class="number">2</span>).where(col(<span class="string">"ORIGIN_COUNTRY_NAME"</span>) != <span class="string">"Croatia"</span>)\</span><br><span class="line">  .show(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- in SQL</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> dfTable <span class="keyword">WHERE</span> <span class="keyword">count</span> &lt; <span class="number">2</span> <span class="keyword">AND</span> ORIGIN_COUNTRY_NAME != <span class="string">"Croatia"</span></span><br><span class="line"><span class="keyword">LIMIT</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>
<ul>
<li>将过滤器表示为SQL语句比使用编程式的DataFrame接口更简单</li>
</ul>
<h2 id="withColumn"><a href="#withColumn" class="headerlink" title="withColumn()"></a>withColumn()</h2><p>添加新列</p>
<ul>
<li>包含两个参数：<ol>
<li>列名</li>
<li>为给定行赋值的表达式</li>
</ol>
</li>
<li>还可用于对列重命名</li>
</ul>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in scala or python</span></span><br><span class="line">df.withColumn(<span class="string">"numberOne"</span>, lit(<span class="number">1</span>)).show(<span class="number">2</span>) <span class="comment">// 添加一个仅包含数字1的列numberOne</span></span><br><span class="line"><span class="comment">// 从已有的列DEST_COUNTRY_NAME新建列Destination并删除旧列DEST_COUNTRY_NAME</span></span><br><span class="line">df.withColumn(<span class="string">"Destination"</span>, expr(<span class="string">"DEST_COUNTRY_NAME"</span>))</span><br><span class="line">  .drop(<span class="string">"DEST_COUNTRY_NAME"</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- in SQL</span></span><br><span class="line"><span class="keyword">SELECT</span> *, <span class="number">1</span> <span class="keyword">AS</span> numberOne <span class="keyword">FROM</span> dfTable <span class="keyword">LIMIT</span> <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<h2 id="withColumnRenamed"><a href="#withColumnRenamed" class="headerlink" title="withColumnRenamed()"></a>withColumnRenamed()</h2><p>重命名列</p>
<ul>
<li>第一个参数是原始列名称</li>
<li>第二个参数是新列名称</li>
</ul>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in Scala</span></span><br><span class="line"><span class="comment">// 将DEST_COUNTRY_NAME重命名为dest</span></span><br><span class="line">df.withColumnRenamed(<span class="string">"DEST_COUNTRY_NAME"</span>, <span class="string">"dest"</span>)</span><br></pre></td></tr></table></figure>
<h1 id="functions"><a href="#functions" class="headerlink" title="functions"></a>functions</h1><h2 id="alias"><a href="#alias" class="headerlink" title="alias()"></a>alias()</h2><p>为选择的列起别名<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># in Python</span></span><br><span class="line"><span class="keyword">from</span> pyspark.sql.functions <span class="keyword">import</span> expr, pow</span><br><span class="line">fabricatedQuantity = pow(col(<span class="string">"Quantity"</span>) * col(<span class="string">"UnitPrice"</span>), <span class="number">2</span>) + <span class="number">5</span></span><br><span class="line">df.select(expr(<span class="string">"CustomerId"</span>), fabricatedQuantity.alias(<span class="string">"realQuantity"</span>)).show(<span class="number">2</span>)</span><br></pre></td></tr></table></figure></p>
<h2 id="array-contains"><a href="#array-contains" class="headerlink" title="array_contains()"></a>array_contains()</h2><p>查询数组是否包含某个值</p>
<ul>
<li>返回<code>true</code>或<code>false</code></li>
</ul>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in Scala</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.sql.functions.array_contains</span><br><span class="line">df.select(array_contains(split(col(<span class="string">"Description"</span>), <span class="string">" "</span>), <span class="string">"WHITE"</span>)).show(<span class="number">2</span>)</span><br><span class="line"><span class="comment">// 将Description按照空格拆分成数组，判断拆分后的数组是否包含字符串"WHITE"</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># in Python</span></span><br><span class="line"><span class="keyword">from</span> pyspark.sql.functions <span class="keyword">import</span> array_contains</span><br><span class="line">df.select(array_contains(split(col(<span class="string">"Description"</span>), <span class="string">" "</span>), <span class="string">"WHITE"</span>)).show(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ARRAY_CONTAINS(<span class="keyword">SPLIT</span>(<span class="keyword">COL</span>(<span class="string">"Desription"</span>), <span class="string">" "</span>), <span class="string">"WHITE"</span>) <span class="keyword">FROM</span> dfTable;</span><br></pre></td></tr></table></figure>
<h2 id="coalesce-1"><a href="#coalesce-1" class="headerlink" title="coalesce()"></a>coalesce()</h2><p>从一组列中选择第一个非空值（第一个非NULL值）</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in Scala</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.sql.functions.coalesce</span><br><span class="line">df.select(coalesce(col(<span class="string">"Description"</span>)， col(<span class="string">"CustomerId"</span>))).show()</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># in Python</span></span><br><span class="line"><span class="keyword">from</span> pyspark.sql.functions <span class="keyword">import</span> coalesce</span><br><span class="line">df.select(coalesce(col(<span class="string">"Description"</span>)， col(<span class="string">"CustomerId"</span>))).show()</span><br></pre></td></tr></table></figure>
<h2 id="col-、column"><a href="#col-、column" class="headerlink" title="col()、column()"></a>col()、column()</h2><p>构造和引用列（获取指定字段）；需要传入列名</p>
<ul>
<li>返回对象为Column类型</li>
</ul>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in scala</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.sql.functions.&#123;col, column&#125;</span><br><span class="line">col(<span class="string">"someColumnName"</span>)</span><br><span class="line">column(<span class="string">"someColumnName"</span>)</span><br><span class="line"><span class="comment">// Scala还可使用下列方式创建列</span></span><br><span class="line">$<span class="string">"myColumn"</span></span><br><span class="line"><span class="symbol">'myColumn</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># in python</span></span><br><span class="line"><span class="keyword">from</span> pyspark.sql.functions <span class="keyword">import</span> col, column</span><br><span class="line">col(<span class="string">"someColumnName"</span>)</span><br><span class="line">column(<span class="string">"someColumnName"</span>)</span><br></pre></td></tr></table></figure>
<h2 id="collect"><a href="#collect" class="headerlink" title="collect()"></a>collect()</h2><p>从整个DataFrame中获取所有数据</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># in Python</span></span><br><span class="line">collectDF = df.limit(<span class="number">10</span>)</span><br><span class="line">collectDF.take(<span class="number">5</span>) <span class="comment"># 获取整数行</span></span><br><span class="line">collectDF.show() <span class="comment"># 更友好的打印</span></span><br><span class="line">collectDF.show(<span class="number">5</span>, <span class="literal">False</span>)</span><br><span class="line">collectDF.collect() <span class="comment"># 获取所有的数据</span></span><br></pre></td></tr></table></figure>
<h2 id="corr"><a href="#corr" class="headerlink" title="corr()"></a>corr()</h2><p>计算两列的相关系数</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in Scala</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.sql.functions.&#123;corr&#125;</span><br><span class="line">df.stat.corr(<span class="string">"Quantity"</span>, <span class="string">"UnitPrice"</span>)</span><br><span class="line">df.select(corr(<span class="string">"Quantity"</span>, <span class="string">"UnitPrice"</span>)).show()</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># in Python</span></span><br><span class="line"><span class="keyword">from</span> pyspark.sql.functions <span class="keyword">import</span> corr</span><br><span class="line">df.stat.corr(<span class="string">"Quantity"</span>, <span class="string">"UnitPrice"</span>)</span><br><span class="line">df.select(corr(<span class="string">"Quantity"</span>, <span class="string">"UnitPrice"</span>)).show()</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- in SQL</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">corr</span>(Quantity, UnitPrice) <span class="keyword">FROM</span> dfTable;</span><br></pre></td></tr></table></figure>
<h2 id="count"><a href="#count" class="headerlink" title="count"></a>count</h2><p>统计记录条数</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">// <span class="keyword">in</span> Scala</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.<span class="keyword">sql</span>.<span class="keyword">functions</span>.&#123;count&#125;</span><br><span class="line"></span><br><span class="line"># <span class="keyword">in</span> Python</span><br><span class="line"><span class="keyword">from</span> pyspark.<span class="keyword">sql</span>.<span class="keyword">functions</span> <span class="keyword">import</span> count</span><br></pre></td></tr></table></figure>
<h2 id="current-date"><a href="#current-date" class="headerlink" title="current_date()"></a>current_date()</h2><p>获取当前日期</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in Scala</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.sql.functions.&#123;current_date, current_timestamp&#125;</span><br><span class="line"><span class="keyword">val</span> dateDF = spark.range(<span class="number">10</span>)</span><br><span class="line">  .withColumn(<span class="string">"today"</span>, current_date())</span><br><span class="line">  .withColumn(<span class="string">"now"</span>, current_timestamp())</span><br><span class="line">dateDF.createOrReplaceTempView(<span class="string">"dateTable"</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># in Python</span></span><br><span class="line"><span class="keyword">from</span> pyspark.sql.functions <span class="keyword">import</span> current_date, current_timestamp</span><br><span class="line">dateDF = spark.range(<span class="number">10</span>)\</span><br><span class="line">  .withColumn(<span class="string">"today"</span>, current_date())\</span><br><span class="line">  .withColumn(<span class="string">"now"</span>, current_timestamp())</span><br><span class="line">dateDF.createOrReplaceTempView(<span class="string">"dateTable"</span>)</span><br></pre></td></tr></table></figure>
<h2 id="current-timestamp"><a href="#current-timestamp" class="headerlink" title="current_timestamp()"></a>current_timestamp()</h2><p>获取当前时间戳</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in Scala</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.sql.functions.&#123;current_date, current_timestamp&#125;</span><br><span class="line"><span class="keyword">val</span> dateDF = spark.range(<span class="number">10</span>)</span><br><span class="line">  .withColumn(<span class="string">"today"</span>, current_date())</span><br><span class="line">  .withColumn(<span class="string">"now"</span>, current_timestamp())</span><br><span class="line">dateDF.createOrReplaceTempView(<span class="string">"dateTable"</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># in Python</span></span><br><span class="line"><span class="keyword">from</span> pyspark.sql.functions <span class="keyword">import</span> current_date, current_timestamp</span><br><span class="line">dateDF = spark.range(<span class="number">10</span>)\</span><br><span class="line">  .withColumn(<span class="string">"today"</span>, current_date())\</span><br><span class="line">  .withColumn(<span class="string">"now"</span>, current_timestamp())</span><br><span class="line">dateDF.createOrReplaceTempView(<span class="string">"dateTable"</span>)</span><br></pre></td></tr></table></figure>
<h2 id="date-add"><a href="#date-add" class="headerlink" title="date_add()"></a>date_add()</h2><p>添加天数</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in Scala</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.sql.functions.&#123;date_add, date_sub&#125;</span><br><span class="line">dateDF.select(date_sub(col(<span class="string">"today"</span>), <span class="number">5</span>), date_add(col(<span class="string">"today"</span>), <span class="number">5</span>)).show(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># in Python</span></span><br><span class="line"><span class="keyword">from</span> pyspark.sql.functions <span class="keyword">import</span> date_add, date_sub</span><br><span class="line">dateDF.select(date_sub(col(<span class="string">"today"</span>), <span class="number">5</span>), date_add(col(<span class="string">"today"</span>), <span class="number">5</span>)).show(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- in SQL</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DATE_SUB</span>(today, <span class="number">5</span>), <span class="keyword">DATE_ADD</span>(today, <span class="number">5</span>) <span class="keyword">FROM</span> dateTable;</span><br></pre></td></tr></table></figure>
<h2 id="datediff"><a href="#datediff" class="headerlink" title="datediff()"></a>datediff()</h2><p>查看两个日期之间的间隔时间（返回两个日期之间的天数）<br><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in Scala</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.sql.functions.&#123;datediff, months_between, to_date&#125;</span><br><span class="line">dateDF.withColumn(<span class="string">"week_ago"</span>, date_sub(col(<span class="string">"today"</span>), <span class="number">7</span>))</span><br><span class="line">  .select(datediff(col(<span class="string">"week_ago"</span>), col(<span class="string">"today"</span>))).show(<span class="number">1</span>)</span><br><span class="line">dateDF.select(</span><br><span class="line">  to_date(lit(<span class="string">"2016-01-01"</span>)).alias(<span class="string">"start"</span>),</span><br><span class="line">  to_date(lit(<span class="string">"2017-05-22"</span>)).alias(<span class="string">"end"</span>))</span><br><span class="line">  .select(months_between(col(<span class="string">"start"</span>), col(<span class="string">"end"</span>))).show(<span class="number">1</span>)</span><br></pre></td></tr></table></figure></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># in Python</span></span><br><span class="line"><span class="keyword">from</span> pyspark.sql.functions <span class="keyword">import</span> datediff, months_between, to_date</span><br><span class="line">dateDF.withColumn(<span class="string">"week_ago"</span>, date_sub(col(<span class="string">"today"</span>), <span class="number">7</span>))\</span><br><span class="line">  .select(datediff(col(<span class="string">"week_ago"</span>), col(<span class="string">"today"</span>))).show(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- in SQL</span></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">   <span class="keyword">to_date</span>(<span class="string">'2016-01-01'</span>), </span><br><span class="line">   months_between(<span class="string">'2016-01-01'</span>, <span class="string">'2017-01-01'</span>), <span class="keyword">datediff</span>(<span class="string">'2016-01-01'</span>, <span class="string">'2017-01-01'</span>)</span><br><span class="line"><span class="keyword">FROM</span> dateTable;</span><br></pre></td></tr></table></figure>
<h2 id="date-sub"><a href="#date-sub" class="headerlink" title="date_sub()"></a>date_sub()</h2><p>减去天数</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in Scala</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.sql.functions.&#123;date_add, date_sub&#125;</span><br><span class="line">dateDF.select(date_sub(col(<span class="string">"today"</span>), <span class="number">5</span>), date_add(col(<span class="string">"today"</span>), <span class="number">5</span>)).show(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># in Python</span></span><br><span class="line"><span class="keyword">from</span> pyspark.sql.functions <span class="keyword">import</span> date_add, date_sub</span><br><span class="line">dateDF.select(date_sub(col(<span class="string">"today"</span>), <span class="number">5</span>), date_add(col(<span class="string">"today"</span>), <span class="number">5</span>)).show(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- in SQL</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DATE_SUB</span>(today, <span class="number">5</span>), <span class="keyword">DATE_ADD</span>(today, <span class="number">5</span>) <span class="keyword">FROM</span> dateTable;</span><br></pre></td></tr></table></figure>
<h2 id="desc"><a href="#desc" class="headerlink" title="desc()"></a>desc()</h2><ul>
<li>降序排列</li>
<li>结合<code>sort</code>、<code>orderBy</code>使用</li>
<li><code>desc</code>函数返回的是一个Column，而不是一个字符串</li>
</ul>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in scala</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.sql.functions.desc</span><br><span class="line"></span><br><span class="line">flightData</span><br><span class="line">   .groupBy(<span class="string">"DEST_COUNTRY_NAME"</span>)</span><br><span class="line">   .sum(<span class="string">"count"</span>)</span><br><span class="line">   .withColumnRenamed(<span class="string">"sum(count)"</span>, <span class="string">"destination_total"</span>)</span><br><span class="line">   .sort(desc(<span class="string">"destination_total"</span>))</span><br><span class="line">   .limit(<span class="number">5</span>)</span><br><span class="line">   .show()</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># in python</span></span><br><span class="line"><span class="keyword">from</span> pyspark.sql.functions <span class="keyword">import</span> desc</span><br><span class="line"></span><br><span class="line">flightData\</span><br><span class="line">   .groupBy(<span class="string">"DEST_COUNTRY_NAME"</span>)\</span><br><span class="line">   .sum(<span class="string">"count"</span>)\</span><br><span class="line">   .withColumnRenamed(<span class="string">"sum(count)"</span>, <span class="string">"destination_total"</span>)\</span><br><span class="line">   .sort(desc(<span class="string">"destination_total"</span>))\</span><br><span class="line">   .limit(<span class="number">5</span>)\</span><br><span class="line">   .show()</span><br></pre></td></tr></table></figure>
<p>33页插图</p>
<h2 id="describe"><a href="#describe" class="headerlink" title="describe()"></a>describe()</h2><p>返回数值类型字段的描述性统计值（汇总统计信息）</p>
<ul>
<li>返回DataFrame对象</li>
<li>返回以下统计值：<ul>
<li><code>count</code>：样本数</li>
<li><code>mean</code>：均值</li>
<li><code>stddev</code>：标准差</li>
<li><code>min</code>：最小值</li>
<li><code>max</code>：最大值</li>
</ul>
</li>
<li>如果某列是字符类型，则<code>mean</code>和<code>stddev</code>为<code>null</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># in Python or Scala</span></span><br><span class="line">df.describe().show()</span><br></pre></td></tr></table></figure>
<h2 id="explode"><a href="#explode" class="headerlink" title="explode()"></a>explode()</h2><p>为输入的数组中的每个值创建一行。如，对<code>[&quot;Hello&quot;, &quot;World&quot;], &quot;other col&quot;</code>实施<code>explode</code>后得到<br><figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line"><span class="string">"Hello"</span>, <span class="string">"other col"</span></span><br><span class="line"><span class="string">"World"</span>, <span class="string">"other col"</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in Scala</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.sql.functions.&#123;split, explode&#125;</span><br><span class="line">df.withColumn(<span class="string">"splitted"</span>, split(col(<span class="string">"Description"</span>), <span class="string">" "</span>))</span><br><span class="line">  .withColumn(<span class="string">"exploded"</span>, explode(col(<span class="string">"splitted"</span>)))</span><br><span class="line">  .select(<span class="string">"Description"</span>, <span class="string">"InvoiceNo"</span>, <span class="string">"exploded"</span>).show(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># in Python</span></span><br><span class="line"><span class="keyword">from</span> pyspark.sql.functions <span class="keyword">import</span> split, explode</span><br><span class="line">df.withColumn(<span class="string">"splitted"</span>, split(col(<span class="string">"Description"</span>), <span class="string">" "</span>))\</span><br><span class="line">  .withColumn(<span class="string">"exploded"</span>, explode(col(<span class="string">"splitted"</span>)))\</span><br><span class="line">  .select(<span class="string">"Description"</span>, <span class="string">"InvoiceNo"</span>, <span class="string">"exploded"</span>).show(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">   Description, InvoiceNo, exploded</span><br><span class="line"><span class="keyword">FROM</span> (</span><br><span class="line">   <span class="keyword">SELECT</span> *, <span class="keyword">SPLIT</span>(Description, <span class="string">" "</span>) <span class="keyword">AS</span> splitted <span class="keyword">FROM</span> dfTable</span><br><span class="line">)</span><br><span class="line"><span class="keyword">LATERAL</span> <span class="keyword">VIEW</span> <span class="keyword">EXPLODE</span>(splitted) <span class="keyword">AS</span> exploded;</span><br></pre></td></tr></table></figure>
<ul>
<li>可使用<code>explode()</code>展开map类型，将其转换为列</li>
</ul>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in Scala</span></span><br><span class="line">df.select(map(col(<span class="string">"Description"</span>), col(<span class="string">"InvoiceNo"</span>)).alias(<span class="string">"complex_map"</span>))</span><br><span class="line">  .selectExpr(<span class="string">"explode(complex_map)"</span>).show(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># in Python</span></span><br><span class="line">df.select(map(col(<span class="string">"Description"</span>), col(<span class="string">"InvoiceNo"</span>)).alias(<span class="string">"complex_map"</span>))\</span><br><span class="line">  .selectExpr(<span class="string">"explode(complex_map)"</span>).show(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p>展开结果如下：<br><figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="code">+--------------------+</span>------+</span><br><span class="line">|                 key| value|</span><br><span class="line"><span class="code">+--------------------+</span>------+</span><br><span class="line">|WHITE HANGING HEA...|536365|</span><br><span class="line">| WHITE METAL LANTERN|536365|</span><br><span class="line"><span class="code">+--------------------+</span>------+</span><br></pre></td></tr></table></figure></p>
<h2 id="from-json"><a href="#from-json" class="headerlink" title="from_json()"></a>from_json()</h2><p>解析JSON数据</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in Scala</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.sql.functions.from_json</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.sql.types._  <span class="comment">// 加载所有的types</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> parseSchema = <span class="keyword">new</span> <span class="type">StructType</span>(<span class="type">Array</span>(</span><br><span class="line">   <span class="keyword">new</span> <span class="type">StructField</span>(<span class="string">"InvoiceNo"</span>, <span class="type">StringType</span>, <span class="literal">true</span>),</span><br><span class="line">   <span class="keyword">new</span> <span class="type">StructField</span>(<span class="string">"Description"</span>, <span class="type">StringType</span>, <span class="literal">true</span>)))</span><br><span class="line">df.selectExpr(<span class="string">"(InvoiceNo, Description) as myStruct"</span>)</span><br><span class="line">  .select(to_json(col(<span class="string">"myStruct"</span>)).alias(<span class="string">"newJSON"</span>))</span><br><span class="line">  .select(from_json(col(<span class="string">"newJSON"</span>), parseSchema), col(<span class="string">"newJSON"</span>)).show(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># in Python</span></span><br><span class="line"><span class="keyword">from</span> pyspark.sql.functions <span class="keyword">import</span> from_json</span><br><span class="line"><span class="keyword">from</span> pyspark.sql.types <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">parseSchema = StructType((</span><br><span class="line">   StructField(<span class="string">"InvoiceNo"</span>,StringType(),<span class="literal">True</span>),</span><br><span class="line">   StructField(<span class="string">"Description"</span>,StringType(),<span class="literal">True</span>)))</span><br><span class="line">df.selectExpr(<span class="string">"(InvoiceNo, Description) as myStruct"</span>)\</span><br><span class="line">  .select(to_json(col(<span class="string">"myStruct"</span>)).alias(<span class="string">"newJSON"</span>))\</span><br><span class="line">  .select(from_json(col(<span class="string">"newJSON"</span>), parseSchema), col(<span class="string">"newJSON"</span>)).show(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<h2 id="get-json-object"><a href="#get-json-object" class="headerlink" title="get_json_object()"></a>get_json_object()</h2><p>查询JSON对象</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in Scala</span></span><br><span class="line"><span class="comment">// 创建JSON类型的列</span></span><br><span class="line"><span class="keyword">val</span> jsonDF = spark.range(<span class="number">1</span>).selectExpr(<span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">   '&#123;</span></span><br><span class="line"><span class="string">      "</span>myJSONK<span class="string">ey" : </span></span><br><span class="line"><span class="string">      &#123;</span></span><br><span class="line"><span class="string">         "</span>myJSONV<span class="string">alue" : [1, 2, 3]</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string">   &#125;' </span></span><br><span class="line"><span class="string">   as jsonString"</span><span class="string">""</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.sql.functions.&#123;get_json_object, json_tuple&#125;</span><br><span class="line">jsonDF.select(</span><br><span class="line">   get_json_object(col(<span class="string">"jsonString"</span>), <span class="string">"$.myJSONKey.myJSONValue[1]"</span>) as <span class="string">"column"</span>, <span class="comment">// 返回2</span></span><br><span class="line">   json_tuple(col(<span class="string">"jsonString"</span>), <span class="string">"myJSONKey"</span>)).show(<span class="number">2</span>)  <span class="comment">// 返回&#123;"muJSONValue": [1, 2, 3]&#125;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># in Python</span></span><br><span class="line"><span class="comment"># 创建JSON类型的列</span></span><br><span class="line">jsonDF = spark.range(<span class="number">1</span>).selectExpr(<span class="string">"""</span></span><br><span class="line"><span class="string">'&#123;"myJSONKey" : &#123;"myJSONValue" : [1, 2, 3]&#125;&#125;' as jsonString"""</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pyspark.sql.functions <span class="keyword">import</span> get_json_object, json_tuple</span><br><span class="line">jsonDF.select(</span><br><span class="line">  get_json_object(col(<span class="string">"jsonString"</span>), <span class="string">"$.myJSONKey.myJSONValue[1]"</span>) <span class="keyword">as</span> <span class="string">"column"</span>,</span><br><span class="line">  json_tuple(col(<span class="string">"jsonString"</span>), <span class="string">"myJSONKey"</span>)).show(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<h2 id="initcap"><a href="#initcap" class="headerlink" title="initcap()"></a>initcap()</h2><p>将给定字符串中空格分隔的每个单词首字母大写</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in Scala</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.sql.functions.&#123;initcap&#125;</span><br><span class="line">df.select(initcap(col(<span class="string">"Description"</span>))).show(<span class="number">2</span>, <span class="literal">false</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># in Python</span></span><br><span class="line"><span class="keyword">from</span> pyspark.sql.functions <span class="keyword">import</span> initcap</span><br><span class="line">df.select(initcap(col(<span class="string">"Description"</span>))).show()</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- in SQL</span></span><br><span class="line"><span class="keyword">SELECT</span> initcap(Description) <span class="keyword">FROM</span> dfTable;</span><br></pre></td></tr></table></figure>
<h2 id="instr"><a href="#instr" class="headerlink" title="instr()"></a>instr()</h2><p>检查在某列上是否存在某字符串</p>
<ul>
<li>在Scala中使用<code>contains()</code>函数</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># in Python</span></span><br><span class="line"><span class="keyword">from</span> pyspark.sql.functions <span class="keyword">import</span> instr</span><br><span class="line">containsBlack = instr(col(<span class="string">"Description"</span>), <span class="string">"BLACK"</span>) &gt;= <span class="number">1</span></span><br><span class="line">containsWhite = instr(col(<span class="string">"Description"</span>), <span class="string">"WHITE"</span>) &gt;= <span class="number">1</span></span><br><span class="line">df.withColumn(<span class="string">"hasSimpleColor"</span>, containsBlack | containsWhite)\</span><br><span class="line">  .where(<span class="string">"hasSimpleColor"</span>)\</span><br><span class="line">  .select(<span class="string">"Description"</span>).show(<span class="number">3</span>, <span class="literal">False</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- in SQL</span></span><br><span class="line"><span class="keyword">SELECT</span> Description <span class="keyword">FROM</span> dfTable</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">instr</span>(Description, <span class="string">'BLACK'</span>) &gt;= <span class="number">1</span> <span class="keyword">OR</span> <span class="keyword">instr</span>(Description, <span class="string">'WHITE'</span>) &gt;= <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<h2 id="json-tuple"><a href="#json-tuple" class="headerlink" title="json_tuple()"></a>json_tuple()</h2><p>如果JSON对象只有一层嵌套，则可使用该函数进行查询</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in Scala</span></span><br><span class="line"><span class="comment">// 创建JSON类型的列</span></span><br><span class="line"><span class="keyword">val</span> jsonDF = spark.range(<span class="number">1</span>).selectExpr(<span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">   '&#123;</span></span><br><span class="line"><span class="string">      "</span>myJSONK<span class="string">ey" : </span></span><br><span class="line"><span class="string">      &#123;</span></span><br><span class="line"><span class="string">         "</span>myJSONV<span class="string">alue" : [1, 2, 3]</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string">   &#125;' </span></span><br><span class="line"><span class="string">   as jsonString"</span><span class="string">""</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.sql.functions.&#123;get_json_object, json_tuple&#125;</span><br><span class="line">jsonDF.select(</span><br><span class="line">   get_json_object(col(<span class="string">"jsonString"</span>), <span class="string">"$.myJSONKey.myJSONValue[1]"</span>) as <span class="string">"column"</span>, <span class="comment">// 返回2</span></span><br><span class="line">   json_tuple(col(<span class="string">"jsonString"</span>), <span class="string">"myJSONKey"</span>)).show(<span class="number">2</span>)  <span class="comment">// 返回&#123;"muJSONValue": [1, 2, 3]&#125;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># in Python</span></span><br><span class="line"><span class="comment"># 创建JSON类型的列</span></span><br><span class="line">jsonDF = spark.range(<span class="number">1</span>).selectExpr(<span class="string">"""</span></span><br><span class="line"><span class="string">'&#123;"myJSONKey" : &#123;"myJSONValue" : [1, 2, 3]&#125;&#125;' as jsonString"""</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pyspark.sql.functions <span class="keyword">import</span> get_json_object, json_tuple</span><br><span class="line">jsonDF.select(</span><br><span class="line">  get_json_object(col(<span class="string">"jsonString"</span>), <span class="string">"$.myJSONKey.myJSONValue[1]"</span>) <span class="keyword">as</span> <span class="string">"column"</span>,</span><br><span class="line">  json_tuple(col(<span class="string">"jsonString"</span>), <span class="string">"myJSONKey"</span>)).show(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<h2 id="lit"><a href="#lit" class="headerlink" title="lit()"></a>lit()</h2><p>创造字面量（literal）（常量值）；把其他语言的类型转换为与其相对应的Spark表示</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in scala</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.sql.functions.lit</span><br><span class="line">df.select(expr(<span class="string">"*"</span>), lit(<span class="number">1</span>).as(<span class="string">"One"</span>)).show(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">df.select(lit(<span class="number">5</span>)， lit(<span class="string">"five"</span>)， lit(<span class="number">5.0</span>))</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># in python</span></span><br><span class="line"><span class="keyword">from</span> pyspark.sql.functions <span class="keyword">import</span> lit</span><br><span class="line">df.select(expr(<span class="string">"*"</span>), lit(<span class="number">1</span>).alias(<span class="string">"One"</span>)).show(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- in SQL</span></span><br><span class="line"><span class="keyword">SELECT</span> *, <span class="number">1</span> <span class="keyword">AS</span> One <span class="keyword">FROM</span> dfTable <span class="keyword">LIMIT</span> <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<h2 id="locate"><a href="#locate" class="headerlink" title="locate()"></a>locate()</h2><p>返回整数位置（从1开始）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pyspark.sql.functions <span class="keyword">import</span> expr, locate</span><br><span class="line">simpleColors = [<span class="string">"black"</span>, <span class="string">"white"</span>, <span class="string">"red"</span>, <span class="string">"green"</span>, <span class="string">"blue"</span>]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">color_locator</span><span class="params">(column, color_string)</span>:</span></span><br><span class="line">   <span class="keyword">return</span> locate(color_string.upper(), column)\</span><br><span class="line">            .cast(<span class="string">"boolean"</span>)\</span><br><span class="line">            .alias(<span class="string">"is_"</span> + color_string)</span><br><span class="line">selectedColumns = [color_locator(df.Description, c) <span class="keyword">for</span> c <span class="keyword">in</span> simpleColors]</span><br><span class="line">selectedColumns.append(expr(<span class="string">"*"</span>))  <span class="comment"># expr()转为Column格式</span></span><br><span class="line">df.select(*selectedColumns).where(expr(<span class="string">"is_white OR is_red"</span>))\</span><br><span class="line">  .select(<span class="string">"Description"</span>).show(<span class="number">3</span>, <span class="literal">False</span>)</span><br></pre></td></tr></table></figure>
<h2 id="lower"><a href="#lower" class="headerlink" title="lower()"></a>lower()</h2><p>将字符串转为小写</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in Scala</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.sql.functions.&#123;lower, upper&#125;</span><br><span class="line">df.select(col(<span class="string">"Description"</span>),</span><br><span class="line">   lower(col(<span class="string">"Description"</span>)),</span><br><span class="line">   upper(lower(col(<span class="string">"Description"</span>)))).show(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># in Python</span></span><br><span class="line"><span class="keyword">from</span> pyspark.sql.functions <span class="keyword">import</span> lower, upper</span><br><span class="line">df.select(col(<span class="string">"Description"</span>),</span><br><span class="line">   lower(col(<span class="string">"Description"</span>)),</span><br><span class="line">   upper(lower(col(<span class="string">"Description"</span>)))).show(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- in SQL</span></span><br><span class="line"><span class="keyword">SELECT</span> Description, <span class="keyword">lower</span>(Description), <span class="keyword">Upper</span>(<span class="keyword">lower</span>(Description)) <span class="keyword">FROM</span> dfTable;</span><br></pre></td></tr></table></figure>
<h2 id="lpad"><a href="#lpad" class="headerlink" title="lpad()"></a>lpad()</h2><p>在字符串左边添加空格</p>
<ul>
<li>如果<code>lpad</code>或<code>rpad</code>方法输入的数值参数小于字符串长度，将从字符串的右侧删除字符</li>
</ul>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in Scala</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.sql.functions.&#123;lit, rpad, lpad&#125;</span><br><span class="line">df.select(</span><br><span class="line">   lpad(lit(<span class="string">"HELLO"</span>), <span class="number">3</span>, <span class="string">" "</span>).as(<span class="string">"lp"</span>),</span><br><span class="line">   rpad(lit(<span class="string">"HELLO"</span>), <span class="number">10</span>, <span class="string">" "</span>).as(<span class="string">"rp"</span>)).show(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># in Python</span></span><br><span class="line"><span class="keyword">from</span> pyspark.sql.functions <span class="keyword">import</span> lit, rpad, lpad</span><br><span class="line">df.select(</span><br><span class="line">   lpad(lit(<span class="string">"HELLO"</span>), <span class="number">3</span>, <span class="string">" "</span>).alias(<span class="string">"lp"</span>),</span><br><span class="line">   rpad(lit(<span class="string">"HELLO"</span>), <span class="number">10</span>, <span class="string">" "</span>).alias(<span class="string">"rp"</span>)).show(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">   <span class="keyword">lpad</span>(<span class="string">'HELLOOOO '</span>, <span class="number">3</span>, <span class="string">' '</span>),</span><br><span class="line">   rpad(<span class="string">'HELLOOOO '</span>, <span class="number">10</span>, <span class="string">' '</span>)</span><br><span class="line"><span class="keyword">FROM</span> dfTable;</span><br></pre></td></tr></table></figure>
<h2 id="map"><a href="#map" class="headerlink" title="map()"></a>map()</h2><p>构建两列内容的键值对映射形式</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in Scala</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.sql.functions.map</span><br><span class="line">df.select(map(col(<span class="string">"Description"</span>), col(<span class="string">"InvoiceNo"</span>)).alias(<span class="string">"complex_map"</span>)).show(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># in Python</span></span><br><span class="line"><span class="keyword">from</span> pyspark.sql.functions <span class="keyword">import</span> create_map</span><br><span class="line">df.select(create_map(col(<span class="string">"Description"</span>), col(<span class="string">"InvoiceNo"</span>)).alias(<span class="string">"complex_map"</span>))\</span><br><span class="line">  .show(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">MAP</span>(Description, InvoiceNo) <span class="keyword">AS</span> complex_map</span><br><span class="line"><span class="keyword">FROM</span> dfTable</span><br><span class="line"><span class="keyword">WHERE</span> Description <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>可以使用正确的键（key）对键值对进行查询</li>
<li>若键（key）不存在则返回NULL</li>
</ul>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in Scala</span></span><br><span class="line">df.select(map(col(<span class="string">"Description"</span>), col(<span class="string">"InvoiceNo"</span>)).alias(<span class="string">"complex_map"</span>))</span><br><span class="line">  .selectExpr(<span class="string">"complex_map['WHITE METAL LANTERN']"</span>).show(<span class="number">2</span>)  <span class="comment">// 查询键'WHITE METAL LANTERN'对应的值</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># in Python</span></span><br><span class="line">df.select(map(col(<span class="string">"Description"</span>), col(<span class="string">"InvoiceNo"</span>)).alias(<span class="string">"complex_map"</span>))\</span><br><span class="line">  .selectExpr(<span class="string">"complex_map['WHITE METAL LANTERN']"</span>).show(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>可使用<code>explode()</code>展开map类型，将其转换为列</li>
</ul>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in Scala</span></span><br><span class="line">df.select(map(col(<span class="string">"Description"</span>), col(<span class="string">"InvoiceNo"</span>)).alias(<span class="string">"complex_map"</span>))</span><br><span class="line">  .selectExpr(<span class="string">"explode(complex_map)"</span>).show(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># in Python</span></span><br><span class="line">df.select(map(col(<span class="string">"Description"</span>), col(<span class="string">"InvoiceNo"</span>)).alias(<span class="string">"complex_map"</span>))\</span><br><span class="line">  .selectExpr(<span class="string">"explode(complex_map)"</span>).show(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p>展开结果如下：<br><figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="code">+--------------------+</span>------+</span><br><span class="line">|                 key| value|</span><br><span class="line"><span class="code">+--------------------+</span>------+</span><br><span class="line">|WHITE HANGING HEA...|536365|</span><br><span class="line">| WHITE METAL LANTERN|536365|</span><br><span class="line"><span class="code">+--------------------+</span>------+</span><br></pre></td></tr></table></figure></p>
<h2 id="max"><a href="#max" class="headerlink" title="max()"></a>max()</h2><p>最大值</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in scala</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.sql.functions.max</span><br><span class="line"></span><br><span class="line">flightData.select(max(<span class="string">"count"</span>)).take(<span class="number">1</span>)</span><br><span class="line"><span class="comment">// 按照count列排序的最大值</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># in python</span></span><br><span class="line"><span class="keyword">from</span> pyspark.sql.functions <span class="keyword">import</span> max</span><br><span class="line"></span><br><span class="line">flightData.select(max(<span class="string">"count"</span>)).count(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<h2 id="mean"><a href="#mean" class="headerlink" title="mean()"></a>mean()</h2><p>计算均值<br><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">// <span class="keyword">in</span> Scala</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.<span class="keyword">sql</span>.<span class="keyword">functions</span>.&#123;mean&#125;</span><br><span class="line"></span><br><span class="line"># <span class="keyword">in</span> Python</span><br><span class="line"><span class="keyword">from</span> pyspark.<span class="keyword">sql</span>.<span class="keyword">functions</span> <span class="keyword">import</span> mean</span><br></pre></td></tr></table></figure></p>
<h2 id="min"><a href="#min" class="headerlink" title="min"></a>min</h2><p>最小值</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">// <span class="keyword">in</span> Scala</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.<span class="keyword">sql</span>.<span class="keyword">functions</span>.&#123;min&#125;</span><br><span class="line"></span><br><span class="line"># <span class="keyword">in</span> Python</span><br><span class="line"><span class="keyword">from</span> pyspark.<span class="keyword">sql</span>.<span class="keyword">functions</span> <span class="keyword">import</span> min</span><br></pre></td></tr></table></figure>
<h2 id="monotonically-increasing-id"><a href="#monotonically-increasing-id" class="headerlink" title="monotonically_increasing_id"></a>monotonically_increasing_id</h2><p>位每行添加一个唯一的id</p>
<ul>
<li>从0开始，为每行生成一个唯一值</li>
</ul>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in Scala</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.sql.functions.monotonically_increasing_id</span><br><span class="line">df.select(monotonically_increasing_id()).show(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># in Python</span></span><br><span class="line"><span class="keyword">from</span> pyspark.sql.functions <span class="keyword">import</span> monotonically_increasing_id</span><br><span class="line">df.select(monotonically_increasing_id()).show(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<h2 id="months-between"><a href="#months-between" class="headerlink" title="months_between()"></a>months_between()</h2><p>返回两个日期之间相隔的月数</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in Scala</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.sql.functions.&#123;months_between, to_date&#125;</span><br><span class="line"></span><br><span class="line">dateDF.select(</span><br><span class="line">  to_date(lit(<span class="string">"2016-01-01"</span>)).alias(<span class="string">"start"</span>),</span><br><span class="line">  to_date(lit(<span class="string">"2017-05-22"</span>)).alias(<span class="string">"end"</span>))</span><br><span class="line">  .select(months_between(col(<span class="string">"start"</span>), col(<span class="string">"end"</span>))).show(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># in Python</span></span><br><span class="line"><span class="keyword">from</span> pyspark.sql.functions <span class="keyword">import</span> months_between, to_date</span><br><span class="line"></span><br><span class="line">dateDF.select(</span><br><span class="line">  to_date(lit(<span class="string">"2016-01-01"</span>)).alias(<span class="string">"start"</span>),</span><br><span class="line">  to_date(lit(<span class="string">"2017-05-22"</span>)).alias(<span class="string">"end"</span>))\</span><br><span class="line">  .select(months_between(col(<span class="string">"start"</span>), col(<span class="string">"end"</span>))).show(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- in SQL</span></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">   <span class="keyword">to_date</span>(<span class="string">'2016-01-01'</span>), </span><br><span class="line">   months_between(<span class="string">'2016-01-01'</span>, <span class="string">'2017-01-01'</span>), <span class="keyword">datediff</span>(<span class="string">'2016-01-01'</span>, <span class="string">'2017-01-01'</span>)</span><br><span class="line"><span class="keyword">FROM</span> dateTable;</span><br></pre></td></tr></table></figure>
<h2 id="pow"><a href="#pow" class="headerlink" title="pow()"></a>pow()</h2><p>进行幂运算<br><code>pow(n, k)</code>：计算$n^k$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># in Python</span></span><br><span class="line"><span class="keyword">from</span> pyspark.sql.functions <span class="keyword">import</span> expr, pow</span><br><span class="line">fabricatedQuantity = pow(col(<span class="string">"Quantity"</span>) * col(<span class="string">"UnitPrice"</span>)， <span class="number">2</span>) + <span class="number">5</span></span><br><span class="line">df.select(expr(<span class="string">"CustomerId"</span>)， fabricatedQuantity.alias(<span class="string">"realQuantity"</span>)).show(<span class="number">2</span>)</span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line">df.selectExpr(</span><br><span class="line">   <span class="string">"CustomerId"</span>,</span><br><span class="line">   <span class="string">"(POWER((Quantity * UnitPrice), 2.0) + 5) as realQuantity"</span>).show(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- in SQL</span></span><br><span class="line"><span class="keyword">SELECT</span> customerId, (<span class="keyword">POWER</span>((Quantity * UnitPrice), <span class="number">2.0</span>) + <span class="number">5</span>) <span class="keyword">as</span> realQuantity</span><br><span class="line"><span class="keyword">FROM</span> dfTable;</span><br></pre></td></tr></table></figure>
<h2 id="regex-extract"><a href="#regex-extract" class="headerlink" title="regex_extract()"></a>regex_extract()</h2><p>提取符合条件的字符串</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in Scala</span></span><br><span class="line"><span class="comment">// 提取Description列中第一个被提到的颜色</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.sql.functions.regexp_extract</span><br><span class="line"><span class="keyword">val</span> simpleColors = <span class="type">Seq</span>(<span class="string">"black"</span>, <span class="string">"white"</span>, <span class="string">"red"</span>, <span class="string">"green"</span>, <span class="string">"blue"</span>)</span><br><span class="line"><span class="keyword">val</span> regexString = simpleColors.map(_.toUpperCase).mkString(<span class="string">"("</span>, <span class="string">"|"</span>, <span class="string">")"</span>)</span><br><span class="line"><span class="comment">// "|"在正则表达式中是"或"的意思</span></span><br><span class="line">df.select(</span><br><span class="line">   regexp_extract(col(<span class="string">"Description"</span>), regexString, <span class="number">1</span>).alias(<span class="string">"color_clean"</span>),</span><br><span class="line">   col(<span class="string">"Description"</span>)).show(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># in Python</span></span><br><span class="line"><span class="keyword">from</span> pyspark.sql.functions <span class="keyword">import</span> regexp_extract</span><br><span class="line">extract_str = <span class="string">"(BLACK|WHITE|RED|GREEN|BLUE)"</span></span><br><span class="line">df.select(</span><br><span class="line">   regexp_extract(col(<span class="string">"Description"</span>), extract_str, <span class="number">1</span>).alias(<span class="string">"color_clean"</span>),</span><br><span class="line">   col(<span class="string">"Description"</span>)).show(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- in SQL</span></span><br><span class="line"><span class="keyword">SELECT</span> regexp_extract(Description, <span class="string">'(BLACK|WHITE|RED|GREEN|BLUE)'</span>, <span class="number">1</span>), Description</span><br><span class="line"><span class="keyword">FROM</span> dfTable;</span><br></pre></td></tr></table></figure>
<h2 id="regex-replace"><a href="#regex-replace" class="headerlink" title="regex_replace()"></a>regex_replace()</h2><p>替换符合条件的字符串</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in Scala</span></span><br><span class="line"><span class="comment">// 将Description列中的颜色字符串BLACK|WHITE|RED|GREEN|BLUE替换为“COLOR”</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.sql.functions.regexp_replace</span><br><span class="line"><span class="keyword">val</span> simpleColors = <span class="type">Seq</span>(<span class="string">"black"</span>, <span class="string">"white"</span>, <span class="string">"red"</span>, <span class="string">"green"</span>, <span class="string">"blue"</span>)</span><br><span class="line"><span class="keyword">val</span> regexString = simpleColors.map(_.toUpperCase).mkString(<span class="string">"|"</span>)</span><br><span class="line"><span class="comment">// "|"在正则表达式中是"或"的意思</span></span><br><span class="line">df.select(</span><br><span class="line">   regexp_replace(col(<span class="string">"Description"</span>), regexString, <span class="string">"COLOR"</span>).alias(<span class="string">"color_clean"</span>),</span><br><span class="line">   col(<span class="string">"Description"</span>)).show(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># in Python</span></span><br><span class="line"><span class="keyword">from</span> pyspark.sql.functions <span class="keyword">import</span> regexp_replace</span><br><span class="line">regex_string = <span class="string">"BLACK|WHITE|RED|GREEN|BLUE"</span></span><br><span class="line">df.select(</span><br><span class="line">   regexp_replace(col(<span class="string">"Description"</span>), regex_string, <span class="string">"COLOR"</span>).alias(<span class="string">"color_clean"</span>),</span><br><span class="line">   col(<span class="string">"Description"</span>)).show(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- in SQL</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">regexp_replace(Description, <span class="string">'BLACK|WHITE|RED|GREEN|BLUE'</span>, <span class="string">'COLOR'</span>) <span class="keyword">AS</span> color_clean, Description</span><br><span class="line"><span class="keyword">FROM</span> dfTable;</span><br></pre></td></tr></table></figure>
<h2 id="round"><a href="#round" class="headerlink" title="round()"></a>round()</h2><ul>
<li>四舍五入</li>
<li>默认情况下，如果恰好位于两个数字之间，<code>round</code>函数会向上取整</li>
<li><code>bround</code>函数可以向下取整</li>
</ul>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in Scala</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.sql.functions.&#123;round， bround&#125;</span><br><span class="line">df.select(round(col(<span class="string">"UnitPrice"</span>)， <span class="number">1</span>).alias(<span class="string">"rounded"</span>)， col(<span class="string">"UnitPrice"</span>)).show(<span class="number">5</span>)</span><br><span class="line"><span class="comment">// 保留1位小数</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.sql.functions.lit</span><br><span class="line">df.select(round(lit(<span class="string">"2.5"</span>)), bround(lit(<span class="string">"2.5"</span>))).show(<span class="number">2</span>)</span><br><span class="line"><span class="comment">// 输出3.0和2.0</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># in Python</span></span><br><span class="line"><span class="keyword">from</span> pyspark.sql.functions <span class="keyword">import</span> lit, round, bround</span><br><span class="line">df.select(round(lit(<span class="string">"2.5"</span>)), bround(lit(<span class="string">"2.5"</span>))).show(<span class="number">2</span>)</span><br><span class="line"><span class="comment"># 输出3.0和2.0</span></span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- in SQL</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">round</span>(<span class="number">2.5</span>), bround(<span class="number">2.5</span>);</span><br><span class="line"><span class="comment">-- 输出3.0和2.0</span></span><br></pre></td></tr></table></figure>
<h2 id="rpad"><a href="#rpad" class="headerlink" title="rpad()"></a>rpad()</h2><p>在字符串右边添加空格</p>
<ul>
<li>如果<code>lpad</code>或<code>rpad</code>方法输入的数值参数小于字符串长度，将从字符串的右侧删除字符</li>
</ul>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in Scala</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.sql.functions.&#123;lit, rpad, lpad&#125;</span><br><span class="line">df.select(</span><br><span class="line">   lpad(lit(<span class="string">"HELLO"</span>), <span class="number">3</span>, <span class="string">" "</span>).as(<span class="string">"lp"</span>),</span><br><span class="line">   rpad(lit(<span class="string">"HELLO"</span>), <span class="number">10</span>, <span class="string">" "</span>).as(<span class="string">"rp"</span>)).show(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># in Python</span></span><br><span class="line"><span class="keyword">from</span> pyspark.sql.functions <span class="keyword">import</span> lit, rpad, lpad</span><br><span class="line">df.select(</span><br><span class="line">   lpad(lit(<span class="string">"HELLO"</span>), <span class="number">3</span>, <span class="string">" "</span>).alias(<span class="string">"lp"</span>),</span><br><span class="line">   rpad(lit(<span class="string">"HELLO"</span>), <span class="number">10</span>, <span class="string">" "</span>).alias(<span class="string">"rp"</span>)).show(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">   <span class="keyword">lpad</span>(<span class="string">'HELLOOOO '</span>, <span class="number">3</span>, <span class="string">' '</span>),</span><br><span class="line">   rpad(<span class="string">'HELLOOOO '</span>, <span class="number">10</span>, <span class="string">' '</span>)</span><br><span class="line"><span class="keyword">FROM</span> dfTable;</span><br></pre></td></tr></table></figure>
<h2 id="size"><a href="#size" class="headerlink" title="size()"></a>size()</h2><p>查询数组的大小（长度）</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in Scala</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.sql.functions.size</span><br><span class="line">df.select(size(split(col(<span class="string">"Description"</span>)， <span class="string">" "</span>))).show(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># in Python</span></span><br><span class="line"><span class="keyword">from</span> pyspark.sql.functions <span class="keyword">import</span> size</span><br><span class="line">df.select(size(split(col(<span class="string">"Description"</span>)， <span class="string">" "</span>))).show(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<h2 id="split"><a href="#split" class="headerlink" title="split()"></a>split()</h2><p>按照指定的分隔符将字符串分割成数组</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in Scala</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.sql.functions.split</span><br><span class="line">df.select(split(col(<span class="string">"Description"</span>), <span class="string">" "</span>)).show(<span class="number">2</span>)</span><br><span class="line"><span class="comment">// 按照空格" "将Description列分割成数组</span></span><br><span class="line"><span class="comment">// 将"WHITE HANGING ON"分割成[WHITE, HANGING, ON]</span></span><br><span class="line"></span><br><span class="line">df.select(split(col(<span class="string">"Description"</span>), <span class="string">" "</span>).alias(<span class="string">"array_col"</span>))</span><br><span class="line">  .selectExpr(<span class="string">"array_col[0]"</span>).show(<span class="number">2</span>)</span><br><span class="line"><span class="comment">// 按照空格" "将Description列分割成数组并选择数组的第一个元素</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pyspark.sql.functions <span class="keyword">import</span> split</span><br><span class="line">df.select(split(col(<span class="string">"Description"</span>), <span class="string">" "</span>)).show(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">df.select(split(col(<span class="string">"Description"</span>), <span class="string">" "</span>).alias(<span class="string">"array_col"</span>))\</span><br><span class="line">  .selectExpr(<span class="string">"array_col[0]"</span>).show(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- in SQL</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">SPLIT</span>(Description, <span class="string">' '</span>) <span class="keyword">FROM</span> dfTable;</span><br></pre></td></tr></table></figure>
<h2 id="stddev-pop"><a href="#stddev-pop" class="headerlink" title="stddev_pop()"></a>stddev_pop()</h2><p>计算标准差</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">// <span class="keyword">in</span> Scala</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.<span class="keyword">sql</span>.<span class="keyword">functions</span>.&#123;stddev_pop&#125;</span><br><span class="line"></span><br><span class="line"># <span class="keyword">in</span> Python</span><br><span class="line"><span class="keyword">from</span> pyspark.<span class="keyword">sql</span>.<span class="keyword">functions</span> <span class="keyword">import</span> stddev_pop</span><br></pre></td></tr></table></figure>
<h2 id="struct"><a href="#struct" class="headerlink" title="struct()"></a>struct()</h2><p>构建结构体</p>
<ul>
<li>在查询中用圆括号括起一组列来创建一个结构体</li>
</ul>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">df</span><span class="selector-class">.selectExpr</span>(<span class="string">"(Description, InvoiceNo) as complex"</span>, <span class="string">"*"</span>)</span><br><span class="line"><span class="selector-tag">df</span><span class="selector-class">.selectExpr</span>(<span class="string">"struct(Description, InvoiceNo) as complex"</span>, <span class="string">"*"</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in Scala</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.sql.functions.struct</span><br><span class="line"><span class="keyword">val</span> complexDF = df.select(struct(<span class="string">"Description"</span>, <span class="string">"InvoiceNo"</span>).alias(<span class="string">"complex"</span>))</span><br><span class="line">complexDF.createOrReplaceTempView(<span class="string">"complexDF"</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># in Python</span></span><br><span class="line"><span class="keyword">from</span> pyspark.sql.functions <span class="keyword">import</span> struct</span><br><span class="line">complexDF = df.select(struct(<span class="string">"Description"</span>, <span class="string">"InvoiceNo"</span>).alias(<span class="string">"complex"</span>))</span><br><span class="line">complexDF.createOrReplaceTempView(<span class="string">"complexDF"</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>使用<code>.</code>或<code>getField</code>访问结构体中的列</li>
</ul>
<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line">complexDF.<span class="keyword">select</span>(<span class="string">"complex.Description"</span>)</span><br><span class="line">complexDF.<span class="keyword">select</span>(col(<span class="string">"complex"</span>).getField(<span class="string">"Description"</span>))  <span class="comment">// 访问结构体complexDF中的Description列</span></span><br></pre></td></tr></table></figure>
<ul>
<li>使用<code>.*</code>查询结构体中的所有值<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">complexDF.<span class="keyword">select</span>(<span class="string">"complex.*"</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="to-date"><a href="#to-date" class="headerlink" title="to_date()"></a>to_date()</h2><p>以指定的格式将字符串转换为日期数据</p>
<ul>
<li>默认格式：<code>yyyy-MM-dd</code>（年-月-日）</li>
<li>需要在Java SimpleDataFormat中指定我们想要的格式</li>
</ul>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in Scala</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.sql.functions.&#123;months_between, to_date&#125;</span><br><span class="line"></span><br><span class="line">dateDF.select(</span><br><span class="line">  to_date(lit(<span class="string">"2016-01-01"</span>)).alias(<span class="string">"start"</span>),</span><br><span class="line">  to_date(lit(<span class="string">"2017-05-22"</span>)).alias(<span class="string">"end"</span>))</span><br><span class="line">  .select(months_between(col(<span class="string">"start"</span>), col(<span class="string">"end"</span>))).show(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> dateFormat = <span class="string">"yyyy-dd-MM"</span>  <span class="comment">// 指定日期格式为年-日-月</span></span><br><span class="line"><span class="keyword">val</span> cleanDateDF = spark.range(<span class="number">1</span>).select(</span><br><span class="line">  to_date(lit(<span class="string">"2017-12-11"</span>), dateFormat).alias(<span class="string">"date"</span>),</span><br><span class="line">  to_date(lit(<span class="string">"2017-20-12"</span>), dateFormat).alias(<span class="string">"date2"</span>))</span><br><span class="line">cleanDateDF.createOrReplaceTempView(<span class="string">"dateTable2"</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># in Python</span></span><br><span class="line"><span class="keyword">from</span> pyspark.sql.functions <span class="keyword">import</span> months_between, to_date</span><br><span class="line"></span><br><span class="line">dateDF.select(</span><br><span class="line">  to_date(lit(<span class="string">"2016-01-01"</span>)).alias(<span class="string">"start"</span>),</span><br><span class="line">  to_date(lit(<span class="string">"2017-05-22"</span>)).alias(<span class="string">"end"</span>))\</span><br><span class="line">  .select(months_between(col(<span class="string">"start"</span>), col(<span class="string">"end"</span>))).show(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">dateFormat = <span class="string">"yyyy-dd-MM"</span>  <span class="comment">## 指定日期格式为年-日-月</span></span><br><span class="line">cleanDateDF = spark.range(<span class="number">1</span>).select(</span><br><span class="line">  to_date(lit(<span class="string">"2017-12-11"</span>), dateFormat).alias(<span class="string">"date"</span>),</span><br><span class="line">  to_date(lit(<span class="string">"2017-20-12"</span>), dateFormat).alias(<span class="string">"date2”))</span></span><br><span class="line"><span class="string">cleanDateDF.createOrReplaceTempView("</span>dateTable2<span class="string">")</span></span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- in SQL</span></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">   <span class="keyword">to_date</span>(<span class="string">'2016-01-01'</span>), </span><br><span class="line">   months_between(<span class="string">'2016-01-01'</span>, <span class="string">'2017-01-01'</span>), <span class="keyword">datediff</span>(<span class="string">'2016-01-01'</span>, <span class="string">'2017-01-01'</span>)</span><br><span class="line"><span class="keyword">FROM</span> dateTable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">to_date</span>(<span class="built_in">date</span>, <span class="string">'yyyy-dd-MM'</span>), <span class="keyword">to_date</span>(date2, <span class="string">'yyyy-dd-MM'</span>), <span class="keyword">to_date</span>(<span class="built_in">date</span>)</span><br><span class="line"><span class="keyword">FROM</span> dateTable2;</span><br></pre></td></tr></table></figure>
<h2 id="to-json"><a href="#to-json" class="headerlink" title="to_json()"></a>to_json()</h2><p>将StructType转换为JSON字符串</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in Scala</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.sql.functions.to_json</span><br><span class="line">df.selectExpr(<span class="string">"(InvoiceNo, Description) as myStruct"</span>)</span><br><span class="line">  .select(to_json(col(<span class="string">"myStruct"</span>)))</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># in Python</span></span><br><span class="line"><span class="keyword">from</span> pyspark.sql.functions <span class="keyword">import</span> to_json</span><br><span class="line">df.selectExpr(<span class="string">"(InvoiceNo, Description) as myStruct"</span>)\</span><br><span class="line">  .select(to_json(col(<span class="string">"myStruct"</span>)))</span><br></pre></td></tr></table></figure>
<h2 id="to-timestamp"><a href="#to-timestamp" class="headerlink" title="to_timestamp()"></a>to_timestamp()</h2><p>将字符串转换为时间戳</p>
<ul>
<li>要求指定一种格式</li>
</ul>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.spark.sql.functions.to_timestamp</span><br><span class="line"><span class="keyword">val</span> dateFormat = <span class="string">"yyyy-dd-MM"</span></span><br><span class="line">cleanDateDF.select(to_timestamp(col(<span class="string">"date”), dateFormat)).show()  // date列的日期格式为"</span>yyyy-dd-<span class="type">MM</span><span class="string">"</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># in Python</span></span><br><span class="line"><span class="keyword">from</span> pyspark.sql.functions <span class="keyword">import</span> to_timestamp</span><br><span class="line">dateFormat = <span class="string">"yyyy-dd-MM"</span></span><br><span class="line">cleanDateDF.select(to_timestamp(col(<span class="string">"date"</span>), dateFormat)).show()</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- in SQL</span></span><br><span class="line"><span class="keyword">SELECT</span> to_timestamp(<span class="built_in">date</span>, <span class="string">'yyyy-dd-MM'</span>), to_timestamp(date2, <span class="string">'yyyy-dd-MM'</span>)</span><br><span class="line"><span class="keyword">FROM</span> dateTable2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">CAST</span>(<span class="keyword">TO_DATE</span>(<span class="string">'2020-01-01'</span>, <span class="string">'yyyy-dd-MM'</span>) <span class="keyword">AS</span> <span class="built_in">TIMESTAMP</span>);</span><br></pre></td></tr></table></figure>
<h2 id="translate"><a href="#translate" class="headerlink" title="translate()"></a>translate()</h2><p>用给定的字符替换掉列中出现的所有该字符</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in Scala</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.sql.functions.translate</span><br><span class="line">df.select(translate(col(<span class="string">"Description"</span>), <span class="string">"LEET"</span>, <span class="string">"1337"</span>), col(<span class="string">"Description"</span>))</span><br><span class="line">.show(<span class="number">2</span>)</span><br><span class="line"><span class="comment">// Description中的所有L都被替换成1，所有E都被替换成3，所有的T都被替换成7</span></span><br><span class="line"><span class="comment">// 替换前：WHITE METAL LANTERN</span></span><br><span class="line"><span class="comment">// 替换后：WHI73 M37A1 1AN73RN</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># in Python</span></span><br><span class="line"><span class="keyword">from</span> pyspark.sql.functions <span class="keyword">import</span> translate</span><br><span class="line">df.select(translate(col(<span class="string">"Description"</span>), <span class="string">"LEET"</span>, <span class="string">"1337"</span>),col(<span class="string">"Description"</span>))\</span><br><span class="line">  .show(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- in SQL</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">translate</span>(Description, <span class="string">'LEET'</span>, <span class="string">'1337'</span>), Description <span class="keyword">FROM</span> dfTable;</span><br></pre></td></tr></table></figure>
<h2 id="rdd"><a href="#rdd" class="headerlink" title="rdd"></a>rdd</h2><h3 id="getNumPartitions"><a href="#getNumPartitions" class="headerlink" title="getNumPartitions"></a>getNumPartitions</h3><p>获取分区数</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in Scala</span></span><br><span class="line">df.rdd.getNumPartitions <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># in Python</span></span><br><span class="line">df.rdd.getNumPartitions() <span class="comment"># 1</span></span><br></pre></td></tr></table></figure>
<h1 id="Row"><a href="#Row" class="headerlink" title="Row()"></a>Row()</h1><ul>
<li>手动创建Row对象，必须按照该行所属的DataFrame的列顺序来初始化Row对象</li>
</ul>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in scala</span></span><br><span class="line"><span class="comment">// 创建Row对象</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.sql.<span class="type">Row</span></span><br><span class="line"><span class="keyword">val</span> myRow = <span class="type">Row</span>(<span class="string">"Hello"</span>, <span class="literal">null</span>, <span class="number">1</span>, <span class="literal">false</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># in python</span></span><br><span class="line"><span class="comment"># 创建Row对象</span></span><br><span class="line"><span class="keyword">from</span> pyspark.sql <span class="keyword">import</span> Row</span><br><span class="line">myRow = Row(<span class="string">"Hello"</span>, <span class="literal">None</span>, <span class="number">1</span>, <span class="literal">False</span>)</span><br></pre></td></tr></table></figure>
<h2 id="stat"><a href="#stat" class="headerlink" title="stat"></a>stat</h2><h3 id="approxQuantile"><a href="#approxQuantile" class="headerlink" title="approxQuantile()"></a>approxQuantile()</h3><p>计算数据的精确分位数或近似分位数</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in Scala</span></span><br><span class="line"><span class="keyword">val</span> colName = <span class="string">"UnitPrice"</span></span><br><span class="line"><span class="keyword">val</span> quantileProbs = <span class="type">Array</span>(<span class="number">0.5</span>)</span><br><span class="line"><span class="keyword">val</span> relError = <span class="number">0.05</span></span><br><span class="line">df.stat.approxQuantile(<span class="string">"UnitPrice"</span>， quantileProbs， relError)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># in Python</span></span><br><span class="line">colName = <span class="string">"UnitPrice"</span></span><br><span class="line">quantileProbs = [<span class="number">0.5</span>]</span><br><span class="line">relError = <span class="number">0.05</span></span><br><span class="line">df.stat.approxQuantile(<span class="string">"UnitPrice"</span>, quantileProbs, relError)</span><br></pre></td></tr></table></figure>
<h3 id="crosstab"><a href="#crosstab" class="headerlink" title="crosstab()"></a>crosstab()</h3><p>查看交叉列表</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in Scala or Python</span></span><br><span class="line">df.stat.crosstab(<span class="string">"StockCode"</span>， <span class="string">"Quantity"</span>).show()</span><br></pre></td></tr></table></figure>
<h3 id="freqItems"><a href="#freqItems" class="headerlink" title="freqItems()"></a>freqItems()</h3><p>查看频繁项对</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in Scala</span></span><br><span class="line">df.stat.freqItems(<span class="type">Seq</span>(<span class="string">"StockCode"</span>， <span class="string">"Quantity"</span>)).show()</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># in Python</span></span><br><span class="line">df.stat.freqItems([<span class="string">"StockCode"</span>， <span class="string">"Quantity"</span>]).show()</span><br></pre></td></tr></table></figure>
<h2 id="反引号"><a href="#反引号" class="headerlink" title="反引号"></a>反引号</h2><p>当列名中包含空格或连字符等保留字时，有时需要通过使用反引号（注意是Tab键上方的反引号键，不是单引号）适当地对列名进行转义</p>
<ul>
<li><code>withColumn</code>允许使用保留字来创建列（因为withColumn的第一个参数只是新列名的字符串）</li>
<li>如果我们显式地使用字符串来引用列，则可以引用带有保留字符的类（而不用转义），这个字符串会被解释成字面值，而不是表达式</li>
</ul>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// withColumn允许使用保留字来创建列</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.sql.functions.expr</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> dfWithLongColName = df.withColumn(</span><br><span class="line">   <span class="string">"This Long Column-Name"</span>,  <span class="comment">// 因为withColumn的第一个参数只是新列名的字符串</span></span><br><span class="line">   expr(<span class="string">"ORIGIN_COUNTRY_NAME)"</span>)</span><br><span class="line">)</span><br><span class="line"><span class="comment">// 引用包含保留字的列时，需要进行转义</span></span><br><span class="line">dfWithLongColName.selectExpr(</span><br><span class="line">   <span class="string">"`This Long Column-Name`"</span>,</span><br><span class="line">   <span class="string">"`This Long Column-Name` as `new col`"</span>)</span><br><span class="line">.show(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">Scala</th>
<th style="text-align:center">Python</th>
<th style="text-align:center">SQL</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">不等于</td>
<td style="text-align:center">=!=</td>
<td style="text-align:center">!=</td>
<td style="text-align:center">!= 或 &lt;&gt;</td>
</tr>
</tbody>
</table>
</div>
<h2 id="不等于"><a href="#不等于" class="headerlink" title="不等于"></a>不等于</h2><ul>
<li>Scala中的“等于”为<code>===</code>或<code>equalTo()</code>，“不等于”为<code>=!=</code>或<code>not()</code>；</li>
<li>Scala中的<code>=!=</code>不仅能比较字符串，也能比较表达式</li>
<li>Python的“不等于”为<code>!=</code></li>
<li>还可以使用下列方式（字符串形式的谓词表达式）表达“不等于”（Python或Scala都支持）   <figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in Scala</span></span><br><span class="line">df.where(<span class="string">"InvoiceNo = 536365"</span>)</span><br><span class="line">   .show(<span class="number">5</span>, <span class="literal">false</span>)</span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line">df.where(<span class="string">"InvoiceNo &lt;&gt; 536365"</span>)</span><br><span class="line">   .show(<span class="number">5</span>, <span class="literal">false</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="时间序列"><a href="#时间序列" class="headerlink" title="时间序列"></a>时间序列</h1><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><h2 id="spark-conf"><a href="#spark-conf" class="headerlink" title="spark.conf"></a>spark.conf</h2><h3 id="sql-shuffle-partitions"><a href="#sql-shuffle-partitions" class="headerlink" title=".sql.shuffle.partitions"></a>.sql.shuffle.partitions</h3><ul>
<li>默认情况，shuffle操作会输出200个shuffle分区<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">spark.<span class="keyword">conf</span>.<span class="keyword">set</span>(<span class="string">"spark.sql.shuffle.partitions"</span>, <span class="string">"5"</span>)</span><br><span class="line"><span class="comment">// 限制shuffle输出分区的数量</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="sessionLocalTimeZone"><a href="#sessionLocalTimeZone" class="headerlink" title="sessionLocalTimeZone"></a>sessionLocalTimeZone</h3><p>设置会话本地时区</p>
<h2 id="spark-sql"><a href="#spark-sql" class="headerlink" title="spark.sql"></a>spark.sql</h2><h3 id="caseSensitive"><a href="#caseSensitive" class="headerlink" title="caseSensitive"></a>caseSensitive</h3><p>Spark默认不区分大小写，可以通过以下配置使Spark区分大小写<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- in SQL</span></span><br><span class="line"><span class="keyword">set</span> spark.sql.caseSensitive <span class="literal">true</span></span><br></pre></td></tr></table></figure></p>
<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><h2 id="TimestampType"><a href="#TimestampType" class="headerlink" title="TimestampType"></a>TimestampType</h2><ul>
<li>Spark的TimestampType只支持二级精度<ul>
<li>如果要处理毫秒或微秒，需要将数据作为long类型操作才能解决该问题</li>
<li>在强制转换为TimestampType时，任何更高的精度都被删除</li>
</ul>
</li>
</ul>
<p>目前到102页</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in scala</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># in python</span></span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- in SQL</span></span><br></pre></td></tr></table></figure>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://book.douban.com/subject/30449649/" target="_blank" rel="noopener">Spark权威指南</a></li>
<li><a href="https://blog.csdn.net/dabokele/article/details/52802150" target="_blank" rel="noopener">Spark-SQL之DataFrame操作大全</a></li>
<li><a href="https://blog.csdn.net/Struggle99/article/details/103799524" target="_blank" rel="noopener">Spark四大组件</a></li>
<li><a href></a></li>
</ul>
]]></content>
      <categories>
        <category>Data Scientist</category>
      </categories>
      <tags>
        <tag>Data Scientist</tag>
      </tags>
  </entry>
  <entry>
    <title>数据分析 | 推荐系统实践</title>
    <url>/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E5%AE%9E%E8%B7%B5.html</url>
    <content><![CDATA[<p><center>《推荐系统实践》读书笔记</center><br><a id="more"></a></p>
<h1 id="推荐系统"><a href="#推荐系统" class="headerlink" title="推荐系统"></a>推荐系统</h1><p>推荐系统的<strong>基本任务</strong>是联系用户和物品，解决信息过载（information overload）的问题。</p>
<p>解决信息过载的方案有：</p>
<ul>
<li>分类目录</li>
<li>搜索引擎</li>
</ul>
<p>和搜索引擎一样，推荐系统也是一种帮助用户快速发现有用信息的工具。和搜索引擎不同的是，推荐系统不需要用户提供明确的需求，而是通过分析用户的历史行为给用户的兴趣建模，从而主动给用户推荐能够满足他们兴趣和需求的信息。</p>
<p>推荐系统就是自动联系用户和物品的一种工具，能够在信息过载的环境中帮助用户发现令他们感兴趣的信息，也能将信息推送给对它们感兴趣的用户。</p>
<h2 id="社会化推荐"><a href="#社会化推荐" class="headerlink" title="社会化推荐"></a>社会化推荐</h2><p>社会化推荐（Social Recommendation）：让好友给自己推荐物品</p>
<h2 id="基于物品的推荐"><a href="#基于物品的推荐" class="headerlink" title="基于物品的推荐"></a>基于物品的推荐</h2><p>基于物品的推荐（item-based method）：给用户推荐那些和他们之前喜欢的物品相似的物品</p>
<h2 id="基于内容的推荐"><a href="#基于内容的推荐" class="headerlink" title="基于内容的推荐"></a>基于内容的推荐</h2><p>基于内容的推荐（content-based filtering）：</p>
<h2 id="基于协同过滤的推荐"><a href="#基于协同过滤的推荐" class="headerlink" title="基于协同过滤的推荐"></a>基于协同过滤的推荐</h2><p>基于协同过滤的推荐（collaborative filtering）：</p>
<h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><p>几乎所有的推荐系统应用都是由以下3部分构成：</p>
<ol>
<li>前台的展示页面</li>
<li>后台的日志系统</li>
<li>推荐算法系统</li>
</ol>
<p>广泛利用推荐系统的领域包括：</p>
<ol>
<li>电子商务</li>
<li>电影和视频</li>
<li>音乐</li>
<li>社交网络</li>
<li>阅读</li>
<li>基于位置的服务</li>
<li>个性化邮件</li>
<li>个性化广告</li>
</ol>
<p>个性化推荐的成功应用需要两个条件：</p>
<ol>
<li>存在信息过载：因为如果用户可以很容易地从所有物品中找到喜欢的物品，就不需要个性化推荐了</li>
<li>用户大部分时候没有特别明确的需求：因为用户如果有明确的需求，可以直接通过搜索引擎找到感兴趣的物品</li>
</ol>
<h2 id="电子商务"><a href="#电子商务" class="headerlink" title="电子商务"></a>电子商务</h2><ul>
<li>亚马逊（基于物品的推荐算法）<ul>
<li>给用户推荐那些和他们之前喜欢的物品相似的物品</li>
<li>给用户推荐他们的Facebook好友在亚马逊上喜欢的物品</li>
<li>相关推荐列表：在商品信息下展示相关的商品；可打包销售（cross selling）</li>
</ul>
</li>
</ul>
<h2 id="电影和视频"><a href="#电影和视频" class="headerlink" title="电影和视频"></a>电影和视频</h2><ul>
<li>Netflix（基于物品的推荐算法）<ul>
<li>Netflix Prize推荐系统比赛</li>
<li>Netflix电影推荐</li>
</ul>
</li>
<li>YouTube（基于物品的推荐算法）<ul>
<li>个性化推荐的点击率明显高于热门视频的点击率</li>
</ul>
</li>
<li>Hulu</li>
</ul>
<h2 id="音乐"><a href="#音乐" class="headerlink" title="音乐"></a>音乐</h2><p>个性化音乐网络电台</p>
<ul>
<li>Pandora（基于内容的推荐）<ul>
<li>根据专家标注的“基因”计算歌曲的相似度，并给用户推荐和他之前喜欢的音乐基因相似的其他音乐</li>
<li>使用了Facebook的推荐API（Instant Personalization）</li>
</ul>
</li>
<li>Last.fm<ul>
<li>记录了所有用户的听歌记录</li>
<li>主要利用用户行为计算歌曲的相似度</li>
</ul>
</li>
<li>豆瓣电台</li>
<li>网易云私人FM</li>
</ul>
<h2 id="社交网络"><a href="#社交网络" class="headerlink" title="社交网络"></a>社交网络</h2><p>社交网络的个性化推荐系统主要应用在以下3个方面：</p>
<ol>
<li>利用用户的社交网络信息对用户进行个性化的物品推荐</li>
<li>信息流的会话推荐</li>
<li>给用户推荐好友</li>
</ol>
<ul>
<li>Facebook<ul>
<li>宝贵数据：（1）用户之间的社交网络关系（2）用户的偏好信息</li>
<li>推荐API，Instant Personalization，根据用户好友喜欢的信息，给用户推荐他们好友最喜欢的物品</li>
<li>开发了EdgeRank算法，对用户的会话进行排序</li>
</ul>
</li>
</ul>
<h2 id="个性化阅读"><a href="#个性化阅读" class="headerlink" title="个性化阅读"></a>个性化阅读</h2><ul>
<li>Google Reader<ul>
<li>允许用户关注自己感兴趣的人并看到所关注用户分享的文章</li>
</ul>
</li>
<li>Zite<ul>
<li>收集用户对文章的偏好信息</li>
</ul>
</li>
<li>Flipboard</li>
<li>新闻阅读网站Digg<ul>
<li>根据用户的历史计算用户之间的兴趣相似度，然后给用户推荐和他兴趣相似的用户喜欢的文章</li>
</ul>
</li>
</ul>
<h2 id="基于位置的服务"><a href="#基于位置的服务" class="headerlink" title="基于位置的服务"></a>基于位置的服务</h2><ul>
<li>位置是一种很重要的上下文信息</li>
<li>往往与社交网络相结合</li>
</ul>
<h2 id="个性化邮件"><a href="#个性化邮件" class="headerlink" title="个性化邮件"></a>个性化邮件</h2><ul>
<li>个性化邮件推荐系统Tapestry<ul>
<li>通过分析用户阅读邮件的历史行为和习惯对新邮件进行重新排序，提高用户的工作效率</li>
</ul>
</li>
<li>Google Gmail优先级收件箱功能<ul>
<li>通过分析用户对邮件的历史行为，找到用户感兴趣的邮件，展示在一个专门的收件箱里</li>
</ul>
</li>
</ul>
<h2 id="个性化广告"><a href="#个性化广告" class="headerlink" title="个性化广告"></a>个性化广告</h2><p>广告定向投放（Ad Targeting）：将广告投放给潜在客户群</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:left">狭义个性化推荐</th>
<th style="text-align:left">个性化广告投放</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">着重于</td>
<td style="text-align:left">帮助用户找到可能令他们感兴趣的物品</td>
<td style="text-align:left">帮助广告找到可能对它们感兴趣的用户</td>
</tr>
<tr>
<td style="text-align:center">核心</td>
<td style="text-align:left">用户</td>
<td style="text-align:left">广告</td>
</tr>
</tbody>
</table>
</div>
<p>目前的<strong>个性化广告投放技术</strong>主要分为3种：</p>
<ol>
<li><strong>上下文广告</strong>：通过分析用户正在浏览的网页内容，投放和网页内容相关的广告<ul>
<li>谷歌的Adsense</li>
</ul>
</li>
<li><strong>搜索广告</strong>：通过分析用户在当前会话中的搜索记录，判断用户的搜索目的，投放和用户目的相关的广告</li>
<li><strong>个性化展示广告</strong>：我们经常在很多网站看到大量展示广告，它们是根据用户的兴趣，对不同用户投放不同的展示广告<ul>
<li>雅虎</li>
</ul>
</li>
</ol>
<h1 id="评测"><a href="#评测" class="headerlink" title="评测"></a>评测</h1><p>一个完整的推荐系统一般存在3个<strong>参与方</strong>：</p>
<ol>
<li><strong>用户</strong>：推荐系统要满足用户的需求，给用户推荐那些他们感兴趣的物品；好的推荐系统不仅仅能够准确预测用户的行为，而且能够扩展用户的视野，帮助用户发现那些他们可能会感兴趣，但却不那么容易发现的东西</li>
<li><strong>物品提供者</strong>：推荐系统要让所有物品都能够被推荐给对其感兴趣的用户</li>
<li><strong>提供推荐系统的网站</strong>：好的推荐系统设计，能够让推荐系统本身收集到高质量的用户反馈，不断完善推荐的质量，增加用户和网站的交互，提高网站的收入</li>
</ol>
<p>在评测一个推荐系统时，需要同时考虑三方的利益。</p>
<h2 id="实验方法"><a href="#实验方法" class="headerlink" title="实验方法"></a>实验方法</h2><p>一般来说，一个新的推荐算法最终上线，需要完成3个实验：</p>
<ol>
<li>通过<strong>离线实验</strong>证明它在很多离线指标上优于现有的算法</li>
<li>通过<strong>用户调查</strong>确定它的用户满意度不低于现有的算法</li>
<li>通过<strong>在线的AB测试</strong>确定它在我们关心的指标上优于现有的算法</li>
</ol>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">方法</th>
<th style="text-align:left">优点</th>
<th style="text-align:left">缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">离线实验</td>
<td style="text-align:left">1. 不需要对实际系统的控制权<br>2. 不需要用户参与实验 <br>3. 速度快，可以测试大量算法</td>
<td style="text-align:left">1. 无法计算商业上关注的指标<br>2. 离线实验的指标和商业指标存在差距</td>
</tr>
<tr>
<td style="text-align:center">用户调查</td>
<td style="text-align:left">1. 可以获得跟多体现用户主观感受的指标<br>2. 相对在线实验风险低，出错后很容易弥补</td>
<td style="text-align:left">1. 招募测试用户成本较高<br>2. 很难组织大规模的测试用户，会使测试结果的统计意义不足</td>
</tr>
<tr>
<td style="text-align:center">在线实验</td>
<td style="text-align:left">可以公平获得不同算法实际在线时的性能指标</td>
<td style="text-align:left">周期比较长，需要进行长时间的实验才能得到可靠的结果</td>
</tr>
</tbody>
</table>
</div>
<h3 id="离线实验"><a href="#离线实验" class="headerlink" title="离线实验"></a>离线实验</h3><p>离线实验（offline experiment）的的方法一般由如下几个步骤构成：</p>
<ol>
<li>通过日志系统获得用户行为数据，并按照一定格式生成一个标准的数据集</li>
<li>将数据集按照一定的规则分成训练集和测试集</li>
<li>在训练集上训练用户兴趣模型，在测试集上进行预测</li>
<li>通过事先定义的离线指标评测算法在测试集上的预测结果</li>
</ol>
<h3 id="用户调查"><a href="#用户调查" class="headerlink" title="用户调查"></a>用户调查</h3><p>用户调查（user study）：在将离线实验的算法上线前，一般需要做一次用户调查。</p>
<ol>
<li>需要一些真实用户在需要测试的推荐系统上完成一些任务</li>
<li>在用户完成任务时，观察和记录他们的行为，并让他们回答一些问题</li>
<li>通过分析用户的行为和答案了解测试系统的性能</li>
</ol>
<p>用户在测试环境下的行为和真实环境下的行为可能有所不同，因而在测试环境下收集的测试指标可能在真实环境下无法重现。</p>
<h3 id="在线实验"><a href="#在线实验" class="headerlink" title="在线实验"></a>在线实验</h3><p>在线实验（online experiment）：在完成离线实验和必要的用户调查后，可以将推荐系统上线做<a href="/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90-ABtest.html" title="AB测试">AB测试</a>，将它与旧的算法进行比较。</p>
<p>AB测试：通过一定的规则将用户随机分成几组，并对不同组的用户采用不同的算法，然后通过统计不同组用户的各种不同评测指标比较不同算法。</p>
<p>AB测试的周期比较长，通常不会用AB测试测试所有的算法，而是测试那些在离线实验和用户调查中表现很好的算法。</p>
<h2 id="评测指标"><a href="#评测指标" class="headerlink" title="评测指标"></a>评测指标</h2><ul>
<li>定量计算</li>
<li>定性描述</li>
</ul>
<p>可参考《<a href="/Machine-Learning-%E5%88%86%E7%B1%BB%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0.html" title="Machine Learning | 分类模型评估">Machine Learning | 分类模型评估</a>》。</p>
<h3 id="用户满意度"><a href="#用户满意度" class="headerlink" title="用户满意度"></a>用户满意度</h3><ul>
<li>用户满意度是评测推荐系统的最重要指标</li>
<li>用户满意度没有办法离线计算，只能通过用户调查或在线实验获得</li>
<li>用户调查获得用户满意度主要是通过调查问卷的形式</li>
</ul>
<blockquote>
<ul>
<li>电子商务中，用户如果购买了推荐的商品，则表示他们在一定程度上满意——可以利用购买率度量用户的满意度</li>
<li>可以设计一些反馈界面收集用户满意度</li>
</ul>
</blockquote>
<h3 id="准确度"><a href="#准确度" class="headerlink" title="准确度"></a>准确度</h3><ul>
<li>预测准确度是最重要的推荐系统离线评测指标</li>
<li>在计算该指标时需要有一个离线的数据集（包含用户的历史行为记录）；然后，将该数据集通过时间分成训练集和测试集；最后，通过在训练集上建立用户的行为和兴趣模型预测用户在测试集上的行为，并计算预测行为和测试集上实际行为的重合度（即预测准确度）</li>
</ul>
<p><strong>评分预测</strong>的预测准确度通常通过<strong>均方根误差</strong>（RMSE）和<strong>平均绝对误差</strong>（MAE）计算。</p>
<script type="math/tex; mode=display">RMSE=\sqrt{\frac{\sum_{u,i\in T}(r_{ui}-\hat{r}_{ui})^2}{|T|}}</script><ul>
<li>$T$是测试集</li>
<li>$|T|$表示测试集的(用户，物品)对数</li>
<li>对测试集中的有一个用户$u$和物品$i$，$r_{ui}$是用户$u$对物品$i$的实际评分，而$\hat{r}_{ui}$是推荐算法给出的预测评分</li>
</ul>
<script type="math/tex; mode=display">MAE=\frac{\sum_{u,i\in T}|r_{ui}-\hat{r}_{ui}|}{|T|}</script><h3 id="覆盖度"><a href="#覆盖度" class="headerlink" title="覆盖度"></a>覆盖度</h3><h3 id="新颖度"><a href="#新颖度" class="headerlink" title="新颖度"></a>新颖度</h3><h3 id="惊喜度"><a href="#惊喜度" class="headerlink" title="惊喜度"></a>惊喜度</h3><h3 id="信任度"><a href="#信任度" class="headerlink" title="信任度"></a>信任度</h3><h3 id="透明度"><a href="#透明度" class="headerlink" title="透明度"></a>透明度</h3><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><style>.post-copyright{display:none}</style>]]></content>
      <categories>
        <category>数据分析</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
        <tag>推荐系统</tag>
      </tags>
  </entry>
  <entry>
    <title>数据分析 | 流量池</title>
    <url>/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90-%E6%B5%81%E9%87%8F%E6%B1%A0.html</url>
    <content><![CDATA[<p><center>《流量池》读书笔记</center><br><a id="more"></a></p>
<h1 id="获取流量的必备工具"><a href="#获取流量的必备工具" class="headerlink" title="获取流量的必备工具"></a>获取流量的必备工具</h1><ol>
<li>品牌<ul>
<li>最稳定的流量来源</li>
</ul>
</li>
<li>微信<ul>
<li>社会化营销的流量高地</li>
</ul>
</li>
<li>数字广告<ul>
<li>流量转化品效合一的关键</li>
</ul>
<ol>
<li>搜索广告：以关键词为核心</li>
<li>社交媒体广告</li>
</ol>
</li>
</ol>
<h2 id="品牌"><a href="#品牌" class="headerlink" title="品牌"></a>品牌</h2><p>品牌广告怎么做才能获得实效？</p>
<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>定位符号塑品牌<br>场景触点做实效</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<h3 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h3><ol>
<li><p>对立型定位</p>
<ul>
<li>通常会使用“更”、“比”、“没有”、“增加”、“不是什么，而是什么”的形式</li>
</ul>
<blockquote>
<ul>
<li>百度更懂中文——巩固百度的中文搜索地位</li>
<li>不是所有的牛奶都叫特仑苏——突出特仑苏奶中贵族的特质</li>
</ul>
</blockquote>
</li>
<li><p>USP定位</p>
<ul>
<li>对产品进行物理属性的定位，找出产品独特的销售价值主张</li>
<li>通常使用场景化口号</li>
<li>明确场景，明确利益点</li>
</ul>
<blockquote>
<ul>
<li>今年过节不收礼啊，收礼只收脑白金</li>
<li>怕上火就喝王老吉</li>
<li>经常用脑，多喝六个核桃</li>
<li>斯达舒：胃痛、胃酸、胃胀</li>
<li>OPPO：充电五分钟，通话两小时</li>
</ul>
</blockquote>
</li>
<li><p>升维定位</p>
<ul>
<li>完全不和对手在一个水平面上进行差异化竞争，而是找到一个更高的维度创造新的蓝海品类市场</li>
<li>引导和创造用户的新的需求</li>
</ul>
</li>
</ol>
<h3 id="符号"><a href="#符号" class="headerlink" title="符号"></a>符号</h3><ol>
<li>视觉符号：产品的logo、包装、人物代言</li>
<li>听觉符号：口号、韵曲</li>
</ol>
<h3 id="场景营销"><a href="#场景营销" class="headerlink" title="场景营销"></a>场景营销</h3><p>场景营销：为产品找到具体的消费环境，包括时间、地点、心情、状态</p>
<ul>
<li>场景营销是让品牌能够迅速接地气、带流量、出效果的关键</li>
</ul>
<h3 id="接触点"><a href="#接触点" class="headerlink" title="接触点"></a>接触点</h3><p>品牌接触点：品牌和用户能够接触的地方</p>
<ul>
<li>快消品的接触点：产品包装、促销人员等</li>
<li>服务产品的接触点：装修、造型、服务员的着装、话术等</li>
</ul>
<h2 id="微信"><a href="#微信" class="headerlink" title="微信"></a>微信</h2><ul>
<li>是企业宣传的一个出口</li>
<li>也是社会营销的重要平台<br>微信该怎样实现流量改造来发挥最大的转化效率呢？</li>
</ul>
<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>官方严肃摆架子<br>不如轻快网感说人话<br>上了微信就能买<br>销售实时能转化<br>创意技术加福利<br>期期做到十万加</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<p>“上了微信就能买”——对于微信运营，首先一定要实现企业的产品功能；通过微信实现业务转化</p>
<p>企业在做微信流量转化时的必不可少的三要素为：</p>
<ol>
<li>创意<ul>
<li>可以解决流量吸引的问题</li>
</ul>
</li>
<li>技术<ul>
<li>在创意的基础上，增加一些交互技术，让创意互动趣味更高、分享力度更大</li>
</ul>
</li>
<li>福利<ul>
<li>在日常创意的基础上，加上一些福利、奖品、好玩的东西，刺激大家去分享，使传播扩散的更快</li>
</ul>
</li>
</ol>
<h2 id="数字广告"><a href="#数字广告" class="headerlink" title="数字广告"></a>数字广告</h2><p>靠谱的数字广告投放形式：</p>
<ol>
<li>搜索渠道<ul>
<li>企业快速获得流量的低成本入口</li>
<li>搜索营销中的核心手段是<strong>搜索引擎营销</strong>（SEM）</li>
</ul>
</li>
<li>原生广告</li>
<li>落地页</li>
</ol>
<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>SEM SEO<br>检索原则要跟紧<br>数据动态要追踪<br>信息流广告更融入<br>朋友圈广告没得说<br>LSB和排期<br>效果品牌都抓牢<br>落地页<br>落地页<br>落地页<br>重要事情说三遍<br>临门一脚很关键<br>简单直白要有效<br>用户一看就明了<br>注册购买留资料<br>关键信息就够了</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<h3 id="搜索渠道"><a href="#搜索渠道" class="headerlink" title="搜索渠道"></a>搜索渠道</h3><h4 id="搜索引擎营销"><a href="#搜索引擎营销" class="headerlink" title="搜索引擎营销"></a>搜索引擎营销</h4><p>搜索引擎营销（SEM）渠道的主要资源是各大搜索引擎的流量。</p>
<p>移动互联网端的推广渠道分为：</p>
<ol>
<li>关键词广告<ul>
<li>百度搜索</li>
<li>搜狗搜索</li>
<li>360搜索</li>
<li>神马搜索</li>
</ul>
</li>
<li>展示类广告<ul>
<li>百度联盟</li>
<li>搜狗网盟</li>
</ul>
</li>
</ol>
<p>一般是在投放前进行趋势分期，关注数据动态，找到波峰和波谷出现的时间，并分析原因。</p>
<p>关键词更换是SEM的重要环节，也是控制营销效果的关键因素。企业要根据投放情况，不断结合产品特性和实际情况，为关键词制定账户策略进行调整，找到最佳匹配。</p>
<h4 id="搜索引擎优化"><a href="#搜索引擎优化" class="headerlink" title="搜索引擎优化"></a>搜索引擎优化</h4><p>搜索引擎优化（SEO）：投入比较少、效果也比较好的营销搜索方式。为了从搜索引擎中获得更多免费流量，从网站结构、内容建设方案、用户互动传播这些方面进行合理规划。</p>
<p>SEO可以免费任意点击，可以规避百度的恶意搜索。</p>
<h4 id="应用商店优化"><a href="#应用商店优化" class="headerlink" title="应用商店优化"></a>应用商店优化</h4><p>应用商店优化（ASO）：利用应用商店的排名和搜索规则，让APP更容易被用户搜索到。</p>
<ul>
<li>面对的是主动搜索应用的用户，用户更加真实准确</li>
<li>可以提高品牌APP的露出频次，提升下载量</li>
</ul>
<h3 id="原生广告"><a href="#原生广告" class="headerlink" title="原生广告"></a>原生广告</h3><p>原生广告：把广告变成内容，通过场景化、定制化、融合性的内容和当前页面的环境整合，实现一体化的阅读体验。即常说的信息流广告。</p>
<p>要实现信息流广告的效果最大化，主要得抓住有吸引力的标题和精美又生活化的配图，更加融入内容本身。</p>
<p>微信朋友圈：最贵的信息流广告。借助LBS（Location Based Services，基于位置的服务）技术，朋友圈推广可以精确定位周围三到五公里的人群，适合线下有实体店的零售商家。</p>
<p>LBS定投广告是一种竞价投放机制，如果抢的人太多，出价再高也拿不了太多的流量。可以选择<strong>排期品牌广告</strong>，可以提前锁定曝光量，提前冻结账户里面的预定排期金额，是一种保价保量的合约购买方式。</p>
<p>排期广告形式更多，支持图文、视频广告，单次投放金额5万起步，适合想针对目标人群快速增加品牌曝光的企业。</p>
<h3 id="落地页"><a href="#落地页" class="headerlink" title="落地页"></a>落地页</h3><ul>
<li>落地页是数字广告转化的第一生产力。</li>
<li>落地页一定要从产品和营销的整体策略出发去考虑如何提高用户的浏览量、留存时间、转化率，都要不厌其烦地反复推敲。</li>
<li>在设计落地页时，要把“尽可能收集有效的用户信息”作为第一要义</li>
</ul>
<p>落地页的逻辑结构有6个构成要素：</p>
<ol>
<li>梳理出核心卖点和品牌活动信息<ul>
<li>要用最简短的画面构成、最直白的话术，迅速打开和消费者沟通的局面，完成最直接有效的信息传递</li>
</ul>
</li>
<li>品牌的整体印象和产品口碑<ul>
<li>一张优质的品牌图片胜过一大段文案描述</li>
<li>构图上要简单直白，同时可以尽量突出其他用户的使用情况，利用从众心理促成更多的用户转化</li>
</ul>
</li>
<li>消费者益处<ul>
<li>让消费者在浏览瞬间就看到产品能够给他提供什么服务、带来什么价值、有多大的优惠力度让他完成冲动型消费</li>
</ul>
</li>
<li>权威认证<ul>
<li>降低用户使用的心理门槛，打消用户疑虑</li>
</ul>
</li>
<li>用户留资<ul>
<li>落地页最核心的作用</li>
<li>希望用户注册、购买或留下他们的资料，完成流量到用户、再到销售转化的过程</li>
</ul>
</li>
<li>索取有效信息<ul>
<li>一定不要在落地页索取不需要的信息，给用户添加负担</li>
</ul>
</li>
</ol>
<h1 id="获取流量的进阶工具"><a href="#获取流量的进阶工具" class="headerlink" title="获取流量的进阶工具"></a>获取流量的进阶工具</h1><p>内容流量运营和再发掘</p>
<ol>
<li>裂变营销<ul>
<li>从存量找增量的核心获客手段</li>
</ul>
<ol>
<li>裂变强调分享</li>
<li>后付奖励：将原先拉新获客的广告费用，分解成用户推荐的奖励费用和新用户注册的奖励费用，可以降低企业的广告投放风险</li>
<li>裂变是最低成本的获客之道，是以存量找增量的核心手段</li>
</ol>
</li>
<li>跨界营销<ul>
<li>流量与流量间的对碰升华</li>
</ul>
<ol>
<li>能够丰富品牌的内涵，增加品牌受众的新鲜度和丰富度</li>
<li>和同等量级的品牌抱团，可以让双方的粉丝交叉流量户籍，实现双方平台价值利用最大化</li>
<li>是个以低成本获得流量的快捷方式</li>
</ol>
</li>
<li>事件营销<ul>
<li>以小博大，撬动流量增长的杠杆手段</li>
</ul>
<ol>
<li>能够迅速打开知名度，聚焦关注</li>
<li>能够以小博大，节约大量的媒体投放费用</li>
<li>但现在用户对于刷屏级的事件内容越来越挑剔，以小博大的难度变大，营销的投入也越来越大，效果不一定能够和销量挂钩</li>
</ol>
</li>
<li>直播营销<ul>
<li>值得关注的新的营销流量入口</li>
</ul>
<ol>
<li>可以承载广告片插播、品牌logo曝光、品牌slogan口播等形式的硬广告</li>
<li>也可以进行富有看点的内容营销创意</li>
</ol>
</li>
</ol>
<h2 id="裂变营销"><a href="#裂变营销" class="headerlink" title="裂变营销"></a>裂变营销</h2><h3 id="关键因素"><a href="#关键因素" class="headerlink" title="关键因素"></a>关键因素</h3><p>裂变营销的三个关键因素：</p>
<ol>
<li>种子用户</li>
<li>裂变诱饵</li>
<li>分享趣味</li>
</ol>
<h4 id="种子用户的选择"><a href="#种子用户的选择" class="headerlink" title="种子用户的选择"></a>种子用户的选择</h4><p>裂变选择的种子用户不等同于产品的初始用户。</p>
<p>种子用户需要具备三大特征：</p>
<ol>
<li>活跃度高、影响力大的忠实用户</li>
<li>种子用户的质量要高于数量</li>
<li>种子用户需要反馈产品建议</li>
</ol>
<h4 id="裂变诱饵的投放"><a href="#裂变诱饵的投放" class="headerlink" title="裂变诱饵的投放"></a>裂变诱饵的投放</h4><p>最常见的裂变诱饵是福利补贴。此外，还有</p>
<ul>
<li>好的创意内容</li>
<li>创新情景交互</li>
<li>有趣的玩法</li>
<li>……</li>
</ul>
<p>福利补贴的效果确定性比较大，在福利的诱导下，再加入一些创意进行诱导催化，就更容易撬动用户的社交关系，产生情感关系，才能获得更多的社交流量。</p>
<h4 id="分享趣味的满足"><a href="#分享趣味的满足" class="headerlink" title="分享趣味的满足"></a>分享趣味的满足</h4><p>除了利益刺激，裂变本身的趣味性是决定其发酵程度的重要一环。</p>
<p>当裂变的内容有助于塑造个人形象时，也会调动用户的分享热情。</p>
<blockquote>
<ul>
<li>攀登读书会：阅读数量和时长分享</li>
<li>Keep：训练打卡分享、成就分享</li>
</ul>
</blockquote>
<h3 id="部署裂变系统"><a href="#部署裂变系统" class="headerlink" title="部署裂变系统"></a>部署裂变系统</h3><p>如何部署流量的裂变系统？</p>
<ol>
<li>平台部署<ul>
<li>流量裂变的平台渠道是裂变的土壤</li>
<li>需要企业针对用户画像进行分析和选择</li>
</ul>
</li>
<li>创意部署<ul>
<li>流量裂变的创意内容是裂变的催化剂</li>
<li>有趣、有料的创意内容和IP内容才能撬动用户的社交关系，形成裂变传播</li>
</ul>
</li>
<li>福利部署<ul>
<li>有品质的福利和复利模式的福利规则设计，能够极大提高用户参与社交裂变的动机，激励用户去打通关系链</li>
</ul>
</li>
<li>技术部署<ul>
<li>系统化的裂变技术，能够最大限度降低用户参与裂变创业的门槛，提高裂变福利的分享效率，简化用户分享传播裂变的路径</li>
</ul>
</li>
</ol>
<h3 id="裂变系统"><a href="#裂变系统" class="headerlink" title="裂变系统"></a>裂变系统</h3><p>裂变系统一般包括：</p>
<ul>
<li>裂变前端创建系统</li>
<li>裂变后台配置系统</li>
<li>裂变福利核销系统</li>
<li>裂变用户管理系统</li>
<li>裂变数据管理系统</li>
<li>裂变平台对接系统</li>
</ul>
<h3 id="裂变渠道"><a href="#裂变渠道" class="headerlink" title="裂变渠道"></a>裂变渠道</h3><ol>
<li>APP</li>
<li>微信</li>
<li>线下</li>
</ol>
<h4 id="APP裂变"><a href="#APP裂变" class="headerlink" title="APP裂变"></a>APP裂变</h4><p>APP的裂变玩法有：</p>
<ol>
<li>拉新奖励</li>
<li>裂变红包</li>
<li>IP裂变</li>
<li>储值裂变<ul>
<li>增加亲情、账号等功能</li>
</ul>
</li>
<li>个体福利裂变<ul>
<li>eg：一些付费的产品经过分享朋友圈后，可以免费获得一些小的福利/给用户一次试用机会</li>
</ul>
</li>
<li>团购裂变<ul>
<li>eg：拼多多得团购裂变</li>
<li>用户在看到平台低价福利刺激后付款开团和分享社交平台完成病毒式传播</li>
</ul>
</li>
</ol>
<h4 id="微信裂变"><a href="#微信裂变" class="headerlink" title="微信裂变"></a>微信裂变</h4><p>微信得裂变形式有：</p>
<ol>
<li>分销裂变</li>
<li>众筹裂变<ul>
<li>砍价活动</li>
<li>考验品牌在朋友圈的人气和能够动用的社交力量</li>
</ul>
</li>
<li>微信卡券<ul>
<li>企业通过公众号、二维码、摇一摇、电视摇一摇、周边等渠道进行的卡券投放，可以提高顾客的到店量</li>
</ul>
</li>
<li>微信礼品卡<ul>
<li>是微信限制开放的一个功能</li>
<li>用户购买电子礼品卡或商品来赠送好友</li>
</ul>
</li>
</ol>
<h4 id="线下裂变"><a href="#线下裂变" class="headerlink" title="线下裂变"></a>线下裂变</h4><p>可以通过o2o把流量导到线上，然后通过社交媒体进行分享。</p>
<blockquote>
<ul>
<li>味全的包装裂变</li>
<li>每日C的拼字瓶</li>
<li>可口可乐的歌词瓶</li>
</ul>
</blockquote>
<h2 id="跨界营销"><a href="#跨界营销" class="headerlink" title="跨界营销"></a>跨界营销</h2><p>跨界营销的合作通常有4个不同的阶段：</p>
<ol>
<li>联合创意品牌<ul>
<li>双方联合想一些创意、做一些活动</li>
</ul>
</li>
<li>内容平台合作<ul>
<li>品牌双方可以借助创意的形式植入内容，互推品牌广告，能够实现更深程度的利益互享</li>
</ul>
</li>
<li>产品技术合作<blockquote>
<p>肯德基与阴阳师合作，在八个城市设置了不同的主题门店，推出阴阳师定制套餐，同时在游戏场景中设置了肯德基门店副本</p>
</blockquote>
</li>
<li>订单交易合作<ul>
<li>和一些重要的品牌完成内部承担交易和订单分享<blockquote>
<p>手机上一些预装软件即是软件品牌与手机厂商的合作，订单完成时双方会共同分享</p>
</blockquote>
</li>
</ul>
</li>
</ol>
<p>企业一定要重视娱乐资源和金融资源。</p>
<ol>
<li>娱乐资源：通过明星、影视、娱乐宣传发行获得的分享、下载和转化的效果远远高于一些纯创意性的传播，可以大大降低企业营销的传播和创意成本</li>
<li>金融资源：增加收益；企业和金融机构的商务合作形式，通常是企业联合银行通过广告产品绑定联名卡的方式获得银行的采购收入、营销支持。</li>
</ol>
<p>怎样才能找到合适的跨界资源？</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://book.douban.com/subject/30191451/" target="_blank" rel="noopener">流量池</a></li>
<li><a href="https://www.jianshu.com/p/70586dd06214" target="_blank" rel="noopener">裂变营销的三个关键因素</a></li>
</ul>
]]></content>
      <categories>
        <category>数据分析</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
      </tags>
  </entry>
  <entry>
    <title>Algorithm | 堆排序</title>
    <url>/Algo-%E5%A0%86%E6%8E%92%E5%BA%8F.html</url>
    <content><![CDATA[<p><center>Heap Sort</center><br><a id="more"></a></p>
<h1 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h1><p>堆是具有以下性质的<a href="/%E6%A0%91.html" title="完全二叉树">完全二叉树</a>：</p>
<ul>
<li>每个结点的值都大于或等于其左右孩子结点的值，称为<strong>大顶堆</strong></li>
<li>或，每个结点的值都小于或等于其左右孩子结点的值，称为<strong>小顶堆</strong></li>
</ul>
<p><meta name="referrer" content="no-referrer"><br><img src="/Algo-%E5%A0%86%E6%8E%92%E5%BA%8F/heap.png" class title="大顶堆和小顶堆"></p>
<p>对堆中的结点按层进行编号，并将这种逻辑结构映射到数组中，如下：</p>
<p><meta name="referrer" content="no-referrer"><br><img src="/Algo-%E5%A0%86%E6%8E%92%E5%BA%8F/array.png" class title="映射成数组"></p>
<p>该数组即是一个堆结构。</p>
<ul>
<li>大顶堆：<script type="math/tex; mode=display">array[i] \geq array[2i+1] 且 array[i] \geq array[2i+2]</script></li>
<li>小顶堆：<script type="math/tex; mode=display">array[i] \leq array[2i+1] 且 array[i] \leq array[2i+2]</script></li>
</ul>
<h1 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h1><ul>
<li>堆排序是一种选择排序</li>
<li>不稳定排序</li>
</ul>
<h2 id="运行时间"><a href="#运行时间" class="headerlink" title="运行时间"></a>运行时间</h2><ul>
<li>最坏、最好、平均时间复杂度均为$O(n\log{n})$</li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://www.cnblogs.com/chengxiao/p/6129630.html" target="_blank" rel="noopener">图解排序算法(三)之堆排序</a></li>
</ul>
]]></content>
      <categories>
        <category>基础算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Python | heapq</title>
    <url>/python-heapq.html</url>
    <content><![CDATA[<p><center></center><br><a id="more"></a></p>
<h1 id="堆队列"><a href="#堆队列" class="headerlink" title="堆队列"></a>堆队列</h1><p>堆队列，也称为优先级队列。</p>
<p>堆是一个二叉树，它的每个父节点的值都只会小于或大于所有孩子节点（的值），原理与<a href="/Algo-%E5%A0%86%E6%8E%92%E5%BA%8F.html" title="Algorithm | 堆排序">Algorithm | 堆排序</a>极为相似。</p>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul>
<li>最小的元素总是在根结点。<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">nums = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">54</span>, <span class="number">23</span>, <span class="number">132</span>]</span><br><span class="line">heap = []</span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">    heapq.heappush(heap, num)  <span class="comment"># 加入堆</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">heap[<span class="number">0</span>]  <span class="comment">## 获取最小值</span></span><br><span class="line"><span class="comment"># 1</span></span><br></pre></td></tr></table></figure></li>
<li>堆的值也可以是元组，可以实现对带权值的元素进行排序<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">h = []</span><br><span class="line">heapq.heappush(h, (<span class="number">5</span>, <span class="string">'write code'</span>))</span><br><span class="line">heapq.heappush(h, (<span class="number">7</span>, <span class="string">'release product'</span>))</span><br><span class="line">heapq.heappush(h, (<span class="number">1</span>, <span class="string">'write spec'</span>))</span><br><span class="line">heapq.heappush(h, (<span class="number">3</span>, <span class="string">'create tests'</span>))</span><br><span class="line">h</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">[(1, 'write spec'),</span></span><br><span class="line"><span class="string"> (3, 'create tests'),</span></span><br><span class="line"><span class="string"> (5, 'write code'),</span></span><br><span class="line"><span class="string"> (7, 'release product')]</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">heapq.heappop(h)</span><br><span class="line"><span class="comment"># (1, 'write spec')</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="heapify"><a href="#heapify" class="headerlink" title="heapify()"></a>heapify()</h2><p>将列表转换为堆结构<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">nums = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">54</span>, <span class="number">23</span>, <span class="number">132</span>]</span><br><span class="line">heapq.heapify(nums)</span><br><span class="line">nums</span><br><span class="line"><span class="comment"># [1, 2, 5, 3, 54, 23, 132]</span></span><br></pre></td></tr></table></figure></p>
<h2 id="heapmerge"><a href="#heapmerge" class="headerlink" title="heapmerge()"></a>heapmerge()</h2><p>合并多个排序后的序列成为一个排序后的序列，返回排序后的值的迭代器。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">num1 = [<span class="number">32</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">34</span>, <span class="number">54</span>, <span class="number">23</span>, <span class="number">132</span>]</span><br><span class="line">num2 = [<span class="number">23</span>, <span class="number">2</span>, <span class="number">12</span>, <span class="number">656</span>, <span class="number">324</span>, <span class="number">23</span>, <span class="number">54</span>]</span><br><span class="line">num1 = sorted(num1)</span><br><span class="line">num2 = sorted(num2)</span><br><span class="line"></span><br><span class="line">res = heapq.merge(num1, num2)</span><br><span class="line">print(list(res))</span><br><span class="line"><span class="comment"># [2, 3, 5, 12, 23, 23, 23, 32, 34, 54, 54, 132, 324, 656]</span></span><br></pre></td></tr></table></figure>
<h2 id="heappop"><a href="#heappop" class="headerlink" title="heappop()"></a>heappop()</h2><p>将最小值弹出</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print([heapq.heappop(nums) <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(nums))])  <span class="comment"># 堆排序结果</span></span><br><span class="line"><span class="comment"># [1, 2, 3, 5, 23, 54, 132]</span></span><br><span class="line"></span><br><span class="line">nums = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">54</span>, <span class="number">23</span>, <span class="number">132</span>]</span><br><span class="line">heapq.heapify(nums)  <span class="comment">## 将列表转换为堆结构</span></span><br><span class="line">heapq.heappop(nums)  <span class="comment">## 将堆结构的最小值弹出</span></span><br><span class="line"><span class="comment"># 1</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 实现堆排序</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">heapsort</span><span class="params">(iterable)</span>:</span></span><br><span class="line">    h = []</span><br><span class="line">    <span class="keyword">for</span> value <span class="keyword">in</span> iterable:</span><br><span class="line">        heappush(h, value)</span><br><span class="line">    <span class="keyword">return</span> [heappop(h) <span class="keyword">for</span> i <span class="keyword">in</span> range(len(h))]</span><br><span class="line"></span><br><span class="line">heapsort([<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">0</span>])</span><br><span class="line"><span class="comment"># [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span><br></pre></td></tr></table></figure>
<h2 id="heappush"><a href="#heappush" class="headerlink" title="heappush()"></a>heappush()</h2><p>将值加入堆中<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">nums = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">54</span>, <span class="number">23</span>, <span class="number">132</span>]</span><br><span class="line">heap = []</span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">    heapq.heappush(heap, num)  <span class="comment"># 加入堆</span></span><br><span class="line"></span><br><span class="line">heap</span><br><span class="line"><span class="comment"># [1, 2, 5, 3, 54, 23, 132]</span></span><br></pre></td></tr></table></figure></p>
<h2 id="heapreplace"><a href="#heapreplace" class="headerlink" title="heapreplace()"></a>heapreplace()</h2><p>删除堆中的最小元素并加入一个元素</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">nums = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">54</span>, <span class="number">23</span>, <span class="number">132</span>]</span><br><span class="line">heapq.heapify(nums)  <span class="comment">## 将列表转换为堆结构</span></span><br><span class="line">heapq.heapreplace(nums, <span class="number">55</span>)  <span class="comment">## 删除最小元素，并加入55</span></span><br><span class="line"><span class="comment"># 1</span></span><br><span class="line"></span><br><span class="line">nums</span><br><span class="line"><span class="comment"># [2, 3, 5, 55, 54, 23, 132]</span></span><br></pre></td></tr></table></figure>
<h2 id="nlargest"><a href="#nlargest" class="headerlink" title="nlargest()"></a>nlargest()</h2><p><code>nlargest(n, lst)</code>：返回列表lst中前n个最大元素</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lst = [<span class="number">3</span>, <span class="number">42</span>, <span class="number">34</span>, <span class="number">12</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line">heapq.nlargest(<span class="number">3</span>, lst)</span><br><span class="line"><span class="comment"># [42, 34, 12]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"><span class="keyword">from</span> pprint <span class="keyword">import</span> pprint</span><br><span class="line">portfolio = [</span><br><span class="line">    &#123;<span class="string">'name'</span>: <span class="string">'IBM'</span>, <span class="string">'shares'</span>: <span class="number">100</span>, <span class="string">'price'</span>: <span class="number">91.1</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'name'</span>: <span class="string">'AAPL'</span>, <span class="string">'shares'</span>: <span class="number">50</span>, <span class="string">'price'</span>: <span class="number">543.22</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'name'</span>: <span class="string">'FB'</span>, <span class="string">'shares'</span>: <span class="number">200</span>, <span class="string">'price'</span>: <span class="number">21.09</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'name'</span>: <span class="string">'HPQ'</span>, <span class="string">'shares'</span>: <span class="number">35</span>, <span class="string">'price'</span>: <span class="number">31.75</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'name'</span>: <span class="string">'YHOO'</span>, <span class="string">'shares'</span>: <span class="number">45</span>, <span class="string">'price'</span>: <span class="number">16.35</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'name'</span>: <span class="string">'ACME'</span>, <span class="string">'shares'</span>: <span class="number">75</span>, <span class="string">'price'</span>: <span class="number">115.65</span>&#125;</span><br><span class="line">]</span><br><span class="line">cheap = heapq.nsmallest(<span class="number">3</span>, portfolio, key=<span class="keyword">lambda</span> s: s[<span class="string">'price'</span>])</span><br><span class="line">expensive = heapq.nlargest(<span class="number">3</span>, portfolio, key=<span class="keyword">lambda</span> s: s[<span class="string">'price'</span>])</span><br><span class="line">pprint(cheap)</span><br><span class="line">pprint(expensive)</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">输出：</span></span><br><span class="line"><span class="string">[&#123;'name': 'YHOO', 'price': 16.35, 'shares': 45&#125;,</span></span><br><span class="line"><span class="string"> &#123;'name': 'FB', 'price': 21.09, 'shares': 200&#125;,</span></span><br><span class="line"><span class="string"> &#123;'name': 'HPQ', 'price': 31.75, 'shares': 35&#125;]</span></span><br><span class="line"><span class="string">[&#123;'name': 'AAPL', 'price': 543.22, 'shares': 50&#125;,</span></span><br><span class="line"><span class="string"> &#123;'name': 'ACME', 'price': 115.65, 'shares': 75&#125;,</span></span><br><span class="line"><span class="string"> &#123;'name': 'IBM', 'price': 91.1, 'shares': 100&#125;]</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>
<h2 id="nsmallest"><a href="#nsmallest" class="headerlink" title="nsmallest()"></a>nsmallest()</h2><p><code>heapq.nsmallest(n, lst)</code>：返回列表lst中前n个最小元素</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lst = [<span class="number">3</span>, <span class="number">42</span>, <span class="number">34</span>, <span class="number">12</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line">heapq.nsmallest(<span class="number">4</span>, lst)</span><br><span class="line"><span class="comment"># [1, 2, 3, 5]</span></span><br></pre></td></tr></table></figure>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://mp.weixin.qq.com/s/tMok3YAKvMWnI3eW46OYlg" target="_blank" rel="noopener">Python 优先级队列</a></li>
<li><a href="https://www.jianshu.com/p/801318c77ab5" target="_blank" rel="noopener">Python标准库模块之heapq</a></li>
</ul>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>数据分析 | 用户行为分析</title>
    <url>/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90-%E7%94%A8%E6%88%B7%E8%A1%8C%E4%B8%BA%E5%88%86%E6%9E%90.html</url>
    <content><![CDATA[<p><center>Analysis of Users' Behavior</center><br><a id="more"></a></p>
<h1 id="用户行为分析"><a href="#用户行为分析" class="headerlink" title="用户行为分析"></a>用户行为分析</h1><p>分析用户的行为习惯，发现产品在推广、拉新、用户留存、转化等方面存在的问题，有助于发掘高质量的推广拉新渠道，发现提高转化率的方法，使产品的营销更加精准、有效。</p>
<p>用户行为数据包括：</p>
<ul>
<li>来源地区、</li>
<li>在网站的停留时间、跳出率、回访者、新访问者、回访次数、回访相隔天数</li>
<li>注册用户和非注册用户</li>
<li>使用的搜索引擎、关键词、关联关键词、站内关键字</li>
<li></li>
</ul>
<h1 id="分析方法"><a href="#分析方法" class="headerlink" title="分析方法"></a>分析方法</h1><h2 id="行为事件分析"><a href="#行为事件分析" class="headerlink" title="行为事件分析"></a>行为事件分析</h2><p>主要用于研究某行为事件的发生对产品的影响及影响程度</p>
<ul>
<li>一般来说，事件通过埋点来获取</li>
</ul>
<p>用5W2H定义用户的行为事件：</p>
<ul>
<li>Who：事件的参与主体</li>
<li>When：事件发生的时间</li>
<li>Where：事件发生的地点</li>
<li>What：用户在事件中所作行为的方式（如使用的设备、app版本、渠道等）</li>
<li>Why</li>
<li>How：用户在事件中所作行为的具体内容</li>
<li>How much</li>
</ul>
<p>事件定义完成后，进行多维度的下钻分析，进行细分，确认导致该行为的原因，针对存在的现象，找出产生这一现象的行为。</p>
<blockquote>
<p>eg：登录页面下，点击登录和跳过登录的用户有什么行为差异</p>
</blockquote>
<h2 id="页面点击分析"><a href="#页面点击分析" class="headerlink" title="页面点击分析"></a>页面点击分析</h2><ul>
<li>页面点击分析模型主要用于对官网首页、活动页面、产品首页或详情页等存在交互的页面分析</li>
<li>主要解决三种问题：<ol>
<li>精准评估用户与产品交互背后的深层关系</li>
<li>实现产品的跳转路径分析，完成产品页面之间深层次的关系需求挖掘</li>
<li>与其他分析模型配合，全面视角探索数据价值，深度感知用户体验，实现科学决策</li>
</ol>
</li>
<li>通用的<strong>分析形式</strong>：<ol>
<li>可视化热力图</li>
<li>固定埋点</li>
</ol>
</li>
</ul>
<blockquote>
<p>eg：某元素的点击次数、占比、哪些用户做了点击行为</p>
</blockquote>
<p>可以通过用户的页面浏览次数、浏览人数、点击次数、点击人数、点击人数/浏览人数、浏览时长等来判断用户的浏览喜好，也可以通过用户的浏览行为对用户进行分群，以便之后进行针对性的分析与优化</p>
<h2 id="用户行为路径分析"><a href="#用户行为路径分析" class="headerlink" title="用户行为路径分析"></a>用户行为路径分析</h2><p>两种方法：</p>
<ol>
<li>转化漏斗：针对少数人为特定模块与事件节点进行路径分析，主要用于提升转化效果</li>
<li>用户路径（行为轨迹）：不需要预先设置漏斗，而是计算用户使用产品时的每个第一步，然后依次计算每一步的流向和转化。可以发现哪条路径用户访问最多、哪条路径用户容易流失</li>
</ol>
<h2 id="产品健康度分析"><a href="#产品健康度分析" class="headerlink" title="产品健康度分析"></a>产品健康度分析</h2><p>产品健康度是基于用户的行为数据进行综合考虑得到的核心指标，用以体现产品的运营情况，为产品的发展进行预警。包括以下指标：</p>
<ul>
<li>产品基础指标：主要评价产品本身的运行状态</li>
<li>流量质量指标：主要评价用户流量的质量高低</li>
<li>产品营收指标：主要评价产品的盈利能力与可持续性</li>
</ul>
<h3 id="产品基础指标"><a href="#产品基础指标" class="headerlink" title="产品基础指标"></a>产品基础指标</h3><p>主要评价<strong>产品本身的运行状态</strong></p>
<ul>
<li><strong>PV</strong>(Page View)：</li>
<li><strong>UV</strong>(Unique View)：</li>
<li><strong>VV</strong>(Visit View)：</li>
<li><strong>IP数</strong></li>
<li><strong>新访客数</strong></li>
</ul>
<h3 id="流量质量指标"><a href="#流量质量指标" class="headerlink" title="流量质量指标"></a>流量质量指标</h3><p>主要评价<strong>用户流量的质量高低</strong></p>
<ul>
<li><strong>跳出率</strong>：只访问了入口页面就离开地访问量/所产生总访问量</li>
<li><strong>平均访问时长</strong>：用户在一次访问中平均使用产品地事件</li>
<li><strong>平均访问页数</strong>：PV/访问次数</li>
</ul>
<h3 id="产品营收指标"><a href="#产品营收指标" class="headerlink" title="产品营收指标"></a>产品营收指标</h3><p>主要评价<strong>产品的盈利能力与可持续性</strong>。营收数据最关键的指标是ARPU值和转化率。</p>
<ul>
<li><strong>支付金额</strong>（GMV，Gross Merchandise Volume）：一般包含拍下未支付订单金额</li>
<li><strong>ARPU值</strong>（Average Revenue Per User，每用户平均收入/客单价）<script type="math/tex; mode=display">ARPU=\frac{支付金额}{支付人数}</script></li>
<li><strong>转化次数</strong>：用户到达目标页面的次数</li>
<li><strong>订单转化率</strong><script type="math/tex; mode=display">转化率=\frac{转化次数}{访问次数}</script></li>
</ul>
<p>销售额的计算：</p>
<script type="math/tex; mode=display">销售额=访客数\times 成交转化率\times 客单价</script><script type="math/tex; mode=display">销售额=曝光次数\times 点击率\times 成交转化率\times 客单价</script><h2 id="漏斗模型分析"><a href="#漏斗模型分析" class="headerlink" title="漏斗模型分析"></a>漏斗模型分析</h2><p>漏斗模型是一套流程式的数据分析模型，能够反映出用户行为状态以及从开始到最终各阶段的转化率及总体转化率情况。</p>
<p>经典的漏斗模型：<a href="/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90-AARRR%E6%A8%A1%E5%9E%8B.html" title="AARRR">AARRR</a>。</p>
<script type="math/tex; mode=display">Acquisition \rightarrow Activation \rightarrow Retention \rightarrow Revenue \rightarrow Referral</script><p>AARRR模型是围绕增长建立的，主要关注拉新、获客。但是当今时代，对绝大多数产品而言，拉新成本剧增，人口流量红利时代不复，转而流行的多是<strong>RARRA模型</strong></p>
<script type="math/tex; mode=display">Retention \rightarrow Activation \rightarrow Referral \rightarrow Revenue \rightarrow Acquisition</script><p>RARRA模型突出用户留存的重要性，通过用户留存来关注增长。</p>
<h2 id="用户画像分析"><a href="#用户画像分析" class="headerlink" title="用户画像分析"></a>用户画像分析</h2><p>用户画像是根据用户特征、网络浏览内容、网络社交活动和消费行为等信息抽象得到一个标签化的用户模型。</p>
<p>用户画像的内容包括：</p>
<ul>
<li>基本属性:<ul>
<li>性别</li>
<li>年龄</li>
<li>职业</li>
<li>位置</li>
<li>兴趣爱好</li>
<li>设备属性</li>
</ul>
</li>
<li>消费购物<br>- </li>
<li>社交方式</li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="http://mp.weixin.qq.com/s?__biz=MzU5NDgyMjc0OQ==&amp;mid=2247490164&amp;idx=2&amp;sn=0d50609b9b02f8452b3086fb43df9c61&amp;chksm=fe7a0946c90d8050ab58f4a84c527d87a3a6be4c6e1c2486025df99bb8a718fe69c94339ba3f&amp;mpshare=1&amp;scene=24&amp;srcid=0714r98u1C0PTaOAaXHLBea2&amp;sharer_sharetime=1594739093150&amp;sharer_shareid=b539221659d6ecf12200314308b58dd3#rd" target="_blank" rel="noopener">六种常见的「用户行为」分析方法</a></li>
<li><a href="http://www.woshipm.com/pmd/274422.html" target="_blank" rel="noopener">如何判断你的产品是否健康？这3个指标来告诉你</a></li>
</ul>
]]></content>
      <categories>
        <category>数据分析</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
        <tag>业务向</tag>
      </tags>
  </entry>
  <entry>
    <title>Data Scientist | 数据埋点</title>
    <url>/%E6%95%B0%E6%8D%AE-%E6%95%B0%E6%8D%AE%E5%9F%8B%E7%82%B9.html</url>
    <content><![CDATA[<p><center></center><br><a id="more"></a></p>
<h1 id="数据流程"><a href="#数据流程" class="headerlink" title="数据流程"></a>数据流程</h1><h1 id="用户行为模型"><a href="#用户行为模型" class="headerlink" title="用户行为模型"></a>用户行为模型</h1><p><strong>4W1H</strong>用户行为模型：</p>
<ul>
<li><strong>WHO</strong>：用户属性<ul>
<li>用户属性本身不随行为的发生而改变，可不在埋点中体现，可user_id将用户行为与用户属性宽表关联</li>
</ul>
</li>
<li><strong>WHEN</strong>：行为发生的时间（不是上报时间）<ul>
<li>一般上报时间比行为时间晚</li>
</ul>
</li>
<li><strong>WHERE</strong>：行为发生的地点</li>
<li><strong>HOW</strong>：发生行为时的一些状态<ul>
<li>操作系统</li>
<li>网络状态</li>
<li>屏幕比例</li>
<li>分辨率等</li>
</ul>
</li>
<li><strong>WHAT</strong>：具体发生的行为<ul>
<li>点击</li>
<li>曝光</li>
<li>浏览</li>
<li>……</li>
</ul>
</li>
</ul>
<h1 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h1><p><strong>什么是事件？</strong><br>追踪或记录的用户行为或业务过程</p>
<blockquote>
<ul>
<li>注册账号</li>
<li>登录</li>
<li>观看视频</li>
<li>点赞</li>
<li>评论</li>
<li>关注</li>
<li>……</li>
</ul>
</blockquote>
<p>事件通常包括曝光（expose）、点击（click）、浏览（view）。</p>
<h2 id="事件三要素"><a href="#事件三要素" class="headerlink" title="事件三要素"></a>事件三要素</h2><ul>
<li><strong>操作</strong>（action）：定义一个操作动作（点击、拖拽等）</li>
<li><strong>参数/属性</strong>：参数可以是任何与该事件相关的属性，包括触发这个事件的人、时间、地点、设备、操作的业务信息</li>
<li><strong>属性值</strong>：参数/属性的值参；参数和值以kv（key-value）形式存储在JSON串中</li>
</ul>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: center;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: center;">
      <th>事件类型</th>
      <th>事件名称</th>
      <th>事件显示名</th>
      <th>参数名</th>
      <th>参数显示名</th>
      <th>参数值类型</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="15">电商行为类</th>
      <td rowspan="6">order</td>
      <td rowspan="6">购买</td>
      <td>order_id</td>
      <td>订单编号</td>
      <td>STRING</td>
    </tr>
    <tr>
      <td>sku_name</td>
      <td>商品名称</td>
      <td>STRING</td>
    </tr>
    <tr>
      <td>sku_type</td>
      <td>商品类型</td>
      <td>STRING</td>
    </tr>
    <tr>
      <td>sku_num</td>
      <td>购买数量</td>
      <td>NUMBER</td>
    </tr>
    <tr>
      <td>order_amt</td>
      <td>购买金额</td>
      <td>NUMBER</td>
    </tr>
    <tr>
      <td>order_type</td>
      <td>购买方式</td>
      <td>STRING</td>
    </tr>
    <tr>
      <td rowspan="5">complaint</td>
      <td rowspan="5">用户投诉</td>
      <td>user_id</td>
      <td>用户id</td>
      <td>STRING</td>
    </tr>
    <tr>
      <td>comp_contents</td>
      <td>投诉内容</td>
      <td>STRING</td>
    </tr>
    <tr>
      <td>comp_object</td>
      <td>投诉对象</td>
      <td>STRING</td>
    </tr>
    <tr>
      <td>comp_channel</td>
      <td>投诉渠道</td>
      <td>STRING</td>
    </tr>
    <tr>
      <td>comp_type</td>
      <td>投诉方式</td>
      <td>STRING</td>
    </tr>
    <tr>
      <td rowspan="4">order_return</td>
      <td rowspan="4">退货</td>
      <td>order_id</td>
      <td>订单编号</td>
      <td>STRING</td>
    </tr>
    <tr>
      <td>return_amt</td>
      <td>退货金额</td>
      <td>NUMBER</td>
    </tr>
    <tr>
      <td>return_reason</td>
      <td>退货原因</td>
      <td>STRING</td>
    </tr>
    <tr>
      <td>return_type</td>
      <td>退货方式</td>
      <td>STRING</td>
    </tr>
    <tr>
      <th rowspan="2">通用功能类</th>
      <td rowspan="2">search</td>
      <td rowspan="2">搜索</td>
      <td>search_keyword</td>
      <td>搜索关键词</td>
      <td>STRING</td>
    </tr>
    <tr>
      <td>search_type</td>
      <td>搜索类型</td>
      <td>STRING</td>
    </tr>
    <tr>
  </tr></tbody>
</table>
</div>

<h1 id="数据埋点"><a href="#数据埋点" class="headerlink" title="数据埋点"></a>数据埋点</h1><blockquote>
<p>数据埋点是数据产品经理、数据运营以及数据分析师，基于业务需求或产品需求对用户在应用内产生行为的每一个事件对应的页面和位置植入相关代码，并通过采集工具上报统计数据，以便相关人员追踪用户行为，推动产品优化或知道运营的一项工程。 ——<a href="http://www.woshipm.com/pd/3261924.html" target="_blank" rel="noopener">产品埋点答疑指南</a></p>
</blockquote>
<h2 id="平台"><a href="#平台" class="headerlink" title="平台"></a>平台</h2><ul>
<li><strong>移动产品</strong>：经常称之为<strong>移动端</strong>、<strong>M端</strong><ul>
<li>手机APP</li>
<li>内嵌H5页面</li>
<li>小程序</li>
<li>WQ页面</li>
<li>……</li>
</ul>
</li>
<li><strong>网页产品</strong>：经常称之为<strong>PC端</strong><ul>
<li>WEB页面</li>
<li>PC客户端</li>
</ul>
</li>
<li><strong>移动设备</strong>：智能手环、POS机等各种智能设备、掌上电脑</li>
<li><strong>服务端</strong>：一般是指服务端服务器资源</li>
</ul>
<p>各种平台的埋点手段：</p>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: center;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: center;">
      <th>设备类型</th>
      <th>展现形式</th>
      <th>展示形式</th>
      <th>采集工具</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="2">PC设备</th>
      <td>PC站</td>
      <td>WEB页面</td>
      <td>JS</td>
    </tr>
    <tr>
      <td>PC客户端</td>
      <td>客户端</td>
      <td>JS</td>
    </tr>
    <tr>
      <th rowspan="5">移动设备</th>
      <td>手机App</td>
      <td>移动应用</td>
      <td>SDK、http</td>
    </tr>
    <tr>
      <td>App内嵌</td>
      <td>App内嵌H5页面</td>
      <td>JS</td>
    </tr>
    <tr>
      <td>M站</td>
      <td>WEB页面</td>
      <td>JS</td>
    </tr>
    <tr>
      <td>微信</td>
      <td>WEB页面</td>
      <td>JS</td>
    </tr>
    <tr>
      <td>微信小程序</td>
      <td>WEB页面</td>
      <td>JS</td>
    </tr>
    <tr>
      <th>服务端</th>
      <td>服务接口</td>
      <td>服务接口</td>
      <td>http</td>
    </tr>
    <tr>
      <th rowspan="2">移动终端</th>
      <td>智能设备</td>
      <td>移动应用</td>
      <td>SDL、http</td>
    </tr>
    <tr>
      <td>掌上电脑</td>
      <td>硬件服务</td>
      <td>http</td>
    </tr>
    <tr>
  </tr></tbody>
</table>
</div>

<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>按照<u>获取数据的类型</u>以及<u>用户触发行为</u>的不同，可将埋点分为以下几种：</p>
<ul>
<li>点击事件</li>
<li>曝光事件</li>
<li>浏览事件</li>
</ul>
<h3 id="点击事件"><a href="#点击事件" class="headerlink" title="点击事件"></a>点击事件</h3><p>用户在应用内的每一次点击行为，都可以记为一次点击事件。</p>
<p>一般通过点击事件，可以统计得到点击PV、点击UV</p>
<h3 id="曝光事件"><a href="#曝光事件" class="headerlink" title="曝光事件"></a>曝光事件</h3><p>曝光事件是为了统计应用内的某些局部区域是否被用户有效浏览。</p>
<blockquote>
<p>eg：推荐区域、某个按钮</p>
</blockquote>
<p>做曝光埋点的时候应该注意：</p>
<ol>
<li>要科学、合理地定义有效曝光</li>
<li>为了不影响页面性能和用户体验，不能在应用内的所有区域都加曝光埋点</li>
</ol>
<h3 id="页面浏览事件"><a href="#页面浏览事件" class="headerlink" title="页面浏览事件"></a>页面浏览事件</h3><p>页面浏览事件通常是指页面的各种维度信息的统计</p>
<blockquote>
<p>eg：页面流量PV、页面流量UV</p>
</blockquote>
<p>页面事件通常统计的信息包括：</p>
<ul>
<li><strong>浏览器信息</strong>：浏览器版本、浏览器语言、浏览器编码、屏幕分辨率等</li>
<li><strong>访问信息</strong>：用户账号、当前页面URL、上次访问时间、访问时长、页面停留时间等</li>
<li><strong>来源信息</strong>：</li>
<li><strong>物品信息</strong></li>
</ul>
<h2 id="方式"><a href="#方式" class="headerlink" title="方式"></a>方式</h2><p>数据埋点方式主要有两种：</p>
<ol>
<li>公司研发在自己的产品当中注入统计代码</li>
<li>集成第三方统计的SDK，如友盟、百度移动统计、Sensors Data、GrowingIO、Talking Data等</li>
</ol>
<p>按照<u>埋点工具</u>可分为：</p>
<ol>
<li>代码埋点（客户端）<blockquote>
<p>Talking Data、Google Analytics </p>
</blockquote>
</li>
<li>可视化埋点（客户端）<blockquote>
<p>诸葛IO、神策数据、MixPanel</p>
</blockquote>
</li>
<li>无埋点/全埋点（客户端）<blockquote>
<p>Heap Analytics、Growing IO</p>
</blockquote>
</li>
</ol>
<h2 id="类别"><a href="#类别" class="headerlink" title="类别"></a>类别</h2><h3 id="通用埋点"><a href="#通用埋点" class="headerlink" title="通用埋点"></a>通用埋点</h3><p>通用规范事件</p>
<h3 id="自定义埋点"><a href="#自定义埋点" class="headerlink" title="自定义埋点"></a>自定义埋点</h3><ul>
<li>需求名称</li>
<li>采集端</li>
<li>页面名称/模块名称</li>
<li>自定义事件名</li>
<li>自定义事件用途<ul>
<li>仅用于内部测试</li>
<li>用于统计</li>
<li>用于推荐/画像</li>
<li>同时用于统计和推荐/画像</li>
</ul>
</li>
<li>需求备注</li>
<li>事件其他隐私说明</li>
<li>同时提交隐私审核申请</li>
</ul>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol>
<li>梳理业务流程</li>
<li>确定关键指标</li>
<li>细化各流程影响因素</li>
<li>评估对老业务的影响</li>
</ol>
<h1 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h1><p>埋点设计原则：</p>
<ol>
<li>唯一原则<ul>
<li>埋点字段相互独立</li>
</ul>
</li>
<li>枚举原则<ul>
<li>将所有可能需要的数据涉及的埋点一一枚举</li>
<li>可以根据页面穷举或根据流程穷举</li>
</ul>
</li>
<li>精确描述<ul>
<li>描述包括：采集逻辑、数据结构、特殊情况处理</li>
</ul>
</li>
</ol>
<h1 id="埋点流程"><a href="#埋点流程" class="headerlink" title="埋点流程"></a>埋点流程</h1><p>埋点的基本流程：</p>
<ol>
<li>整理埋点方案</li>
<li>采集工具植入</li>
<li>埋点测试</li>
<li>线上数据跟踪</li>
</ol>
<p>或为：</p>
<ol>
<li>业务需求梳理<ul>
<li>需求背景：该打点是为了什么场景/活动/页面</li>
<li>需求提出方：产品、运营、研发等</li>
<li>衡量指标：根据以上需求背景，明确需要量化的指标</li>
<li>其他信息：对以上信息的补充</li>
</ul>
</li>
<li>埋点设计<ul>
<li>根据业务需求，将指标进行拆解，拆解出原子指标及维度，罗列出需要埋点的具体点位，设计出每个埋点的点位应该用什么事件，需要带哪些参数、每个参数的类型、填什么取值</li>
</ul>
</li>
<li>埋点需求评审：对埋点设计进行评审，对不合理的设计进行调整，剔除不可实现或过于复杂的埋点或寻求其他方案</li>
<li>埋点开发：研发按照评审后的埋点需求文档进行开发</li>
<li>埋点测试</li>
<li>上线校验</li>
</ol>
<h2 id="整理埋点方案"><a href="#整理埋点方案" class="headerlink" title="整理埋点方案"></a>整理埋点方案</h2><p>通常至少要包含以下几点内容：</p>
<ul>
<li><strong>埋点位置</strong>：需要添加埋点相关信息的位置</li>
<li><strong>埋点标识</strong>：每一个位置上需要设置一个埋点的标识来代表这个点击位<ul>
<li>必须全站唯一，不能出现重复</li>
</ul>
</li>
<li><strong>埋点参数</strong>：除了正常的流量数据（UV、PV）外，还想看到的数据</li>
<li><strong>页面名称</strong>：当前埋点所属的页面</li>
<li><strong>应用标识</strong>：当前应用的唯一标识，也叫站点；用来进行数据归属划分</li>
</ul>
<h2 id="采集工具植入"><a href="#采集工具植入" class="headerlink" title="采集工具植入"></a>采集工具植入</h2><ul>
<li>数据的采集工具通常为埋点代码</li>
<li>不同的产品形态采取不同的埋点代码植入</li>
</ul>
<p>通常有3种：</p>
<ul>
<li>JS文件</li>
<li>SDK</li>
<li>http请求</li>
</ul>
<h2 id="埋点测试"><a href="#埋点测试" class="headerlink" title="埋点测试"></a>埋点测试</h2><p><strong>埋点测试</strong>是指完成埋点代码植入后，需要对埋点的有效性进行测试</p>
<p>通常关注以下内容：</p>
<ul>
<li>埋点代码是否引入</li>
<li>点击位以及相关事件参数是否正常加入埋点</li>
<li>数据能否正常上报</li>
</ul>
<h2 id="线上数据跟踪"><a href="#线上数据跟踪" class="headerlink" title="线上数据跟踪"></a>线上数据跟踪</h2><p>埋点上线后，可用对应的数据可视化产品进行产品数据展示，或使用SQL提数看数据。</p>
<h1 id="用户唯一标识"><a href="#用户唯一标识" class="headerlink" title="用户唯一标识"></a>用户唯一标识</h1><p>用户唯一标识：是用户唯一的身份ID；包括设备ID和用户ID。</p>
<h2 id="设备ID"><a href="#设备ID" class="headerlink" title="设备ID"></a>设备ID</h2><p>使用相应的算法，生成一个设备ID，以唯一识别用户的终端设备。</p>
<h3 id="Android系统"><a href="#Android系统" class="headerlink" title="Android系统"></a>Android系统</h3><p><strong>Android系统</strong>适合做设备唯一标识符的几种标识符及其特性：</p>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: center;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: center;">
      <th>标识符</th>
      <th>安卓版本/权限特性</th>
      <th>重置特性</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>OAID</th>
      <td>1. Android 10及以上版本支持<br>2. 需要获取OAID的权限</td>
      <td>1. 用户可手动重置<br>2. 恢复出厂可重置<br>3. 用户可关闭OAID的获取权限</td>
    </tr>
    <tr>
      <th>Android_id</th>
      <td>1. 不需要权限<br>2. Android 8.0之后，Android_ID将不再适合唯一设备标识符</td>
      <td>刷机、root、恢复出厂设置会重置</td>
    </tr>
    <tr>
      <th>IMEI</th>
      <td>1. 获取IMEI需要READ_PHONE_STATE权限<br>2. Android 6.0之后，这类权限需要动态申请<br>3. Android 10之后，禁止获取手机IMEI号</td>
      <td>具备唯一性，恢复出厂设置不会重置</td>
    </tr>
    <tr>
  </tr></tbody>
</table>
</div>

<p>因此，IMEI是最适合做设备唯一标识符的，但是获取IMEI需要授予权限且Android 10之后不再开放IMEI的权限</p>
<p>因此，在Android系统中，应按</p>
<script type="math/tex; mode=display">IMEI \rightarrow OAID \rightarrow Android\_ID</script><p>的顺序生成设备ID</p>
<blockquote>
<p>先获取IMEI号；获取不到IMEI时获取OAID；获取不到OAID时，再获取Android_ID；然后使用相关算法生成设备ID。</p>
</blockquote>
<h3 id="IOS系统"><a href="#IOS系统" class="headerlink" title="IOS系统"></a>IOS系统</h3><p><strong>IOS系统</strong>的可用于生成设备ID的标识符：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">标识符</th>
<th style="text-align:center">说明</th>
<th style="text-align:center">IOS版本/权限特性</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">IDFA</td>
<td style="text-align:center">广告标识符</td>
<td style="text-align:center">IOS 10之后，用户修改后或关闭后无法确定用户的唯一性</td>
</tr>
<tr>
<td style="text-align:center">IDFV</td>
<td style="text-align:center">应用开发商标识符</td>
<td style="text-align:center">统一开发商下的不同App的IDFV相同</td>
</tr>
<tr>
<td style="text-align:center">UDID</td>
<td style="text-align:center">IOS设备的唯一标识码</td>
<td style="text-align:center">IOS 6及以前系统是可以获取到设备的UDID，IOS 7中已经完全禁用</td>
</tr>
</tbody>
</table>
</div>
<p>苹果系统生成设备ID的标识符顺序应该是</p>
<script type="math/tex; mode=display">IDFA\rightarrow IDFV\rightarrow UDID</script><blockquote>
<p>先获取IDFA；获取不到IDFA时获取IDFV；获取不到IDFV时，再获取UDID；然后使用相关算法生成设备ID。</p>
</blockquote>
<h3 id="Web网站"><a href="#Web网站" class="headerlink" title="Web网站"></a>Web网站</h3><p>使用cookie_id作为设备ID，并存储在浏览器的cookie中</p>
<h3 id="小程序"><a href="#小程序" class="headerlink" title="小程序"></a>小程序</h3><p>微信小程序通常使用openid作为设备ID，也可自己生产一个ID作为设备ID。</p>
<h2 id="用户ID"><a href="#用户ID" class="headerlink" title="用户ID"></a>用户ID</h2><p>用户ID：用户在业务产品注册的用户账号</p>
<h1 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h1><ul>
<li><strong>了解用户行为</strong><ul>
<li>用户的使用习惯</li>
<li>用户的决策路径</li>
<li>用户的注意力分布</li>
</ul>
</li>
<li><strong>掌握产品动向</strong><ul>
<li>产品用户量</li>
<li>产品所处的生命周期</li>
<li>目前的数据表现</li>
</ul>
</li>
<li><strong>支持产品决策</strong><ul>
<li>新功能的上线</li>
<li>旧功能的迭代优化</li>
</ul>
</li>
</ul>
<h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><ul>
<li>埋点方案的梳理要越早越好，并且与开发同步，以防止相关的埋点参数接口取不到</li>
<li>埋点一定要测试</li>
<li>埋点标识要唯一</li>
<li>埋点方案发生变动要及时同步到各方</li>
</ul>
<ul>
<li><strong>引</strong>：埋点代码是否引入，引入的代码是否与当前产品形态吻合</li>
<li><strong>埋</strong>：是否产品的所有模块都添加了埋点</li>
<li><strong>报</strong>：埋点之后数据是否能够正常上报</li>
<li><strong>落</strong>：上报的数据最后是否落到了对应的表里面</li>
</ul>
<h1 id="一些埋点管理系统"><a href="#一些埋点管理系统" class="headerlink" title="一些埋点管理系统"></a>一些埋点管理系统</h1><h2 id="网易HubbleData"><a href="#网易HubbleData" class="headerlink" title="网易HubbleData"></a>网易HubbleData</h2><p>网易HubbleData是一个洞察用户行为的数据分析系统，提供一套完整的数据解决方案。</p>
<p>平台工作流程：<br><figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">graph TB<span class="comment">;</span></span><br><span class="line">    数据采集---&gt;数据上报<span class="comment">;</span></span><br><span class="line">    数据上报---&gt;数据存储<span class="comment">;</span></span><br><span class="line">    数据存储---&gt;数据分析<span class="comment">;</span></span><br><span class="line">    数据分析---&gt;数据展示<span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<p>平台包括的应用有：</p>
<ul>
<li>事件分析</li>
<li>漏斗转化</li>
<li>用户路径分析</li>
<li>用户分群构建</li>
</ul>
<p>HubbleData平台用户分为两类：</p>
<ol>
<li><p>匿名用户：SDK内部自动依据某个算法生成的唯一id，且只生成一次，该id同时</p>
</li>
<li><p>真实用户</p>
</li>
</ol>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="http://www.woshipm.com/pd/3261924.html" target="_blank" rel="noopener">产品埋点答疑指南</a></li>
<li><a href="http://www.woshipm.com/data-analysis/3887258.html" target="_blank" rel="noopener">数据埋点：用户唯一标识</a></li>
<li><a href="http://www.woshipm.com/pmd/3523904.html" target="_blank" rel="noopener">从业务视角，分析埋点思路</a></li>
<li><a href="http://www.woshipm.com/data-analysis/3405281.html" target="_blank" rel="noopener">如何做好数据埋点？</a></li>
<li><a href="https://hubble.netease.com/help/_book/behaviorAnalysis/eventManagement.html" target="_blank" rel="noopener">HubbleData事件管理</a></li>
<li><a href="https://blog.csdn.net/ihaveahappyfamily/article/details/80071384" target="_blank" rel="noopener">网易HubbleData之web端js-sdk数据采集库讲解</a></li>
<li><a href="https://medium.com/@allaboutdataanalysis/%E4%B8%80%E9%80%B1%E6%95%B8%E6%93%9A%E5%9F%8B%E9%BB%9E%E4%B9%8B%E6%97%85-%E7%AC%AC%E4%B8%80%E5%A4%A9-%E5%88%9D%E8%AD%98%E5%9F%8B%E9%BB%9E-9c6a7b1c211" target="_blank" rel="noopener">一周数据埋点之旅</a></li>
<li><a href="https://www.jianshu.com/p/d45235b51601" target="_blank" rel="noopener">用户行为的深度追踪——事件与埋点</a></li>
</ul>
]]></content>
      <categories>
        <category>Data Scientist</category>
      </categories>
      <tags>
        <tag>Data Scientist</tag>
      </tags>
  </entry>
  <entry>
    <title>Data Scientist | 数据仓库</title>
    <url>/%E6%95%B0%E6%8D%AE-%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93.html</url>
    <content><![CDATA[<p><center>Data Warehouse</center><br><a id="more"></a></p>
<h1 id="数据仓库"><a href="#数据仓库" class="headerlink" title="数据仓库"></a>数据仓库</h1><p>数据仓库是为企业所有级别的决策指定计划过程，提供所有类型数据支持的战略集合。</p>
<blockquote>
<p>数据仓库是一个面向主题的（Subject Oriented）、集成的（Integrated）、相对稳定的（Non-Volatile）、反映历史变化（Time Variant）的数据集合，用于支持管理决策。</p>
</blockquote>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul>
<li><strong>主题性</strong>（Subject Oriented）<ul>
<li>数据仓库是针对某个主题来进行组织，可以将多种不同的数据源进行整合<blockquote>
<p>如：滴滴出行的司机行为分析就是一个主题</p>
</blockquote>
</li>
</ul>
</li>
<li><strong>集成性</strong><ul>
<li>数据仓库需要将多个数据源的数据存到一起，但是这些数据的存储方式可能不同，需要经过抽取、清洗、转换的过程实现数据集成</li>
</ul>
</li>
<li><strong>稳定性</strong><ul>
<li>保存的数据是一系列历史快照，不允许修改，只能用于分析</li>
</ul>
</li>
<li><strong>时变性</strong><ul>
<li>数据仓库会定期接收新的数据，反映出最新的数据变化</li>
</ul>
</li>
</ul>
<h1 id="数据仓库-vs-数据库"><a href="#数据仓库-vs-数据库" class="headerlink" title="数据仓库 vs 数据库"></a>数据仓库 vs 数据库</h1><ul>
<li><strong>数据库软件</strong>是一种软件，用来实现数据库逻辑过程，属于<u>物理层</u></li>
<li><strong>数据库</strong>是一种逻辑概念，用来存放数据，通过数据库软件实现</li>
<li><strong>数据仓库</strong>是数据库概念的升级。</li>
</ul>
<p>从逻辑上理解，数据库和数据仓库没有区别，都是通过数据库软件实现存放数据的地方。从数量上来说，数据仓库比数据库更加庞大。</p>
<ul>
<li>数据仓库主要用于数据挖掘和数据分析</li>
<li>数据仓库的表结构是依照分析需求、分析维度、分析指标进行设计的</li>
<li>数据库与数据仓库的区别实际是<strong>OLTP</strong>与<strong>OLAP</strong>的区别<ul>
<li>数据库：OLTP</li>
<li>数据仓库：OLAP</li>
</ul>
</li>
</ul>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: center;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: center;">
      <th>操作型处理</th>
      <th>分析型处理</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>OLTP</td>
      <td>OLAP</td>
    </tr>
    <tr>
      <td>On-Line Transaction Processing</td>
      <td>On-Line Analytical Processing</td>
    </tr>
    <tr>
      <td>细节的</td>
      <td>综合或提炼的</td>
    </tr>
    <tr>
      <td>实体-关系（E-R）模型</td>
      <td>星型或雪花模型</td>
    </tr>
    <tr>
      <td>存储瞬时数据</td>
      <td>存储历史数据，不包含最近的数据</td>
    </tr>
    <tr>
      <td>可更新的</td>
      <td>只读、只追加</td>
    </tr>
    <tr>
      <td>一次操作一个单元</td>
      <td>一次操作一个集合</td>
    </tr>
    <tr>
      <td>性能要求高，响应时间短</td>
      <td>性能要求宽松</td>
    </tr>
    <tr>
      <td>面向事务</td>
      <td>面向分析</td>
    </tr>
    <tr>
      <td>一次操作数据量小</td>
      <td>支持决策需求</td>
    </tr>
    <tr>
      <td>数据量小</td>
      <td>数据量大</td>
    </tr>
    <tr>
      <td>客户订单、库存水平和银行账户查询</td>
      <td>客户收益分析、市场细分</td>
    </tr>
    <tr>
  </tr></tbody>
</table>
</div>


<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://blog.csdn.net/maiduiyizu/article/details/80371410" target="_blank" rel="noopener">详解数据仓库和数据库的区别</a></li>
<li><a href="https://mp.weixin.qq.com/s/Gc-dv7Zq7pI1jT4Rz3YyhQ" target="_blank" rel="noopener">数据产品经理和产品经理的区别是什么？</a></li>
</ul>
]]></content>
      <categories>
        <category>Data Scientist</category>
      </categories>
      <tags>
        <tag>Data Scientist</tag>
      </tags>
  </entry>
  <entry>
    <title>Algorithm | 二叉排序树</title>
    <url>/Algo-%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91.html</url>
    <content><![CDATA[<p><center>Binary Sort Tree</center><br><a id="more"></a></p>
<h1 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a>二叉排序树</h1><p><strong>二叉排序树</strong>或者是<u>一棵空树</u>，或者是具有如下性质的二叉树：</p>
<ol>
<li>若它的左子树不为空，则左子树上所有结点的值均小于它的根结点的值；</li>
<li>如它的右子树不为空，则右子树上所有结点的值均大于它的根结点的值；</li>
<li>它的左、右子树分别为二叉排序树。</li>
</ol>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://www.cxyxiaowu.com/9956.html" target="_blank" rel="noopener">图解：什么是二叉排序树？</a></li>
</ul>
]]></content>
      <categories>
        <category>基础算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>Algorithm | 希尔排序</title>
    <url>/Algo-%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F.html</url>
    <content><![CDATA[<p><center>Shell's Sort</center><br><a id="more"></a></p>
<h1 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h1><p>Shell’s Sort是Donald Shell于1959年提出的一种排序算法。</p>
<ul>
<li>希尔排序是一种<strong>分组插入排序</strong></li>
<li>也称为<strong>缩小增量排序</strong></li>
<li>动态演示希尔排序：<a href="https://www.cs.usfca.edu/~galles/visualization/ComparisonSort.html" target="_blank" rel="noopener">Shell Sort</a></li>
</ul>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>先将整个待排序元素序列分割成若干个子序列（由相隔某个“增量”的元素组成的），分别进行直接插入排序；然后依次缩减增量再进行排序；待整个序列中的元素基本有序时，再对全体元素进行一次直接插入排序。</p>
<div class="note default">
            <p>例：对序列$\{55，26，33，80，70，90，6，30，40，20\}$进行增量为5的希尔排序。</p><ol><li>从55开始每隔5个距离取值分为1组，共分为5组，<br>分别为$\{55, 90\}\{26,6\}\{33,30\}\{80,40\}\{70,20\}$</li><li>组内进行排序：<script type="math/tex; mode=display">\{55, 90\}\{6,26\}\{30,33\}\{40,80\}\{20,70\}</script></li><li>然后增量取$5//2=2$，数据被分为2组<script type="math/tex; mode=display">\{55, 6,30,40,20\},\{90,26,33,80,70\}</script></li><li>组内进行直接插入排序：<script type="math/tex; mode=display">\{6,20,30,40,55\},\{26,33,70,80,90\}</script>即<script type="math/tex; mode=display">\{6,26,20,33,30,70,40,80,55,90\}</script></li><li>再缩小增量$2//2=1$，整个数组为1组<script type="math/tex; mode=display">\{6,20,26,30,33,40,55,70,80,90\}</script></li></ol>
          </div>
<h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><ul>
<li>最坏的情况：$O(n^2)$</li>
<li><ul>
<li>Hibbard优化后，最坏的实践复杂度为$O(n^{3/2})$</li>
</ul>
</li>
</ul>
<h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shell_sort</span><span class="params">(lst)</span>:</span></span><br><span class="line">    n = len(lst)  <span class="comment">## 序列长度</span></span><br><span class="line">    gap = n &gt;&gt; <span class="number">1</span>  <span class="comment">## n divided by 2**1</span></span><br><span class="line">    <span class="keyword">while</span> gap &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(gap, n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i, <span class="number">0</span>, -gap):</span><br><span class="line">                <span class="keyword">if</span> lst[j] &lt; lst[j-gap]:</span><br><span class="line">                    lst[j], lst[j-gap] = lst[j-gap], lst[j]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        gap &gt;&gt;= <span class="number">1</span>  <span class="comment">## 增量gap减半</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    lst = [<span class="number">10</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">1</span>, <span class="number">40</span>, <span class="number">30</span>, <span class="number">20</span>]</span><br><span class="line">    print(lst)</span><br><span class="line">    shell_sort(lst)</span><br><span class="line">    print(lst)</span><br><span class="line"><span class="comment"># [10, 4, 3, 1, 6, 20, 30, 1, 40, 30, 20]</span></span><br><span class="line"><span class="comment"># [1, 1, 3, 4, 6, 10, 20, 20, 30, 30, 40]</span></span><br></pre></td></tr></table></figure>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://www.cnblogs.com/chengxiao/p/6104371.html" target="_blank" rel="noopener">图解排序算法(二)之希尔排序</a></li>
<li><a href="https://blog.csdn.net/u012468376/article/details/78233124" target="_blank" rel="noopener">用python实现希尔排序(shell_sort)</a></li>
</ul>
]]></content>
      <categories>
        <category>基础算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title>数据分析 | SWOT分析模型</title>
    <url>/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90-SWOT%E5%88%86%E6%9E%90%E6%A8%A1%E5%9E%8B.html</url>
    <content><![CDATA[<p><center>Strength + Weakness + Opportunity + Threat</center><br><a id="more"></a></p>
<h1 id="SWOT"><a href="#SWOT" class="headerlink" title="SWOT"></a>SWOT</h1><p>该模型主要通过分析企业内部和外部存在的优势和劣势、机会和挑战来概括企业内外部研究结果。</p>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: center;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: center;">
      <th></th>
      <th>S 优势</th>
      <th>W 劣势</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>O 机会</th>
      <td>SO战略<br>发出优势、利用机会</td>
      <td>WO战略<br>利用机会、克服弱点</td>
    </tr>
    <tr>
      <th>T 威胁</th>
      <td>ST战略<br>利用优势、回避威胁</td>
      <td>WT战略<br>减小弱点、回避威胁</td>
    </tr>
    <tr>
  </tr></tbody>
</table>
</div>

<h2 id="Strength-优势"><a href="#Strength-优势" class="headerlink" title="Strength 优势"></a>Strength 优势</h2><p>比较分析企业在外部市场环境、内部经营方面相对于其他竞争对手的优势</p>
<h2 id="Weakness-劣势"><a href="#Weakness-劣势" class="headerlink" title="Weakness 劣势"></a>Weakness 劣势</h2><p>比较分析企业在外部市场环境、内部经营方面相对于其他竞争对手的劣势</p>
<h2 id="Opportunity-机会"><a href="#Opportunity-机会" class="headerlink" title="Opportunity 机会"></a>Opportunity 机会</h2><p>分析在目前的市场竞争态势下企业存在的发展机会</p>
<h2 id="Threat-挑战"><a href="#Threat-挑战" class="headerlink" title="Threat 挑战"></a>Threat 挑战</h2><p>分析在目前的市场竞争态势下企业存在的威胁和挑战</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzA3MTM3NTA5Ng==&amp;mid=2651064405&amp;idx=4&amp;sn=e184bfcdaae3415c72a303c07cf49710&amp;chksm=84de29c2b3a9a0d45c1129514c8e866d071565906cd8ff5bc4fad490dd99e46eccdb5b0e4bfc&amp;mpshare=1&amp;scene=24&amp;srcid=&amp;sharer_sharetime=1592998676149&amp;sharer_shareid=b539221659d6ecf12200314308b58dd3&amp;key=991a1e3dcd215fe847d45100526b4748f39cd5d44512bbe5b40c8748134b0321fe357ef131aa7e054ef920cf62e70f053bf4798983a5bf00ed16c50560c0f1f890115e1ed46b55478566b5b84df3f29d&amp;ascene=14&amp;uin=MjAwNDUzMjgxNw%3D%3D&amp;devicetype=Windows+10+x64&amp;version=62090529&amp;lang=zh_CN&amp;exportkey=AckfnRhoSp9TU3qV3hhKAMA%3D&amp;pass_ticket=ws7WEjys7meG8tQvR9%2BINrP5RKEp1Mus1mqNfeaPYCNHYnD2%2FhjK5ZF3mONasy7H" target="_blank" rel="noopener">10大经典数据分析模型，你知道几个？</a></li>
</ul>
]]></content>
      <categories>
        <category>数据分析</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
        <tag>业务向</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>数据分析 | 用户体验要素</title>
    <url>/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90-%E7%94%A8%E6%88%B7%E4%BD%93%E9%AA%8C%E8%A6%81%E7%B4%A0.html</url>
    <content><![CDATA[<center>《用户体验要素》学习笔记</center>
<a id="more"></a>






# 用户体验
**用户体验**是指产品如何于外界产生联系并发挥作用
- 企业关注的是财务营收——投资收到的回报（return on investment）或投资回报率（ROI）
- 一个最常用的投资收益的度量标准是**转化率**（conversion rate）
 - 常用来衡量用户体验的效果
- 任何在用户体验上所做的努力，目的都是为了提高效率
 - 帮助用户工作得更快
 - 减少用户犯错的几率

# 五个层面

**自下而上**地建设，从抽象到具体
<pre class="mermaid">graph BT;
    战略层 ---> 范围层;
    范围层 ---> 结构层;
    结构层 ---> 框架层;
    框架层 ---> 表现层</pre>

- 在“较高层面”中选择一个界限之外地选项，需要重新考虑“较低层面”中所做出地决策

## 战略层-产品目标和用户需求
strategy
网站的范围基本上是由网站战略层所决定的
- **产品目标**（product objectives）
 > 我们要通过这个产品得到什么？
- **用户需求**（user needs）
 > 我们的用户要通过这个产品得到什么？

<center>需要**明确**产品目标和用户需求</center>

<h3 id="产品目标"><a href="#产品目标" class="headerlink" title="产品目标"></a>产品目标</h3><ul>
<li>商业目标（business goals）、商业驱动因素（business drivers）<ul>
<li>替公司赚钱或替公司省钱</li>
</ul>
</li>
<li>品牌识别（brand identity）</li>
<li>成功标准（success metrics）：一些可追踪的指标，在产品上线后用来显示它是否满足了我们自己的目标和用户的需求</li>
</ul>
<h3 id="用户需求"><a href="#用户需求" class="headerlink" title="用户需求"></a>用户需求</h3><ol>
<li>用户是谁</li>
<li>用户的需求是什么</li>
</ol>
<h4 id="细分用户"><a href="#细分用户" class="headerlink" title="细分用户"></a>细分用户</h4><ul>
<li>通过<strong>用户细分</strong>（user segmentation）将大量的用户需求划分为几个可管理的部分<ul>
<li>每一群用户都是由具有某些共同关键特征的用户所组成</li>
</ul>
</li>
<li>创建细分用户群只是一种用于“揭示用户最终需求的手段”</li>
</ul>
<p>细分用户群的方法有很多：</p>
<ol>
<li>市场营销人员通常根据<strong>人口统计学</strong>（demographic）的标准来划分用户<br>性别、年龄、教育水平、婚姻状况、收入等</li>
<li><strong>消费心态档案</strong>（psychographic profile）用于描述用户对于世界，尤其是与我们的产品有关的某个事物的观点和看法的心理分析方法</li>
</ol>
<h4 id="可用性和用户研究"><a href="#可用性和用户研究" class="headerlink" title="可用性和用户研究"></a>可用性和用户研究</h4><p>用户研究（User Research）的<strong>研究工具</strong>：</p>
<ul>
<li>用于收集用户的普遍观点与感知：<ul>
<li>问卷调查</li>
<li>用户访谈</li>
<li>焦点小组</li>
</ul>
</li>
<li>用于理解具体的用户行为以及用户在和产品交互时的表现：<ul>
<li>用户测试</li>
<li>现场调查</li>
</ul>
</li>
</ul>
<p>问卷调查和焦点小组属于<strong>市场调研方法</strong>（market research methods），是获取用户的基本信息的宝贵来源。</p>
<p><strong>现场调查</strong>（contextual inquiry）：用于了解在日常生活情境中的用户行为。</p>
<ul>
<li>通常应用于一个较小的范围</li>
<li>缺点：耗时、费用高</li>
</ul>
<p><strong>用户测试</strong>（user testing）：请用户帮忙测试产品。有时用于测试一个已完成的网站，也可以用于测试改版效果，或用于在网站发布之前发现可用性的问题，也可测试一个正在建造中的网站，甚至是一个粗略的低保真原型。</p>
<h2 id="范围层-功能规格和内容需求"><a href="#范围层-功能规格和内容需求" class="headerlink" title="范围层-功能规格和内容需求"></a>范围层-功能规格和内容需求</h2><p>scope<br>结构层确定网站各种特性和功能最合适的组合方式，而这些特性和功能构成了网站的范围层</p>
<ul>
<li>把用户需求和产品目标转变成产品应该提供给用户什么样的内容和功能</li>
</ul>
<h2 id="表现层"><a href="#表现层" class="headerlink" title="表现层"></a>表现层</h2><p>surface<br>一系列网页，由图片和文字组成</p>
<h2 id="框架层"><a href="#框架层" class="headerlink" title="框架层"></a>框架层</h2><p>skeleton<br>按钮、控件、照片和文本区域的位置</p>
<ul>
<li>用于优化设计布局，以达到这些元素的最大效果和效率</li>
<li>框架层确定了在结账页面上交互元素的位置</li>
<li>框架层定义了导航条上各要素的排列方式，允许用户可以浏览不同的商品分类</li>
</ul>
<h2 id="结构层"><a href="#结构层" class="headerlink" title="结构层"></a>结构层</h2><p>structure</p>
<ul>
<li>框架是结构的具体表达方式</li>
<li>结构层用来设计用户如何到达某个页面，并且在他们做完事情之后能去什么地方</li>
<li>结构层确定哪些类别应该出现在哪里</li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href>用户体验要素：以用户为中心的产品设计</a></li>
</ul>
]]></content>
      <categories>
        <category>数据分析</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
      </tags>
  </entry>
  <entry>
    <title>HIVE学习笔记</title>
    <url>/HIVE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html</url>
    <content><![CDATA[<p><center></center><br><a id="more"></a></p>
<h1 id="HIVE"><a href="#HIVE" class="headerlink" title="HIVE"></a>HIVE</h1><ul>
<li>HIVE最适合于数据仓库应用程序</li>
<li>用户可以通过查询生成新表或将查询结果导入到文件中</li>
</ul>
<p><strong>HIVE不支持的</strong></p>
<ul>
<li>HIVE不是一个完整的数据库</li>
<li>HIVE不支持记录级别的更新、插入或删除操作</li>
<li>HIVE不支持事务</li>
<li>HIVE不支持OLTP(联机事务处理，Online Transaction Processing)所需的关键功能，而更接近成为一个OLAP（联机分析处理，Online Analytical Processing）工具</li>
<li>HiveQL不符合ANSI SQL标准，和Oracle、MySQL、SQL Server支持的常规SQL方言在很多方面存在差异<ul>
<li>HiveQL和MySQL提供的SQL方言最接近</li>
</ul>
</li>
</ul>
<h1 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h1><h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h2><div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: center;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: center;">
      <th>命名空间</th>
      <th>使用权限</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>hivevar</th>
      <td>可读、可写</td>
      <td>用户自定义变量（HIVE v0.8.0以上）</td>
    </tr>
    <tr>
      <th>hiveconf</th>
      <td>可读、可写</td>
      <td>Hive相关的配置属性</td>
    </tr>
    <tr>
      <th>system</th>
      <td>可读、可写</td>
      <td>Java定义的配置属性</td>
    </tr>
    <tr>
      <th>env</th>
      <td>只可读</td>
      <td>Shell环境定义的环境变量</td>
    </tr>
    <tr>
  </tr></tbody>
</table>
</div>

<ul>
<li>用户可以在查询中引用变量。Hive会先使用变量值替换掉查询的变量引用，然后才会将查询语句提交给查询处理器</li>
<li>和hivevar变量不同，用户必须使用 <code>system:</code>或<code>env:</code>前缀来指定系统属性和环境变量</li>
</ul>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: center;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: center;">
      <th>数据类型</th>
      <th>长度</th>
      <th>例子</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>TINYINT</th>
      <td>1字节、有符号整数</td>
      <td>20</td>
    </tr>
    <tr>
      <th>SMALINT</th>
      <td>2字节、有符号整数</td>
      <td>20</td>
    </tr>
    <tr>
      <th>INT</th>
      <td>4字节、有符号整数</td>
      <td>20</td>
    </tr>
    <tr>
      <th>BIGINT</th>
      <td>8字节、有符号整数</td>
      <td>20</td>
    </tr>
    <tr>
      <th>BOOLEAN</th>
      <td>布尔类型</td>
      <td>TRUE 或 FALSE</td>
    </tr>
    <tr>
      <th>FLOAT</th>
      <td>单精度浮点数</td>
      <td>3.14159625</td>
    </tr>
    <tr>
      <th>DOUBLE</th>
      <td>双精度浮点数</td>
      <td>3.14159625</td>
    </tr>
    <tr>
      <th>STRING</th>
      <td>字符序列；可以指定字符集<br>可以使用单引号或双引号</td>
      <td>'Hello, World!'<br>"print something"</td>
    </tr>
    <tr>
      <th>TIMESTAMP</th>
      <td>整数、浮点数、字符串</td>
      <td>1327882394（Unix新纪元秒）<br>
      1327882394.123456789（Unix新纪元秒+纳秒数）<br>
      '2012-02-03 12:34:56.123456789'（JDBC所兼容的java.sql.Timestamp时间格式）</td>
    </tr>
    <tr>
        <th>BINARY</th>
        <td>字节数组</td>
        <td></td>
    </tr>
    <tr>
  </tr></tbody>
</table>
</div>

<h3 id="INT"><a href="#INT" class="headerlink" title="INT"></a>INT</h3><p><code>CAST(s AS INT)</code><br>将一个字符串的列转换为整型</p>
<h3 id="TIMESTAMP"><a href="#TIMESTAMP" class="headerlink" title="TIMESTAMP"></a>TIMESTAMP</h3><p>数据类型<code>TIMESTAMP</code>的值可以是整数，也可以是浮点数，也可以是字符串</p>
<ul>
<li>整数：距离UNIX新纪元时间（1970年1月1日午夜12点）的秒数</li>
<li>浮点数：距离UNIX新纪元时间（1970年1月1日午夜12点）的秒数，精确到纳秒（小数点后保留9位小数）</li>
<li>字符串：JDBC约定的时间字符串格式 <code>YYYY-MM-DD hh:mm:ss.fffffffff</code></li>
</ul>
<h3 id="TIMESTAMPS"><a href="#TIMESTAMPS" class="headerlink" title="TIMESTAMPS"></a>TIMESTAMPS</h3><p><code>TIMESTAMPS</code>表示的是UTC时间。</p>
<h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><p>如果用户在查询中将一种整型类型的值和另一种整型类型的值作对比，则HIVE会隐式地将类型转换未两个整型类型中值较大的那个类型。</p>
<ul>
<li>如果用户在查询中将一个FLOAT类型的列与一个DOUBLE类型的列作对比，则HIVE会隐式地将FLOAT类型转换为DOUBLE类型然后进行比较。<ul>
<li>FLOAT类型的0.2实际是0.2000001，而DOUBLE类型的0.2是0.200000000001</li>
<li>在对数据进行比较时，可使用<code>CAST(data AS FLOAT)</code>指定数据类型，再进行比较，防止出错</li>
<li>与钱相关的数都避免使用浮点数</li>
</ul>
</li>
</ul>
<h2 id="集合数据类型"><a href="#集合数据类型" class="headerlink" title="集合数据类型"></a>集合数据类型</h2><h3 id="ARRAY"><a href="#ARRAY" class="headerlink" title="ARRAY"></a>ARRAY</h3><p>一组具有相同类型和名称的变量的集合。</p>
<ul>
<li>元素：这些变量称为数组的元素</li>
<li>每个数组元素都有一个编号，编号从0开始</li>
<li>应用一个不存在的元素将会返回NULL</li>
<li>提取出来的STRING数据类型的值不再加引号</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">Array('John', 'Doe')</span><br></pre></td></tr></table></figure>
<p>其中<code>&#39;Doe&#39;</code>的应用应为<code>数组名[1]</code>。</p>
<h3 id="MAP"><a href="#MAP" class="headerlink" title="MAP"></a>MAP</h3><ul>
<li>MAP是一组键值对元组集合，使用数组表示法访问元素（使用键值索引而不是整数索引）</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">map('first', 'John', 'last', 'Doe')</span><br></pre></td></tr></table></figure>
<p>键-&gt;值对的对应关系如：</p>
<ul>
<li>‘first’ -&gt; ‘Jhon’</li>
<li><p>‘last’ -&gt; ‘Doe’<br>通过<code>字段名[&#39;last&#39;]</code>可以获取元素<code>&#39;Doe&#39;</code></p>
</li>
<li><p>HIVE中并没有键的概念（？？），但是用户可以对表建立索引</p>
</li>
</ul>
<h3 id="STRUCT"><a href="#STRUCT" class="headerlink" title="STRUCT"></a>STRUCT</h3><p>和C语言中的struct或者“对象”类似，都可以通过“点”符号访问元素内容</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> employees(</span><br><span class="line">  <span class="keyword">name</span> <span class="keyword">STRING</span>,</span><br><span class="line">  salary <span class="built_in">FLOAT</span>,</span><br><span class="line">  subordinates <span class="built_in">ARRAY</span>&lt;<span class="keyword">STRING</span>&gt;,</span><br><span class="line">  deductions <span class="keyword">MAP</span>&lt;<span class="keyword">STRING</span>, <span class="built_in">FLOAT</span>&gt;,</span><br><span class="line">  address <span class="keyword">STRUCT</span>&lt;street: <span class="keyword">STRING</span>, city: <span class="keyword">STRING</span>, state: <span class="keyword">STRING</span>, zip: <span class="built_in">INT</span>&gt;</span><br><span class="line">);</span><br><span class="line"><span class="comment">-- 若要访问address中的city字段，则应 address.city</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">'store'</span>: &#123;</span><br><span class="line">    <span class="string">'fruit'</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="string">'weight'</span>: <span class="number">8</span>,</span><br><span class="line">        <span class="string">'type'</span>: <span class="string">'apple'</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="string">'weight'</span>: <span class="number">9</span>,</span><br><span class="line">        <span class="string">'type'</span>: <span class="string">'pear'</span></span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">'bicycle'</span>: &#123;</span><br><span class="line">      <span class="string">'price'</span>: <span class="number">19.95</span>,</span><br><span class="line">      <span class="string">'color'</span>: <span class="string">'red'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">'email'</span>: <span class="string">'12345678@163.com'</span>,</span><br><span class="line">  <span class="string">'owner'</span>: <span class="string">'Jack'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假设上述JSON数据存储在字段s中，则若要读取<code>apple</code>的<code>weight</code>，则应<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">GET_JSON_OBJECT(s, '$.store.fruit[0].weight')</span><br><span class="line"><span class="comment">-- 返回 8</span></span><br></pre></td></tr></table></figure></p>
<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><ul>
<li>可以使用正则表达式来选择想要的列：<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 从stocks表中选择symbol列和所有列名以price作为前缀的列</span></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">  symbol</span><br><span class="line">  , <span class="string">`price.*`</span>  <span class="comment">-- 注意是反引号，不是普通的单引号</span></span><br><span class="line"><span class="keyword">FROM</span> stocks;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="字段分隔符"><a href="#字段分隔符" class="headerlink" title="字段分隔符"></a>字段分隔符</h2><p>70页</p>
<h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><ul>
<li>如果没有显式指定数据库，则会使用默认的数据库default</li>
</ul>
<h2 id="表"><a href="#表" class="headerlink" title="表"></a>表</h2><p>HIVE中的表分为两种：</p>
<ol>
<li>管理表，也称内部表</li>
<li>外部表</li>
</ol>
<ul>
<li>用户可在<code>DESCRIBE EXTENDED table_name</code>语句的输出中查看到该表的类型（管理表MANAGED_TABLE，外部表EXTERNAL_TABLE）</li>
<li>Hive没有临时表的概念</li>
</ul>
<h3 id="管理表"><a href="#管理表" class="headerlink" title="管理表"></a>管理表</h3><ul>
<li>Hive默认将管理表的数据存储在由配置项<code>hive.metastore.warehouse.dir</code>所定义的目录的子目录下</li>
<li>删除一个管理表时，会删除这个表中的数据</li>
<li>管理表不方便和其他工作共享数据</li>
<li>对于管理表，用户可以对一张存在的表进行表结构复制（仅复制表结构，不复制数据）</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">EXTERNAL</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> db_name.table_name_1</span><br><span class="line"><span class="keyword">LIKE</span> db_name.table_name_2</span><br><span class="line">LOCATION <span class="string">'/path/to.data'</span>;</span><br></pre></td></tr></table></figure>
<p>其中，</p>
<ul>
<li>如果<code>EXTERNAL</code>关键词省略且源表是外部表，则生成的新表也为外部表</li>
<li>如果<code>EXTERNAL</code>关键词省略且源表是管理表，则生成的新表也为管理表</li>
<li>如果有<code>EXTERNAL</code>关键词而源表是管理表，则生成的新表为外部表</li>
</ul>
<h3 id="外部表"><a href="#外部表" class="headerlink" title="外部表"></a>外部表</h3><ul>
<li>删除外部表，并不会删除掉该份数据，但是描述表的元数据信息会被删除掉</li>
<li>有些HiveQL语法结构并不适用于外部表</li>
</ul>
<h3 id="分区表"><a href="#分区表" class="headerlink" title="分区表"></a>分区表</h3><ul>
<li>在WHERE子句中增加谓词来按照分区值进行过滤时，这些谓词被称为<strong>分区过滤器</strong></li>
<li>内部表、外部表都可以使用分区</li>
</ul>
<h2 id="存储格式"><a href="#存储格式" class="headerlink" title="存储格式"></a>存储格式</h2><ul>
<li>Hive的默认存储格式是：文本文件格式<ul>
<li>这个可以通过可选的子句 <code>STORED AS TEXTFILE</code>显式指定</li>
<li>也可以在创建表时指定各种各样的分隔符</li>
</ul>
</li>
<li>除了TEXTFILE, SEQUENCEFILE, RCFILE外，用户还可以指定第三方的输入和输出格式以及SerDe——允许用户自定义Hive本身不支持的其他广泛的文件格式</li>
</ul>
<h3 id="TEXTFILE"><a href="#TEXTFILE" class="headerlink" title="TEXTFILE"></a>TEXTFILE</h3><ul>
<li>Hive的默认存储格式</li>
</ul>
<h3 id="SEQUENCEFILE"><a href="#SEQUENCEFILE" class="headerlink" title="SEQUENCEFILE"></a>SEQUENCEFILE</h3><ul>
<li>SEQUENCEFILE和RCFILE都是使用二进制编码和压缩（可选）来优化磁盘空间使用及I/O带宽性能的</li>
</ul>
<h3 id="RCFILE"><a href="#RCFILE" class="headerlink" title="RCFILE"></a>RCFILE</h3><h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><h2 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h2><ul>
<li>Hive支持所有典型的算术运算符</li>
<li>如果数据类型不同，则两种类型中值范围较小的那个数据类型将转换为其他范围更广的数据类型</li>
<li>Hive遵循的是底层Java中数据类型的规则，当数据溢出或下溢发生时，计算结果不会自动转换为更广泛的数据类型</li>
</ul>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: center;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: center;">
      <th>运算符</th>
      <th>类型</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>A+B</th>
      <td>数值</td>
      <td>A和B相加</td>
    </tr>
    <tr>
      <th>A-B</th>
      <td>数值</td>
      <td>A减去B</td>
    </tr>
    <tr>
      <th>A * B</th>
      <td>数值</td>
      <td>A和B相乘</td>
    </tr>
    <tr>
      <th>A/B</th>
      <td>数值</td>
      <td>A除以B<br>如果能整除，则返回商数（商数是一个整数）</td>
    </tr>
    <tr>
      <th>A%B</th>
      <td>数值</td>
      <td>A除以B的余数</td>
    </tr>
    <tr>
      <th>A&B</th>
      <td>数值</td>
      <td>A和B按位取与</td>
    </tr>
    <tr>
      <th>A|B</th>
      <td>数值</td>
      <td>A和B按位取或</td>
    </tr>
    <tr>
      <th>A^B</th>
      <td>数值</td>
      <td>A和B按位取亦或</td>
    </tr>
    <tr>
      <th>~A</th>
      <td>数值</td>
      <td>A按位取反</td>
    </tr>
    <tr>
  </tr></tbody>
</table>
</div>


<h2 id="谓词操作符"><a href="#谓词操作符" class="headerlink" title="谓词操作符"></a>谓词操作符</h2><ul>
<li>可用于<code>JOIN ... ON</code>和<code>HAVING</code>语句中</li>
</ul>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: center;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: center;">
      <th>操作符</th>
      <th>支持的数据类型</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>A = B</th>
      <td>基本数据类型</td>
      <td>如果A等于，则返回true；<br>否则，返回false</td>
    </tr>
    <tr>
      <th>A <> B 或 A != B</th>
      <td>基本数据类型</td>
      <td>A或B为NULL，则返回NULL；<br>如果A不等于B，则返回true；<br>否则，返回false</td>
    </tr>
    <tr>
      <th>A < B</th>
      <td>基本数据类型</td>
      <td>A或B为NULL，则返回NULL；<br>如果A小于B，则返回true；<br>否则，返回false</td>
    </tr>
    <tr>
      <th>A <= b< th>
      <td>基本数据类型</td>
      <td>A或B为NULL，则返回NULL；<br>如果A小于或等于B，则返回true；<br>否则，返回false</td>
    </=></th></tr>
    <tr>
      <th>A > B</th>
      <td>基本数据类型</td>
      <td>A或B为NULL，则返回NULL；<br>如果A大于B，则返回true；<br>否则，返回false</td>
    </tr>
    <tr>
      <th>A >= B</th>
      <td>基本数据类型</td>
      <td>A或B为NULL，则返回NULL；<br>如果A大于或等于B，则返回true；<br>否则，返回false</td>
    </tr>
    <tr>
      <th>A [NOT] BETWEEN B AND C</th>
      <td>基本数据类型</td>
      <td>如果A、B、C任一为NULL，则返回NULL；<br>如果A的值大于或等于B且小于或等于C，则返回true；<br>否则，返回false。<br>NOT关键字取反效果</td>
    </tr>
    <tr>
      <th>A IS NULL</th>
      <td>所有数据类型</td>
      <td>如果A等于NULL，则返回true;<br>否则，返回false</td>
    </tr>
    <tr>
      <th>A IS NOT NULL</th>
      <td>所有数据类型</td>
      <td>如果A不等于NULL，则返回true；<br>否则，返回false</td>
    </tr>
    <tr>
      <th>A [NOT] LIKE B</th>
      <td>STRING类型</td>
      <td>B是一个正则表达式。
      <br>如果A与正则表达式B匹配，则返回true；<br>否则，返回false。<br>NOT关键字取反效果</td>
    </tr>
    <tr>
      <th>A RLIKE B<br>A REGEXP B</th>
      <td>STRING类型</td>
      <td>B是一个正则表达式。<br>如果A与正则表达式B匹配，则返回true；<br>否则，返回false。<br>匹配使用的是JDK中的正则表达式实现，正则规则应该依据JDK的正则规则。</td>
    </tr>
    <tr>
  </tr></tbody>
</table>
</div>


<h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><h2 id="S"><a href="#S" class="headerlink" title="-S"></a>-S</h2><p>开启静默模式，可将输出结果中的<code>OK</code>和<code>Time taken</code>等行以及其他一些无关紧要的输出信息</p>
<h2 id="alter"><a href="#alter" class="headerlink" title="alter"></a>alter</h2><p>大多数的表属性可以通过<code>ALTER TABLE</code>语句进行修改。</p>
<ul>
<li><code>ALTER TABLE</code>会修改元数据，但不会修改数据本身</li>
</ul>
<h3 id="重命名表"><a href="#重命名表" class="headerlink" title="重命名表"></a>重命名表</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_old_name <span class="keyword">RENAME</span> <span class="keyword">TO</span> table_new_name;</span><br></pre></td></tr></table></figure>
<h3 id="增加表分区"><a href="#增加表分区" class="headerlink" title="增加表分区"></a>增加表分区</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 增加表分区</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">ADD</span> <span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span></span><br><span class="line"><span class="keyword">PARTITION</span> (<span class="keyword">year</span>=<span class="number">2020</span>, <span class="keyword">month</span>=<span class="number">7</span>, <span class="keyword">day</span>=<span class="number">15</span>) LOCATION <span class="string">'/logs/2020/07/15'</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>HIVE v0.8.0及以上版本，可在同一个查询中同时增加多个分区。</li>
</ul>
<h3 id="修改表分区"><a href="#修改表分区" class="headerlink" title="修改表分区"></a>修改表分区</h3><p>修改某个分区的路径：<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">PARTITION</span>(<span class="keyword">year</span>=<span class="number">2020</span>, <span class="keyword">month</span>=<span class="number">7</span>, <span class="keyword">day</span>=<span class="number">15</span>) <span class="keyword">SET</span> LOCATION <span class="string">'s3n://ourbucket/logs/2020/07/15'</span>;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>该命令不会将数据从旧的路径转移走，也不会删除旧的数据</li>
</ul>
<h3 id="删除表分区"><a href="#删除表分区" class="headerlink" title="删除表分区"></a>删除表分区</h3><p>删除某个表分区：<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">DROP</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> <span class="keyword">PARTITION</span>(<span class="keyword">year</span>=<span class="number">2020</span>, <span class="keyword">month</span>=<span class="number">7</span>, <span class="keyword">day</span>=<span class="number">15</span>);</span><br></pre></td></tr></table></figure></p>
<ul>
<li>对于管理表，即使是使用<code>ALTER TABLE ... ADD PARTITION</code>语句增加的分区，分区内的数据也会同时和元数据信息一起被删除</li>
<li>对于外部表，分区内数据不会被删除</li>
</ul>
<h3 id="修改表属性"><a href="#修改表属性" class="headerlink" title="修改表属性"></a>修改表属性</h3><p><code>SET TBLPROPERTIES</code></p>
<ul>
<li>用户可以增加附加的表属性或修改已经存在的属性</li>
<li>但用户无法删除属性</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">SET</span> TBLPROPERTIES (</span><br><span class="line">  <span class="string">'notes'</span> = <span class="string">'The process id is no longer captured; this column is always NULL'</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h3 id="修改列"><a href="#修改列" class="headerlink" title="修改列"></a>修改列</h3><p><code>CHANGE COLUMN</code></p>
<p>对某个字段进行重命名，修改其位置、类型或注释：<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name</span><br><span class="line"><span class="keyword">CHANGE</span> <span class="keyword">COLUMN</span> old_col_name new_col_name <span class="built_in">INT</span>  <span class="comment">-- 重命名old_col_name为new_col_name，且数据类型为INT</span></span><br><span class="line"><span class="keyword">COMMENT</span> <span class="string">'Comment for Column new_col_name'</span>  <span class="comment">-- 修改该列的注释</span></span><br><span class="line"><span class="keyword">AFTER</span> another_column;  <span class="comment">-- 将new_col_name的位置修改到another_column列的后面</span></span><br></pre></td></tr></table></figure></p>
<h3 id="增加列"><a href="#增加列" class="headerlink" title="增加列"></a>增加列</h3><p><code>ADD COLUMNS</code></p>
<p>在分区字段之前增加新的字段到已有的字段后：<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">ADD</span> <span class="keyword">COLUMNS</span> (</span><br><span class="line">  col_name_1 <span class="keyword">STRING</span> <span class="keyword">COMMENT</span> <span class="string">'Application name'</span>,</span><br><span class="line">  col_name_2 <span class="keyword">LONG</span> <span class="keyword">COMMENT</span> <span class="string">'The current session id'</span></span><br><span class="line">);</span><br><span class="line"><span class="comment">-- 其中 COMMENT 子句是可选的</span></span><br></pre></td></tr></table></figure></p>
<h3 id="删除-替换列"><a href="#删除-替换列" class="headerlink" title="删除/替换列"></a>删除/替换列</h3><p><code>REPLACE COLUMNS</code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">REPLACE</span> <span class="keyword">COLUMNS</span> (</span><br><span class="line">  col_name_1  <span class="built_in">INT</span>     <span class="keyword">COMMENT</span> <span class="string">'comment 1'</span>,</span><br><span class="line">  col_name_2  <span class="keyword">STRING</span>  <span class="keyword">COMMENT</span> <span class="string">'comment 2'</span>,</span><br><span class="line">  col_name_3  <span class="keyword">STRING</span>  <span class="keyword">COMMENT</span> <span class="string">'comment 3'</span></span><br><span class="line">);</span><br><span class="line"><span class="comment">-- 以上语句移除了表table_name的所有字段并重新制定了以上3个新的字段</span></span><br><span class="line"><span class="comment">-- 只有表的元数据信息改变了</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>REPLACE</code>语句只能用于使用了如下两种内置SerDe模块的表：<ul>
<li>DynamicSerDe</li>
<li>MetadataTypedColumnsetSerDe</li>
</ul>
</li>
</ul>
<h3 id="修改存储属性"><a href="#修改存储属性" class="headerlink" title="修改存储属性"></a>修改存储属性</h3><p><code>SET FILEFORMAT</code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name</span><br><span class="line"><span class="keyword">PARTITION</span> (<span class="keyword">year</span>=<span class="number">2020</span>, <span class="keyword">month</span>=<span class="number">7</span>, <span class="keyword">day</span>=<span class="number">15</span>)</span><br><span class="line"><span class="keyword">SET</span> FILEFORMAT SEQUENCEFILE;</span><br><span class="line"><span class="comment">-- 将存储格式修改为SEQUENCEFILE</span></span><br></pre></td></tr></table></figure>
<h3 id="修改SerDe属性"><a href="#修改SerDe属性" class="headerlink" title="修改SerDe属性"></a>修改SerDe属性</h3><p>用户可以指定一个新的SerDe，并为其指定SerDe属性，或修改已存在的SerDe的属性</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_using_JSON_storage</span><br><span class="line"><span class="keyword">SET</span> SERDE <span class="string">'com.example.JSONSerDe'</span></span><br><span class="line"><span class="keyword">WITH</span> SERDEPROPERTIES (</span><br><span class="line">  <span class="string">'prop1'</span> = <span class="string">'value1'</span>,</span><br><span class="line">  <span class="string">'prop2'</span> = <span class="string">'value2'</span></span><br><span class="line">);</span><br><span class="line"><span class="comment">-- 使用一个名为com.example.JSONSerDe的Java类来处理记录使用JSON编码的文件</span></span><br><span class="line"><span class="comment">-- SERDEPROPERTIES中的属性会被传递给SerDe模块（即com.example.JSONSerDe这个Java类）</span></span><br><span class="line"><span class="comment">-- 属性名和属性值都应当是带引号的字符串</span></span><br></pre></td></tr></table></figure>
<p>向已经存在着的SerDe增加新的SERDEPROPERTIES属性：<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_using_JSON_storage</span><br><span class="line"><span class="keyword">SET</span> SERDEPROPERTIES (</span><br><span class="line">  <span class="string">'prop3'</span> = <span class="string">'value3'</span>,</span><br><span class="line">  <span class="string">'prop4'</span> = <span class="string">'value4'</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<h2 id="as"><a href="#as" class="headerlink" title="as"></a>as</h2><p>给列起别名，或给中间表起别名</p>
<h2 id="case…when…then"><a href="#case…when…then" class="headerlink" title="case…when…then"></a>case…when…then</h2><p><code>CASE ... WHEN ... THEN</code>语句与if条件语句类似，用于处理单个列的查询结果<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">  <span class="keyword">name</span>,</span><br><span class="line">  salary,</span><br><span class="line">  <span class="keyword">CASE</span></span><br><span class="line">    <span class="keyword">WHEN</span> salary &lt; <span class="number">50000.0</span> <span class="keyword">THEN</span> <span class="string">'low'</span></span><br><span class="line">    <span class="keyword">WHEN</span> salary &gt;= <span class="number">50000.0</span> <span class="keyword">AND</span> salary &lt; <span class="number">70000.0</span> <span class="keyword">THEN</span> <span class="string">'middle'</span></span><br><span class="line">    <span class="keyword">WHEN</span> salary &gt;= <span class="number">70000.0</span> <span class="keyword">AND</span> salary &lt; <span class="number">100000.0</span> <span class="keyword">THEN</span> <span class="string">'high'</span></span><br><span class="line">    <span class="keyword">ELSE</span> <span class="string">'very high'</span></span><br><span class="line">  <span class="keyword">END</span> <span class="keyword">AS</span> bracket</span><br><span class="line"><span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure></p>
<h2 id="cluster-by"><a href="#cluster-by" class="headerlink" title="cluster by"></a>cluster by</h2><ul>
<li><code>CLUSTER BY</code>语句剥夺了<code>SORT BY</code>的并行性，可以实现输出文件的数据是全局排序的</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> s.ymd, s.symbol, s.price_close</span><br><span class="line"><span class="keyword">FROM</span> stocks s</span><br><span class="line"><span class="keyword">DISTRIBUTE</span> <span class="keyword">BY</span> s.symbol</span><br><span class="line"><span class="keyword">SORT</span> <span class="keyword">BY</span> s.symbol;</span><br><span class="line"><span class="comment">-- 等价于</span></span><br><span class="line"><span class="keyword">SELECT</span> s.ymd, s.symbol, s.price_close</span><br><span class="line"><span class="keyword">FROM</span> stocks s</span><br><span class="line">CLUSTER <span class="keyword">BY</span> s.symbol;</span><br></pre></td></tr></table></figure>
<h2 id="comment"><a href="#comment" class="headerlink" title="comment"></a>comment</h2><p>添加描述信息(备注).</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> db_name_1</span><br><span class="line"><span class="keyword">COMMENT</span> <span class="string">'Some comments for database db_name_1.'</span>;</span><br><span class="line"><span class="comment">-- 在创建数据库时添加备注，方便后续他人查看数据库的说明</span></span><br></pre></td></tr></table></figure>
<h2 id="create"><a href="#create" class="headerlink" title="create"></a>create</h2><h3 id="create-database"><a href="#create-database" class="headerlink" title="create database"></a>create database</h3><p>创建数据库：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATEABASE db_name;</span><br><span class="line"><span class="comment">-- 如果该数据库db_name已存在，则会报错</span></span><br><span class="line"><span class="comment">-- 避免报错：</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> <span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> db_name;</span><br></pre></td></tr></table></figure>
<h3 id="create-table"><a href="#create-table" class="headerlink" title="create table"></a>create table</h3><ul>
<li>默认情况下，HIVE总是将创建的表的目录放置在这个表所属的数据库目录之后</li>
<li>但default库在<code>/user/hive/warehouse</code>下没有对应一个数据库目录，default库中的表目录会直接位于<code>/user/hive/warehouse</code>目录之后（除了用户明确指定为其他路径）</li>
</ul>
<p>在创建表时，可以直接拷贝一张已经存在的表的表模式：<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> db_name_1.tbl_2</span><br><span class="line"><span class="keyword">LIKE</span> db_name_1.tbl_1;</span><br></pre></td></tr></table></figure></p>
<h2 id="describe"><a href="#describe" class="headerlink" title="describe"></a>describe</h2><ul>
<li>查看数据库的描述信息：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DESCRIBE</span> <span class="keyword">DATABASE</span> db_name_1;</span><br><span class="line"><span class="comment">-- 则会返回：</span></span><br><span class="line"><span class="comment">-- Some comments for database db_name_1.</span></span><br><span class="line"><span class="comment">-- 以及数据库所在的文件目录位置路径</span></span><br></pre></td></tr></table></figure>
<ul>
<li>查看某一列的信息：<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DESCRIBE</span> db_name.table_name.col_name;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="extended"><a href="#extended" class="headerlink" title="extended"></a>extended</h3><p>用户可以为数据库增加一些和其相关的键值对属性信息，通过下列语句可以显示出这些信息：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建数据库时增加一些和其相关的键值对属性信息</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> db_name_1</span><br><span class="line"><span class="keyword">WITH</span> DBPROPERTIES (<span class="string">'creator'</span> = <span class="string">'Mark Moneybags'</span>, <span class="string">'date'</span> = <span class="string">'2020-07-12'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 显示那些信息</span></span><br><span class="line"><span class="keyword">DESCRIBE</span> <span class="keyword">DATABASE</span> <span class="keyword">EXTENDED</span> db_name_1;</span><br><span class="line">db_name_1 hdfs://master-server/user/hive/warehouse/db_name_1.db</span><br><span class="line">&#123;date=2020-07-12, creator=Mark Moneybags&#125;;</span><br></pre></td></tr></table></figure>
<p><code>DESRIBE EXTENDED table_name</code>也会显示出分区键。</p>
<h3 id="formatted"><a href="#formatted" class="headerlink" title="formatted"></a>formatted</h3><p>显示数据库的信息，输出内容详细且可读性强</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DESCRIBE</span> <span class="keyword">DATABASE</span> FORMATTED db_name_1;</span><br></pre></td></tr></table></figure>
<h2 id="distinct"><a href="#distinct" class="headerlink" title="distinct"></a>distinct</h2><ul>
<li>在Hive中可以实现<strong>去重</strong>的命令：<ul>
<li><code>DISTINCT</code></li>
<li><code>GROUP BY</code></li>
<li><code>ROW_NUMBER</code>：排序后再取topN</li>
</ul>
</li>
</ul>
<h2 id="distribute-by"><a href="#distribute-by" class="headerlink" title="distribute by"></a>distribute by</h2><p><code>DISTRIBUTE BY</code>控制map的输出在reducer中是如何划分的</p>
<ul>
<li>默认情况下，MapReduce计算框架会依据map输入的键计算相应的哈希值，然后按照得到的哈希值将键-值对均匀分发到多个reducer中去</li>
<li>Hive要求<code>DISTRIBUTE BY</code>语句要写在<code>SORT BY</code>语句之前</li>
<li><code>DISTRIBUTE BY ... SORT BY</code>语句剥夺了<code>SORT BY</code>的并行性，可以实现输出文件的数据是全局排序的</li>
</ul>
<h2 id="drop"><a href="#drop" class="headerlink" title="drop"></a>drop</h2><p>删除数据库：<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">DATABASE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> db_name_1;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>HIVE不允许用户删除一个包含表的数据库<ul>
<li>或，先删除数据库中的表，再删除数据库</li>
<li>或，在删除命令的最后加上关键字<code>CASCADE</code>——可以使HIVE自行先删除数据库中的表</li>
</ul>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">DATABASE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> db_name_1 <span class="keyword">CASCADE</span>;</span><br></pre></td></tr></table></figure>
<p>删除数据表:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> table_name;</span><br></pre></td></tr></table></figure>
<ul>
<li>若删除管理表，则表的元数据信息和表内的数据都会被删除。</li>
<li>若删除外部表，则表的元数据信息会被删除，但是表中的数据不会被删除。</li>
<li>如果用户开启了Hadoop回收站功能（默认是关闭的），则数据将会被转移到用户在分布式文件系统中的用户根目录下的.Trash目录（即HDFS中的<code>/user/$USER/.Trash</code>目录）<ul>
<li>开启该功能，只需将配置属性<code>fs.trash.interval</code>的值（单位为分钟）设置为一个合理的正整数即可</li>
</ul>
</li>
</ul>
<h2 id="group-by"><a href="#group-by" class="headerlink" title="group by"></a>group by</h2><p>通常与聚合函数一起使用，按照一个或多个列对结果进行分组，然后对每个组进行聚合操作。</p>
<h2 id="having"><a href="#having" class="headerlink" title="having"></a>having</h2><p>对<code>GROUP BY</code>语句产生的分组进行条件过滤</p>
<h2 id="join"><a href="#join" class="headerlink" title="join"></a>join</h2><ul>
<li>大多数情况下，Hive会对每对JOIN连接对象启动一个MapReduce任务</li>
<li>Hive总是按照从左到右的顺序连接表</li>
<li>对3个或者更多个表进行JOIN连接时，如果每个ON子句都使用相同的连接键，则只会产生一个MapReduce任务</li>
<li>为了优化HiveQL执行性能，应保证连续查询中的表的大小从左到右是依次增加的</li>
</ul>
<h3 id="on"><a href="#on" class="headerlink" title="on"></a>on</h3><p><code>ON</code>子句指定两个表之间数据进行连接的条件</p>
<ul>
<li>标准SQL支持对连接关键词进行非等值连接</li>
<li>Hive不支持连接关键词非等值连接</li>
<li>Hive不支持在<code>ON</code>子句中使用<code>OR</code>谓词</li>
</ul>
<h3 id="inner-join"><a href="#inner-join" class="headerlink" title="inner join"></a>inner join</h3><p>只有进行连接的两个表中都存在与连接标准相匹配的数据才会被保留下来。</p>
<h3 id="left-join"><a href="#left-join" class="headerlink" title="left join"></a>left join</h3><p>左表中符合WHERE子句中的所有记录将会被返回；JOIN操作符右边表中如果没有符合ON后面连接条件的记录时，则从右边表指定选择的列的值将会是NULL</p>
<h3 id="outer-join"><a href="#outer-join" class="headerlink" title="outer join"></a>outer join</h3><p>外连接</p>
<ul>
<li>外连接会忽略掉分区过滤条件</li>
</ul>
<h3 id="right-outer-join"><a href="#right-outer-join" class="headerlink" title="right outer join"></a>right outer join</h3><p>右外连接，会返回右边表中符合WHERE语句的记录；左表中匹配不上的字段值用NULL代替</p>
<h3 id="full-outer-join"><a href="#full-outer-join" class="headerlink" title="full outer join"></a>full outer join</h3><p>完全外连接，将会返回所有表中符合WHERE语句条件的所有记录；如果任一表的指定字段没有符合条件的值的话，则使用NULL值替代</p>
<h3 id="left-semi-join"><a href="#left-semi-join" class="headerlink" title="left semi join"></a>left semi join</h3><p>左半开连接，返回左边表的记录且这些记录对于右边表满足ON语句中的判定条件。</p>
<ul>
<li><code>SELECT</code>和<code>WHERE</code>语句中不能引用到右边表中的字段</li>
<li>Hive不支持右半开连接<code>RIGHT SEMI JOIN</code></li>
<li><code>SEMI-JOIN</code>通常比<code>INNER JOIN</code>高效</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- SQL支持，但Hive不支持：</span></span><br><span class="line"><span class="keyword">SELECT</span> s.ymd, s.price_close <span class="keyword">FROM</span> stocks s</span><br><span class="line"><span class="keyword">WHERE</span> s.yms, s.symbol <span class="keyword">IN</span> </span><br><span class="line">  (<span class="keyword">SELECT</span> d.ymd, d.symbol <span class="keyword">FROM</span> dividends d);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 等价于Hive中的LEFT SEMI JOIN：</span></span><br><span class="line"><span class="keyword">SELECT</span> s.ymd, s.symbol, s.price_close</span><br><span class="line"><span class="keyword">FROM</span> stocks s</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">SEMI</span> <span class="keyword">JOIN</span> dividends d </span><br><span class="line"><span class="keyword">ON</span> s.ymd=d.ymd <span class="keyword">AND</span> s.symbol=d.symbol;</span><br></pre></td></tr></table></figure>
<h3 id="map-side-join"><a href="#map-side-join" class="headerlink" title="map-side join"></a>map-side join</h3><p>如果所有表中只有一张是小表，则可以在最大的表通过mapper的时候将小表完全放到内存中。</p>
<ul>
<li>Hive可以在map端执行连接过程（称为map-side JOIN）</li>
</ul>
<h2 id="like"><a href="#like" class="headerlink" title="like"></a>like</h2><p>使用正则表达式匹配字符串</p>
<ul>
<li><code>%</code>：匹配任意字符<ul>
<li><code>%x</code>：表示以x为结尾的字符串</li>
<li><code>x%</code>：表示以x为开头的字符串</li>
<li><code>%x%</code>：表示包含x的字符串，x可以位于开头、结尾或字符串中间</li>
</ul>
</li>
<li><code>_</code>：下划线匹配单个字符</li>
</ul>
<h2 id="limit"><a href="#limit" class="headerlink" title="limit"></a>limit</h2><p>限制返回的行数</p>
<h2 id="location"><a href="#location" class="headerlink" title="location"></a>location</h2><p>创建数据库时修改数据库的存储位置</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> db_name1</span><br><span class="line">LOCATION <span class="string">'/my/preferred/directory'</span>;</span><br></pre></td></tr></table></figure>
<h2 id="order-by"><a href="#order-by" class="headerlink" title="order by"></a>order by</h2><p><code>ORDER BY</code>会对查询结果集执行一个全局排序</p>
<ul>
<li>会有一个所有的数据都通过一个reducer进行处理的过程</li>
<li>可以使用<code>SORT BY</code>在每个reducer中对数据进行排序（执行局部排序），可以保证每个reducer的输出数据都是（局部）有序的</li>
<li>可以指定任意期望进行排序的字段<ul>
<li>默认升序排列<code>ASC</code></li>
<li>若要按降序排列，则应在字段后添加<code>DESC</code>关键字</li>
</ul>
</li>
</ul>
<h2 id="partitioned"><a href="#partitioned" class="headerlink" title="partitioned"></a>partitioned</h2><p>一般按照分区存储、管理表</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> employees (</span><br><span class="line">  <span class="keyword">name</span>          <span class="keyword">STRING</span>,</span><br><span class="line">  salary        <span class="built_in">FLOAT</span>,</span><br><span class="line">  subordinates  <span class="built_in">ARRAY</span>&lt;<span class="keyword">STRING</span>&gt;,</span><br><span class="line">  deductions    <span class="keyword">MAP</span>&lt;<span class="keyword">STRING</span>, <span class="built_in">FLOAT</span>&gt;,</span><br><span class="line">  address       <span class="keyword">STRUCT</span>&lt;street: <span class="keyword">STRING</span>, city: <span class="keyword">STRING</span>, state: <span class="keyword">STRING</span>, zip: <span class="built_in">INT</span>&gt;</span><br><span class="line">)</span><br><span class="line">PARTITIONED <span class="keyword">BY</span> (country <span class="keyword">STRING</span>, state <span class="keyword">STRING</span>);</span><br><span class="line"><span class="comment">-- 按照country、state进行分区管理</span></span><br><span class="line"><span class="comment">-- country是第一级细分</span></span><br><span class="line"><span class="comment">-- state是第二级细分</span></span><br></pre></td></tr></table></figure>
<p><code>SHOW PARTITIONS table_name</code>：查看数据表中存在的所有分区。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">PARTITIONS</span> employees;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Country=CA/state=AB</span></span><br><span class="line"><span class="comment">-- Country=CA/state=BC</span></span><br><span class="line"><span class="comment">-- ...</span></span><br></pre></td></tr></table></figure>
<p><code>SHOW PARTITIONS table_name PARTITION(country=&#39;US&#39;)</code>：查看数据表中的某个一级细分下的所有分区。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">PARTITIONS</span> employees <span class="keyword">PARTITION</span>(country=<span class="string">'US'</span>);</span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">PARTITIONS</span> employees <span class="keyword">PARTITION</span>(country=<span class="string">'US'</span>, state=<span class="string">'AK'</span>);</span><br></pre></td></tr></table></figure>
<h2 id="rlike"><a href="#rlike" class="headerlink" title="rlike"></a>rlike</h2><p>通过Java的正则表达式匹配字符串</p>
<ul>
<li>字符串中的点号<code>.</code>表示和任意的字符匹配</li>
<li>字符串中的星号<code>*</code>表示重复“左边的字符串”零次到无数次</li>
<li><code>(x|y)</code>表示和x或y匹配</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> address.street <span class="keyword">RLIKE</span> <span class="string">'.*(Chicago|Ontario).*'</span>;</span><br><span class="line"><span class="comment">-- 查找住址的街道名称中含有单词Chicago或Ontario的所有记录</span></span><br><span class="line"><span class="comment">-- 等价于</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> address.street <span class="keyword">LIKE</span> <span class="string">'%Chicago%'</span> </span><br><span class="line">   <span class="keyword">OR</span> address.street <span class="keyword">LIKE</span> <span class="string">'%Ontario%'</span>;</span><br></pre></td></tr></table></figure>
<p>更多Java正则表达式可见：</p>
<ul>
<li><a href="https://docs.oracle.com/javase/6/docs/api/java/util/regex/Pattern.html" target="_blank" rel="noopener">java.util.regex.Class Pattern</a></li>
<li><a href="https://tool.oschina.net/uploads/apidocs/jquery/regexp.html" target="_blank" rel="noopener">正则表达式手册</a></li>
<li><a href="https://harttle.land/2016/07/18/intro-to-regexp.html" target="_blank" rel="noopener">正则表达式参考手册（JavaScript版本）</a></li>
</ul>
<h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><ul>
<li>可用于给变量赋新的值</li>
</ul>
<h2 id="show"><a href="#show" class="headerlink" title="show"></a>show</h2><ul>
<li>查看Hive中所包含的数据库：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">DATABASES</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>显示当前数据库下的所有表：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">TABLES</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>显示指定数据库下的所有表：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">TABLES</span> <span class="keyword">IN</span> db_name_2;</span><br></pre></td></tr></table></figure>
<p>也可使用正则表达式筛选表名：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">TABLES</span> <span class="string">'empl.*'</span>;</span><br><span class="line"><span class="comment">-- 列出所有以empl开头的所有表名</span></span><br></pre></td></tr></table></figure>
<ul>
<li>显示数据表中存在的所有分区</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">PARTITIONS</span> table_name</span><br></pre></td></tr></table></figure>
<h2 id="sort-by"><a href="#sort-by" class="headerlink" title="sort by"></a>sort by</h2><p>在每个reducer中对数据进行排序</p>
<ul>
<li>排序结果是局部有序的</li>
<li>Hive要求<code>DISTRIBUTE BY</code>语句要写在<code>SORT BY</code>语句之前</li>
</ul>
<h2 id="where"><a href="#where" class="headerlink" title="where"></a>where</h2><p>WHERE语句用于过滤条件</p>
<ul>
<li>不能在WHERE语句中使用列别名</li>
</ul>
<h2 id="union-all"><a href="#union-all" class="headerlink" title="union all"></a>union all</h2><p>可以将2个或多个表进行合并。</p>
<ul>
<li>每一个UNION子查询都必需具有相同的列，且对应的每个字段的字段类型必须一致</li>
<li>也可用于同一个源表的数据合并</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> log.ymd, log.level, log.message</span><br><span class="line"><span class="keyword">FROM</span> </span><br><span class="line">(</span><br><span class="line">  <span class="keyword">SELECT</span> l1.ymd, l1.level, l1.message, <span class="string">'Log1'</span> <span class="keyword">AS</span> <span class="keyword">source</span></span><br><span class="line">  <span class="keyword">FROM</span> log1 l1</span><br><span class="line"></span><br><span class="line">  <span class="keyword">UNION</span> <span class="keyword">ALL</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">SELECT</span> l2.ymd, l2.level, l2.message, <span class="string">'Log2'</span> <span class="keyword">AS</span> <span class="keyword">source</span></span><br><span class="line">  <span class="keyword">FROM</span> log1 l2</span><br><span class="line">) <span class="keyword">log</span></span><br><span class="line"><span class="keyword">SORT</span> <span class="keyword">BY</span> log.ymd <span class="keyword">ASC</span>;</span><br></pre></td></tr></table></figure>
<h2 id="use"><a href="#use" class="headerlink" title="use"></a>use</h2><p>用于将某个数据库设置为用户当前的工作数据库</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">USE</span> db_name_2;</span><br></pre></td></tr></table></figure>
<h2 id="数据函数"><a href="#数据函数" class="headerlink" title="数据函数"></a>数据函数</h2><p>82页</p>
<h2 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h2><p>85页</p>
<h2 id="表生成函数"><a href="#表生成函数" class="headerlink" title="表生成函数"></a>表生成函数</h2><p>86页</p>
<h1 id="数据操作"><a href="#数据操作" class="headerlink" title="数据操作"></a>数据操作</h1><ul>
<li>Hive没有行级别的数据插入、数据更新和删除操作</li>
<li>数据插入方式有：<ul>
<li>装载数据文件到目标目录</li>
<li>INSERT INTO/OVERWRITE</li>
<li>创建表并将查询结果载入该表</li>
</ul>
</li>
</ul>
<h2 id="数据插入"><a href="#数据插入" class="headerlink" title="数据插入"></a>数据插入</h2><h3 id="load-data"><a href="#load-data" class="headerlink" title="load data"></a>load data</h3><p>装载数据到管理表：<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">LOAD</span> <span class="keyword">DATA</span> <span class="keyword">LOCAL</span> INPATH <span class="string">'$&#123;env:HOME&#125;/california-employees'</span></span><br><span class="line">OVERWRITE <span class="keyword">INTO</span> <span class="keyword">TABLE</span> table_name</span><br><span class="line"><span class="keyword">PARTITION</span> (country = <span class="string">'US'</span>, state = <span class="string">'CA'</span>);</span><br></pre></td></tr></table></figure></p>
<ul>
<li>如果分区目录不存在，则会先创建分区目录，再将数据拷贝到该目录下</li>
<li>如果目标表是非分区表，则PARTITION子句被忽略</li>
<li>通常情况下，指定的路径应该是一个目录，而不是单个独立的文件</li>
<li><code>INPATH</code>子句中的文件路径下不可以包含任何文件夹</li>
<li>Hive不会验证用户转载的数据和表的模式是否匹配</li>
<li>Hive会验证文件格式是否与表结构定义一致<ul>
<li>如果表的存储格式是SEQUENCEFILE，则装载进去的文件也应该是SEQUENCEFILE格式</li>
</ul>
</li>
</ul>
<h4 id="local"><a href="#local" class="headerlink" title="local"></a>local</h4><ul>
<li>如果使用了<code>LOCAL</code>关键字，则这个路径应该为本地文件系统路径，数据将被拷贝到目标位置</li>
<li>如果省略了<code>LOCAL</code>关键字，则这个路径应该是分布式文件系统中的路径，数据是从这个路径转移到目标位置的（因为用户在分布式文件系统中可能并不需要重复的多份数据文件拷贝）<ul>
<li>此时要求源文件和目标文件以及目录应该在同一个文件系统中</li>
<li>用户不可以使用<code>LOCAL DATA</code>语句将数据从一个集群的HDFS中转移到另一个集群的HDFS中</li>
</ul>
</li>
</ul>
<h4 id="overwrite"><a href="#overwrite" class="headerlink" title="overwrite"></a>overwrite</h4><ul>
<li>如果用户指定了<code>OVERWRITE</code>关键字，则目标文件夹中之前的数据将会被先删除</li>
<li>如果没有指定<code>OVERWRITE</code>关键字，则仅仅会把新增的文件增加到目标文件夹中而不会删除之前的数据<ul>
<li>如果目标文件夹中已经存在和装载的文件同名的文件，则旧的同名文件将会被覆盖重写（“之前的文件名_序列号”）</li>
</ul>
</li>
</ul>
<h3 id="insert"><a href="#insert" class="headerlink" title="insert"></a>insert</h3><p>通过查询语句向表中插入数据：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> OVERWRITE <span class="keyword">TABLE</span> table_name</span><br><span class="line"><span class="keyword">PARTITION</span> (country = <span class="string">'US'</span>, state = <span class="string">'OR'</span>)</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> another_table se</span><br><span class="line"><span class="keyword">WHERE</span> se.cnty = <span class="string">'US'</span> <span class="keyword">AND</span> se.et = <span class="string">'OR'</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>如果没有使用<code>OVERWRITE</code>关键字或<code>INTO</code>关键字，则将以追加的方式写入数据，而不会覆盖掉之前已经存在的内容</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 为三个州创建表分区</span></span><br><span class="line"><span class="comment">-- 将数据写入目标表的多个分区</span></span><br><span class="line"><span class="comment">-- 静态分区</span></span><br><span class="line">FROM another_table se</span><br><span class="line"><span class="keyword">INSERT</span> OVERWRITE <span class="keyword">TABLE</span> table_name</span><br><span class="line">  <span class="keyword">PARTITION</span> (country = <span class="string">'US'</span>, state = <span class="string">'OR'</span>)</span><br><span class="line">  <span class="keyword">SELECT</span> * <span class="keyword">WHERE</span> se.cnty = <span class="string">'US'</span> <span class="keyword">AND</span> se.st = <span class="string">'OR'</span></span><br><span class="line"><span class="keyword">INSERT</span> OVERWRITE <span class="keyword">TABLE</span> table_name</span><br><span class="line">  <span class="keyword">PARTITION</span> (country = <span class="string">'US'</span>, state = <span class="string">'CA'</span>)</span><br><span class="line">  <span class="keyword">SELECT</span> * <span class="keyword">WHERE</span> se.cnty = <span class="string">'US'</span> <span class="keyword">AND</span> se.st = <span class="string">'CA'</span></span><br><span class="line"><span class="keyword">INSERT</span> OVERWRITE <span class="keyword">TABLE</span> table_name</span><br><span class="line">  <span class="keyword">PARTITION</span> (country = <span class="string">'US'</span>, state = <span class="string">'IL'</span>)</span><br><span class="line">  <span class="keyword">SELECT</span> * <span class="keyword">WHERE</span> se.cnty = <span class="string">'US'</span> <span class="keyword">AND</span> se.st = <span class="string">'IL'</span></span><br><span class="line"><span class="comment">-- 这里可以混用 INSERT OVERWRITE 句式和 INSERT INTO 句式</span></span><br></pre></td></tr></table></figure>
<p>动态分区：<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> OVERWRITE <span class="keyword">TABLE</span> table_name</span><br><span class="line"><span class="keyword">PARTITION</span> (country, state)</span><br><span class="line"><span class="keyword">SELECT</span> ..., se.cnty, se.st</span><br><span class="line"><span class="keyword">FROM</span> another_table se;</span><br><span class="line"><span class="comment">-- Hive根据`SELECT`语句中最后2列来确定分区字段`country`和`state`的值</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>源表字段值和输出分区值之间是根据位置来匹配的，而不是根据字段命名</li>
<li><p>可以混合使用动态分区和静态分区</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> OVERWRITE <span class="keyword">TABLE</span> table_name</span><br><span class="line"><span class="keyword">PARTITION</span> (country = <span class="string">'US'</span>, state)</span><br><span class="line"><span class="keyword">SELECT</span> ..., se.cnty, se.st</span><br><span class="line"><span class="keyword">FROM</span> another_table se</span><br><span class="line"><span class="keyword">WHERE</span> se.cnty = <span class="string">'US'</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>静态分区键必须出现在动态分区键之前</p>
</li>
</ul>
<h3 id="创建表并插入数据"><a href="#创建表并插入数据" class="headerlink" title="创建表并插入数据"></a>创建表并插入数据</h3><p>在单个查询语句中创建表并载入数据：<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> table_name</span><br><span class="line"><span class="keyword">AS</span> </span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">  <span class="keyword">name</span></span><br><span class="line">  , salary</span><br><span class="line">  , address</span><br><span class="line"><span class="keyword">FROM</span> employees se</span><br><span class="line"><span class="keyword">WHERE</span> se.state = <span class="string">'CA'</span>;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>该功能（在单个查询语句中创建表并载入数据）不适用于外部表</li>
</ul>
<h2 id="导出数据"><a href="#导出数据" class="headerlink" title="导出数据"></a>导出数据</h2><ul>
<li><p>如果不需要更改数据文件格式，则可简单地拷贝文件夹或文件即可</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hadoop fs -cp source_path target_path</span><br></pre></td></tr></table></figure>
</li>
<li><p>可用<code>INSERT ... DIRECTORY ...</code>导出数据:</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> OVERWRITE <span class="keyword">LOCAL</span> <span class="keyword">DIRECTORY</span> <span class="string">'/tmp/ca_employees'</span></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">  <span class="keyword">name</span></span><br><span class="line">  , salary</span><br><span class="line">  , address</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> se.state = <span class="string">'CA'</span>;</span><br><span class="line"><span class="comment">-- 其中指定路径也可写成全URL路径（如hdfs://master-server/tmp/ca_employees</span></span><br></pre></td></tr></table></figure>
<h1 id="其他内置函数"><a href="#其他内置函数" class="headerlink" title="其他内置函数"></a>其他内置函数</h1><h2 id="ascii"><a href="#ascii" class="headerlink" title="ascii()"></a>ascii()</h2><p><code>ASCII(STRING s)</code>：返回字符串s中首个ASCII字符的整数值</p>
<ul>
<li>返回值是STRING</li>
</ul>
<h2 id="base64"><a href="#base64" class="headerlink" title="base64()"></a>base64()</h2><p><code>BASE64(BINARY bin)</code>：将二进制值bin转换为基于64位的字符串</p>
<ul>
<li>BASE64字符表：ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/</li>
<li>返回值是STRING</li>
</ul>
<h2 id="binary"><a href="#binary" class="headerlink" title="binary()"></a>binary()</h2><p>将输入的值转换成二进制值（Hive v0.12.0新增）<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">BINARY(STRING s)</span><br><span class="line">BINARY(BINARY b)</span><br></pre></td></tr></table></figure></p>
<ul>
<li>返回值是BINARY</li>
</ul>
<h2 id="cast-…-as-…"><a href="#cast-…-as-…" class="headerlink" title="cast(… as …)"></a>cast(… as …)</h2><p><code>CAST(&lt;expr&gt; AS &lt;type&gt;)</code>：将expr转换成type类型；如果转换过程失败，则会返回NULL<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">CAST(col_1 AS INT) <span class="comment">-- 将col_1列转换为INT类型</span></span><br><span class="line">CAST(col_2 AS FLOAT)  <span class="comment">-- 将字段的类型转换为FLOAT</span></span><br><span class="line"><span class="comment">-- 将字段的类型转换为FLOAT，推荐使用ROUND()或FLOOR()，而不是CAST(... AS FLOAT)</span></span><br><span class="line">CAST(col_3 AS STRING)</span><br><span class="line">CAST(col_4 AS DOUBLE)</span><br></pre></td></tr></table></figure></p>
<h2 id="concat"><a href="#concat" class="headerlink" title="concat()"></a>concat()</h2><p>将多个字符串拼接成一个字符串<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">CONCAT('abc', 'defg')</span><br><span class="line"><span class="comment">-- 结果为 abcdefg</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>返回值是STRING</li>
</ul>
<h2 id="concat-ws"><a href="#concat-ws" class="headerlink" title="concat_ws"></a>concat_ws</h2><p>concat with sep，拼接字符串<br><code>CONCAT_WS(STRING seperator, BINARY s1, STRING s2, ...)</code>：与<code>concat</code>类似，不过是使用指定的分隔符进行拼接</p>
<ul>
<li>返回值是STRING</li>
</ul>
<h2 id="context-ngrams"><a href="#context-ngrams" class="headerlink" title="context_ngrams"></a>context_ngrams</h2><p><code>CONTEXT_NGRAMS(ARRAY&lt;ARRAY&lt;STRING&gt;&gt;, ARRAY&lt;STRING&gt;, INT k, INT pf)</code>：和ngrams类似，从每个外层数组的第二个单词数组来查找前k个字尾<br>（不理解）</p>
<h2 id="date-add"><a href="#date-add" class="headerlink" title="date_add"></a>date_add</h2><p><code>DATE_ADD(STRING startdate, INT days)</code>：为开始时间<code>startdate</code>增加<code>days</code>天</p>
<ul>
<li>返回值是STRING</li>
</ul>
<h2 id="datediff"><a href="#datediff" class="headerlink" title="datediff"></a>datediff</h2><p><code>DATEDIFF(STRING enddate, STRING startdate)</code>：计算开始时间<code>startdate</code>到结束时间<code>enddate</code>相差的天数</p>
<ul>
<li>返回值是INT<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">DATEDIFF('2020-03-03', '2020-01')</span><br><span class="line"><span class="comment">-- 2</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="date-format"><a href="#date-format" class="headerlink" title="date_format"></a>date_format</h2><p>将时间字符串转换为指定的日期格式</p>
<ul>
<li>可以识别到“年”、“月”等一级的时间</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">DATE_FORMAT('2020-09-01 15:34:03', 'y')</span><br><span class="line"><span class="comment">-- 2020</span></span><br><span class="line"></span><br><span class="line">DATE_FORMAT('2020-09-01 15:34:03', 'yyyy-MM')</span><br><span class="line"><span class="comment">-- 2020-09</span></span><br><span class="line"></span><br><span class="line">DATE_FORMAT('2020-09-01', 'yyyy-MM')</span><br><span class="line"><span class="comment">-- 2020-09</span></span><br><span class="line"></span><br><span class="line">DATE_FORMAT('2020-09-01 15:34:03', 'yyyy-MM-dd')</span><br><span class="line"><span class="comment">--2020-09-01</span></span><br></pre></td></tr></table></figure>
<h2 id="date-sub"><a href="#date-sub" class="headerlink" title="date_sub"></a>date_sub</h2><p><code>DATE_SUB(STRING startdate, INT days)</code>：从开始时间<code>startdate</code>增加<code>days</code>天</p>
<ul>
<li>返回值是STRING</li>
</ul>
<h2 id="day"><a href="#day" class="headerlink" title="day"></a>day</h2><p><code>DAY(STRING date)</code>：提取时间字符串中的天<br><code>DAYOFMONTH(STRING date)</code>：返回当月第几天</p>
<ul>
<li>返回值是INT</li>
</ul>
<h2 id="dayofmonth"><a href="#dayofmonth" class="headerlink" title="dayofmonth"></a>dayofmonth</h2><p><code>DAYOFMONTH(STRING date)</code>：返回当月第几天</p>
<ul>
<li>返回值是INT</li>
</ul>
<h2 id="decode"><a href="#decode" class="headerlink" title="decode"></a>decode</h2><p><code>DECODE(BINARY bin, STRING charset)</code>：使用指定的字符集charset将二进制值bin解码成字符串</p>
<ul>
<li>若任一输入参数为NULL，则结果为NULL</li>
<li>返回值是STRING</li>
<li>支持的字符集有：<ul>
<li>US_ASCII</li>
<li>ISO-8859-1</li>
<li>UTF-8</li>
<li>UTF-16BE</li>
<li>UTF-16LF</li>
<li>UTF-16</li>
</ul>
</li>
</ul>
<h2 id="dense-rank"><a href="#dense-rank" class="headerlink" title="dense_rank"></a>dense_rank</h2><p><code>DENSE_RANK()</code>：生成数据项在分组中的排名，排名相等的名次一样，序号<strong>不会</strong>在中间留下空白</p>
<ul>
<li><p><a href="#rank">RANK</a>：生成数据项在分组中的排名，排名相等的名次一样，序号<strong>会</strong>在中间留下空白</p>
</li>
<li><p>其他窗口函数：<a href="#row-number">ROW_NUMBER</a>、<a href="#rank">RANK</a></p>
</li>
</ul>
<h2 id="encode"><a href="#encode" class="headerlink" title="encode"></a>encode</h2><p><code>ENCODE(STRING str, STRING charset)</code>：使用指定的字符集charset将字符串str编码成二进制值</p>
<ul>
<li>若任一输入参数为NULL，则结果为NULL</li>
<li>返回值是BINARY</li>
<li>支持的字符集有：<ul>
<li>US_ASCII</li>
<li>ISO-8859-1</li>
<li>UTF-8</li>
<li>UTF-16BE</li>
<li>UTF-16LF</li>
<li>UTF-16</li>
</ul>
</li>
</ul>
<h2 id="find-in-set"><a href="#find-in-set" class="headerlink" title="find_in_set()"></a>find_in_set()</h2><p><code>FIND_IN_SET(STRING s, STRING commaSeparatedString)</code>：返回在以逗号分隔的字符串commaSeparatedString中s出现的位置</p>
<ul>
<li>返回值是INT</li>
<li>如果没找到，则返回NULL</li>
</ul>
<h2 id="format-number"><a href="#format-number" class="headerlink" title="format_number"></a>format_number</h2><p><code>FORMAT_NUMBER(NUMBER x, INT d)</code>：将数值x转换成“#,###,###.##”格式字符串，并保留d位小数。</p>
<ul>
<li>返回值是STRING</li>
<li>如果d为0，则输出整数字符串</li>
</ul>
<h2 id="from-unixtime"><a href="#from-unixtime" class="headerlink" title="from_unixtime"></a>from_unixtime</h2><p><code>FROM_UNIXTIME(BIGINT unixtime[, STRING format])</code>：将时间戳秒数转换为UTC时间</p>
<ul>
<li>返回值是STRING</li>
<li>可以通过format指定输出的时间格式<ul>
<li>‘yyyyMMdd’</li>
<li>‘yyyy-MM-dd’</li>
</ul>
</li>
</ul>
<h2 id="from-utc-timestamp"><a href="#from-utc-timestamp" class="headerlink" title="from_utc_timestamp"></a>from_utc_timestamp</h2><p><code>FROM_UTC_TIMESTAMP(TIMESTAMP timestamp, STRING timezone)</code>：如果给定的时间戳<code>timestamp</code>不是UTC，则将其转换成指定时区<code>timezone</code>下的时间戳</p>
<ul>
<li>返回值是TIMESTAMP</li>
</ul>
<h2 id="get-json-object"><a href="#get-json-object" class="headerlink" title="get_json_object"></a>get_json_object</h2><p><code>GET_JSON_OBJECCT(STRING json_string, STRING path)</code>：从给定路径上的JSON字符串中抽取出JSON对象，并返回这个对象的JSOM字符串形式</p>
<ul>
<li>返回值是STRING</li>
<li>如果输入的JSON字符串是非法的，则返回NULL</li>
</ul>
<h2 id="hour"><a href="#hour" class="headerlink" title="hour"></a>hour</h2><p><code>HOUR(STRING date)</code>：提取时间戳字符串中的小时</p>
<ul>
<li>返回值是INT</li>
</ul>
<h2 id="in"><a href="#in" class="headerlink" title="in"></a>in</h2><p><code>test IN (val1, val2, ...)</code>：判断test是否等于后面列表中的任一值，是的话返回true</p>
<ul>
<li>返回值是BOOLEAN</li>
</ul>
<h2 id="in-file"><a href="#in-file" class="headerlink" title="in_file"></a>in_file</h2><p><code>IN_FILE(STRING s, STRING filename)</code>：如果文件名为filename的文件中有完整一行数据和字符串s完全匹配，则返回true</p>
<ul>
<li>返回值是BOOLEAN</li>
</ul>
<h2 id="instr"><a href="#instr" class="headerlink" title="instr"></a>instr</h2><p><code>INSTR(STRING str, STRING substr)</code>：查找字符串str中子字符串substr第一次出现的位置</p>
<ul>
<li>返回值是INT</li>
</ul>
<h2 id="length"><a href="#length" class="headerlink" title="length"></a>length</h2><p><code>LENGTH(STRING s)</code>：返回字符串s的长度</p>
<ul>
<li>返回值是INT</li>
</ul>
<h2 id="locate"><a href="#locate" class="headerlink" title="locate"></a>locate</h2><p><code>LOCATE(STRING substr, STRING str[, INT pos])</code>：查找在字符串str中的pos位置后字符串substr第一次出现的位置</p>
<ul>
<li>返回值是INT</li>
</ul>
<h2 id="lower-lcase"><a href="#lower-lcase" class="headerlink" title="lower(), lcase()"></a>lower(), lcase()</h2><p><code>LOWER(STRING s)</code> 或 <code>LCASE(STRING s)</code>：将字符串s中所有字母转换成小写字母</p>
<ul>
<li>返回值是STRING</li>
<li>与<code>LCASE()</code>一样</li>
</ul>
<h2 id="lpad"><a href="#lpad" class="headerlink" title="lpad"></a>lpad</h2><p><code>LPAD(STRING s, INT len, STRING pad)</code>：从左边开始对字符串s使用字符串pad进行填充，直到达到len长度为止</p>
<ul>
<li>如果s本身长度比len大，则多余的部分会被去除</li>
<li>返回值是STRING</li>
</ul>
<h2 id="ltrim"><a href="#ltrim" class="headerlink" title="ltrim"></a>ltrim</h2><p><code>LTRIM(STRING s)</code> ：将字符串s前面出现的空格全部去除</p>
<h2 id="minuite"><a href="#minuite" class="headerlink" title="minuite"></a>minuite</h2><p><code>MINUTE(STRING date)</code>：提取时间字符串中的分钟数</p>
<ul>
<li>返回值是INT</li>
</ul>
<h2 id="month"><a href="#month" class="headerlink" title="month"></a>month</h2><p><code>MONTH(STRING date)</code>：提取时间字符串中的月份</p>
<ul>
<li>返回值是INT</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">MONTH('2020-09-01 12:00:05')</span><br><span class="line"><span class="comment">-- 9</span></span><br><span class="line"></span><br><span class="line">MONTH('2020-09-02')</span><br><span class="line"><span class="comment">-- 9</span></span><br></pre></td></tr></table></figure>
<h2 id="ngrams"><a href="#ngrams" class="headerlink" title="ngrams"></a>ngrams</h2><p><code>NGRAMS(ARRAY&lt;ARRAY&lt;string&gt;&gt;, INT n, INT k, INT pf)</code>：估算文件前k个字尾</p>
<ul>
<li>其中pf是精度系数</li>
<li>返回值是<code>ARRAY&lt;STRUCT&lt;STRING, DOUBLE&gt;&gt;</code><br>（不理解）</li>
</ul>
<h2 id="ntile"><a href="#ntile" class="headerlink" title="ntile()"></a>ntile()</h2><p><code>NTILE(INT n)</code>：将分组数据按照顺序切分为n片；返回当前切片值<br><code>NTILE(INT n) OVER(PARTITION BY col_1 ORDER BY col_2)</code></p>
<ul>
<li><code>NTILE()</code>不支持<code>ROWS BETWEEN</code></li>
</ul>
<h2 id="parse-url"><a href="#parse-url" class="headerlink" title="parse_url()"></a>parse_url()</h2><p><code>PARSE_URL(STRING url, STRING partname[, STRING key])</code>：从url中抽取指定部分的内容</p>
<ul>
<li>参数<code>partname</code>：要抽取的部分名称（是大小写敏感的）；可选的值有：<ul>
<li>HOST</li>
<li>PATH</li>
<li>QUERY</li>
<li>REF</li>
<li>PROTOCOL</li>
<li>AUTHORITY</li>
<li>FILE</li>
<li>USERINFO</li>
<li>QUERY:<key></key></li>
</ul>
</li>
<li>如果partname是QUERY的话，则还需要指定第三个参数key</li>
<li>返回值是STRING</li>
</ul>
<h2 id="printf"><a href="#printf" class="headerlink" title="printf()"></a>printf()</h2><p><code>PRINTF(STRING format, Obj ... args)</code>：按照printf风格格式化输出输入的字符串</p>
<ul>
<li>返回值是STRING</li>
</ul>
<h2 id="rand"><a href="#rand" class="headerlink" title="rand()"></a>rand()</h2><p>产生随机数<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 分桶抽样</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> numbers</span><br><span class="line"><span class="keyword">TABLESAMPLE</span>(<span class="keyword">BUCKET</span> <span class="number">3</span> <span class="keyword">OUT</span> <span class="keyword">OF</span> <span class="number">10</span> <span class="keyword">ON</span> <span class="keyword">RAND</span>()) s;</span><br><span class="line"><span class="comment">-- 分母10表示的是数据将会被散列的桶的个数</span></span><br><span class="line"><span class="comment">-- 分子3表示的是将会选择的桶的个数</span></span><br></pre></td></tr></table></figure></p>
<h2 id="rank"><a href="#rank" class="headerlink" title="rank"></a>rank</h2><p><code>RANK()</code>：从1开始，按照顺序生成分组内记录的序列</p>
<ul>
<li><p>序号是连续的，且间隔为1</p>
</li>
<li><p>其他窗口函数：<a href="#row-number">ROW_NUMBER</a>、<a href="#dense-rank">DENSE_RANK</a></p>
</li>
</ul>
<h2 id="regexp-extract"><a href="#regexp-extract" class="headerlink" title="regexp_extract"></a>regexp_extract</h2><p><code>REGEXP_EXTRACT(STRING s, STRING regex_pattern, STRING index)</code>：抽取字符串st中符合正则表达式regex_pattern的第index个部分的子字符串</p>
<ul>
<li>返回值是STRING</li>
</ul>
<h2 id="regexp-replace"><a href="#regexp-replace" class="headerlink" title="regexp_replace"></a>regexp_replace</h2><p><code>REGEXP_REPLACE(STRING s, STRING regex, STRING replacement)</code>：按照Java正则表达式regex将字符串s中符合条件的部分替换成replacement所指定的字符串</p>
<ul>
<li>如果<code>replacement</code>为空，则将符合正则表达式的部分去掉</li>
<li>返回值是STRING</li>
</ul>
<h2 id="repeat"><a href="#repeat" class="headerlink" title="repeat"></a>repeat</h2><p><code>REPEAT(STRING s, INT n)</code>：重复输出n次字符串s</p>
<ul>
<li>返回值是STRING</li>
</ul>
<h2 id="reverse"><a href="#reverse" class="headerlink" title="reverse"></a>reverse</h2><p><code>REVERSE(STRING s)</code>：反转字符串</p>
<ul>
<li>返回值是STRING</li>
</ul>
<h2 id="row-number"><a href="#row-number" class="headerlink" title="row_number"></a>row_number</h2><h2 id="rpad"><a href="#rpad" class="headerlink" title="rpad"></a>rpad</h2><p><code>RPAD(STRING s, INT len, STRING pad)</code>：从右边开始对字符串s使用字符串pad进行填充，直到达到len长度为止</p>
<ul>
<li>如果字符串s本身长度比len大，则多余的部分被去除</li>
<li>返回值是STRING</li>
</ul>
<h2 id="rtrim"><a href="#rtrim" class="headerlink" title="rtrim"></a>rtrim</h2><p><code>RTRIM(STRING s)</code>：将字符串s后面出现的空格全部去除</p>
<ul>
<li>返回值是STRING</li>
</ul>
<h2 id="second"><a href="#second" class="headerlink" title="second"></a>second</h2><p><code>SECOND(STRING date)</code>：提取时间字符串中的秒数</p>
<ul>
<li>返回值是INT</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">SECOND('2020-09-01 12:23:34')</span><br><span class="line"><span class="comment">-- 34</span></span><br></pre></td></tr></table></figure>
<h2 id="sentences"><a href="#sentences" class="headerlink" title="sentences"></a>sentences</h2><p><code>SENTENCES(STRING s, STRING lang, STRING locale)</code>：将输入字符串s转换成句子数组，每个句子又由一个单词数组构成。</p>
<ul>
<li>参数<code>lang</code>：可选</li>
<li>参数<code>locale</code>：可选</li>
<li>返回值是<code>ARRAY&lt;ARRAY&lt;STRING&gt;&gt;</code></li>
</ul>
<h2 id="size"><a href="#size" class="headerlink" title="size"></a>size</h2><p><code>SIZE(MAP&lt;key, value&gt;)</code>：返回MAP中元素的个数<br><code>SIZE(ARRAY&lt;...&gt;)</code>：返回数组ARRAY的元素个数</p>
<ul>
<li>返回值是INT</li>
</ul>
<h2 id="space"><a href="#space" class="headerlink" title="space()"></a>space()</h2><p><code>SPACE(INT n)</code>：返回n个空格</p>
<ul>
<li>返回值是STRING</li>
</ul>
<h2 id="split"><a href="#split" class="headerlink" title="split"></a>split</h2><p><code>SPLIT(STRING s, STRING pattern)</code>：按照正则表达式pattern分割字符串s，并将分割后的部分以字符串数组的方式返回</p>
<ul>
<li>返回值是<code>ARRAY&lt;STRING&gt;</code></li>
</ul>
<h2 id="str-to-map"><a href="#str-to-map" class="headerlink" title="str_to_map()"></a>str_to_map()</h2><p><code>STRING_TO_MAP(STRING s, STRING delim1, STRING delim2)</code>：将字符串s按照指定分隔符转换成MAP</p>
<ul>
<li>delim1：键值对之间的分隔符（对与对之间）</li>
<li>delim2：键和值之间的分隔符（对内的键和值之间）</li>
<li>返回值是MAP<STRING, string></STRING,></li>
</ul>
<h2 id="substr-substring"><a href="#substr-substring" class="headerlink" title="substr(), substring()"></a>substr(), substring()</h2><p><code>SUBSTR(STRING s, INT start_index, INT length)</code> 或 <code>SUBSTRING(STRING s, INT start_index, INT length)</code>：截取字符串s的从start_index位置开始的、长度为length的子字符串<br><code>SUBSTR(BINARY) s, INT start_index, INT length)</code> 或 <code>SUBSTRING(STRING s, INT start_index, INT length)</code>：截取二进制字节值s的从start_index位置开始的、长度为length的子字符串（Hive v0.12.0新增）</p>
<ul>
<li>包括start_index位置上的字符在内</li>
<li>返回值是STRING</li>
</ul>
<h2 id="tablesample"><a href="#tablesample" class="headerlink" title="tablesample()"></a>tablesample()</h2><p>数据抽样</p>
<ol>
<li><p>分桶抽样</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 分桶抽样</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> numbers</span><br><span class="line"><span class="keyword">TABLESAMPLE</span>(<span class="keyword">BUCKET</span> <span class="number">3</span> <span class="keyword">OUT</span> <span class="keyword">OF</span> <span class="number">10</span> <span class="keyword">ON</span> <span class="keyword">RAND</span>()) s;</span><br><span class="line"><span class="comment">-- 分母10表示的是数据将会被散列的桶的个数</span></span><br><span class="line"><span class="comment">-- 分子3表示的是将会选择的桶的个数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> numbers</span><br><span class="line"><span class="keyword">TABLESAMPLE</span>(<span class="keyword">BUCKET</span> <span class="number">3</span> <span class="keyword">OUT</span> <span class="keyword">OF</span> <span class="number">10</span> <span class="keyword">ON</span> <span class="built_in">number</span>) s;</span><br><span class="line"><span class="comment">-- 根据number字段分桶</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>数据块抽样</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 基于行数按照数据块百分比进行抽样</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> numbersflat</span><br><span class="line"><span class="keyword">TABLESAMPLE</span>(<span class="number">0.1</span> <span class="keyword">PERCENT</span>) s;</span><br><span class="line"><span class="comment">-- 数据块抽样（百分比抽样）的最小抽样单元是一个HDFS数据块</span></span><br><span class="line"><span class="comment">-- 如果表的数据大小小于普通的块大小（128MB），则将会返回所有行</span></span><br><span class="line"></span><br><span class="line">TABLESAMPLE(n M)  <span class="comment">-- 指定抽样数据的大小，单位为M</span></span><br><span class="line"></span><br><span class="line">TABLESAMPLE(n rows)  <span class="comment">-- 指定抽样数据的行数</span></span><br><span class="line"><span class="comment">-- n代表每个map任务均取n行数据</span></span><br><span class="line"><span class="comment">-- map梳理可以通过hive表的简单查询语句确认（number of mappers: x）</span></span><br></pre></td></tr></table></figure></li>
<li>随机抽样<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">col</span>=xxx </span><br><span class="line"><span class="keyword">DISTRIBUTE</span> <span class="keyword">BY</span> <span class="keyword">RAND</span>() </span><br><span class="line"><span class="keyword">SORT</span> <span class="keyword">BY</span> <span class="keyword">RAND</span>()</span><br><span class="line"><span class="keyword">LIMIT</span> <span class="keyword">num</span>;</span><br><span class="line"><span class="comment">-- 使用RAND()函数进行随机抽样</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">col</span>=xxx</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">RAND</span>()</span><br><span class="line"><span class="keyword">LIMIT</span> <span class="keyword">num</span>;</span><br><span class="line"><span class="comment">-- ORDER BY方式耗时更长</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="to-date"><a href="#to-date" class="headerlink" title="to_date()"></a>to_date()</h2><p><code>TO_DATE(STRING timestamp)</code>：返回时间字符串的日期部分</p>
<ul>
<li>返回值是STRING</li>
<li>时间字符串的格式为“年-月-日”，不能为“年-月”</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">TO_DATE('1970-01-01 00:00:00')</span><br><span class="line"><span class="comment">-- "1970-01-01"</span></span><br></pre></td></tr></table></figure>
<h2 id="to-utc-timestamp"><a href="#to-utc-timestamp" class="headerlink" title="to_utc_timestamp()"></a>to_utc_timestamp()</h2><p><code>TO_UTC_TIMESTAMP(TIMESTAMP timestamp, STRING timezone)</code>：如果给定的时间戳<code>timestamp</code>是指定时区<code>timezone</code>下的时间戳，则将其转化为UTC下的时间戳</p>
<ul>
<li>返回值是TIMESTAMP</li>
</ul>
<h2 id="translate"><a href="#translate" class="headerlink" title="translate()"></a>translate()</h2><p>？？？</p>
<h2 id="trim"><a href="#trim" class="headerlink" title="trim()"></a>trim()</h2><p><code>TRIM(STRING s)</code>：将字符串s前后出现的空格全部去除掉</p>
<ul>
<li>返回值是STRING</li>
</ul>
<h2 id="unbase64"><a href="#unbase64" class="headerlink" title="unbase64()"></a>unbase64()</h2><p><code>UNBASE64(STRING str)</code>：将基于64位的字符串str转换成二进制值</p>
<ul>
<li>BASE64字符表：ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/</li>
<li>返回值是BINARY</li>
</ul>
<h2 id="unix-timestamp"><a href="#unix-timestamp" class="headerlink" title="unix_timestamp()"></a>unix_timestamp()</h2><p><code>UNIX_TIMESTAMP()</code>：获取当前本地时区下的当前时间戳<br><code>UNIX_TIMESTAMP(STRING date)</code>：输入的时间字符串格式必须是<code>yyyy-MM-dd HH:mm:ss</code>。如果不符合，则返回0；如果符合，则将此时间字符串转换成Unix时间戳<br><code>UNIX_TIMESTAMP(STRING date, STRING pattern)</code>：将指定时间字符串格式字符串转换成Unix时间戳。如果格式不符合，则返回0。</p>
<ul>
<li>返回值是BIGINT</li>
</ul>
<h2 id="upper-ucase"><a href="#upper-ucase" class="headerlink" title="upper(), ucase()"></a>upper(), ucase()</h2><p><code>UPPER(STRING s)</code> 或 <code>UCASE(STRING s)</code>：将字符串s中所有字母转换成大写字母</p>
<h2 id="weekofyear"><a href="#weekofyear" class="headerlink" title="weekofyear()"></a>weekofyear()</h2><p><code>WEEKOFYEAR(STRING date)</code>：返回时间字符出位于一年中的第几周内</p>
<ul>
<li>返回值是INT</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">WEEKOFYEAR('2016-12-08 10:05:15')</span><br><span class="line"><span class="comment">-- 49</span></span><br></pre></td></tr></table></figure>
<h2 id="year"><a href="#year" class="headerlink" title="year()"></a>year()</h2><p><code>YEAR(STRING date)</code>：提取时间字符串中的年份</p>
<ul>
<li>返回值是INT</li>
</ul>
<h2 id><a href="#" class="headerlink" title=" "></a> </h2><p>91页</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="属性配置"><a href="#属性配置" class="headerlink" title="属性配置"></a>属性配置</h1><div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: center;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: center;">
      <th>属性名称</th>
      <th>缺省值</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>hive.cli.print.header</th>
      <td></td>
      <td>是否让CLI打印出字段名称<br>`=true`：让CLI打印出字段名称<br>`=false`：不打印出字段名称</td>
    </tr>
    <tr>
      <th>hive.exec.dynamic.partition</th>
      <td>false</td>
      <td>`=true`：开启动态分区功能</td>
    </tr>
    <tr>
      <th>hive.exec.dynamic.partition.mode</th>
      <td>strict</td>
      <td>`=nonstrict`：允许所有分区都是动态的</td>
    </tr>
    <tr>
      <th>hive.exec.max.created.files</th>
      <td>100000</td>
      <td>全局可以创建的最大文件个数。<br>有一个Hadoop计数器会跟踪记录已创建的文件个数，若超过该值，则会抛出一个致命错误信息。</td>
    </tr>
    <tr>
      <th>hive.exec.max.dynamic.partitions</th>
      <td>+1000</td>
      <td>一个动态分区创建语句可以创建的最大动态分区个数。<br>若超过该值，则会抛出一个致命错误信息。</td>
    </tr>
    <tr>
      <th>hive.exec.max.dynamic.partitions.pernode</th>
      <td>100</td>
      <td>每个mapper或reducer可以创建的最大动态分区数。<br>如果某个mapper或reducer尝试创建大于这个值的分区，则会抛出一个致命错误信息</td>
    </tr>
    <tr>
      <th>hive.exec.mode.local.auto</th>
      <td>false</td>
      <td>`=true`：Hive会尝试使用本地模式执行其他操作；否则Hive使用MapReduce来执行其他所有的查询</td>
    </tr>
    <tr>
      <th>hive.map.aggr</th>
      <td></td>
      <td>`=true`：触发在map阶段进行的“顶级”聚合过程，提高聚合的性能。<br>非顶级的聚合过程将会在执行一个  `GROUP BY`后进行。</td>
    </tr>
    <tr>
      <th>hive.mapred.mode</th>
      <td></td>
      <td>`=strict`：如果任务对分区表进行查询而WHERE子句没有加分区过滤，则会禁止提交这个任务；会阻止用户执行笛卡尔积查询；执行ORDER BY操作时需要加LIMIT语句进行限制。<br>`=nonstrict`：如果任务对分区表进行查询而WHERE子句没有加分区过滤，这个任务并不会被禁止</td>
    </tr>
    <tr>
      <th></th>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <th></th>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <th></th>
      <td></td>
      <td></td>
    </tr>
    <tr>
  </tr></tbody>
</table>
</div>


<h2 id="hive-cli-print-header"><a href="#hive-cli-print-header" class="headerlink" title="hive.cli.print.header"></a>hive.cli.print.header</h2><p><code>hive.cli.print.header</code>：是否让CLI打印出字段名称</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 让CLI打印出字段名称</span></span><br><span class="line"><span class="keyword">SET</span> hive.cli.print.header=<span class="literal">true</span>;</span><br></pre></td></tr></table></figure>
<p>如果要设置为默认选项，则需将第一行添加到<code>$HOME/.hiverc</code>文件中。</p>
<h2 id="hive-mapred-mode"><a href="#hive-mapred-mode" class="headerlink" title="hive.mapred.mode"></a>hive.mapred.mode</h2><p><code>hive.mapred.mode=strict</code>：如果任务对分区表进行查询而WHERE子句没有加分区过滤，则会禁止提交这个任务。</p>
<ul>
<li>防止触发一个巨大的MapReduce任务</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> hive.mapred.mode=<span class="keyword">strict</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">  t.name</span><br><span class="line">  , t.salary</span><br><span class="line"><span class="keyword">FROM</span> </span><br><span class="line">  table_1</span><br><span class="line"><span class="keyword">LIMIT</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<p><code>hive.mapred.mode=nonstrict</code>：如果任务对分区表进行查询而WHERE子句没有加分区过滤，这个任务并不会被禁止。</p>
<h1 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h1><ul>
<li>视图是一个逻辑结构，不会存储数据</li>
</ul>
<p><strong>用途</strong>：</p>
<ol>
<li>降低查询复杂度<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> shorter_join <span class="keyword">AS</span> </span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> people </span><br><span class="line"><span class="keyword">JOIN</span> cart</span><br><span class="line"><span class="keyword">ON</span> cart.people_id=people.id</span><br><span class="line"><span class="keyword">WHERE</span> first_name = <span class="string">'John'</span>;</span><br></pre></td></tr></table></figure>
2.限制基于条件过滤的数据，保护信息不被随意查询<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> temp_view <span class="keyword">AS</span> </span><br><span class="line"><span class="keyword">SELECT</span> first_name, last_name </span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> department=<span class="string">'dep_name'</span>;</span><br><span class="line"><span class="comment">-- 只提供特定部门的员工信息</span></span><br><span class="line"><span class="comment">-- 有效保护信息</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li>一个视图的名称要和这个视图所在的数据库下的其他表和视图的名称不同</li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href>HIVE编程指南</a></li>
<li><a href="https://blog.csdn.net/zylove2010/article/details/78290319" target="_blank" rel="noopener">Hive实现数据抽样的三种方法</a></li>
</ul>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>HIVE</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>Python | Categorical_encoders</title>
    <url>/python-categorical-encoders.html</url>
    <content><![CDATA[<p><center> </center><br><a id="more"></a></p>
<h1 id="Categorical-encoders"><a href="#Categorical-encoders" class="headerlink" title="Categorical_encoders"></a>Categorical_encoders</h1><p>categorical_encoders包有多种不同的编码技术可以把类别变量转换为数值型变量。</p>
<p>使用Anaconda Prompt进行<strong>安装</strong>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install categorical_encoders</span><br></pre></td></tr></table></figure>
<h2 id="BinaryEncoder"><a href="#BinaryEncoder" class="headerlink" title="BinaryEncoder()"></a>BinaryEncoder()</h2><p>进行0-1转换</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> category_encoders <span class="keyword">as</span> ce</span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_boston</span><br><span class="line"></span><br><span class="line">bunch = load_boston()</span><br><span class="line">y = bunch.target</span><br><span class="line">X = pd.DataFrame(bunch.data, columns=bunch.feature_names)</span><br><span class="line">X.head()</span><br><span class="line"><span class="comment">#      CRIM    ZN  INDUS  CHAS    NOX  ...  RAD    TAX  PTRATIO       B  LSTAT</span></span><br><span class="line"><span class="comment">#0  0.00632  18.0   2.31   0.0  0.538  ...  1.0  296.0     15.3  396.90   4.98</span></span><br><span class="line"><span class="comment">#1  0.02731   0.0   7.07   0.0  0.469  ...  2.0  242.0     17.8  396.90   9.14</span></span><br><span class="line"><span class="comment">#2  0.02729   0.0   7.07   0.0  0.469  ...  2.0  242.0     17.8  392.83   4.03</span></span><br><span class="line"><span class="comment">#3  0.03237   0.0   2.18   0.0  0.458  ...  3.0  222.0     18.7  394.63   2.94</span></span><br><span class="line"><span class="comment">#4  0.06905   0.0   2.18   0.0  0.458  ...  3.0  222.0     18.7  396.90   5.33</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#[5 rows x 13 columns]</span></span><br><span class="line"></span><br><span class="line">ohe = ce.BinaryEncoder(cols=[<span class="string">'CHAS'</span>, <span class="string">'RAD'</span>], handle_unknown=<span class="string">'indicator'</span>).fit(X, y)</span><br><span class="line">numeric_dataset = ohe.transform(X)</span><br><span class="line">numeric_dataset.info()</span><br><span class="line"><span class="comment">#&lt;class 'pandas.core.frame.DataFrame'&gt;</span></span><br><span class="line"><span class="comment">#RangeIndex: 506 entries, 0 to 505</span></span><br><span class="line"><span class="comment">#Data columns (total 19 columns):</span></span><br><span class="line"><span class="comment">#CRIM       506 non-null float64</span></span><br><span class="line"><span class="comment">#ZN         506 non-null float64</span></span><br><span class="line"><span class="comment">#INDUS      506 non-null float64</span></span><br><span class="line"><span class="comment">#CHAS_0     506 non-null int64</span></span><br><span class="line"><span class="comment">#CHAS_1     506 non-null int64</span></span><br><span class="line"><span class="comment">#CHAS_2     506 non-null int64</span></span><br><span class="line"><span class="comment">#NOX        506 non-null float64</span></span><br><span class="line"><span class="comment">#RM         506 non-null float64</span></span><br><span class="line"><span class="comment">#AGE        506 non-null float64</span></span><br><span class="line"><span class="comment">#DIS        506 non-null float64</span></span><br><span class="line"><span class="comment">#RAD_0      506 non-null int64</span></span><br><span class="line"><span class="comment">#RAD_1      506 non-null int64</span></span><br><span class="line"><span class="comment">#RAD_2      506 non-null int64</span></span><br><span class="line"><span class="comment">#RAD_3      506 non-null int64</span></span><br><span class="line"><span class="comment">#RAD_4      506 non-null int64</span></span><br><span class="line"><span class="comment">#TAX        506 non-null float64</span></span><br><span class="line"><span class="comment">#PTRATIO    506 non-null float64</span></span><br><span class="line"><span class="comment">#B          506 non-null float64</span></span><br><span class="line"><span class="comment">#LSTAT      506 non-null float64</span></span><br><span class="line"><span class="comment">#dtypes: float64(11), int64(8)</span></span><br><span class="line"><span class="comment">#memory usage: 75.2 KB</span></span><br><span class="line"></span><br><span class="line">numeric_dataset[[<span class="string">'CHAS_0'</span>, <span class="string">'CHAS_1'</span>, <span class="string">'CHAS_2'</span>]].head()</span><br><span class="line"><span class="comment">#   CHAS_0  CHAS_1  CHAS_2</span></span><br><span class="line"><span class="comment">#0       0       0       1</span></span><br><span class="line"><span class="comment">#1       0       0       1</span></span><br><span class="line"><span class="comment">#2       0       0       1</span></span><br><span class="line"><span class="comment">#3       0       0       1</span></span><br><span class="line"><span class="comment">#4       0       0       1</span></span><br><span class="line"></span><br><span class="line">numeric_dataset[[<span class="string">'RAD_0'</span>, <span class="string">'RAD_1'</span>, <span class="string">'RAD_2'</span>, <span class="string">'RAD_3'</span>, <span class="string">'RAD_4'</span>]].head()</span><br><span class="line"><span class="comment">#   RAD_0  RAD_1  RAD_2  RAD_3  RAD_4</span></span><br><span class="line"><span class="comment">#0      0      0      0      0      1</span></span><br><span class="line"><span class="comment">#1      0      0      0      1      0</span></span><br><span class="line"><span class="comment">#2      0      0      0      1      0</span></span><br><span class="line"><span class="comment">#3      0      0      0      1      1</span></span><br><span class="line"><span class="comment">#4      0      0      0      1      1</span></span><br></pre></td></tr></table></figure>
<h2 id="OneHotEncoder"><a href="#OneHotEncoder" class="headerlink" title="OneHotEncoder()"></a>OneHotEncoder()</h2><p>进行One-Hot Encoding<br><code>OneHotEncoder(verbose=0, cols=None, drop_invariant=False, 
    return_df=True, handle_missing=&#39;value&#39;, 
    handle_unknown=&#39;value&#39;, use_cat_names=False)</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> category_encoders <span class="keyword">as</span> ce</span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_boston</span><br><span class="line"></span><br><span class="line">bunch = load_boston()</span><br><span class="line">y = bunch.target</span><br><span class="line">X = pd.DataFrame(bunch.data, columns=bunch.feature_names)</span><br><span class="line">X.head()</span><br><span class="line"><span class="comment">#      CRIM    ZN  INDUS  CHAS    NOX  ...  RAD    TAX  PTRATIO       B  LSTAT</span></span><br><span class="line"><span class="comment">#0  0.00632  18.0   2.31   0.0  0.538  ...  1.0  296.0     15.3  396.90   4.98</span></span><br><span class="line"><span class="comment">#1  0.02731   0.0   7.07   0.0  0.469  ...  2.0  242.0     17.8  396.90   9.14</span></span><br><span class="line"><span class="comment">#2  0.02729   0.0   7.07   0.0  0.469  ...  2.0  242.0     17.8  392.83   4.03</span></span><br><span class="line"><span class="comment">#3  0.03237   0.0   2.18   0.0  0.458  ...  3.0  222.0     18.7  394.63   2.94</span></span><br><span class="line"><span class="comment">#4  0.06905   0.0   2.18   0.0  0.458  ...  3.0  222.0     18.7  396.90   5.33</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#[5 rows x 13 columns]</span></span><br><span class="line"></span><br><span class="line">ohe = ce.OneHotEncoder(cols=[<span class="string">'CHAS'</span>, <span class="string">'RAD'</span>], handle_unknown=<span class="string">'indicator'</span>).fit(X, y)</span><br><span class="line">numeric_dataset = ohe.transform(X)</span><br><span class="line">numeric_dataset.info()</span><br><span class="line"><span class="comment">#&lt;class 'pandas.core.frame.DataFrame'&gt;</span></span><br><span class="line"><span class="comment">#RangeIndex: 506 entries, 0 to 505</span></span><br><span class="line"><span class="comment">#Data columns (total 24 columns):</span></span><br><span class="line"><span class="comment">#CRIM       506 non-null float64</span></span><br><span class="line"><span class="comment">#ZN         506 non-null float64</span></span><br><span class="line"><span class="comment">#INDUS      506 non-null float64</span></span><br><span class="line"><span class="comment">#CHAS_1     506 non-null int64</span></span><br><span class="line"><span class="comment">#CHAS_2     506 non-null int64</span></span><br><span class="line"><span class="comment">#CHAS_-1    506 non-null int64</span></span><br><span class="line"><span class="comment">#NOX        506 non-null float64</span></span><br><span class="line"><span class="comment">#RM         506 non-null float64</span></span><br><span class="line"><span class="comment">#AGE        506 non-null float64</span></span><br><span class="line"><span class="comment">#DIS        506 non-null float64</span></span><br><span class="line"><span class="comment">#RAD_1      506 non-null int64</span></span><br><span class="line"><span class="comment">#RAD_2      506 non-null int64</span></span><br><span class="line"><span class="comment">#RAD_3      506 non-null int64</span></span><br><span class="line"><span class="comment">#RAD_4      506 non-null int64</span></span><br><span class="line"><span class="comment">#RAD_5      506 non-null int64</span></span><br><span class="line"><span class="comment">#RAD_6      506 non-null int64</span></span><br><span class="line"><span class="comment">#RAD_7      506 non-null int64</span></span><br><span class="line"><span class="comment">#RAD_8      506 non-null int64</span></span><br><span class="line"><span class="comment">#RAD_9      506 non-null int64</span></span><br><span class="line"><span class="comment">#RAD_-1     506 non-null int64</span></span><br><span class="line"><span class="comment">#TAX        506 non-null float64</span></span><br><span class="line"><span class="comment">#PTRATIO    506 non-null float64</span></span><br><span class="line"><span class="comment">#B          506 non-null float64</span></span><br><span class="line"><span class="comment">#LSTAT      506 non-null float64</span></span><br><span class="line"><span class="comment">#dtypes: float64(11), int64(13)</span></span><br><span class="line"><span class="comment">#memory usage: 95.0 KB</span></span><br><span class="line"></span><br><span class="line">numeric_dataset.head()</span><br><span class="line"><span class="comment">#      CRIM    ZN  INDUS  CHAS_1  CHAS_2  ...  RAD_-1    TAX  PTRATIO       B  LSTAT</span></span><br><span class="line"><span class="comment">#0  0.00632  18.0   2.31       1       0  ...       0  296.0     15.3  396.90   4.98</span></span><br><span class="line"><span class="comment">#1  0.02731   0.0   7.07       1       0  ...       0  242.0     17.8  396.90   9.14</span></span><br><span class="line"><span class="comment">#2  0.02729   0.0   7.07       1       0  ...       0  242.0     17.8  392.83   4.03</span></span><br><span class="line"><span class="comment">#3  0.03237   0.0   2.18       1       0  ...       0  222.0     18.7  394.63   2.94</span></span><br><span class="line"><span class="comment">#4  0.06905   0.0   2.18       1       0  ...       0  222.0     18.7  396.90   5.33</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#[5 rows x 24 columns]</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://blog.csdn.net/weixin_42422585/article/details/83542722" target="_blank" rel="noopener">Python类别变量处理</a></li>
</ul>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>检验 | 卡方检验</title>
    <url>/%E6%A3%80%E9%AA%8C-%E5%8D%A1%E6%96%B9%E6%A3%80%E9%AA%8C.html</url>
    <content><![CDATA[<p><center>$\chi^2$-test</center><br><a id="more"></a></p>
<h1 id="卡方检验"><a href="#卡方检验" class="headerlink" title="卡方检验"></a>卡方检验</h1><ul>
<li>用于检验单个正态总体方差</li>
</ul>
<p>假设$x_1,\cdots,x_n$是来自正态总体$N(\mu,\sigma^2)$的样本，对方差考虑如下三个检验问题：</p>
<ol>
<li><script type="math/tex; mode=display">H_0:\sigma^2 \leq \sigma_0^2 \quad \mathrm{vs} \quad H_1:\sigma^2 > \sigma^2_0</script></li>
<li><script type="math/tex; mode=display">H_0:\sigma^2 \geq \sigma_0^2 \quad \mathrm{vs} \quad H_1:\sigma^2 < \sigma^2_0</script></li>
<li><script type="math/tex; mode=display">H_0:\sigma^2 = \sigma_0^2 \quad \mathrm{vs} \quad H_1:\sigma^2 \neq \sigma^2_0</script></li>
</ol>
<p>其中$\sigma_0^2$是已知常数。通常假定$\mu$未知。</p>
<p>以上假设检验采用的<strong>检验统计量</strong>为</p>
<script type="math/tex; mode=display">\chi^2=(n-1)\frac{s^2}{\sigma_0^2}</script><p>当$\sigma^2=\sigma_0^2$时，有$\chi^2\sim \chi^2(n-1)$。</p>
<p>若取显著性水平为$\alpha$，则对应三个检验问题的拒绝域分别为</p>
<script type="math/tex; mode=display">W_1=\{\chi^2\geq \chi^2_{1-\alpha}(n-1)\}</script><script type="math/tex; mode=display">W_2=\{\chi^2\leq \chi^2_\alpha(n-1)\}</script><script type="math/tex; mode=display">W_3=\{\chi^2 \leq \chi^2_{\frac{\alpha}{2}}(n-1)\}或\{\chi^2 \geq \chi_{1-\frac{\alpha}{2}}(n-1)\}</script><ul>
<li>$\chi^2$分布是偏态分布</li>
</ul>
<p>三个检验问题的p值分别为</p>
<script type="math/tex; mode=display">p_1=P(\chi^2\geq \chi_0^2)</script><script type="math/tex; mode=display">p_2=P(\chi^2\leq \chi_0^2)</script><script type="math/tex; mode=display">p_3=2\min\left\{P(\chi\geq \chi^2_0), P(\chi^2\leq \chi^2_0) \right\}</script><h1 id="chi-2-拟合优度检验"><a href="#chi-2-拟合优度检验" class="headerlink" title="$\chi^2$拟合优度检验"></a>$\chi^2$拟合优度检验</h1><p>分类数据的$\chi^2$拟合优度检验</p>
<p>根据某项指标，总体被分为$K$类：$A_1,A_2,\cdots,A_K$。关心各类元素在总体中所占的比率：</p>
<script type="math/tex; mode=display">H_0:A_i所占的比率是$p_{i0},\quad i=1,\cdots,K.</script><p>其中，$p_{i0}$已知且满足$\sum_{i=1}^Kp_{i0}=1$。</p>
<p>记$x_1,\cdots,x_n$是从该总体抽出的样本，且其中属于$A_i$类别的样本数为$n_i$。</p>
<p>当零假设$H_0$成立时，在$n$个样本中属于$A_i$类的“理论个数”/“期望个数”为$np_{i0}$，而实际观测得到的值是$n_i$，当$H_0$成立时，$n_i$与$np_{i0}$应相差不大。因此，使用统计量（Pearson提出的）</p>
<script type="math/tex; mode=display">\chi^2=\sum_{i=1}^K\frac{(n_i-np_{i0})^2}{np_{i0}}</script><p>来衡量“理论个数”$np_{i0}$与实际个数$n_i$间的差异。</p>
<p>当$H_0$为真时，该统计量的值应该比较小。因此，拒绝域为</p>
<script type="math/tex; mode=display">\{\chi^2\geq c\}</script><p>其中$c$为待确定的临界值。</p>
<div class="note success">
            <p><strong>定理*</strong></p><p>在前述各项假定下，在$H_0$成立时，检验统计量$\chi^2=\sum_{i=1}^K\frac{(n_i-np_{i0})^2}{np_{i0}}$有</p><script type="math/tex; mode=display">\chi^2\stackrel{L}{\longrightarrow} \chi^2(K-1)</script>
          </div>
<p>显著性水平为$\alpha$时检验的拒绝域为</p>
<script type="math/tex; mode=display">W=\{\chi^2\geq \chi^2_{1-\alpha}(K-1)\}</script><p>在实际问题中，第$i$类$A_i$出现的概率$p_{i}$并不一定已知，可以先用最大似然估计方法估计出$p_{i}$依赖的参数（$r$个），然后再算出$p_{i}$的估计值$\hat{p}_i$，则统计量为</p>
<script type="math/tex; mode=display">\chi^2=\sum_{i=1}^K\frac{(n_i-n\hat{p}_i)^2}{n\hat{p}_i}</script><p>当$n\rightarrow \infty$时，该统计量渐近服从自由度为$K-r-1$的$\chi^2$分布。</p>
<p>上述两个检验统计量主要用于大样本场合，在实际应用中，一般要求各类的观测数均不小于5。当有些类的样本数不满足要求时，需要将一些相邻的类合并以达到要求。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://book.douban.com/subject/5998092/" target="_blank" rel="noopener">概率论与数理统计教程</a></li>
</ul>
]]></content>
      <categories>
        <category>Statistics</category>
      </categories>
      <tags>
        <tag>概率统计基础</tag>
        <tag>检验</tag>
      </tags>
  </entry>
  <entry>
    <title>Machine Learning | Apriori算法</title>
    <url>/%E7%AE%97%E6%B3%95-Apriori.html</url>
    <content><![CDATA[<p><center></center><br><a id="more"></a></p>
<h1 id="Apriori"><a href="#Apriori" class="headerlink" title="Apriori"></a>Apriori</h1><ul>
<li>常用于挖掘<strong>数据关联规则</strong></li>
<li>其他<strong>关联规则挖掘算法</strong>有：PrefixSpan、CBA</li>
</ul>
<blockquote>
<p>在超市购物数据集、电商购物数据集，找出了频繁出现的数据集，则可以优化超市产品的位置摆放、优化电商商品所在的仓库位置，从而节约成本，增加经济效益</p>
</blockquote>
<div class="note warning">
            <p><strong>项集</strong>（Itemset）：包含0个或多个项的集合。</p><p>如果包含$k$个项，则称为$k-$<strong>项集</strong>。</p>
          </div>
<ul>
<li><strong>空集</strong>是不包含任何项的项集</li>
</ul>
<div class="note default">
            <p>以经典的“啤酒-尿布”案例为例，某位顾客到超市购买的物品清单</p><p><center>{牛奶，尿布，可乐，啤酒}</center><br>就是一个项集。其中{牛奶}、{尿布}等都是数据项。该项集的长度为4，称为4-项集。</p>
          </div>
<h2 id="频繁项集"><a href="#频繁项集" class="headerlink" title="频繁项集"></a>频繁项集</h2><p>常见的频繁项集(Frequent Itemset)的评估标准：</p>
<ol>
<li>支持度</li>
<li>置信度</li>
<li>提升度</li>
</ol>
<p>一般情况下，要选择一个数据集合中的频繁项集，则需要自定义评估标准。如：</p>
<ul>
<li>自定义的支持度</li>
<li>自定义支持度和置信度的一个组合</li>
</ul>
<p><strong>强规则</strong>：同时满足最小支持度阈值（minsup）和最小置信度阈值（minconf）的规则。</p>
<div class="note warning">
            <h3 id="支持度Support"><a href="#支持度Support" class="headerlink" title="支持度Support"></a>支持度Support</h3><ul><li>几个关联的数据在数据集中出现的次数占总数据集的比重</li><li>或，几个数据关联出现的概率</li><li>或，同时包含事务$A$和事务$B$的事务占所有事务的比例<script type="math/tex; mode=display">Support=P(A\&B)</script></li></ul>
          </div>
<ul>
<li>支持度高的数据不一定构成频繁项集，但是支持度太低的数据肯定不构成频繁项集</li>
</ul>
<div class="note default">
            <p>考虑多个顾客，每个顾客的购物清单是一个项集</p><p><center>{牛奶，可乐，啤酒，纸巾}</center></p><p><center>{面包，牛奶，鸡蛋}</center></p><p><center>{啤酒，鸡蛋，可乐，尿布}</center></p><p><center>{牛奶，啤酒，尿布}</center></p><p><center>{面包，牛奶，尿布，啤酒}</center></p><p><center>{尿布，啤酒，可乐，纸巾}</center><br>{尿布}和{啤酒}同时出现4次，一共有6个项集，则{尿布，啤酒}的支持度为</p><script type="math/tex; mode=display">Support(尿布\&啤酒)=\frac{4}{6}=\frac{2}{3}</script>
          </div>
<div class="note warning">
            <h3 id="置信度Confidence"><a href="#置信度Confidence" class="headerlink" title="置信度Confidence"></a>置信度Confidence</h3><ul><li>体现一个数据出现后，另一个数据出现的概率<script type="math/tex; mode=display">Confidence(X\rightarrow Y)=\frac{\{X,Y\}同时出现}{出现X}</script></li><li>或，数据的条件概率</li><li>或，同时包含$A$和$B$的事务占包含$A$事务的比例<script type="math/tex; mode=display">Confidence(A\rightarrow B)=\frac{P(A\&B)}{P(A)}</script></li></ul>
          </div>
<div class="note default">
            <script type="math/tex; mode=display">Confidence(啤酒\rightarrow尿布)=\frac{Support(尿布\&啤酒)}{P(啤酒)}=\frac{2}{3}/\frac{5}{6}=\frac{4}{5}</script>
          </div>
<div class="note warning">
            <h3 id="提升度Lift"><a href="#提升度Lift" class="headerlink" title="提升度Lift"></a>提升度Lift</h3><ul><li>表示含有$X$的条件下，同时含有$Y$的概率，与$Y$总体发生的概率之比<script type="math/tex; mode=display">Lift(X\rightarrow Y)=\frac{P(Y|X)}{P(Y)}=\frac{P(XY)}{P(X)P(Y)}</script></li><li>或，“包含事务$A$的事务中同时包含事务$B$的比例”与“包含事务$B$的比例”的比值<script type="math/tex; mode=display">Lift(A\rightarrow B)=\frac{Confidence(A\rightarrow B)}{P(B)}=\frac{P(A\&B)}{P(A)P(B)}</script></li></ul>
          </div>
<div class="note default">
            <script type="math/tex; mode=display">Lift(啤酒\rightarrow尿布)=\frac{Confidence(啤酒\rightarrow尿布)}{P(尿布)}=\frac{4}{5}/\frac{4}{6}=\frac{6}{5}>1</script>
          </div>
<ul>
<li>提升度反映了关联规则中$A$与$B$的<strong>相关性</strong><ul>
<li>提升度$&gt;1$且越高表明正相关性越高，则$A\rightarrow B$是有效的强关联规则</li>
<li>提升度$&lt;1$且越低表明负相关性越高，则$A\rightarrow B$是无效的强关联规则</li>
<li>提升度$=1$表明没有相关性，此时<script type="math/tex; mode=display">P(B|A)=P(B)</script></li>
</ul>
</li>
</ul>
<p>Apriori算法的目标是<u>找到最大的$k$项频繁集</u></p>
<ul>
<li>首先找到符合支持度标准的频繁项集</li>
<li>其次从中找到最大个数的频繁项集</li>
</ul>
<p>Apriori算法采用<strong>迭代</strong>的方法，先搜索出候选1-项集及对应的支持度</p>
<p>未完待续</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://www.cnblogs.com/pinard/p/6293298.html" target="_blank" rel="noopener">Apriori算法原理总结</a></li>
<li><a href="https://blog.csdn.net/Pizza_great/article/details/101224098" target="_blank" rel="noopener">机器学习之关联规则（支持度和置信度、Apriori算法）</a></li>
<li><a href="https://blog.csdn.net/DD18203614685/article/details/98057386" target="_blank" rel="noopener">关联规则、支持度（support）、置信度（confidence）</a></li>
<li><a href="https://www.jianshu.com/p/dc053deb94f2" target="_blank" rel="noopener">数据挖掘关联分析中的支持度、置信度和提升度</a></li>
</ul>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Machine Learning | 隐马尔可夫模型</title>
    <url>/%E7%AE%97%E6%B3%95-HMM.html</url>
    <content><![CDATA[<p><center>Hidden Markov Model</center><br><a id="more"></a></p>
<h1 id="HMM"><a href="#HMM" class="headerlink" title="HMM"></a>HMM</h1><p>隐马尔可夫模型是关于<strong>时序</strong>的概率模型。</p>
<ul>
<li>用来描述一个含有隐含未知参数的马尔可夫过程</li>
<li>是可用于标注问题的统计学习模型</li>
<li><a href="/%E7%94%9F%E6%88%90%E5%BC%8F%E6%A8%A1%E5%9E%8B-%E5%88%A4%E5%88%AB%E5%BC%8F%E6%A8%A1%E5%9E%8B.html" title="生成式模型">生成式模型</a></li>
<li>隐马尔可夫模型由<strong>初始概率分布</strong>、<strong>状态转移概率分布</strong>以及<strong>观测概率分布</strong>确定。</li>
<li>HMM在语言识别、自然语言处理、模式识别等领域得到广泛的应用</li>
<li>HMM适用的问题：<ol>
<li>问题是基于序列的（如时间序列，或状态序列）</li>
<li>问题中有两类数据，一类序列数据是可以观测到的（<strong>观测序列</strong>），另一类数据是不可观测的（<strong>隐藏状态序列</strong>，简称<strong>状态序列</strong>）</li>
</ol>
</li>
</ul>
<p>隐马尔可夫模型描述由一个隐藏的马尔可夫链随机生成不可观测的状态随机序列，再由各个状态生成一个观测而产生观测随机序列的过程。</p>
<ul>
<li><strong>状态序列</strong>（state sequence）：隐藏的马尔可夫链随机生成的状态的序列</li>
<li><strong>观测序列</strong>（observation sequence）：每个状态生成一个观测，而由此产的观测的随机序列</li>
<li>序列的每一个位置又可以看作是一个时刻</li>
</ul>
<div class="note warning">
            <p>假设：</p><ul><li>$Q$是所有可能的隐藏状态的集合<script type="math/tex; mode=display">Q=\{q_1, q_2,\cdots, q_N\}</script>其中，$N$是可能的隐藏状态数。</li><li>$V$是所有可能的观测状态的集合<script type="math/tex; mode=display">V=\{v_1,v_2,\cdots,v_M\}</script>其中，$M$是可能的观测状态数。</li></ul><p>对于一个长度为$T$的序列，</p><ul><li>$I$是对应的状态序列<script type="math/tex; mode=display">I=\{i_1,i_2,\cdots, i_T\}</script></li><li>$O$是对应的观测序列<script type="math/tex; mode=display">O=\{o_1,o_2,\cdots,o_T\}</script>其中，$\forall i_t\in Q,\quad \forall o_t\in V$。</li></ul>
          </div>
<p>隐马尔可夫模型由<strong>初始概率分布</strong>、<strong>状态转移概率分布</strong>以及<strong>观测概率分布</strong>确定。</p>
<div class="note warning">
            <p>在时刻$t=1$的隐藏状态概率分布为</p><script type="math/tex; mode=display">\Pi=\left(\pi_i\right)_{N\times 1}</script><p>其中，</p><script type="math/tex; mode=display">\pi_i=P(i_1=q_i)</script><p>$i=1,\cdots,N$。</p>
          </div>
<h2 id="基本假设"><a href="#基本假设" class="headerlink" title="基本假设"></a>基本假设</h2><p>HMM作了两个基本假设<br><div class="note info">
            <h3 id="齐次马尔可夫性假设"><a href="#齐次马尔可夫性假设" class="headerlink" title="齐次马尔可夫性假设"></a>齐次马尔可夫性假设</h3><p>假设马尔可夫链在任意时刻$t$的隐藏状态只依赖于其前一时刻的状态，与其他时刻的状态及观测无关，也与时刻$t$无关。</p>
          </div><br>基于该假设，有<br><div class="note warning">
            <p>如果在时刻$t$的隐藏状态为$i_t=q_i$，在时刻$t+1$的隐藏状态为$i_{t+1}=q_j$，则从时刻$t$到时刻$t+1$的HMM状态转移概率$a_{ij}$为</p><script type="math/tex; mode=display">a_{ij}=P(i_{t+1}=q_j|i_t=q_i)</script><p>其中$i=1,\cdots,N;j=1,\cdots,N$。</p><p>马尔可夫链的状态转移概率矩阵为</p><script type="math/tex; mode=display">A=\left[a_{ij} \right]_{N\times N}</script>
          </div></p>
<div class="note info">
            <h3 id="观测独立性假设"><a href="#观测独立性假设" class="headerlink" title="观测独立性假设"></a>观测独立性假设</h3><p>假设任意时刻的观测状态只依赖于该时刻的隐藏状态，与其他观测及状态无关。</p>
          </div>
<p>基于该假设，有<br><div class="note warning">
            <p>如果在时刻$t$的隐藏状态为$i_t=q_j$，而对应的观测状态为$o_t=v_k$，则该时刻观测状态$v_k$在隐藏状态$q_j$下生成的概率为$b_j(k)$，满足</p><script type="math/tex; mode=display">b_j(k)=P\left(o_t=v_k|i_t=q_j\right)</script><p>其中$k=1,\cdots,M;j=1,\cdots,N$。</p><p>则观测状态生成的概率矩阵为</p><script type="math/tex; mode=display">B=\left[b_j(k) \right]_{N\times M}</script>
          </div></p>
<p>隐马尔可夫模型由<strong>初始状态概率向量</strong>$\Pi$、<strong>状态转移概率矩阵</strong>$A$以及<strong>观测概率矩阵</strong>$B$确定。</p>
<ul>
<li>$\Pi$和$A$决定状态序列</li>
<li>$B$决定观测序列</li>
</ul>
<p>隐马尔可夫模型科用三元组表示：</p>
<script type="math/tex; mode=display">\lambda=(A,B,\Pi)</script><p>$A,B,\Pi$称为隐马尔可夫模型的<strong>三要素</strong>。</p>
<div class="note danger">
            <h2 id="算法：观测序列的生成"><a href="#算法：观测序列的生成" class="headerlink" title="算法：观测序列的生成"></a>算法：观测序列的生成</h2><p><strong>输入</strong>：</p><ul><li>隐马尔可夫模型$\lambda=(A,B,\Pi)$</li><li>观测序列的长度$T$</li></ul><p><strong>输出</strong>：观测序列$O=\{o_1,\cdots,o_T\}$</p><ol><li>根据初始状态概率分布$\Pi$生成隐藏状态$i_1$</li><li>对于$t=1,\cdots,T$，<ol><li>按照隐藏状态$i_t$的观测状态分布$b_{i_t}(k)$生成观测状态$o_t$</li><li>按照隐藏状态$i_t$的状态转移概率分布$a_{i_t,i_{t+1}}$产生隐藏状态$i_{t+1}\quad (i_{t+1}=1,\cdots,N)$</li></ol></li></ol>
          </div>
<h2 id="基本问题"><a href="#基本问题" class="headerlink" title="基本问题"></a>基本问题</h2><p>隐马尔可夫模型有三个经典的基本问题需要解决：</p>
<ol>
<li><strong>概率计算问题</strong><ul>
<li>给定模型$\lambda=(A,B,\Pi)$和观测序列$O=\{o_1,\cdots,o_T\}$，计算在模型$\lambda$下观测序列$O$出现的概率$P(O|\lambda)$</li>
<li>用<strong>前向后向算法</strong></li>
</ul>
</li>
<li><strong>模型参数学习问题</strong><ul>
<li>给定观测序列$O=\{o_1,\cdots,o_T\}$，估计模型$\lambda=(A,B,\Pi)$的参数，使得在该模型下观测序列的条件概率$P(O|\lambda)$最大</li>
<li>用<strong>极大似然估计</strong>的方法估计参数</li>
<li>用<strong>基于EM算法的Baum-Welch算法</strong></li>
</ul>
</li>
<li><strong>预测问题/解码（decoding）问题</strong><ul>
<li>给定模型$\lambda=(A,B,\Pi)$和观测序列$O=\{o_1,\cdots,o_T\}$，求给定观测序列条件该概率$P(I|O)$下，最可能出现的对应的状态序列$I=\{i_1,\cdots,i_T\}$</li>
<li>用<strong>基于动态规划的维特比算法</strong></li>
</ul>
</li>
</ol>
<h1 id="概率计算问题"><a href="#概率计算问题" class="headerlink" title="概率计算问题"></a>概率计算问题</h1><p>给定模型$\lambda=(A,B,\Pi)$和观测序列$O=\{o_1,\cdots,o_T\}$，计算观测序列$O$在模型$\lambda$下出现的条件概率$P(O|\lambda)$。</p>
<div class="note danger">
            <h2 id="直接计算法"><a href="#直接计算法" class="headerlink" title="直接计算法"></a>直接计算法</h2><p>列举所有可能出现的长度为$T$的隐藏序列$I=\{i_1,i_2,\cdots,i_T\}$，分别求出各个状态序列$I$与观测序列$O=\{o_1,o_2,\cdots,o_T\}$的联合概率分布$P(O,I|\lambda)$，然后对所有可能的状态序列求和，得到边缘分布$P(O|\lambda)$。</p>
          </div>
<p>任意一个隐藏序列$I=\{i_1,i_2,\cdots,i_T\}$出现的概率是</p>
<script type="math/tex; mode=display">P(I|\lambda)=\pi_{i_1}a_{i_1i_2}a_{i_2i_3}\cdots a_{i_{T-1}i_T}</script><p>对固定的状态序列$I=\{i_1,i_2,\cdots,i_T\}$，（要求的）观测序列$O=\{o_1,o_2,\cdots,o_T\}$出现的概率是</p>
<script type="math/tex; mode=display">P(O|I,\lambda)=b_{i_1}(o_1)b_{i_2}(o_2)\cdots b_{i_T}(o_T)</script><p>则$O$和$I$同时出现的联合概率为<br>\begin{aligned}<br>P(O,I|\lambda) &amp;= P(I|\lambda)P(O|I,\lambda)\\<br>&amp;= \pi_{i_1}b_{i_1}(o_1)a_{i_1i_2}b_{i_2}(o_2)\cdots a_{i_{T-1}i_T}b_{i_T}(o_T)<br>\end{aligned}</p>
<p>然后对所有可能的状态序列$I$求和，得到观测序列$O$的边缘概率<br>\begin{aligned}<br>P(O|\lambda) &amp;= \sum_I P(O,I|\lambda)\\<br>&amp;= \sum_{I}P(O|I,\lambda)P(I|\lambda)\\<br>&amp;= \sum_{i_1,i_2,\cdots,i_T}\pi_{i_1}b_{i_1}(o_1)a_{i_1i_2}b_{i_2}(o_2)\cdots a_{i_{T-1}i_T}b_{i_T}(o_T)<br>\end{aligned}</p>
<ul>
<li>预测状态有$N^T$种组合</li>
<li>算法的时间复杂度为$O(TN^T)$</li>
</ul>
<p>对于一些隐藏状态数极少的模型，可以使用上述“暴力求解”法来求解观测序列出现的概率。但是，如果隐藏状态多，上述算法太过耗时，则应考虑<strong>前向后向算法</strong>。</p>
<div class="note warning">
            <p><strong>前向概率</strong>：</p><p>给定隐马尔可夫模型$\lambda$，定义时刻$t$的隐藏状态为$q_i$，观测状态序列为$o_1,o_2,\cdots,o_t$的概率为前向概率。记为</p><script type="math/tex; mode=display">\alpha_t(i)=P(o_1,o_2,\cdots,o_t,i_t=q_i|\lambda)</script>
          </div>
<p>假设已经找到在时刻$t$时各个隐藏状态的前向概率，需要递推初时刻$t+1$时各个隐藏状态的前向概率。</p>
<p>基于时刻$t$时各个隐藏状态的前向概率$\alpha_t(j)$，乘以对应的状态转移概率$a_{ji}$，得到时刻$t$隐藏状态为$q_j$、时刻$t+1$隐藏状态为$q_i$的概率$\alpha_t(j)a_{ji}$；对所有$j$求和，得到时刻$t+1$观测序列为$o_1,o_2,\cdots,o_t,o_{t+1}$且隐藏状态为$q_i$的概率$\alpha_t(j)a_{ji}$。</p>
<p>因为观测状态$o_{t+1}$只依赖于$t+1$时刻的隐藏状态$q_i$，所以$\left[\sum_{j=1}^N\alpha_t(j)a_{ji} \right]b_i(o_{t+1})$为在时刻$t+1$观测到$o_1,o_2,\cdots,o_t,o_{t+1}$且时刻$t+1$的隐藏状态为$q_i$的前向概率。所以前向概率的递推关系式为</p>
<script type="math/tex; mode=display">\alpha_{t+1}(i)=\left[\sum_{j=1}^N\alpha_t(j)a_{ji} \right]b_i(o_{t+1})</script><p>$\alpha_T(i)$表示在时刻$T$观测序列为$o_1,o_2,\cdots,o_T$，且时刻$T$隐藏状态为$q_i$的概率，所以$\sum_{i=1}^N\alpha_T(i)$表示在时刻$T$观测序列为$o_1,o_2,\cdots,o_T$的概率。</p>
<p><meta name="referrer" content="no-referrer"><br><img src="/%E7%AE%97%E6%B3%95-HMM/forward.png" class title="来自[刘建平Pinard-隐马尔科夫模型HMM（二）前向后向算法评估观察序列概率]"></p>
<div class="note danger">
            <h2 id="前向算法"><a href="#前向算法" class="headerlink" title="前向算法"></a>前向算法</h2><p><strong>输入</strong>：</p><ul><li>隐马尔可夫模型$\lambda$</li><li>观测序列$O$</li></ul><p><strong>输出</strong>：观测序列概率$P(O|\lambda)$</p><script type="math/tex; mode=display">P(O|\lambda)=\sum_{i=1}^N\alpha_T(i)</script><ol><li>计算时刻$1$的各个隐藏状态前向概率$(i=1,2,\cdots,N)$<script type="math/tex; mode=display">\alpha_1(i)=\pi_ib_i(o_1)</script></li><li>递推：对$t=1,2, \cdots, T-1$<script type="math/tex; mode=display">\alpha_{t+1}(i)=\left[\sum_{j=1}^N\alpha_t(j)a_{ji} \right]b_i(o_{t+1})</script>$i=1,2,\cdots,N$。</li></ol>
          </div>
<ul>
<li>前向算法本质上属于<strong>动态规划</strong>的算法</li>
<li>通过找到局部状态递推的公式，从子问题的最优解拓展到整个问题的最优解</li>
<li>前向算法的时间复杂度为$O(TN^2)$</li>
</ul>
<div class="note warning">
            <p><strong>后向概率</strong>：</p><p>给定隐马尔可夫模型$\lambda$，定义时刻$t$时隐藏状态为$q_i$，从时刻$t+1$到最后时刻$T$的观测状态序列为$o_{t+1},o_{t+2},\cdots,o_T$的概率为后向概率。记为</p><script type="math/tex; mode=display">\beta_t(i)=P(o_{t+1},o_{t+2},\cdots,o_T|i_t=q_i, \lambda)</script>
          </div>
<p>假设已经找到在时刻$t+1$时各个隐藏状态的后向概率$\beta_{t+1}(j)$，需要递推初时刻$t$的各个隐藏状态的后向概率。</p>
<p>可以计算出观测状态序列为$o_{t+2},o_{t+3},\cdots,o_T$、$t$时隐藏状态为$q_i$、$t+1$时隐藏状态为$q_j$的概率为$a_{ij}\beta_{t+1}(j)$；则观测状态序列为$o_{t+1},o_{t+2},o_{t+3},\cdots,o_T$、$t$时隐藏状态为$q_i$、$t+1$时隐藏状态为$q_j$的概率为$a_{ij}b_j(o_{t+1})\beta_{t+1}(j)$；将$t+1$时所有隐藏状态概率加总，得到观测状态序列为$o_{t+1},o_{t+2},o_{t+3},\cdots,o_T$、$t$时隐藏状态为$q_i$的概率为$\sum_{j=1}^Na_{ij}b_j(o_{t+1})\beta_{t+1}(j)$，即时刻$t$的后向概率。</p>
<p><meta name="referrer" content="no-referrer"><br><img src="/%E7%AE%97%E6%B3%95-HMM/backward.png" class title="来自[刘建平Pinard-隐马尔科夫模型HMM（二）前向后向算法评估观察序列概率]"></p>
<div class="note danger">
            <h2 id="后向算法"><a href="#后向算法" class="headerlink" title="后向算法"></a>后向算法</h2><p><strong>输入</strong>：</p><ul><li>隐马尔可夫模型$\lambda$</li><li>观测序列$O$</li></ul><p><strong>输出</strong>：观测序列概率$P(O|\lambda)$</p><script type="math/tex; mode=display">P(O|\lambda)=\sum_{i=1}^N\pi_ib_i(o_1)\beta_1(i)</script><ol><li>初始化时刻$T$的各个隐藏状态后向概率<script type="math/tex; mode=display">\beta_T(i)=1</script>$i=1,2,\cdots,N$。</li><li>递推：对于$t=T-1,T-2,\cdots,1$，计算<script type="math/tex; mode=display">\beta_t(i)=\sum_{j=1}^Na_{ij}b_j(o_{t+1})\beta_{t+1}(j)</script>$i=1,2,\cdots,N$。</li></ol>
          </div>
<ul>
<li>后向算法本质上也是属于<strong>动态规划</strong>的算法</li>
<li>后向算法的时间复杂度为$O(TN^2)$</li>
</ul>
<div class="note warning">
            <h2 id="常用概率计算"><a href="#常用概率计算" class="headerlink" title="常用概率计算"></a>常用概率计算</h2><p>给定隐马尔可夫模型$\lambda$和观测序列$O$，</p><ul><li>在时刻$t$处于状态$q_i$的概率为<br>\begin{aligned}<br>\gamma_t(i)&amp;=P(i_t=q_i|O,\lambda)\\<br>&amp;=\frac{P(i_t=q_i,O|\lambda)}{P(O|\lambda)}\\<br>&amp;= \frac{\alpha_t(i)\beta_t(i)}{\sum_{j=1}^N\alpha_t(j)\beta_t(j)}<br>\end{aligned}</li><li>在时刻$t$处于状态$q_i$、时刻$t+1$处于状态$q_j$的概率为<br>\begin{aligned}<br>\xi_t(i,j)&amp;=P(i_t=q_i,i_{t+1}=q_j|O,\lambda)\\<br>&amp;= \frac{P(i_t=q_i,i_{t+1}=q_j,O|\lambda)}{P(O|\lambda)}\\<br>&amp;= \frac{\alpha_t(i)a_{ij}b_j(o_{t+1})\beta_{t+1}(j)}{\sum_{r=1}^N\sum_{s=1}^N\alpha_t(r)a_{rs}b_s(o_{t+1})\beta_{t+1}(s)}<br>\end{aligned}</li><li>在观测序列$O$下<ul><li>状态$i$出现的期望值为<script type="math/tex; mode=display">\sum_{t=1}^T\gamma_t(i)</script></li><li>由状态$i$转移的期望值<script type="math/tex; mode=display">\sum_{t=1}^{T-1}\gamma_t(i)</script></li><li>由状态$i$转移到状态$j$的期望值<script type="math/tex; mode=display">\sum_{t=1}^{T-1}\xi_t(i,j)</script></li></ul></li></ul>
          </div>
<h1 id="参数学习问题"><a href="#参数学习问题" class="headerlink" title="参数学习问题"></a>参数学习问题</h1><p>隐马尔可夫模型的参数求解根据<u>已知条件</u>可分为两种情况：</p>
<ol>
<li>已知观测序列和对应的隐藏状态序列，可用<strong>极大似然估计法</strong>来求解模型参数</li>
<li>只有观测序列，而无法得到对应的隐藏状态序列，可用<strong>基于EM算法的Baum-Welch算法</strong>（鲍姆-韦尔奇算法）来求解模型参数</li>
</ol>
<p>对于<strong>第一种情况</strong>：<br>已知$D$个长度为$T$的观测序列和对应的隐藏序列</p>
<script type="math/tex; mode=display">\left\{(O_1,I_1,),(O_2,I_2), \cdots, (O_D,I_D) \right\}</script><div class="note danger">
            <h2 id="极大似然估计"><a href="#极大似然估计" class="headerlink" title="极大似然估计"></a>极大似然估计</h2><ul><li>假设样本从隐藏状态$q_i$转移到$q_j$的频率计数是$A_{ij}$，则状态转移矩阵为<script type="math/tex; mode=display">A=\left[a_{ij} \right]_{N\times N}</script>其中<script type="math/tex; mode=display">a_{ij}=\frac{A_{ij}}{\sum_{s=1}^NA_{is}}</script></li><li>假设样本隐藏状态为$q_j$且观测状态为$v_k$的频率计数是$B_{jk}$，则观测状态概率矩阵为<script type="math/tex; mode=display">B=\left[b_j(k) \right]_{N\times M}</script>其中<script type="math/tex; mode=display">b_j(k)=\frac{B_{jk}}{\sum_{s=1}B_{js}}</script></li><li>假设所有样本种初始隐藏状态为$q_i$的频率计数为$C(i)$，则初始概率分布为<script type="math/tex; mode=display">\Pi=\left[\pi(i) \right]_{N\times 1}</script>其中<script type="math/tex; mode=display">\pi(i)=\frac{C(i)}{\sum_{s=1}^NC(s)}</script></li></ul>
          </div>
<p>对于<strong>第二种情况</strong>：<br>只有$D$个长度为$T$的观测序列</p>
<script type="math/tex; mode=display">\{(O_1),(O_2),\cdots,(O_D)\}</script><p>基于EM算法的Baum-Welch算法：</p>
<ul>
<li>E步：基于条件概率$P(I|O,\overline{\lambda})$求出联合分布$P(O,I|\lambda)$<br>其中$\overline{\lambda}$为当前的模型参数</li>
<li>M步：最大化联合分布$P(O,I|\lambda)$的期望，得到更新的模型参数$\lambda$</li>
</ul>
<p>不停地进行EM迭代，直到模型参数的值收敛为止。</p>
<div class="note danger">
            <h2 id="Baum-Welch算法"><a href="#Baum-Welch算法" class="headerlink" title="Baum-Welch算法"></a>Baum-Welch算法</h2>
          </div>
<h1 id="预测问题"><a href="#预测问题" class="headerlink" title="预测问题"></a>预测问题</h1><p>未完待续</p>
<h1 id="笔试题目"><a href="#笔试题目" class="headerlink" title="笔试题目"></a>笔试题目</h1><div class="note default">
            <p>在HMM中,如果已知观察序列和产生观察序列的状态序列,那么可用以下哪种方法直接进行参数估计(D)<br>A. EM算法<br>B. 维特比算法<br>C. 前向后向算法<br>D. 极大似然估计</p><p>[<font face="宋体" color="grey">来自：<a href="https://www.nowcoder.com/questionTerminal/dc4e7ad7e9634b65b56f2541a580eba0" target="_blank" rel="noopener">牛客试题广场</a></font>]</p>
          </div>
<ul>
<li>EM算法：只有观测序列，无状态序列时，用于学习模型参数，即Baum-Welch算法</li>
<li>维特比算法：用动态规划解决HMM的预测问题，不是参数估计</li>
<li>前向后向算法：用于算概率</li>
<li>极大似然估计：预测序列和相应的状态序列都存在时的监督学习算法，用来估计参数</li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://book.douban.com/subject/10590856/" target="_blank" rel="noopener">李航-统计学习方法</a></li>
<li><a href="https://www.cnblogs.com/skyme/p/4651331.html" target="_blank" rel="noopener">一文搞懂HMM（隐马尔可夫模型）</a></li>
<li><a href="https://www.cnblogs.com/pinard/p/6945257.html" target="_blank" rel="noopener">刘建平Pinard-隐马尔科夫模型HMM（一）HMM模型</a></li>
<li><a href="https://www.cnblogs.com/pinard/p/6955871.html" target="_blank" rel="noopener">刘建平Pinard-隐马尔科夫模型HMM（二）前向后向算法评估观察序列概率</a></li>
<li><a href="https://www.cnblogs.com/pinard/p/6972299.html" target="_blank" rel="noopener">隐马尔科夫模型HMM（三）鲍姆-韦尔奇算法求解HMM参数</a></li>
</ul>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>机器学习</tag>
        <tag>生成式模型</tag>
      </tags>
  </entry>
  <entry>
    <title>Machine Learning | BIRCH</title>
    <url>/%E7%AE%97%E6%B3%95-BIRCH.html</url>
    <content><![CDATA[<p><center>Balanced Iterative Reducing and Clustering Using Hierarchies</center><br><a id="more"></a></p>
<p>利用层次方法的平衡迭代规约和聚类</p>
<h1 id="BIRCH"><a href="#BIRCH" class="headerlink" title="BIRCH"></a>BIRCH</h1><ul>
<li>是一种针对大规模数据集的聚类算法</li>
<li>只需单遍扫描数据集就能进行聚类</li>
</ul>
<h2 id="聚类特征"><a href="#聚类特征" class="headerlink" title="聚类特征"></a>聚类特征</h2><p>聚类特征（CF，Clustering Feature）</p>
<ul>
<li>是BIRCH增量聚类算法的核心</li>
<li>使用CF概括描述各簇的信息</li>
</ul>
<div class="note warning">
            <p>设某簇中有$N$个$p$维数据点$\{\mathbf{x}_i\}\quad (i=1,\cdots,N)$，则该簇的<strong>聚类特征（CF）</strong>定义为三元组：</p><script type="math/tex; mode=display">CF=(N, LS, SS)</script><p>其中：</p><ul><li>$N$：簇中点的数目</li><li>矢量$LS$：各点的线性求和，即<script type="math/tex; mode=display">\sum_{i=1}^N\mathbf{x}_i=\left(\sum_{i=1}^Nx_{i1},\cdots, \sum_{i=1}^Nx_{ip} \right)^T</script></li><li>标量$SS$：各点的平方和，即<script type="math/tex; mode=display">\sum_{i=1}^N\mathbf{x}_i^T\mathbf{x}_i=\sum_{i=1}^N\sum_{j=1}^px_{ij}^2</script></li></ul>
          </div>
<div class="note success">
            <p>聚类特征（CF）具有<strong>可加性</strong>。</p><p>若有$CF_1=(n_1,LS_1,SS_1)$, $CF_2=(n_2,LS_2,SS_2)$，</p><p>则$CF_1+CF_2=(n_1+n_2,LS_1+LS_2, SS_1+SS_2)$表示将两个不相交的簇合并成一个大簇的聚类特征。</p>
          </div>
<p>聚类特征本质上是给定簇的统计汇总，可以有效地对数据进行压缩。</p>
<p>基于聚类特征，可以推导出簇的许多统计量和距离度量。</p>
<div class="note warning">
            <p>设某簇中有$N$个$p$维数据点$\{\mathbf{x}_i\}\quad (i=1,\cdots,N)$，则该簇的</p><ul><li><strong>簇质心</strong><script type="math/tex; mode=display">\mathbf{x}_0=\frac{1}{N}\sum_{i=1}^N\mathbf{x}_i=\frac{LS}{N}</script></li><li><strong>簇半径</strong><script type="math/tex; mode=display">R=\sqrt{\frac{1}{N}\sum_{i=1}^N\left(\mathbf{x}_i-\mathbf{x}_0 \right)^2}=\sqrt{\frac{N\cdot SS-LS^2}{N^2}}</script></li><li><strong>簇直径</strong><script type="math/tex; mode=display">D=\sqrt{\frac{\sum_{i=1}^N\sum_{j=1}^N\left(\mathbf{x}_i-\mathbf{x}_j \right)^2}{N(N-1)}}=\sqrt{\frac{2N\cdot SS-2LS^2}{N(N-1)}}</script></li></ul>
          </div>
<p>其中</p>
<ul>
<li>R 是簇中的点到质心的平均距离</li>
<li>D 是簇中两两数据点的平均距离</li>
<li>R和D都反映了<u>簇内紧实度</u></li>
</ul>
<p>不同簇之间的距离度量通常用<strong>曼哈顿距离</strong>：</p>
<script type="math/tex; mode=display">D_0=\sqrt{\frac{\sum_{i=1}^{N_1}\sum_{j=N_1+1}^{N_1+N_2}\left(\mathbf{x}_i-\mathbf{x}_j \right)^2}{N_1N_2}}=\sqrt{\frac{SS_1}{N_1}+\frac{SS_2}{N_2}-2\cdot \frac{LS_1}{N_1}\cdot\frac{LS_2}{N_2}}</script><h2 id="聚类特征树"><a href="#聚类特征树" class="headerlink" title="聚类特征树"></a>聚类特征树</h2><p>聚类特征树（CF-tree，Clustering Feature Tree）存储了层次聚类的簇的特征，这棵树的每一个节点是由若干个聚类特征组成的。</p>
<ul>
<li>每个节点（包括叶子节点）都有若干个CF</li>
<li>内部节点的CF有指向孩子节点的指针</li>
<li>所有叶子节点用一个双向链表连接起来</li>
</ul>
<p>聚类特征树有三个参数：</p>
<ul>
<li>枝平衡因子$\beta$</li>
<li>叶平衡因子$\lambda$</li>
<li>空间阈值$\tau$</li>
</ul>
<p>未完待续</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://blog.csdn.net/congnaahahei/article/details/78881128" target="_blank" rel="noopener">BIRCH算法</a></li>
<li><a href="https://www.cnblogs.com/pinard/p/6179132.html" target="_blank" rel="noopener">刘建平Pinard-BIRCH聚类算法原理</a></li>
</ul>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>机器学习</tag>
        <tag>聚类</tag>
      </tags>
  </entry>
  <entry>
    <title>TED | 5 Ways to Create Stronger Connections</title>
    <url>/TED-5WaystoCreateStrongerConnections.html</url>
    <content><![CDATA[<p><center>Another New Week!</center><br><a id="more"></a></p>
<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>Last 2 Weeks</p>
<p><a href="/TED-TrySomethingNewfor30days.html" title="Try Something New for 30 Days">Try Something New for 30 Days</a></p>
<p><a href="/TED-WhyDoCatsActSoWeird.html" title="Why Do Cats Act so Weird?">Why Do Cats Act so Weird?</a></p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<h1 id="5-Ways-to-Create-Stronger-Connections"><a href="#5-Ways-to-Create-Stronger-Connections" class="headerlink" title="5 Ways to Create Stronger Connections"></a>5 Ways to Create Stronger Connections</h1><ul>
<li><a href="https://www.ted.com/talks/robert_reffkin_5_ways_to_create_stronger_connections?referrer=playlist-how_to_sustain_meaningful_relationships_near_and_far#t-6045" target="_blank" rel="noopener">5 Ways to Create Stronger Connections</a></li>
<li>2020.06.03</li>
</ul>
<p><strong>So when</strong> was the last time you <strong>worte a</strong> handwritten notes? It’s probably been a while.</p>
<p>Technology <del>is changing</del> <strong>has changed</strong> the ways we communicate. You send emails, not letters, <del>take</del> <strong>text</strong> messages, not phone call<strong>s</strong>. <del>you</del> <strong>We</strong> order <del>a</del> delivery instead of cooking dinners in our kitchen. All in the name of efficiency. But here is the point, technology has made it easier to communicate, but it hasn’t made it easier to connect with other human beings.</p>
<p>I found <strong>that</strong> the secret to connecting in the high-tech, fast<strong>-paced</strong> <del>text</del> world that we<del>‘re living</del> <strong>live in,</strong> is doing a few small things the old-fashion<strong>ed</strong> ways.</p>
<p>Write a letter. I <strong>have</strong> written thousands of handwritten notes. Thanking <strong>people</strong> for advice, thanking <strong>them</strong> for an interview <strong>.</strong> <del>,</del> <strong>It just</strong> <del>is</del> put<strong>s</strong> that extra effort to show somebody <strong>that</strong> you really care and <strong>that</strong> you <strong>are willing</strong> <del>won’t</del> to go <strong>above and</strong> beyond. Some advices <strong>for writing a</strong> thank-you letter is  <strong>to</strong> really <del>making</del> <strong>make</strong> it clear <strong>to the</strong> person <strong>that</strong> you’re writing to  the impact <strong>that they have had</strong> on your life. Talk about something specific, like “Thank you for the advice that you gave me<strong>. It</strong> is because of the advice you gave me, <del>then</del> <strong>that</strong> I am now doing <del>thing extra</del> <strong>x</strong>. People are looking to make a difference<del>,</del> <strong>And</strong> so you can show someone <strong>that they’ve really</strong> <del>the</del> had <strong>an</strong> impact on the life you’re living and the life you’re pursuing, it <strong>could have</strong> <del>gets out</del> a huge impact.</p>
<p>Pick up the phone and dial. We<strong>‘ve</strong> hire<strong>d</strong> thousands of employees and I<strong>‘ve</strong> personal<strong>ly</strong> called every single one of them to welcome them come to <strong>the Compass</strong> <del>this</del> family <strong>. I’m able to set the tone of really</strong> <del>and make people totally know</del> what I <del>really</del> want the company <strong>to</strong> be. <del>Well</del> <strong>Where</strong>, you know, people go <strong>above and</strong> beyond to make feel welcomed, and <del>make</del> <strong>to give</strong> people <strong>a sense of</strong> <del>feels</del> belonging. <strong>And</strong> sometimes I call<del>ed</del> people on their last<del>-year</del> <strong>day of</strong> <del>at</del> work. <strong>When</strong> people leave<del>s</del>, sometimes they<strong>‘re more</strong> <del>move</del> transparent <strong>than</strong> they <strong>ever</strong> were <strong>when they were still at the company.</strong> <del>actually leaves the company.</del> <strong>And so</strong> it’s a great opportunity to get <del>a kind of</del> feedback <strong>that</strong> <del>it</del> is very hard to get otherwise.</p>
<p>Ask interesting meaningful questions when you get outside <strong>of</strong> the office. When I’m travelling the country very single night, I <strong>will</strong> have dinner with people <strong>in the</strong> company. <strong>And I like to</strong> ask questions, like, what is your underlying motivation, <strong>what’s something that is</strong> <del>will something</del> happen<strong>ed</strong> this week <strong>that meant a lot to you?</strong>, and <strong>when you</strong> <del>we</del> go around the table, and people really open up, <strong>and are able to</strong> <del>people</del> engage<strong>, it sets</strong> a different tone. When people come back to the office, they can see each other and <strong>they</strong> know each other in a deep<strong>er</strong> way.</p>
<p>Answet questions with honesty (rather than abstraction). And you know how <strong>it feels when you go into an elevator and someone says,</strong> <del>to go on to a letter, such as,</del>  “How was your weekend?” it could<strong>‘ve been the</strong> <del>be like, ~~ best weekend <strong>ever, you could’ve met the love of your life,</strong> ~~what you like,</del> and you will say, “Good, how was yours?” If you want to connect with people, then you have to open up, <del>I know</del> I am not always good at it, and I <strong>imagine</strong> most people <del>around</del> <strong>aren’t.</strong> but that <strong>is</strong> why being open <del>send us</del> <strong>stand out</strong> so much because most people <del>want</del> <strong>aren’t</strong>.</p>
<p>Turn the video on. I would always recommend a <del>video</del> <strong>videoconference</strong> over <strong>a</strong> phone call, because <strong>that’s when</strong> you can see <strong>the</strong> real personality <strong>come out</strong> <del>that they</del> , when you<strong>‘re</strong> on video, you<strong>‘re forced to be present</strong> , <strong>it’s almost a forcing mechanism</strong> <del>if is also a force</del> to be <strong>in the</strong> <del>a</del> moment.</p>
<p>Nobody succeed<strong>s</strong> <del>to</del> alone, the more you <strong>can take time to develop genuine, authentic</strong> <del>contact a</del> relationship<strong>s</strong>, the more you&amp;&amp;’re going to be able to<strong> <del>can</del> realise your dreams. <del>Because</del> you’re <del>gonna</del> </strong>going to<strong> be able to take <del>rest</del> </strong>big risks<strong> and vyou could never~~ </strong>know that there’s a network of people** to cheer you on and to <del>some</del> support your efforts.</p>
<h1 id="5-Ways-to-Kill-Your-Dreams"><a href="#5-Ways-to-Kill-Your-Dreams" class="headerlink" title="5 Ways to Kill Your Dreams"></a>5 Ways to Kill Your Dreams</h1><ul>
<li><a href="https://www.ted.com/talks/bel_pesce_5_ways_to_kill_your_dreams" target="_blank" rel="noopener">5 Ways to Kill Your Dreams</a></li>
<li>2020.06.05</li>
</ul>
<p>I dedicated <strong>the past two years</strong> to understanding how people <strong>achieve</strong> <del>kill</del> their dreams. When we think <del>of</del> <strong>about</strong> the dreams we have, and <strong>the dent we want to leave</strong> <del>what are living</del> in the universe, it is <del>trying</del> <strong>striking</strong> to seek how big <strong>of an overlap there is</strong> between the dreams we have and the projects that never happened. </p>
<p>So I’m here to talk to you about 5 ways how not to follow your dreams.</p>
<p>One, believe in overnight success. <strong>You know the</strong> <del>in order</del> story, right? <strong>The tech</strong> <del>that take</del> guy <strong>built</strong> a mobile <strong>app</strong> <del>way</del> and <strong>sold it</strong> <del>saw a</del> very fast <strong>for a</strong> lot of money. You know, the story may seem<del>ed</del> real, but I bet it is <strong>incomplete</strong> <del>incon</del>. If you go investigate further, the guy has <strong>done</strong> <del>then 38</del> <strong>30 apps</strong> before and he <strong>has done a</strong> <del>is the</del> Master<strong>‘s on the topic,</strong> <del>or</del> <strong>a</strong> PhD. He <del>is</del> <strong>has</strong> been working on <del>a</del> <strong>the</strong> topic for <del>a like</del> 20 years. </p>
<p><del>It</del> <strong>This</strong> is really interesting. I myself have a story <strong>in Brazil</strong> <del>involced you</del> that people think it’s an overnight success. I <del>gone</del> <strong>come</strong> from <del>my</del> <strong>a humble</strong>(简陋的, 低劣的) family, and 2 weeks before <strong>the deadline to apply for MIT,</strong> <del>they land the flight I stucked at op processess</del> <strong>I started the application process. And, volia!</strong> <del>and</del> I got <del>it</del> <strong>in</strong>. People may think it’s an overnight success, but that only <del>works</del> <strong>worded</strong> because for the 17 years <strong>prior to that</strong> <del>today</del>, I took life <strong>and</strong> education seriously. Your overnight success <strong>story</strong> <del>, sorry, it</del> is always always <strong>a</strong> result<del>s</del> of everything <strong>you’ve done in</strong> your life through that moment.</p>
<p>Two, believe someone else has the answers for you. <del>Consequently</del> <strong>Constantly</strong>, people want to <strong>help</strong> out, right? All sorts of people, your family, your friends, your business partners, they all have opinions on which path you should take, “And let me tell you, go through <del>these b</del> <strong>this pipe.”</strong> but <strong>whenever</strong> <del>if</del> you <del>never</del> go inside, there <del>is</del> <strong>are</strong> <del>always</del> <strong>other</strong> ways you have to pick as well. And you need to make those decisions yourself. No one else has the perfect answers for your life, and you need to keep picking those decisions, right? The <del>b</del> <strong>pipes</strong> are infinite, <strong>and you</strong> <del>they</del> are <del>gone</del> <strong>going</strong> to bump your head and <strong>it’s a part of</strong> <del>spout to</del> the process.</p>
<p>Three, <del>that’s</del> <strong>and it’s</strong> very <strong>subtle</strong> <del>that</del> <strong>but</strong> very <strong>important</strong>. Decide to settle when <del>girl</del> <strong>growth</strong> is <del>voluntee</del> <strong>guaranteed.</strong> so <strong>when</strong> your life is going <del>to</del> great, you have put together <strong>a</strong> great team and you have <strong>growing revenue,</strong> <del>go renew</del> and everything to <del>settle</del> <strong>set— time to settle</strong>. When I <strong>launched</strong> my first book, I work<strong>ed</strong> really, really hard to <strong>distribute it everywhere in Brazil.</strong> <del>beauty every very , 2</del> <strong>With that, over three</strong> million people <strong>downloaded it,</strong> over 50,000 people <del>for</del> <strong>bought</strong> physical copies. When <del>they</del> <strong>I</strong> wrote <del>the</del> <strong>a sequel</strong>(续集), some impact was <del>volunteed</del> <strong>guaranteed</strong>. Even <strong>if I did</strong> little, <strong>sales would</strong> <del>will</del> be OK. But OK is never OK, when you’re <del>going</del> <strong>growing towards a</strong> peak , you need to work hard<strong>er than</strong> ever and <del>found</del> <strong>find yourself</strong> <del>there is</del> another peak. Right, maybe <strong>if I did</strong> <del>for</del> little, a couple <del>of 500,000</del> <strong>hundred thousand</strong> people would read it, that <strong>is great</strong> <del>the</del> already. But if you work hard<strong>er</strong> <del>and</del> <strong>than</strong> ever, I <del>convince it is</del> <strong>can bring this</strong> number <del>per</del> <strong>up tp</strong> million<strong>s</strong>. That’s why I decide<strong>d,</strong> <strong>with</strong> my new book, to <del>devote</del> <strong>go to</strong> every single <del>step</del> <strong>state of Brazil.</strong> And I can <strong>already see a</strong> higher peak. <del>it’s</del> <strong>There is</strong> no time to settle down.</p>
<p>Forth <del>thing</del> <strong>tip</strong>, <del>it’s</del> <strong>and that’s</strong> really important, believe <del>that</del> the fault is someone else<strong>‘s</strong>. I <strong>constantly</strong> see people saying, “yes, I <del>have these</del> <strong>had this</strong> great idea<del>s</del> but no <strong>investor had the vision</strong> <del>one has</del> to invest.”  “it’s a great product, but you know, the market is so bad, the sale<strong>s</strong> didn’t go well.” or “I can’t found <strong>good talent</strong>, my team is so <strong>below expectations.</strong> “ If you have dreams, it’s your responsilbility to make them happen. Yes, it may be hard to find talent, yes, the market maybe be bad. But if no one invest<strong>ed</strong> in your idea, if no one your product<del>s</del>, for sure, there is something that is your fault.</p>
<p><del>Definately</del> <strong>Definitely</strong>, you need to get your dreams and make them happen, and no one <strong>achieved their goals</strong> <del>are go along</del> <strong>alone</strong>. But if you didn’t make them happen, it’s your fault<del>s</del>, and no one <del>knows</del> <strong>else’s</strong>. Be responsible <del>to</del> <strong>for</strong> your dreams.</p>
<p>And one last tip, and this one is really important as well, believe that the only thing<strong>s</strong> that matter<del>s</del> are the dreams themselves. <del>One says act</del> <strong>Once I saw an ad,</strong> and <strong>it was a lot</strong> <del>he talks to lots</del> of friends, they <strong>were</strong> going up <del>for</del> <strong>a</strong> mountain<del>s</del> <strong>,it was a</strong> very high mountain, and <strong>it was</strong> a lot of work. <strong>You can see that</strong> they were sweaty and <strong>this</strong> was <strong>tough.</strong> And they were going <del>enough</del> <strong>up</strong>, and they finally <del>make</del> <strong>made it</strong> to the peak. <del>And</del> Of course, they decided to celebrate, and they celebrated, “Yes! We made it! We are at the top!” Two seconds later, one <del>looked</del> <strong>looks</strong> at <strong>the</strong> each other <del>,</del> <strong>and syas</strong> <del>said</del>, “OK, let’s go down.” </p>
<p>Life is never about the <del>golden</del> <strong>goals themselves</strong> , life is about the <del>dreams</del> <strong>journey</strong>. Yes, you should<del>n’t drive</del> <strong>enjoy</strong> the <del>golden</del> <strong>goals themselves</strong> , but people think that you have dreams and whenever you get to reach<strong>ing</strong> one of those dreams<strong>, it’s a magical place where happiness will</strong> <del>some magic placed would happen</del> all <del>over</del> around. But <strong>achieving a</strong> <del>I the</del> dream is a momentary <strong>sentation,</strong>(感悟) <del>section</del> and your life is not. The only way to really achieve all <strong>of</strong> your dreams is to fully enjoy every step of your <strong>journey.</strong> That’s the best way. And your <strong>journey</strong> is simple, it is made <strong>of</strong> steps . Some steps will be right on. Sometimes <del>your</del> <strong>you will</strong> trip. If it is right on, celebrate. Because some people will <strong>wait a lot</strong> <del>lose</del> to celebrate, and if you trip<strong>ped</strong>, <strong>turn that into</strong> <del>there is</del> something to learn, if every step becomes something to learn<del>,</del> <strong>or</strong> something to celebrate, you will for sure enjoy the journey. </p>
<p>So, 5 tips, believe in overnight success, believe someone else has the answers for you, believe <del>if if voluntee</del> <strong>that when growth is guaranteed,</strong> you should settle <del>all</del> down, believe <del>that</del> <strong>the</strong> fault someone else<strong>‘s</strong> and believe that only the goals themselves matter. Believe me? <del>If</del> you do that, and you <strong>will</strong> destroy your dreams.</p>
<h1 id="5-Ways-to-Listen-Better"><a href="#5-Ways-to-Listen-Better" class="headerlink" title="5 Ways to Listen Better"></a>5 Ways to Listen Better</h1><ul>
<li><a href="https://www.ted.com/talks/julian_treasure_5_ways_to_listen_better/up-next" target="_blank" rel="noopener">5 Ways to Listen Better</a></li>
<li>2020.06.10</li>
</ul>
<p>We are <del>using</del> <strong>losing</strong> our listening, we spend roughly 60% of our communication time listening. But we’re not <strong>very</strong> good at it, we retain just 25% <strong>of</strong> what we hear. Now, not you, not this talk, but that is generally true. </p>
<p>Let’s define listening as making meaning from sound, it’s a mental process, <del>as</del> <strong>and it’s</strong> a process of extraction. </p>
<p>We use <del>pre</del> <strong>pretty cool</strong> technique<strong>s</strong> to do this, one of them is pattern recognition. <strong>So in a cocktail</strong> party like this, if I say, “David, <strong>Sarah,</strong> pay attention!” some of you just <strong>sat</strong> up. we recognise pattern<strong>s</strong> to distinguish noise from signal<del>s</del>, and <del>expressions our made</del> <strong>especially our name</strong>. <del>Different thing</del> <strong>Differencing</strong> is another technique we use while this <del>pic</del> <strong>pink</strong> noise <strong>on for more than</strong> <del>from</del> a couple of minutes, you <del>will li see</del> <strong>would literally（adv. 逐字地; 照字面地；确实地, 真正地） cease (停止) to hear it</strong>. We listen to <del>different</del> <strong>differences</strong> , we discount sounds that remain <strong>the same</strong>. </p>
<p>And then there is a whole <strong>range of filters.</strong> <del>brain of ,</del> These <strong>filters</strong> take <del>up</del> <strong>us</strong> from all <strong>sound</strong> down to what we pay attention to. Most of people <del>aren’t</del> <strong>entirely</strong> <del>partly</del> unconscious of these <del>photos</del> <strong>filters</strong>. But they <strong>actually</strong> <del>action</del> they create reality <strong>in a</strong> way because they tell us what we<strong>‘re</strong> pay<strong>ing</strong> attention to right now. <strong>I will</strong> give you one example <strong>of</strong> that. <del>attention</del> <strong>Intention</strong>(意向，意图) is very important <strong>in sound,</strong> <del>to</del> <strong>in</strong> listen<strong>ing.</strong> <del>sound and listening</del>. When I married my wife, I promised <strong>her</strong> I <del>will</del> <strong>would</strong> listen to her every day <del>and</del> as if for the first time, now that’s something I <del>to show</del> <strong>fall short of</strong> <del>off</del> on <del>the</del> <strong>a</strong> daily basis. </p>
<p>But it’s great <del>attention</del> <strong>intention</strong> to have <strong>in</strong> a relationship. </p>
<p>But that’s not all. Sound place<strong>s</strong> in space and in time. If you close your eyes right now in this room, you<strong>‘re</strong> <del>won’t</del> aware of the size of the room from the <del>rewavation</del> <strong>reverberation</strong>(反响，回响) and <del>they</del> <strong>the</strong> bouncing <strong>of</strong> the sound <del>of</del> <strong>off the surfaces;</strong> <del>And</del> you<strong>‘re</strong> aware of how many people <strong>are</strong> around you, because of the micro-noise<strong>s</strong> you<strong>‘re</strong> receiving. And sound places <strong>us</strong> in time as well, because sound always has time <del>and</del> <strong>embedded in it</strong> . In fact, I <del>will</del> <strong>would</strong> suggest <strong>that</strong> our listening is the main way that we<del>‘re experiencing</del> <strong>experience</strong> the flow of time from past to future. So, “sonority (响亮) is time and meaning”<strong>—a great quote.</strong> </p>
<p>I said at the beginning, we are losing our listening, why did I say that? <strong>Well, there are a lot of reasons for this.</strong> <del>Why do we lose for it?</del> First of all, we invented <strong>ways of</strong> recording, first, writing, then <del>ordinary</del> <strong>audio</strong> recording, and now video recording as well. The premium on <del>the</del> <strong>accurate</strong> and careful listening has simply disappeared. Secondly, the world is now so noisy <strong>, with this cacophony</strong>(杂音) <del>when this is</del> going on visually and auditorily, it’s just hard to listen, <strong>it’s</strong> tiring to listen. Many people take <strong>refuge (庇护)in</strong> headphones, but they turn big, public spaces like this, <strong>shared soundscapes（音响范围,音景）,</strong> <del>sound skipped</del> into millions of tiny, little personal sound bubbles. <strong>In this scenario,</strong> <del>and listen our area</del> nobody <strong>is</strong> listening to anybody. </p>
<p>We’re becoming <del>inpatient</del> <strong>impatient</strong>. We don’t want <strong>oratory (辞藻华丽的言辞) anymore</strong> , we want sound bites. And <del>they are</del> <strong>the art of</strong> conversation is being replaced — <strong>dangerously,</strong> <del>dangerly</del> I think— <strong>by</strong> personal broadcasting. I don’t know how much listening <del>where</del> <strong>there</strong> is in this  <strong>conversation,</strong> <del>composation</del> which is sadly very common, especially in the UK. We’re becoming <strong>desensitized</strong>(不敏感，脱敏) <del>dis</del>. Our media have to <strong>scream at us</strong> <del>matters</del> with these kind<strong>s</strong> of headlines in order to get our attention. And that means <strong>it</strong> is hard for us to pay attention to the quiet <strong>, the subtle</strong>(敏感的, 敏锐的, 有辨别力的) <del>subtitle</del> <strong>, the understated</strong> . </p>
<p>This is a serious problem that we’re losing our listening. This is not trivival, because listening is our <strong>access</strong> to understanding, conscious listening always creates understanding, and only <del>with our</del> <strong>without</strong> conscious <del>thing</del> <strong>listening</strong> can these things happen. <del>And what</del> <strong>A world where</strong> we don’t listen to each other <strong>at all</strong> <del>that the</del> is a very scary place indeed. So I’d like to share with you 5 simple exercise<strong>s,</strong> tools you can take away with you, to improve your own conscious listening, would you like that? Good.</p>
<p>The first one is silence. Just 3 minutes a day of silence is a wonderful exercise to reset your ears and to recalibrate(重新校准) it, so <strong>that</strong> you can hear the quiet <del>to get</del> <strong>again</strong>. If you can’t get absolute silence, go <del>to</del> <strong>for</strong> quiet, that <strong>is absolutely fine</strong> <del>sounds very fun</del>.</p>
<p>Second, I call this, the mixer. So <strong>even</strong> if you<strong>‘re in a</strong> noisy <strong>environment</strong> <del>and</del> like this, <strong>and</strong> we spend a lot of time in places like this, listen <strong>in the coffee bar to</strong> <del>and ,</del> how many channels of these sound can I hear? How many individual channels in that mix <del>you can hear</del> <strong>am I listening to</strong>? You can do <strong>it in a beautiful</strong> place <strong>as</strong> well, like <strong>in</strong> a lake, how many birds <strong>am</strong> I hearing? Where are they? Where <del>is their reports</del> <strong>are those ripples</strong>(起潺潺声;波纹，涟漪)? It’s a great exercise for improving the quality of your listening.</p>
<p>Third, this exercise I call , <strong>“savoring,”</strong>(仔细品味) and this is <del>I</del> <strong>a</strong> beutiful <del>exercising</del> <strong>exercise. It’s</strong> about enjoying <del>Monday</del> <strong>mundane</strong>(世俗的，平凡的；世界的，宇宙的) sounds. This, for example, is my <strong>tumble dryer</strong>(滚筒式烘干机) <del>driver</del>. It’s a <del>worth</del> <strong>waltz</strong>, one two three, one two three, one two three, I love it! Or just try this one for <strong>size.</strong> <del>exercise</del>, Wow! So <del>Monday</del> <strong>mundane</strong> sounds can be really interesting if you pay attention. I call that the <strong>“hidden choir</strong>(合唱队) <del>quiet,</del> it’s around us all the time.</p>
<p>The next exercise is probably the most important <strong>of</strong> all of these, <strong>if you</strong> just take one <del>single way</del> <strong>thing away. This is</strong> listening positions—The <del>ideal</del> <strong>idea that</strong> you can move <del>you</del> <strong>your</strong> listening position<del>s</del> to <del>work</del> <strong>whar’s appropriate</strong> to what you<strong>‘re</strong> listening to. This is <del>a plan</del> <strong>playing</strong> with <strong>those filters.</strong> <del>to member</del> <strong>Remenble</strong> I <del>give</del> <strong>gave you those filters?</strong> <del>to giving something place</del> <strong>It’s starting to play</strong> with them <strong>as levers, to</strong> get conscious about them and to move to different places. These are just some of <strong>the</strong> listening positions, <strong>or scales</strong> <del>we are scare</del> of listening positions<strong>, that</strong> you <del>could</del> <strong>can</strong> use. <del>they</del> <strong>There</strong> are many. Have fun with that<strong>. It</strong> is very exciting.</p>
<p>And finally, <del>and I</del> <strong>an acronym</strong>(首字母缩略词) , you <del>could</del> <strong>can</strong> use this <del>thing</del> <strong>in</strong> listening <strong>, in</strong> <del>and</del> communication. If you <strong>are in</strong> <del>and</del> any one of those roles <strong>—and</strong> I think <del>might</del> <strong>that</strong> probably <strong>is</strong> everybody who <strong>is</strong> <del>listens</del> <strong>listening</strong> to this talk. The <strong>acronym</strong> is “RASA”, which is <strong>the Sanskrit</strong> word<del>s</del> for <strong>“juice”</strong> and <strong>“essence</strong> . And <em>RASA</em> stands for <em>Receive</em>, which means pay attention to <strong>the</strong> person; <em>Appreciate</em>, <strong>making little</strong> <del>that can ignore</del> noise<strong>s like “hmm”, “Oh”, “OK”;</strong> <em>Summarise</em> <strong>—the word</strong>  <del>was</del> “so” is very important <del>to</del> <strong>in communication;</strong> and <em>Ask</em>, ask questions after<strong>wards</strong> .</p>
<p>Now, sound is my passion <strong>, it</strong> is my <del>love</del> <strong>life.</strong>  I <strong>wrote a whole book</strong> about it. So I live to listen. <strong>That’s</strong> too much to ask for most people. But I believe every human being <del>least</del> <strong>needs to listen</strong> conscious<strong>ly</strong> in order to live <strong>fully</strong> <del>for live,</del><strong>—</strong>connected in space, and in time to the <del>physics</del> <strong>physical</strong> world around us, connected <strong>in</strong> understanding to each other, not to mention <strong>spiritually</strong> <del>spirits</del> connecte,d because every <del>spirit</del> <strong>spiritual path</strong> I know <strong>of has</strong> <del>have</del> listening and <del>con</del> <strong>contemplation</strong>(沉思，意图，期望) <del>is hard</del> <strong>at its heart</strong>. </p>
<p>That is why we need to teach listening in our schools as a skill. Why is <strong>it</strong> not <del>talk</del> <strong>taught?</strong> <strong>It</strong> is crazy, and <strong>if</strong> we can teach listening in our schools, we can take our listening <del>or</del> <strong>off slippery</strong>(狡猾的，滑的) slope to <del>danger</del> <strong>that dangerous,</strong> scary world that I talk<strong>ed</strong> about, and move it to <strong>a</strong> place <strong>where</strong> everybody is consciously listening all the time, <del>please</del> <strong>or at least</strong> capable <strong>of</strong> doing <strong>it</strong> <del>that</del>. </p>
<p>Now I don’t know how to do that. But this is TED, and I think the TED community is capable of anything, so I invite you to connect with me, connect to each other, take this <strong>mission out.</strong> <del>air,</del> And <strong>let’s get</strong> listening <strong>in schools,</strong> <del>to</del> and transform the <del>words</del> <strong>world in</strong> one generation to <strong>a</strong> conscious <strong>, listening</strong> world<strong>—</strong>a world of connection, a world of understanding, and a world of peace.</p>
<p>Thank you for listening to me today.</p>
]]></content>
      <categories>
        <category>Everything</category>
      </categories>
      <tags>
        <tag>TED</tag>
        <tag>English</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL | SQL语言类型</title>
    <url>/sql-sql%E8%AF%AD%E8%A8%80%E7%B1%BB%E5%9E%8B.html</url>
    <content><![CDATA[<p><center></center><br><a id="more"></a></p>
<h1 id="SQL语言"><a href="#SQL语言" class="headerlink" title="SQL语言"></a>SQL语言</h1><p>SQL有四种语言（也有的说法将TCL考虑为第五种）：</p>
<ul>
<li>DDL  数据定义语言</li>
<li>DQL  数据查询语言</li>
<li>DML  数据库操纵语言</li>
<li>DCL  数据库控制语言</li>
<li>TCL  事务控制语言</li>
</ul>
<h2 id="DDL"><a href="#DDL" class="headerlink" title="DDL"></a>DDL</h2><p>DDL（Data Definition Language），数据定义语言，用于定义数据库的结构（structure）或架构（schema）。用于定义数据库的三级结构，包括外模式、概念模式、内模式及其相互之间的映像；用于定理数据的完整性、安全控制等约束。</p>
<ul>
<li>执行后会自动提交，不需要commit</li>
<li>相关命令有：CREATE，ALTER，DROP，TRUNCATE，COMMENT，RENAME</li>
</ul>
<div class="note default">
            <ul><li>CREATE：在数据库内创建对象</li><li>ALTER：更改数据库对象</li><li>DROP：删除数据库里的对象</li><li>TRUNCATE：删除数据表中的所有记录并还原该表至初始设置</li><li>COMMENT：注释</li><li>RENAME：重命名表名或列名</li></ul>
          </div>
<h2 id="DQL"><a href="#DQL" class="headerlink" title="DQL"></a>DQL</h2><p>DQL（Data Query Language），数据查询语言</p>
<ul>
<li>相关命令有：SELECT</li>
</ul>
<h2 id="DML"><a href="#DML" class="headerlink" title="DML"></a>DML</h2><p>DML（Data Manipulation Language），数据操作语言，实现对数据库中数据的操作。</p>
<ul>
<li>根据语言的级别，DML可分为过程性DML和非过程性DML。</li>
<li>执行之后需要commit（所有DML都是显式提交的）</li>
<li>相关命令有：INSERT，UPDATE，DELETE，MERGE，CALL，EXPLAIN PLAN，LOCK TABLE</li>
</ul>
<h2 id="DCL"><a href="#DCL" class="headerlink" title="DCL"></a>DCL</h2><p>DCL（Data Control Language），数据控制语言；负责数据库的权限管理、角色控制等。</p>
<ul>
<li>相关命令有：GRANT，REVOKE</li>
</ul>
<div class="note default">
            <ul><li>GRANT：授权</li><li>REVOKE：取消授权</li></ul>
          </div>
<h2 id="TCL"><a href="#TCL" class="headerlink" title="TCL"></a>TCL</h2><p>TCL（Transaction Control Language），事务控制语言</p>
<ul>
<li>相关命令有：SAVEPOINT，ROLLBACK，SET TRANSACTION，COMMIT</li>
</ul>
<div class="note default">
            <ul><li>SAVEPOINT：设置保存点</li><li>ROLLBACK：回滚</li><li>SET TRANSACTION：</li><li>COMMIT：提交事务</li></ul>
          </div>
<p><meta name="referrer" content="no-referrer"><br><img src="/sql-sql%E8%AF%AD%E8%A8%80%E7%B1%BB%E5%9E%8B/Types-of-SQL-Commands.jpg" class title="SQL语言"></p>
<div class="note default">
            <p>哪个不是DDL(数据库定义语言)语句？<br>A. ALTER<br>B. CREATE<br>C. RENAME<br>D. GRANT</p><p>答案：D</p><p>[<font face="宋体" color="grey">来自：<a href="https://www.nowcoder.com/questionTerminal/29cb393ca36146e78230f07f096247e5" target="_blank" rel="noopener">网易2018校招数据分析师笔试卷</a></font>]</p>
          </div>
<div class="note default">
            <p><strong>DDL</strong>和<strong>DML</strong>完成对数据库数据的建表与更新。</p>
          </div>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://www.geeksforgeeks.org/sql-ddl-dql-dml-dcl-tcl-commands/" target="_blank" rel="noopener">SQL | DDL, DQL, DML, DCL and TCL Commands</a></li>
<li><a href="https://www.cnblogs.com/henryhappier/archive/2010/07/05/1771295.html" target="_blank" rel="noopener">SQL四种语言：DDL,DML,DCL,TCL</a></li>
<li><a href="https://blog.sqlauthority.com/2009/05/02/sql-server-example-of-ddl-dml-dcl-and-tcl-commands/" target="_blank" rel="noopener">SQL SERVER – Example of DDL, DML, DCL and TCL Commands</a></li>
<li><a href="https://www.jb51.net/article/160797.htm" target="_blank" rel="noopener">MySql是否需要commit详解</a></li>
</ul>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>SQL</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>数据分析 | 笔试题目积累</title>
    <url>/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90-%E7%AC%94%E8%AF%95%E9%A2%98%E7%9B%AE%E7%A7%AF%E7%B4%AF.html</url>
    <content><![CDATA[<p><center> </center><br><a id="more"></a></p>
<h1 id="概率统计"><a href="#概率统计" class="headerlink" title="概率统计"></a>概率统计</h1><div class="note default">
            <p>反映<strong>数据离散程度</strong>的有：</p><ul><li>方差</li><li>标准差</li><li>极差</li></ul><p>[<font face="宋体" color="grey">来自：<a href="https://www.nowcoder.com/test/23567918/summary" target="_blank" rel="noopener">小红书2020校招数据分析笔试题卷一</a></font>]</p>
          </div>
<div class="note default">
            <p>关于正态分布的说法正确的是</p><ul><li>正态分布具有集中性和对称性</li><li>正态分布的均值和方差能够决定正态分布的位置和形态</li><li>标准正态分布的均值为0，方差为1</li><li>正态分布的偏度为0，峰度为3</li></ul><p>[<font face="宋体" color="grey">来自：<a href="https://www.nowcoder.com/test/23567918/summary" target="_blank" rel="noopener">小红书2020校招数据分析笔试题卷一</a></font>]</p>
          </div>
<div class="note default">
            <p>老王有两个孩子，已知至少有一个孩子是在星期二出生的男孩。问：两个孩子都是男孩的概率是多大？</p><ul><li>星期二出生的男孩的概率=$\frac{1}{2}\times\frac{1}{7}=\frac{1}{14}$</li><li>星期二出生的女孩的概率=$\frac{1}{2}\times\frac{1}{7}=\frac{1}{14}$</li><li>非星期二出生的男孩的概率=$\frac{1}{2}\times\frac{6}{7}=\frac{6}{14}$</li><li>非星期二出生的女孩的概率=$\frac{1}{2}\times\frac{6}{7}=\frac{6}{14}$</li></ul><p>记</p><ul><li>事件A=两个孩子至少有一个孩子是星期二出生的男孩</li><li>事件B=两个孩子都是男孩<br>\begin{aligned}<br>P(A)&amp;=1-P(两个孩子都不是星期二出生的男孩)\\<br>&amp;= 1-(1-\frac{1}{14})(1-\frac{1}{14})\\<br>&amp;= \frac{27}{196}\\<br>P(AB)&amp;=P(两个都是男孩且至少有一个是在星期二出生的男孩)\\<br>&amp;=P(两个孩子都是星期二出生的男孩)+P(一个男孩是星期二出生的，另一个不是星期二出生的男孩)\\<br>&amp;=\frac{1}{14}\cdot\frac{1}{14}+2\cdot\frac{1}{14}\cdot\frac{6}{14}\\<br>&amp;=\frac{13}{196}<br>\end{aligned}<br>则要求的概率为<br>\begin{aligned}<br>P(B|A)&amp;=\frac{P(AB)}{P(A)}\\<br>&amp;=\frac{13}{196}/\frac{27}{196}\\<br>&amp;=\frac{13}{27}<br>\end{aligned}<br>[<font face="宋体" color="grey">来自：<a href="https://www.nowcoder.com/questionTerminal/030b183f37fd41f7ad4486f56f5ec355" target="_blank" rel="noopener">小红书2020校招数据分析笔试题卷一</a></font>]</li></ul>
          </div>
<div class="note default">
            <p>假设有三个人同时参加这场笔试，假设满分为1，三个人的得分符合分布U（0，1）。那么三个人最低分的期望为？</p><p>假设三人的的成绩分别为$X_1,X_2,X_3$，则三人的最低分为$Y=\min\{X_1,X_2,X_3\}$。<br>\begin{aligned}<br>F_Y(y)&amp;=P(Y\leq y)=1-P(Y&gt;y)\\<br>&amp;=1-P(X_1&gt;y)P(X_2&gt;y)\cdots P(X_n&gt;y)\\<br>&amp;=1-\left[1-F_X(y) \right]^n<br>\end{aligned}<br>求导得到</p><script type="math/tex; mode=display">f_Y(y)=f_X(y)\left[1-F_X(y) \right]^{n-1}=n(1-y)^{n-1}</script><p>所以期望为<br>\begin{aligned}<br>E(Y)&amp;=\int_0^1 yf_Y(y)\mathrm{d}y\\<br>&amp;= -\left[y(1-y)^n|_0^1-\int_0^1(1-y)^n\mathrm{d}y \right]\\<br>&amp;= -\frac{1}{1+n}(1-y)^{n+1}|_0^1=\frac{1}{1+n}<br>\end{aligned}<br>所以三个人最低分的期望为$\frac{1}{4}$。</p><p>[<font face="宋体" color="grey">来自：<a href="https://www.nowcoder.com/questionTerminal/4654695df1dc4e1685d702f9a83d9fe0" target="_blank" rel="noopener">小红书2020校招数据分析笔试题卷一</a></font>]</p>
          </div>
<div class="note default">
            <p>通常可以通过<strong>关联规则</strong>挖掘来发现啤酒和尿布的关系， 那么如果对于一条规则A →B, 如果同时购买A和B的顾客比例是4/7, 而购买A的顾客当中也购买了B的顾客比例是1/2, 而购买B的顾客当中也购买了A的顾客比例是1/3,则以下对于规则A →B的支持度(support)和置信度(confidence)分别是多少？</p><p>由已知条件可知</p><script type="math/tex; mode=display">P(A\cap B)=\frac{4}{7},\quad P(B|A)=\frac{1}{2},\quad P(A|B)=\frac{1}{3}</script><p>则支持度support$(A\rightarrow B)=P(A\cap B)=\frac{4}{6}$，置信度Confidence$(A\rightarrow B)=P(B|A)=\frac{1}{2}$。</p><p>[<font face="宋体" color="grey">来自：<a href="https://www.nowcoder.com/questionTerminal/3e854987c6e64b9c8b26880b48f09062" target="_blank" rel="noopener">网易2018校招数据分析师笔试卷</a></font>]</p>
          </div>
<div class="note default">
            <p>从数字集合$\{1,2,3,4,… ,20\}$中选出4个数字的子集，如果不允许两个相连的数字出现在同一集合中，那么能够形成多少个这种子集？<br>答案：2380</p><p><strong>插空法</strong>：把4个数插到16个数形成的17个空格中</p><script type="math/tex; mode=display">C_{17}^4=2380</script><p>[<font face="宋体" color="grey">来自：<a href="https://www.nowcoder.com/questionTerminal/3e854987c6e64b9c8b26880b48f09062" target="_blank" rel="noopener">网易2018校招数据分析师笔试卷</a></font>]</p>
          </div>
<div class="note default">
            <p>将4个不一样的球随机放入5个杯子中，则杯子中球的最大个数为3的概率是?<br>答案：$\frac{16}{125}$</p><ul><li>总体情况：每个球都可以任选一个杯子，共$5^4$种可能结果</li><li>杯子中球的最大个数为3，则任选一个杯子装3个球$C_5^1$，再从剩下的4个杯子中选一个（$C_4^1$）放剩下的那个球（因为4个球都不一样，所以这个球有$C_4^1$种可能）。<script type="math/tex; mode=display">\frac{C_5^1C_4^1C_4^1}{5^4}=\frac{16}{125}</script></li></ul><p>[<font face="宋体" color="grey">来自：<a href="https://www.nowcoder.com/questionTerminal/3e854987c6e64b9c8b26880b48f09062" target="_blank" rel="noopener">网易2018校招数据分析师笔试卷</a></font>]</p>
          </div>
<h1 id="抽样调查"><a href="#抽样调查" class="headerlink" title="抽样调查"></a>抽样调查</h1><div class="note default">
            <p>抽样调查遵循的<strong>原则</strong>是：<u>随机原则</u></p><p>[<font face="宋体" color="grey">来自：<a href="https://www.nowcoder.com/test/23567918/summary" target="_blank" rel="noopener">小红书2020校招数据分析笔试题卷一</a></font>]</p>
          </div>
<div class="note default">
            <p>抽样估计的优良标准：</p><ul><li>无偏性</li><li>一致性</li><li>有效性</li></ul><p>[<font face="宋体" color="grey">来自：<a href="https://www.nowcoder.com/test/23567918/summary" target="_blank" rel="noopener">小红书2020校招数据分析笔试题卷一</a></font>]</p>
          </div>
<div class="note default">
            <p><strong>抽样误差</strong>是指由于随机抽样的偶然因素使样本各单位的结构不足以代表总体各单位的结构，而引起抽样指标和全局指标的<u>绝对离差</u>。</p>
          </div>
<h1 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h1><div class="note default">
            <p>常用的<strong>最优模型选择方法</strong>是哪些？</p><ul><li>增加正则化项</li><li>交叉验证</li><li>增加罚项</li></ul><p>[<font face="宋体" color="grey">来自：<a href="https://www.nowcoder.com/test/23567918/summary" target="_blank" rel="noopener">小红书2020校招数据分析笔试题卷一</a></font>]</p>
          </div>
<div class="note default">
            <p>三种常见的<strong>聚类算法</strong>:</p><ul><li>K-means聚类、K-中心点聚类、CLARANS算法、DIANA算法、BIRCH算法、Chameleon算法</li><li>EM算法</li><li>OPTICS算法、DBSCAN算法</li></ul><p>[<font face="宋体" color="grey">来自：<a href="https://www.nowcoder.com/questionTerminal/e4614b62c2bd471198d7491ff027a8a6" target="_blank" rel="noopener">小红书2020校招数据分析笔试题卷一</a></font>] </p>
          </div>
<div class="note default">
            <p>在数理统计中，一般通过增加抽样次数取平均来使得预估误差减小，在机器学习中也有类似的模型处理，如随机森林，通过引入随机样本并且增加决策树的数据，对于随机森林主要降低预估的哪个方面值</p><p>答案：预估方差。</p><ul><li>降低偏差：在一棵树数上增加深度，增加叶子节点个数（增加模型的复杂度）</li><li>降低方差：提高模型的泛化能力；增加数据</li></ul><p>[<font face="宋体" color="grey">来自：<a href="https://www.nowcoder.com/test/question/done?tid=33791867&amp;qid=167736#summary" target="_blank" rel="noopener">网易2018校招数据分析师笔试卷</a></font>]</p>
          </div>
<h1 id="时间序列"><a href="#时间序列" class="headerlink" title="时间序列"></a>时间序列</h1><div class="note default">
            <p>影响<strong>时间序列</strong>的因素：</p><ul><li>长期趋势</li><li>季节变动</li><li>循环波动</li><li>不规则波动</li></ul><p>[<font face="宋体" color="grey">来自：<a href="https://www.nowcoder.com/test/23567918/summary" target="_blank" rel="noopener">小红书2020校招数据分析笔试题卷一</a></font>]</p>
          </div>
<h1 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h1><div class="note default">
            <p>某电商有100家店铺，每家店铺每天销售商品和销售额gmv的数据存放在purchase表中，现需统计5月和6月，总gmv中，两个月分别的贡献前50% gmv的店铺名</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">CONCAT</span>(<span class="string">'2019M'</span>, <span class="keyword">month</span>), seller_name</span><br><span class="line"><span class="keyword">FROM</span> (<span class="keyword">SELECT</span> <span class="keyword">MONTH</span>(dt) <span class="keyword">AS</span> <span class="keyword">month</span>, seller_name, <span class="keyword">SUM</span>(gmv) <span class="keyword">AS</span> total_gmv </span><br><span class="line">      <span class="keyword">FROM</span> purchase <span class="keyword">WHERE</span> <span class="keyword">MONTH</span>(dt) <span class="keyword">IN</span> (<span class="string">'5'</span>, <span class="string">'6'</span>)</span><br><span class="line">      <span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">MONTH</span>(dt), seller_name) <span class="keyword">AS</span> tb_a</span><br><span class="line"><span class="keyword">JOIN</span> (<span class="keyword">SELECT</span> <span class="keyword">month</span>, seller_name, PERCENTILE(total_gmv, <span class="number">0.5</span>) <span class="keyword">AS</span> <span class="keyword">mid</span> </span><br><span class="line">      <span class="keyword">FROM</span></span><br><span class="line">          (<span class="keyword">SELECT</span> <span class="keyword">MONTH</span>(dt) <span class="keyword">AS</span> <span class="keyword">month</span>, seller_name, <span class="keyword">SUM</span>(gmv) <span class="keyword">AS</span> total_gmv</span><br><span class="line">          <span class="keyword">FROM</span> purchase <span class="keyword">WHERE</span> <span class="keyword">MONTH</span>(dt) <span class="keyword">IN</span> (<span class="string">'5'</span>, <span class="string">'6'</span>) </span><br><span class="line">          <span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">MONTH</span>(dt), seller_name) <span class="keyword">AS</span> tb_c</span><br><span class="line">      <span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">month</span>, seller_name) <span class="keyword">AS</span> tb_b</span><br><span class="line"><span class="keyword">ON</span> tb_a.month=tb_b.month <span class="keyword">AND</span> tb_a.seller_name=tb_b.seller_name</span><br><span class="line"><span class="keyword">WHERE</span> total_gmv &gt; <span class="keyword">mid</span>;</span><br></pre></td></tr></table></figure><p>[<font face="宋体" color="grey">来自：<a href="https://www.nowcoder.com/questionTerminal/be517fb03c854905be5acb706b680199" target="_blank" rel="noopener">小红书2020校招数据分析笔试题卷一</a></font>]</p>
          </div>
<h1 id="基础算法"><a href="#基础算法" class="headerlink" title="基础算法"></a>基础算法</h1><div class="note default">
            <p>将一个整数序列整理为升序，两趟处理后序列变为10,12,21,9,7,3,4,25，则采用的排序算法可能是</p><p>答案：A.插入排序。</p><ul><li>插入排序：第n趟前n+1个有序</li><li>选择排序：第n趟前n个位置正确</li><li>快速排序：第n趟有n个元素位置正确</li><li>堆排序：第n趟前或后n个位置正确</li></ul><p>[<font face="宋体" color="grey">来自：<a href="https://www.nowcoder.com/test/question/done?tid=33791867&amp;qid=167735#summary" target="_blank" rel="noopener">网易2018校招数据分析师笔试卷</a></font>]</p>
          </div>
<div class="note default">
            <p>[<font face="宋体" color="grey">来自：<a href></a></font>]</p>
          </div>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1>]]></content>
      <categories>
        <category>数据分析</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
      </tags>
  </entry>
  <entry>
    <title>Python | statistics</title>
    <url>/python-statistics.html</url>
    <content><![CDATA[<p><center> </center><br><a id="more"></a></p>
<h1 id="statistics"><a href="#statistics" class="headerlink" title="statistics"></a>statistics</h1><h2 id="median"><a href="#median" class="headerlink" title="median()"></a>median()</h2><p>求中位数<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lst = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">8</span>]</span><br><span class="line"><span class="keyword">from</span> statistics <span class="keyword">import</span> median</span><br><span class="line">median(lst)</span><br><span class="line"><span class="comment"># 3</span></span><br></pre></td></tr></table></figure></p>
<h2 id="median-high"><a href="#median-high" class="headerlink" title="median_high()"></a>median_high()</h2><p>当元素个数为偶数时，求中位数，返回中间两个元素的较大的那个作为中位数<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lst = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>]</span><br><span class="line"><span class="keyword">import</span> statistics <span class="keyword">as</span> s</span><br><span class="line">s.median(lst)</span><br><span class="line"><span class="comment"># 4.0</span></span><br><span class="line">s.median_high(lst)</span><br><span class="line"><span class="comment"># 5</span></span><br></pre></td></tr></table></figure></p>
<h2 id="median-low"><a href="#median-low" class="headerlink" title="median_low()"></a>median_low()</h2><p>当元素个数为偶数时，求中位数，返回中间两个元素的较小的那个作为中位数<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lst = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>]</span><br><span class="line"><span class="keyword">import</span> statistics <span class="keyword">as</span> s</span><br><span class="line">s.median(lst)</span><br><span class="line"><span class="comment"># 4.0</span></span><br><span class="line">s.median_low(lst)</span><br><span class="line"><span class="comment"># 3</span></span><br></pre></td></tr></table></figure></p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://blog.csdn.net/weixin_41084236/article/details/81482984" target="_blank" rel="noopener">统计模块：Python3.7的statistics模块</a></li>
</ul>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Data Balancing | SMOTE</title>
    <url>/%E7%AE%97%E6%B3%95-SMOTE.html</url>
    <content><![CDATA[<p><center>Synthetic Minority Oversampling Technique</center><br><a id="more"></a></p>
<p>合成少数类过采样技术</p>
<h1 id="类不平衡"><a href="#类不平衡" class="headerlink" title="类不平衡"></a>类不平衡</h1><p>类不平衡（Class-imbalance）是指在训练分类器时所使用的训练数据的类别分布不均。</p>
<blockquote>
<p>一个二分类问题，训练数据集有1000个样本</p>
<ul>
<li>理想情况：正类和负类样本的数量相差不多</li>
<li>类不平衡：如果正类样本有990个，而负类样本只有10个</li>
</ul>
</blockquote>
<ul>
<li>把样本数量过少的类别称为<strong>少数类</strong></li>
<li>把样本数量较多的类别称为<strong>多数类</strong></li>
</ul>
<p>类不平衡的解决方案有：</p>
<ol>
<li>过采样（Oversampling）：对少数类进行过采样，合成新的样本来缓解类不平衡</li>
<li>欠采样（Undersampling）：对多数类进行欠采样，抛弃一些样本来缓解类不平衡</li>
</ol>
<h1 id="SMOTE"><a href="#SMOTE" class="headerlink" title="SMOTE"></a>SMOTE</h1><p>合成少数类过采样技术（SMOTE，Synthetic Minority Oversampling Technique），基于随机过采样算法的一种数据不平衡改进方案。</p>
<div class="note default">
            <p>Chawla N V , Bowyer K W , Hall L O , et al. <a href="https://arxiv.org/pdf/1106.1813.pdf" target="_blank" rel="noopener">SMOTE: Synthetic Minority Over-sampling Technique</a>[J]. Journal of Artificial Intelligence Research, 2002, 16(1):321-357.</p>
          </div>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://www.cnblogs.com/Determined22/p/5772538.html" target="_blank" rel="noopener">机器学习 —— 类不平衡问题与SMOTE过采样算法</a></li>
</ul>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>机器学习</tag>
        <tag>数据不平衡</tag>
      </tags>
  </entry>
  <entry>
    <title>Python | SciPy</title>
    <url>/python-scipy.html</url>
    <content><![CDATA[<p><center> </center><br><a id="more"></a></p>
<h1 id="scipy"><a href="#scipy" class="headerlink" title="scipy"></a>scipy</h1><h2 id="stats"><a href="#stats" class="headerlink" title="stats"></a>stats</h2><h3 id="mode"><a href="#mode" class="headerlink" title="mode()"></a>mode()</h3><p>求众数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 求矩阵/数组的众数</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> scipy.stats <span class="keyword">import</span> mode</span><br><span class="line"></span><br><span class="line">a = np.array([[<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>],</span><br><span class="line">              [<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>],</span><br><span class="line">              [<span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>]])</span><br><span class="line">print(<span class="string">"# Print mode(a):"</span>, mode(a))</span><br><span class="line">print(<span class="string">"# Print mode(a.transpose()):"</span>, mode(a.transpose()))</span><br><span class="line">print(<span class="string">"# a的每一列中最常见的成员为：&#123;&#125;，分别出现了&#123;&#125;次。"</span>.format(mode(a)[<span class="number">0</span>][<span class="number">0</span>], mode(a)[<span class="number">1</span>][<span class="number">0</span>]))</span><br><span class="line">print(<span class="string">"# a的第一列中最常见的成员为：&#123;&#125;，出现了&#123;&#125;次。"</span>.format(mode(a)[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>], mode(a)[<span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>]))</span><br><span class="line">print(<span class="string">"# a的每一行中最常见的成员为：&#123;&#125;，分别出现了&#123;&#125;次。"</span>.format(mode(a.transpose())[<span class="number">0</span>][<span class="number">0</span>], mode(a.transpose())[<span class="number">1</span>][<span class="number">0</span>]))</span><br><span class="line">print(<span class="string">"# a中最常见的成员为：&#123;&#125;，出现了&#123;&#125;次。"</span>.format(mode(a.reshape(<span class="number">-1</span>))[<span class="number">0</span>][<span class="number">0</span>], mode(a.reshape(<span class="number">-1</span>))[<span class="number">1</span>][<span class="number">0</span>]))</span><br><span class="line"><span class="comment"># Print mode(a): ModeResult(mode=array([[1, 2, 2, 1]]), count=array([[2, 2, 2, 1]]))</span></span><br><span class="line"><span class="comment"># Print mode(a.transpose()): ModeResult(mode=array([[2, 2, 1]]), count=array([[3, 3, 2]]))</span></span><br><span class="line"><span class="comment"># a的每一列中最常见的成员为：[1 2 2 1]，分别出现了[2 2 2 1]次。</span></span><br><span class="line"><span class="comment"># a的第一列中最常见的成员为：1，出现了2次。</span></span><br><span class="line"><span class="comment"># a的每一行中最常见的成员为：[2 2 1]，分别出现了[3 3 2]次。</span></span><br><span class="line"><span class="comment"># a中最常见的成员为：2，出现了6次。</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 求列表的众数</span></span><br><span class="line"><span class="keyword">from</span> scipy <span class="keyword">import</span> stats</span><br><span class="line"></span><br><span class="line">lst = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">6</span>]</span><br><span class="line">print(int(stats.mode(lst)[<span class="number">0</span>]))</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://blog.csdn.net/kane7csdn/article/details/84795405" target="_blank" rel="noopener">Python中的scipy.stats.mode函数</a></li>
</ul>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Machine Learning | GBDT</title>
    <url>/%E7%AE%97%E6%B3%95-GBDT.html</url>
    <content><![CDATA[<p><center>Gradient Boosting Decision Tree</center><br><a id="more"></a></p>
<p>梯度提升树</p>
<p>不同简称：</p>
<ul>
<li><strong>GBDT</strong> (Gradient Boosting Decision Tree)</li>
<li><strong>GBT</strong> (Gradient Boosting Tree)</li>
<li><strong>GTB</strong> (Gradient Tree Boosting)</li>
<li><strong>GBRT</strong> (Gradient Boosting Regression Tree)</li>
<li><strong>MART</strong> (Multiple Additive Regression Tree)</li>
</ul>
<h1 id="GBDT"><a href="#GBDT" class="headerlink" title="GBDT"></a>GBDT</h1><div class="note default">
            <p>Breiman, L. (June 1997). “<a href="https://statistics.berkeley.edu/sites/default/files/tech-reports/486.pdf" target="_blank" rel="noopener">Arcing The Edge</a>“. Technical Report 486. Statistics Department, University of California, Berkeley.</p>
          </div>
<p><meta name="referrer" content="no-referrer"><br><img src="/%E7%AE%97%E6%B3%95-GBDT/GBDT.png" class title="GBDT训练过程(图片来自:Boosting框架)"></p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>GBDT进行$T$次迭代，第$t$次（$t=1,\cdots,T$）迭代产生一个弱分类器$h_t(x)$；下一次迭代时，会根据上一次迭代计算得到的残差进行学习，并生成一个弱分类器。</p>
<p>最终得到的强分类器为</p>
<script type="math/tex; mode=display">H(x)=\sum_{t=1}^Th_t(x)</script><p>在GBDT的第$t$次迭代，假设在前一轮迭代得到的组合强学习器是$H_{t-1}(x)$，损失函数是$L(y,H_{t-1}(x))$</p>
<p>本轮迭代的目标是找到一个CART回归树模型的弱学习器$h_t(x)$使得本轮的损失函数最小</p>
<script type="math/tex; mode=display">L\left(y, H_{t}(x) \right)=L\left(y, H_{t-1}(x)+h_t(x) \right)</script><ul>
<li>GBDT通过经验风险最小化来确定下一个弱分类器的参数</li>
<li><p>损失函数$L$的选择有多种</p>
<ul>
<li>平方损失函数</li>
<li>0-1损失函数</li>
<li>对数损失函数</li>
<li>……</li>
</ul>
<p>通常使用平方损失函数（即残差）</p>
</li>
</ul>
<p>到目前为止，上述方法描述的是<a href="/%E7%AE%97%E6%B3%95-BoostingTree.html" title="提升树(Boosting Tree)">提升树(Boosting Tree)</a>。</p>
<p>当损失函数为平方损失函数时，每一步优化的实现较为简单，当损失函数为一般损失函数时，每一步优化的实现较为困难。</p>
<p>针对该问题，Freidman提出了梯度提升（Gradient Boosting）算法——用损失函数的负梯度来拟合本轮迭代（优化）的近似值，进而拟合一棵CART回归树。</p>
<p>第$t$轮迭代的第$i$个样本的损失函数的负梯度为</p>
<script type="math/tex; mode=display">r_i^{(t)}=-\left[\frac{\partial{L(y_i,f(x_i))}}{\partial{f(x_i)}} \right]_{f(x)=H_{t-1}(x)}</script><div class="note danger">
            <h2 id="GBDT回归算法"><a href="#GBDT回归算法" class="headerlink" title="GBDT回归算法"></a>GBDT回归算法</h2><p><strong>输入</strong>：训练数据集$\{(x_1,y_1),\cdots, (x_N,y_N)\}$</p><p>  $x_i\in X\subseteq \mathbb{R}^p,\quad y_i\in Y\subseteq \mathbb{R}$</p><p><strong>输出</strong>：提升树</p><script type="math/tex; mode=display">H(x)=H_0(x)+\sum_{t=1}^T\sum_{j=1}^Jc_j^{(t)}\mathbf{I}\left(x\in R_j^{(t)} \right)</script><ol><li>初始化 <script type="math/tex; mode=display">H_0(x)=\arg{\min_c{\sum_{i=1}^NL(y_i, c)}}</script></li><li>对于$t=1,\cdots, T$，<ol><li>对$i=1,\cdots,N$，计算<script type="math/tex; mode=display">r_i^{(t)}=-\left[\frac{\partial{L(y_i,f(x_i))}}{\partial{f(x_i)}} \right]_{f(x)=H_{t-1}(x)}</script></li><li>对$r_i^{(t)}$拟合一棵回归树，得到第$t$棵树的叶结点区域$R_j^{(t)}\quad(j=1,\cdots,J)$，其中$J$为叶结点的个数</li><li>对$j=1,\cdots,J$，计算<script type="math/tex; mode=display">c_j^{(t)}=\arg{\min_c{\sum_{x_i\in R_j^{(t)}}L\left(y_i, H_{t-1}(x_i)+c \right)}}</script></li><li>更新<script type="math/tex; mode=display">H_t(x)=H_{t-1}(x)+\sum_{j=1}^Jc_j^{(t)}\mathbf{I}\left(x\in R_j^{(t)} \right)</script></li></ol></li></ol>
          </div>
<p>再看GBDT分类算法。</p>
<p>当损失函数为指数损失函数时，此时二分类GBDT退化为<a href="/%E7%AE%97%E6%B3%95-AdaBoost.html" title="AdaBoost算法">AdaBoost算法</a>。</p>
<p>下面讨论对数似然损失函数的情况。</p>
<p>损失函数为</p>
<script type="math/tex; mode=display">L(y, H(x))=\log\left(1+\exp{\left(-yH(x) \right)} \right)</script><div class="note danger">
            <h2 id="GBDT二分类算法"><a href="#GBDT二分类算法" class="headerlink" title="GBDT二分类算法"></a>GBDT二分类算法</h2><p><strong>输入</strong>：训练数据集$\{(x_1,y_1),\cdots, (x_N,y_N)\}$</p><p>  $x_i\in X\subseteq \mathbb{R}^p,\quad y_i\in \{-1,+1\}$</p><p><strong>输出</strong>：提升树</p><script type="math/tex; mode=display">H(x)=H_0(x)+\sum_{t=1}^T\sum_{j=1}^Jc_j^{(t)}\mathbf{I}\left(x\in R_j^{(t)} \right)</script><ol><li>初始化 <script type="math/tex; mode=display">H_0(x)=\arg{\min_c{\sum_{i=1}^NL(y_i, c)}}</script></li><li>对于$t=1,\cdots, T$，<ol><li>对$i=1,\cdots,N$，计算<script type="math/tex; mode=display">r_i^{(t)}=-\left[\frac{\partial{L(y_i,f(x_i))}}{\partial{f(x_i)}} \right]_{f(x)=H_{t-1}(x)}=\frac{y_i}{1+\exp\left(y_iH_{t-1}(x_i) \right)}</script></li><li>对$r_i^{(t)}$拟合一棵决策树，得到第$t$棵树的叶结点区域$R_j^{(t)}\quad(j=1,\cdots,J)$，其中$J$为叶结点的个数</li><li>对$j=1,\cdots,J$，计算<script type="math/tex; mode=display">c_j^{(t)}=\arg{\min_c{\sum_{x_i\in R_j^{(t)}}\log{\left\{1+\exp{\left[-y_i \left(H_{t-1}(x_i)+c \right)\right]} \right\}}}}</script>一般使用下面这个近似值代替<script type="math/tex; mode=display">c_j^{(t)}=\frac{\sum_{x_i\in R_j^{(t)}}r_i^{(t)}}{\sum_{x_i\in R_j^{(t)}}|r_i^{(t)}|\left(1- |r_i^{(t)}|\right)}</script></li><li>更新<script type="math/tex; mode=display">H_t(x)=H_{t-1}(x)+\sum_{j=1}^Jc_j^{(t)}\mathbf{I}\left(x\in R_j^{(t)} \right)</script></li></ol></li></ol>
          </div>
<p>考虑多元GBDT分类。</p>
<p>假设类别数为$K$，对应的对数似然函数为</p>
<script type="math/tex; mode=display">L(y, f(x))=-\sum_{k=1}^Ky_k\log{p_k(x)}</script><p>其中</p>
<script type="math/tex; mode=display">y_k=\left\{
  \begin{array}{ll}
  1,&样本输出类别为k\\
  0,&否则
  \end{array}
  \right.</script><p>第$k$类的概率$p_k(x)$</p>
<script type="math/tex; mode=display">p_k(x)=P(y=k|x)=\frac{\exp\{f_k(x)\}}{\sum_{l=1}^K\exp\{f_l(x)\}}</script><p>其中$f_1,\cdots,f_K$是$K$个不同的CART回归树。<br><div class="note default">
            <p>每一轮的训练，实际上是训练了$K$棵树，去拟合Softmax的每一个分支模型的负梯度。</p>
          </div></p>
<p>单个样本的损失函数为</p>
<script type="math/tex; mode=display">L(y,x)=-\sum_{k=1}^Ky_k\log{\frac{\exp\{f_k(x)\}}{\sum_{l=1}^K\exp\{f_l(x)\}}}</script><p>负梯度为</p>
<script type="math/tex; mode=display">-\frac{\partial{L}}{\partial{f_k(x)}}=y_k-\frac{\exp\{f_k(x)\}}{\sum_{l=1}^K\exp\{f_l(x)\}}=y_k-p_k(x)</script><blockquote>
<p>Python中<code>sklearn</code>的GBDT不支持多因变量，可以针对每个因变量单独运行GBDT，建立多个GBDT模型</p>
</blockquote>
<div class="note danger">
            <h2 id="GBDT多分类算法"><a href="#GBDT多分类算法" class="headerlink" title="GBDT多分类算法"></a>GBDT多分类算法</h2><p><strong>输入</strong>：训练数据集$\{(x_1,y_1),\cdots, (x_N,y_N)\}$</p><p>  $x_i\in X\subseteq \mathbb{R}^p,\quad y_i\in Y\subseteq \mathbb{R}^K$</p><script type="math/tex; mode=display">y_i=(y_{i1},\cdots,y_{iK})^T, \quad y_{ij}=\left\{\begin{array}{ll}  1, & 如果第i个样本属于第k个类别\\  0, & j\neq k  \end{array} \right.</script><p><strong>输出</strong>：提升树</p><script type="math/tex; mode=display">H(x)=\left(f_1(x),\cdots,f_K(x) \right)</script><p>  其中</p><script type="math/tex; mode=display">f_k(x)=\sum_{t=1}^T\sum_{j=1}^Jc_{jk}^{(t)}\mathbf{I}\left(x\in R_{jk}^{(t)} \right)</script><ol><li>初始化 <script type="math/tex; mode=display">H_0(x)=\left(f_1^{(0)}(x),\cdots,f_K^{(0)}(x) \right)^T, 其中f_j^{(0)}(x)=0(j=1,\cdots,K)</script></li><li><p>对$t=1,\cdots,T$，</p><ol><li>对$k=1,\cdots,K$，计算<script type="math/tex; mode=display">p_k^{(t)}(x)=\frac{\exp{f_k^{(t)}(x)}}{\sum_{l=1}^K\exp{f_l^{(t)}(x)}}</script><ol><li>对$i=1,\cdots,N$，计算<script type="math/tex; mode=display">r_{ik}^{(t)}=y_{ik}-p_k^{(t)}(x_i)</script></li><li>对$r_{ik}^{(t)}$拟合一棵回归树，得到第$t$次迭代的第$k$棵树的叶结点区域$R_{jk}^{(t)}\quad(j=1,\cdots,J)$，其中$J$为叶结点的个数</li><li>对$j=1,\cdots,J$，计算<script type="math/tex; mode=display">c_{jk}^{(t)}=\frac{K-1}{K}\frac{\sum_{x_i\in R_{jk}^{(t)}}r_{ik}^{(t)}}{\sum_{x_i\in R_{jk}^{(t)}}|r_{ik}^{(t)}|(1-|r_{ik}^{(t)}|)}</script></li><li>更新<script type="math/tex; mode=display">f_k^{(t)}(x)=f_k^{(t-1)}(x)+\sum_{j=1}^Jc_{jk}^{(t)}\mathbf{I}\left(x\in R_{jk}^{(t)} \right)</script></li></ol></li></ol></li></ol>
          </div>
<h2 id="正则化"><a href="#正则化" class="headerlink" title="正则化"></a>正则化</h2><p>为了防止过拟合，可以对GBDT进行正则化。</p>
<ol>
<li>与<a href="/%E7%AE%97%E6%B3%95-AdaBoost.html" title="AdaBoost">AdaBoost</a>类似的正则化项，即<strong>步长</strong>（learning rate）$\nu$，在弱学习器的迭代<script type="math/tex; mode=display">H_{t}(x)=H_{t-1}(x)+h_t(x)</script>中添加正则化项，即<script type="math/tex; mode=display">H_{t}(x)=H_{t-1}(x)+\nu h_t(x)</script>其中$0&lt;\nu\leq1$<ul>
<li>对于同一训练集，较小的$\nu$意味着需要更多的弱学习器的迭代次数（$T$需要更大）。</li>
<li>通常结合<strong>步长</strong>和<strong>迭代最大次数</strong>一起决定算法的拟合效果。</li>
</ul>
</li>
<li>子采样比例（subsample），取值为$(0,1]$<ul>
<li>不放回抽样（而随机森林是有放回抽样）</li>
<li>小于1的比例可以减少方差（防止过拟合），但是会增加样本拟合的偏差，因此取值不能太低</li>
<li>推荐在$[0.5, 0.8]$之间</li>
<li>程序可以通过采样分发到不同的任务去做Boosting的迭代过程，最后形成新树（减少弱学习器难以并行学习的弱点）</li>
<li>采用了子采样的GBDT也称<strong>随机梯度提升树</strong>（SGBT，Stochastic Gradient Boosting Tree）</li>
</ul>
</li>
<li>对弱学习器（CART回归树）进行正则化剪枝</li>
</ol>
<h1 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h1><p>分类算法：</p>
<ul>
<li>对数损失函数</li>
<li>指数损失函数</li>
</ul>
<p>回归算法：</p>
<ul>
<li>平方损失函数（误差平方和）</li>
<li>绝对损失函数（绝对误差和）</li>
<li>Huber损失</li>
<li>Quantile损失（分位数损失）</li>
</ul>
<h2 id="对数损失"><a href="#对数损失" class="headerlink" title="对数损失"></a>对数损失</h2><p>二元</p>
<script type="math/tex; mode=display">L(y, H(x))=\log\left\{1+\exp{\left[-yH(x) \right]} \right\}</script><p>多元</p>
<script type="math/tex; mode=display">L(y, H(x))=-\sum_{k=1}^Ky_k\log{p_k(x)}</script><h2 id="指数损失"><a href="#指数损失" class="headerlink" title="指数损失"></a>指数损失</h2><script type="math/tex; mode=display">L(y, H(x))=\exp{\left[-yH(x) \right]}</script><h2 id="平方损失"><a href="#平方损失" class="headerlink" title="平方损失"></a>平方损失</h2><script type="math/tex; mode=display">L(y, H(x))=\left(y-H(x) \right)^2</script><h2 id="绝对损失"><a href="#绝对损失" class="headerlink" title="绝对损失"></a>绝对损失</h2><script type="math/tex; mode=display">L(y, H(x))=|y-H(x)|</script><p>对应负梯度误差为</p>
<script type="math/tex; mode=display">\mathrm{sign}\left(y_i-H(x_i) \right)</script><h2 id="Huber损失"><a href="#Huber损失" class="headerlink" title="Huber损失"></a>Huber损失</h2><ul>
<li>对于远离中心的异常点，采用绝对损失</li>
<li>中心附近的点，采用平方损失</li>
<li>这个界限一般用分位数点度量</li>
</ul>
<script type="math/tex; mode=display">L(y, H(x))=\left\{
  \begin{array}{ll}
  \frac{1}{2}(y-H(x))^2 ,& |y-H(x)|\leq \delta\\
  \delta \left(|y-H(x)|-\frac{\delta}{2} \right), & |y-H(x)|> \delta 
  \end{array}
  \right.</script><p>对应的负梯度误差为</p>
<script type="math/tex; mode=display">r(y_i, H(x_i))=\left\{
  \begin{array}{ll}
  y_i-H(x_i), & |y_i-H(x_i)|\leq \delta\\
  \delta\mathrm{sign}\left(y_i-H(x_i) \right), & |y_i-H(x_i)|> \delta
  \end{array}
  \right.</script><h2 id="分位数损失"><a href="#分位数损失" class="headerlink" title="分位数损失"></a>分位数损失</h2><p>对应的是分位数回归的损失函数</p>
<script type="math/tex; mode=display">L(y,H(x))=\sum_{y\geq H(x)}\theta|y-H(x)|+\sum_{y< H(x)}(1-\theta)|y-H(x)|</script><p>其中$\theta$是分位数，需要提前指定。</p>
<p>对应的负梯度误差为</p>
<script type="math/tex; mode=display">r(y_i, H(x_i))=\left\{
  \begin{array}{ll}
  \theta, & y_i\geq H(x_i)\\
  \theta-1, & y_i< H(x_i)
  \end{array}
  \right.</script><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul>
<li>可以灵活处理各种类型的数据<ul>
<li>连续值</li>
<li>离散值</li>
</ul>
</li>
<li>使用Huber损失函数、Quantile损失函数，对异常值不敏感</li>
<li>（相对<a href="/%E7%AE%97%E6%B3%95-SVM.html" title="SVM">SVM</a>来说）在相对少的调参时间情况下，预测的准确率也可以比较高</li>
</ul>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul>
<li>弱学习器之间存在依赖关系，难以并行训练数据<ul>
<li>可通过自采样的SGBT来达到部分并行</li>
</ul>
</li>
</ul>
<h1 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h1><h2 id="GBDT-vs-RF"><a href="#GBDT-vs-RF" class="headerlink" title="GBDT vs RF"></a>GBDT vs RF</h2><p>GBDT vs <a href="/%E7%AE%97%E6%B3%95-%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97.html" title="随机森林">随机森林</a></p>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: center;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: center;">
      <th></th>
      <th>GBDT</th>
      <th>随机森林</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>集成思想</th>
      <td>Boosting</td>
      <td>Bagging</td>
    </tr>
    <tr>
      <th>基树</th>
      <td>只能是回归树</td>
      <td>分类树或回归树</td>
    </tr>
    <tr>
      <th>生成</th>
      <td>串行生成</td>
      <td>并行生成</td>
    </tr>
    <tr>
      <th>最终模型</th>
      <td>直接累加或加权累加</td>
      <td>多数投票</td>
    </tr>
    <tr>
      <th>异常点</th>
      <td>非常敏感</td>
      <td>不敏感</td>
    </tr>
    <tr>
      <th>训练集</th>
      <td>训练集样本具有权值</td>
      <td>对训练集一视同仁</td>
    </tr>
    <tr>
      <th>variance-bias</th>
      <td>减少模型的偏差（bias）</td>
      <td>减少模型的方差（variance）</td>
    </tr>
    <tr>
  </tr></tbody>
</table>
</div>

<h2 id="GBDT-vs-XGBoost"><a href="#GBDT-vs-XGBoost" class="headerlink" title="GBDT vs XGBoost"></a>GBDT vs XGBoost</h2><p>GBDT vs <a href="/%E7%AE%97%E6%B3%95-XGBoost.html" title="XGBoost">XGBoost</a></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">GBDT</th>
<th style="text-align:center">XGBoost</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>基分类器</strong></td>
<td style="text-align:center">CART</td>
<td style="text-align:center">还支持线性分类器</td>
</tr>
<tr>
<td style="text-align:center"><strong>优化</strong></td>
<td style="text-align:center">梯度下降法<sup><a href="#fn_1" id="reffn_1">1</a></sup></td>
<td style="text-align:center">牛顿法<sup><a href="#fn_2" id="reffn_2">2</a></sup></td>
</tr>
<tr>
<td style="text-align:center"><strong>正则项</strong><sup><a href="#fn_3" id="reffn_3">3</a></sup></td>
<td style="text-align:center">没有</td>
<td style="text-align:center">有</td>
</tr>
<tr>
<td style="text-align:center"><strong>Learning rate</strong></td>
<td style="text-align:center"></td>
<td style="text-align:center">Shrinkage</td>
</tr>
<tr>
<td style="text-align:center"><strong>列抽样</strong></td>
<td style="text-align:center"></td>
<td style="text-align:center">支持列抽样<sup><a href="#fn_4" id="reffn_4">4</a></sup></td>
</tr>
<tr>
<td style="text-align:center"><strong>缺失值</strong></td>
<td style="text-align:center"></td>
<td style="text-align:center">可以自动学习出缺失值的分裂方向</td>
</tr>
</tbody>
</table>
</div>
<blockquote id="fn_1">
<sup>1</sup>. 在优化时只用到一阶导数信息<a href="#reffn_1" title="Jump back to footnote [1] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_2">
<sup>2</sup>. XGBoost对代价函数进行了二阶泰勒展开，同时使用了一阶导数和二阶导数的信息；XGBoost还支持自定义代价函数<a href="#reffn_2" title="Jump back to footnote [2] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_3">
<sup>3</sup>. 正则项降低了模型的Variance，学习得到的模型复杂度更低（防止过拟合）<a href="#reffn_3" title="Jump back to footnote [3] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_4">
<sup>4</sup>. XGBoost借鉴了随机森林的做法，支持列抽样（column sampling），既能降低过拟合，还能减少计算<a href="#reffn_4" title="Jump back to footnote [4] in the text."> &#8617;</a>
</blockquote>
<h2 id="GBDT-vs-AdaBoost"><a href="#GBDT-vs-AdaBoost" class="headerlink" title="GBDT vs AdaBoost"></a>GBDT vs AdaBoost</h2><p>GBDT vs <a href="/%E7%AE%97%E6%B3%95-AdaBoost.html" title="AdaBoost">AdaBoost</a></p>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: center;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: center;">
      <th></th>
      <th>GBDT</th>
      <th>AdaBoost</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>共同点</th>
      <td colspan="2">目标都是优化偏差（Bias）</td>
    </tr>
    <tr>
      <th>每轮学习新的学习器</th>
      <td>通过改变输出值<br>每轮拟合的值为真实值与已有的加法模型的差值（即残差）</td>
      <td>通过改变样本的权值<br>关注上轮分类错误的样本的权值</td>
    </tr>
    <tr>
      <th>异常点</th>
      <td>一定程度上优化了AdaBoost异常点敏感的问题</td>
      <td>敏感</td>
    </tr>
    <tr>
      <th>树</th>
      <td>CART树</td>
      <td></td>
    </tr>
    <tr>
  </tr></tbody>
</table>
</div>



<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://blog.csdn.net/suranxu007/article/details/49910323" target="_blank" rel="noopener">GBDT（MART） 迭代决策树入门教程 | 简介</a></li>
<li><a href="https://www.cnblogs.com/pinard/p/6140514.html" target="_blank" rel="noopener">刘建平Pinard-梯度提升树(GBDT)原理小结</a></li>
<li><a href="http://www.17bigdata.com/%e9%9a%8f%e6%9c%ba%e6%a3%ae%e6%9e%97%e5%92%8cgbdt%e7%9a%84%e5%8c%ba%e5%88%ab/" target="_blank" rel="noopener">随机森林和GBDT的区别</a></li>
<li><a href="https://www.zybuluo.com/vivounicorn/note/446479#24-bagging-and-boosting%E6%A1%86%E6%9E%B6" target="_blank" rel="noopener">Boosting框架</a></li>
<li><a href="https://book.douban.com/subject/10590856/" target="_blank" rel="noopener">李航-统计学习方法</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/91652813?utm_source=wechat_session" target="_blank" rel="noopener">深入理解GBDT多分类算法</a></li>
</ul>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>机器学习</tag>
        <tag>分类</tag>
        <tag>集成学习</tag>
        <tag>回归</tag>
        <tag>Boosting</tag>
      </tags>
  </entry>
  <entry>
    <title>Kaggle | House Prices:Advanced Regression Techniques</title>
    <url>/%E6%95%B0%E6%8D%AE%E6%B8%85%E6%B4%97-kaggle-HousePrice.html</url>
    <content><![CDATA[<p><center></center><br><a id="more"></a></p>
<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>汇总请见：<a href="/Data-Cleaning-Projects.html" title="数据清洗合集">数据清洗合集</a></p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<h1 id="House-Prices-Advanced-Regression-Techniques"><a href="#House-Prices-Advanced-Regression-Techniques" class="headerlink" title="House Prices: Advanced Regression Techniques"></a>House Prices: Advanced Regression Techniques</h1><p>数据来源：<a href="https://www.kaggle.com/c/house-prices-advanced-regression-techniques/data" target="_blank" rel="noopener">Kaggle</a></p>
<p>代码参考：<a href="https://www.kaggle.com/pmarcelino/comprehensive-data-exploration-with-python" target="_blank" rel="noopener">COMPREHENSIVE DATA EXPLORATION WITH PYTHON</a></p>
<p>进行数据分析前的主要工作：</p>
<ol>
<li>理解问题 Understanding the problem<ul>
<li>看每个变量的含义和重要性</li>
</ul>
</li>
<li>进行单变量探究 Univariate study<ul>
<li>关注因变量</li>
</ul>
</li>
<li>进行多变量探究 Multivariate study<ul>
<li>因变量与自变量间的关系</li>
</ul>
</li>
<li>简单数据清洗 Basic cleaning<ul>
<li>数据缺失</li>
<li>异常点</li>
<li>分类变量的处理</li>
</ul>
</li>
<li>检验假设 Test assumptions</li>
</ol>
<h2 id="载入数据"><a href="#载入数据" class="headerlink" title="载入数据"></a>载入数据</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"><span class="keyword">from</span> scipy.stats <span class="keyword">import</span> norm</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> StandardScaler</span><br><span class="line"><span class="keyword">from</span> scipy <span class="keyword">import</span> stats</span><br><span class="line"><span class="keyword">import</span> warnings</span><br><span class="line"></span><br><span class="line">warnings.filterwarnings(<span class="string">"ignore"</span>)</span><br><span class="line">%matplotlib inline</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df_train = pd.read_csv(<span class="string">"train.csv"</span>)</span><br><span class="line">df_train.columns</span><br></pre></td></tr></table></figure>
<pre><code>Index([&#39;Id&#39;, &#39;MSSubClass&#39;, &#39;MSZoning&#39;, &#39;LotFrontage&#39;, &#39;LotArea&#39;, &#39;Street&#39;,
       &#39;Alley&#39;, &#39;LotShape&#39;, &#39;LandContour&#39;, &#39;Utilities&#39;, &#39;LotConfig&#39;,
       &#39;LandSlope&#39;, &#39;Neighborhood&#39;, &#39;Condition1&#39;, &#39;Condition2&#39;, &#39;BldgType&#39;,
       &#39;HouseStyle&#39;, &#39;OverallQual&#39;, &#39;OverallCond&#39;, &#39;YearBuilt&#39;, &#39;YearRemodAdd&#39;,
       &#39;RoofStyle&#39;, &#39;RoofMatl&#39;, &#39;Exterior1st&#39;, &#39;Exterior2nd&#39;, &#39;MasVnrType&#39;,
       &#39;MasVnrArea&#39;, &#39;ExterQual&#39;, &#39;ExterCond&#39;, &#39;Foundation&#39;, &#39;BsmtQual&#39;,
       &#39;BsmtCond&#39;, &#39;BsmtExposure&#39;, &#39;BsmtFinType1&#39;, &#39;BsmtFinSF1&#39;,
       &#39;BsmtFinType2&#39;, &#39;BsmtFinSF2&#39;, &#39;BsmtUnfSF&#39;, &#39;TotalBsmtSF&#39;, &#39;Heating&#39;,
       &#39;HeatingQC&#39;, &#39;CentralAir&#39;, &#39;Electrical&#39;, &#39;1stFlrSF&#39;, &#39;2ndFlrSF&#39;,
       &#39;LowQualFinSF&#39;, &#39;GrLivArea&#39;, &#39;BsmtFullBath&#39;, &#39;BsmtHalfBath&#39;, &#39;FullBath&#39;,
       &#39;HalfBath&#39;, &#39;BedroomAbvGr&#39;, &#39;KitchenAbvGr&#39;, &#39;KitchenQual&#39;,
       &#39;TotRmsAbvGrd&#39;, &#39;Functional&#39;, &#39;Fireplaces&#39;, &#39;FireplaceQu&#39;, &#39;GarageType&#39;,
       &#39;GarageYrBlt&#39;, &#39;GarageFinish&#39;, &#39;GarageCars&#39;, &#39;GarageArea&#39;, &#39;GarageQual&#39;,
       &#39;GarageCond&#39;, &#39;PavedDrive&#39;, &#39;WoodDeckSF&#39;, &#39;OpenPorchSF&#39;,
       &#39;EnclosedPorch&#39;, &#39;3SsnPorch&#39;, &#39;ScreenPorch&#39;, &#39;PoolArea&#39;, &#39;PoolQC&#39;,
       &#39;Fence&#39;, &#39;MiscFeature&#39;, &#39;MiscVal&#39;, &#39;MoSold&#39;, &#39;YrSold&#39;, &#39;SaleType&#39;,
       &#39;SaleCondition&#39;, &#39;SalePrice&#39;],
      dtype=&#39;object&#39;)
</code></pre><p>‘SalePrice’是因变量</p>
<h2 id="描述性统计"><a href="#描述性统计" class="headerlink" title="描述性统计"></a>描述性统计</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df_train[<span class="string">'SalePrice'</span>].describe()</span><br></pre></td></tr></table></figure>
<pre><code>count      1460.000000
mean     180921.195890
std       79442.502883
min       34900.000000
25%      129975.000000
50%      163000.000000
75%      214000.000000
max      755000.000000
Name: SalePrice, dtype: float64
</code></pre><ul>
<li>‘SalePrice’最小值应该为正（√）</li>
<li>最小值和最大值相差较大</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 直方图</span></span><br><span class="line">sns.distplot(df_train[<span class="string">'SalePrice'</span>])</span><br></pre></td></tr></table></figure>
<pre><code>&lt;matplotlib.axes._subplots.AxesSubplot at 0x16f6ce68828&gt;
</code></pre><p><meta name="referrer" content="no-referrer"><br><img src="/%E6%95%B0%E6%8D%AE%E6%B8%85%E6%B4%97-kaggle-HousePrice/output_9_1.png" class title="直方图"></p>
<ul>
<li>‘SalePrice’集中分布在300000以下</li>
<li>右偏</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 计算‘SalePrice’的偏度和峰度</span></span><br><span class="line">print(<span class="string">'Skewness: %f'</span> % df_train[<span class="string">'SalePrice'</span>].skew())  <span class="comment">## 偏度</span></span><br><span class="line">print(<span class="string">'Kurtosis: %f'</span> % df_train[<span class="string">'SalePrice'</span>].kurt())  <span class="comment">## 峰度</span></span><br></pre></td></tr></table></figure>
<pre><code>Skewness: 1.882876
Kurtosis: 6.536282
</code></pre><ul>
<li>偏度大于0——右偏</li>
<li>峰度大于3——厚尾</li>
</ul>
<h2 id="探究变量之间的关系"><a href="#探究变量之间的关系" class="headerlink" title="探究变量之间的关系"></a>探究变量之间的关系</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## GrLivArea: Above grade (ground) living area square feet</span></span><br><span class="line"><span class="comment">## ‘GrLivArea’与‘SalePrice’的散点图</span></span><br><span class="line">var = <span class="string">'GrLivArea'</span></span><br><span class="line">data = pd.concat([df_train[<span class="string">'SalePrice'</span>], df_train[var]],</span><br><span class="line">                axis=<span class="number">1</span>)  <span class="comment">## 按列合并</span></span><br><span class="line">data.plot.scatter(x=var, y=<span class="string">'SalePrice'</span>, ylim=(<span class="number">0</span>, <span class="number">800000</span>))</span><br></pre></td></tr></table></figure>
<pre><code>&lt;matplotlib.axes._subplots.AxesSubplot at 0x16f6d629978&gt;
</code></pre><p><meta name="referrer" content="no-referrer"><br><img src="/%E6%95%B0%E6%8D%AE%E6%B8%85%E6%B4%97-kaggle-HousePrice/output_14_1.png" class title="散点图"></p>
<p>‘GriLivArea’与’SalePrice’之间具有明显的线性关系</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">##  TotalBsmtSF：Total square feet of basement area</span></span><br><span class="line"><span class="comment">## ‘TotalBsmtSF’与‘SalePrice’的散点图</span></span><br><span class="line">var = <span class="string">'TotalBsmtSF'</span></span><br><span class="line">data = pd.concat([df_train[<span class="string">'SalePrice'</span>], df_train[var]],</span><br><span class="line">                axis=<span class="number">1</span>)  <span class="comment">## 按列合并</span></span><br><span class="line">data.plot.scatter(x=var, y=<span class="string">'SalePrice'</span>, ylim=(<span class="number">0</span>, <span class="number">800000</span>))</span><br></pre></td></tr></table></figure>
<pre><code>&lt;matplotlib.axes._subplots.AxesSubplot at 0x16f6d6eacc0&gt;
</code></pre><p><meta name="referrer" content="no-referrer"><br><img src="/%E6%95%B0%E6%8D%AE%E6%B8%85%E6%B4%97-kaggle-HousePrice/output_16_1.png" class title="散点图"></p>
<ul>
<li>‘TotalBsmtSF’与‘SalePrice’之间也具有明显的线性关系</li>
<li>一些样本中，‘TotalBsmtSF’为零</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## OverallQual: Rates the overall material and finish of the house</span></span><br><span class="line"><span class="comment">## 'OverallQual'与‘SalePrice’的箱线图</span></span><br><span class="line"><span class="comment">## 'OverallQual'是分类变量，有1~10共10个取值</span></span><br><span class="line">var = <span class="string">'OverallQual'</span></span><br><span class="line">data = pd.concat([df_train[<span class="string">'SalePrice'</span>], df_train[var]], </span><br><span class="line">                axis=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">f, ax = plt.subplots(figsize=(<span class="number">8</span>, <span class="number">6</span>))</span><br><span class="line">fig = sns.boxplot(x=var, y=<span class="string">'SalePrice'</span>, data=data)</span><br><span class="line">fig.axis(ymin=<span class="number">0</span>, ymax=<span class="number">800000</span>)</span><br></pre></td></tr></table></figure>
<pre><code>(-0.5, 9.5, 0, 800000)
</code></pre><p><meta name="referrer" content="no-referrer"><br><img src="/%E6%95%B0%E6%8D%AE%E6%B8%85%E6%B4%97-kaggle-HousePrice/output_9_1.png" class title="箱线图"></p>
<ul>
<li>“OverallQual”越高，”SalePrice”的值相对越大</li>
<li>“OverallQual”较高的”SalePrice”的分布较为分散</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## YearBuilt: Original construction date</span></span><br><span class="line">var = <span class="string">'YearBuilt'</span></span><br><span class="line">data = pd.concat([df_train[<span class="string">'SalePrice'</span>], df_train[var]], </span><br><span class="line">                axis=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">f, ax = plt.subplots(figsize=(<span class="number">16</span>, <span class="number">8</span>))</span><br><span class="line">fig = sns.boxplot(x=var, y=<span class="string">'SalePrice'</span>, data=data)</span><br><span class="line">fig.axis(ymin=<span class="number">0</span>, ymax=<span class="number">800000</span>)</span><br><span class="line">plt.xticks(rotation=<span class="number">90</span>)  <span class="comment">## x轴的刻度旋转90度（即垂直于x轴）</span></span><br></pre></td></tr></table></figure>
<pre><code>(array([  0,   1,   2,   3,   4,   5,   6,   7,   8,   9,  10,  11,  12,
         13,  14,  15,  16,  17,  18,  19,  20,  21,  22,  23,  24,  25,
         26,  27,  28,  29,  30,  31,  32,  33,  34,  35,  36,  37,  38,
         39,  40,  41,  42,  43,  44,  45,  46,  47,  48,  49,  50,  51,
         52,  53,  54,  55,  56,  57,  58,  59,  60,  61,  62,  63,  64,
         65,  66,  67,  68,  69,  70,  71,  72,  73,  74,  75,  76,  77,
         78,  79,  80,  81,  82,  83,  84,  85,  86,  87,  88,  89,  90,
         91,  92,  93,  94,  95,  96,  97,  98,  99, 100, 101, 102, 103,
        104, 105, 106, 107, 108, 109, 110, 111]),
 &lt;a list of 112 Text xticklabel objects&gt;)
</code></pre><p><meta name="referrer" content="no-referrer"><br><img src="/%E6%95%B0%E6%8D%AE%E6%B8%85%E6%B4%97-kaggle-HousePrice/output_20_1.png" class></p>
<p>不知“SalePrice”是否已剔除通胀影响的价格，无法对不同建造年份的房屋价格进行比较。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 相关系数阵</span></span><br><span class="line">cor_m = df_train.corr()</span><br><span class="line"></span><br><span class="line">f, ax = plt.subplots(figsize=(<span class="number">12</span>, <span class="number">9</span>))</span><br><span class="line">sns.heatmap(cor_m, vmax=<span class="number">.8</span>, square=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<pre><code>&lt;matplotlib.axes._subplots.AxesSubplot at 0x16f6f3a2da0&gt;
</code></pre><p><meta name="referrer" content="no-referrer"><br><img src="/%E6%95%B0%E6%8D%AE%E6%B8%85%E6%B4%97-kaggle-HousePrice/output_22_1.png" class title="相关系数矩阵热力图"></p>
<ul>
<li>颜色越浅，表明正相关性越强<ul>
<li>‘TotalBsmtSF’和’1stFlrSF’的正相关性很强（很显然）</li>
<li>‘GarageCars’和’GarageArea’的正相关性很强（也很显然）</li>
</ul>
</li>
<li>上述两组正相关性很强的变量，导致数据存在多重共线性<ul>
<li>考虑剔除其中一个变量，因为正相关性强的两个变量包含的信息是相似的</li>
</ul>
</li>
<li>看‘SalePrice’那一列，也可以通过热力图的颜色深浅，直观地发现与‘SalePrice’正相关性较强的变量，如‘OverallQual’、‘GriLivArea’</li>
</ul>
<p>其中：</p>
<ul>
<li>1stFlrSF: First Floor square feet</li>
<li>TotalBsmtSF: Total square feet of basement area</li>
<li>GarageCars: Size of garage in car capacity</li>
<li>GarageArea: Size of garage in square feet</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 放大相关系数矩阵热力图的部分</span></span><br><span class="line"><span class="comment">## 相关系数最大的10个变量</span></span><br><span class="line">k = <span class="number">10</span></span><br><span class="line">cols = cor_m.nlargest(k, <span class="string">'SalePrice'</span>)[<span class="string">'SalePrice'</span>].index</span><br><span class="line">cm = np.corrcoef(df_train[cols].values.T)</span><br><span class="line"></span><br><span class="line">sns.set(font_scale=<span class="number">1.25</span>)</span><br><span class="line">hm = sns.heatmap(cm, cbar=<span class="literal">True</span>, annot=<span class="literal">True</span>, square=<span class="literal">True</span>,</span><br><span class="line">                fmt=<span class="string">'.2f'</span>, annot_kws=&#123;<span class="string">'size'</span>: <span class="number">10</span>&#125;,</span><br><span class="line">                yticklabels=cols.values, xticklabels=cols.values)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><meta name="referrer" content="no-referrer"><br><img src="/%E6%95%B0%E6%8D%AE%E6%B8%85%E6%B4%97-kaggle-HousePrice/output_24_0.png" class title="相关性最强的10个变量的相关性热力图"></p>
<p>相关性较强的几对变量：</p>
<ul>
<li>‘GarageCars’、‘GarageArea’</li>
<li>‘GriLivArea’、‘TotRmsAbvGrd’</li>
<li>‘TotalBsmtSF’、‘1stFlrSF’</li>
</ul>
<p>考虑剔除每对中的一个</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 散点图</span></span><br><span class="line">sns.set()</span><br><span class="line">cols = [<span class="string">'SalePrice'</span>, <span class="string">'OverallQual'</span>, <span class="string">'GrLivArea'</span>, <span class="string">'GarageCars'</span>, </span><br><span class="line">        <span class="string">'TotalBsmtSF'</span>, <span class="string">'FullBath'</span>, <span class="string">'YearBuilt'</span>]</span><br><span class="line">sns.pairplot(df_train[cols], size=<span class="number">2.5</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><meta name="referrer" content="no-referrer"><br><img src="/%E6%95%B0%E6%8D%AE%E6%B8%85%E6%B4%97-kaggle-HousePrice/output_26_0.png" class title="两两散点图"></p>
<h2 id="数据清洗"><a href="#数据清洗" class="headerlink" title="数据清洗"></a>数据清洗</h2><h3 id="缺失"><a href="#缺失" class="headerlink" title="缺失"></a>缺失</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 统计每列的缺失数据个数，并按降序排列</span></span><br><span class="line">total = df_train.isnull().sum().sort_values(ascending=<span class="literal">False</span>)</span><br><span class="line">percent = (df_train.isnull().sum()/df_train.isnull().count()).sort_values(ascending=<span class="literal">False</span>)</span><br><span class="line">missing_data = pd.concat([total, percent], axis=<span class="number">1</span>,</span><br><span class="line">                        keys=[<span class="string">'Total'</span>, <span class="string">'Percent'</span>])</span><br><span class="line">missing_data.head(<span class="number">20</span>)  <span class="comment">## 缺失数据最多的20个列</span></span><br></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Total</th>
      <th>Percent</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>PoolQC</th>
      <td>1453</td>
      <td>0.995205</td>
    </tr>
    <tr>
      <th>MiscFeature</th>
      <td>1406</td>
      <td>0.963014</td>
    </tr>
    <tr>
      <th>Alley</th>
      <td>1369</td>
      <td>0.937671</td>
    </tr>
    <tr>
      <th>Fence</th>
      <td>1179</td>
      <td>0.807534</td>
    </tr>
    <tr>
      <th>FireplaceQu</th>
      <td>690</td>
      <td>0.472603</td>
    </tr>
    <tr>
      <th>LotFrontage</th>
      <td>259</td>
      <td>0.177397</td>
    </tr>
    <tr>
      <th>GarageCond</th>
      <td>81</td>
      <td>0.055479</td>
    </tr>
    <tr>
      <th>GarageType</th>
      <td>81</td>
      <td>0.055479</td>
    </tr>
    <tr>
      <th>GarageYrBlt</th>
      <td>81</td>
      <td>0.055479</td>
    </tr>
    <tr>
      <th>GarageFinish</th>
      <td>81</td>
      <td>0.055479</td>
    </tr>
    <tr>
      <th>GarageQual</th>
      <td>81</td>
      <td>0.055479</td>
    </tr>
    <tr>
      <th>BsmtExposure</th>
      <td>38</td>
      <td>0.026027</td>
    </tr>
    <tr>
      <th>BsmtFinType2</th>
      <td>38</td>
      <td>0.026027</td>
    </tr>
    <tr>
      <th>BsmtFinType1</th>
      <td>37</td>
      <td>0.025342</td>
    </tr>
    <tr>
      <th>BsmtCond</th>
      <td>37</td>
      <td>0.025342</td>
    </tr>
    <tr>
      <th>BsmtQual</th>
      <td>37</td>
      <td>0.025342</td>
    </tr>
    <tr>
      <th>MasVnrArea</th>
      <td>8</td>
      <td>0.005479</td>
    </tr>
    <tr>
      <th>MasVnrType</th>
      <td>8</td>
      <td>0.005479</td>
    </tr>
    <tr>
      <th>Electrical</th>
      <td>1</td>
      <td>0.000685</td>
    </tr>
    <tr>
      <th>Utilities</th>
      <td>0</td>
      <td>0.000000</td>
    </tr>
  </tbody>
</table>
</div>



<ul>
<li>当一个列的数据超过15%都是缺失，则应考虑删除该列</li>
<li>列’PoolQC’, ‘MiscFeature’, ‘Alley’等的缺失比例较大，考虑删除</li>
<li>‘GarageX’几个列的缺失个数一样，但是缺失比例都较小</li>
<li>‘BsmtX’几个列的缺失个数也一样</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 考虑删除上述存在缺失值的列（除了‘Electrical’）</span></span><br><span class="line">df_train = df_train.drop((missing_data[missing_data[<span class="string">'Total'</span>] &gt; <span class="number">1</span>]).index, <span class="number">1</span>)</span><br><span class="line"><span class="comment">## 删除‘Electrical’缺失的样本</span></span><br><span class="line">df_train = df_train.drop(df_train.loc[df_train[<span class="string">'Electrical'</span>].isnull()].index)</span><br><span class="line">df_train.isnull().sum().max()  <span class="comment">## 检查是否还存在缺失</span></span><br></pre></td></tr></table></figure>
<pre><code>0
</code></pre><h3 id="异常点"><a href="#异常点" class="headerlink" title="异常点"></a>异常点</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 标准化</span></span><br><span class="line">SalePrice_scaled = StandardScaler().fit_transform(df_train[<span class="string">'SalePrice'</span>][:, np.newaxis])</span><br><span class="line">low_range = SalePrice_scaled[SalePrice_scaled[:, <span class="number">0</span>].argsort()][:<span class="number">10</span>]</span><br><span class="line">high_range = SalePrice_scaled[SalePrice_scaled[:, <span class="number">0</span>].argsort()][<span class="number">-10</span>:]</span><br><span class="line">print(<span class="string">'Outer range (low) of the distribution:'</span>)</span><br><span class="line">print(low_range)</span><br><span class="line">print(<span class="string">'\nOuter range (high) of the distribution:'</span>)</span><br><span class="line">print(high_range)</span><br></pre></td></tr></table></figure>
<pre><code>Outer range (low) of the distribution:
[[-1.83820775]
 [-1.83303414]
 [-1.80044422]
 [-1.78282123]
 [-1.77400974]
 [-1.62295562]
 [-1.6166617 ]
 [-1.58519209]
 [-1.58519209]
 [-1.57269236]]

Outer range (high) of the distribution:
[[3.82758058]
 [4.0395221 ]
 [4.49473628]
 [4.70872962]
 [4.728631  ]
 [5.06034585]
 [5.42191907]
 [5.58987866]
 [7.10041987]
 [7.22629831]]
</code></pre><ul>
<li>较低的10个值仅在-1.5到-1.9之间</li>
<li>而较高的10个值的跨度从3到7.5</li>
<li>要小心SalePrice标准化后值为7以上的样本点</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 再来看看该图</span></span><br><span class="line"><span class="comment">## ‘GrLivArea’与‘SalePrice’的散点图</span></span><br><span class="line">var = <span class="string">'GrLivArea'</span></span><br><span class="line">data = pd.concat([df_train[<span class="string">'SalePrice'</span>], df_train[var]],</span><br><span class="line">                axis=<span class="number">1</span>)  <span class="comment">## 按列合并</span></span><br><span class="line">data.plot.scatter(x=var, y=<span class="string">'SalePrice'</span>, ylim=(<span class="number">0</span>, <span class="number">800000</span>))</span><br></pre></td></tr></table></figure>
<pre><code>&#39;c&#39; argument looks like a single numeric RGB or RGBA sequence, which should be avoided as value-mapping will have precedence in case its length matches with &#39;x&#39; &amp; &#39;y&#39;.  Please use a 2-D array with a single row if you really want to specify the same RGB or RGBA value for all points.





&lt;matplotlib.axes._subplots.AxesSubplot at 0x16f736e0ac8&gt;
</code></pre><p><meta name="referrer" content="no-referrer"><br><img src="/%E6%95%B0%E6%8D%AE%E6%B8%85%E6%B4%97-kaggle-HousePrice/output_35_2.png" class title="散点图"></p>
<p>观察上图，可以发现右上方和右下方各有2个点较为异常。</p>
<ul>
<li>右上方的两个点比较顺应整体趋势</li>
<li>而右下方的两个点并没有顺应整体趋势，考虑将其删去</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 删除异常点</span></span><br><span class="line">df_train.sort_values(by=<span class="string">'GrLivArea'</span>, ascending=<span class="literal">False</span>)[:<span class="number">2</span>]</span><br></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Id</th>
      <th>MSSubClass</th>
      <th>MSZoning</th>
      <th>LotArea</th>
      <th>Street</th>
      <th>LotShape</th>
      <th>LandContour</th>
      <th>Utilities</th>
      <th>LotConfig</th>
      <th>LandSlope</th>
      <th>...</th>
      <th>EnclosedPorch</th>
      <th>3SsnPorch</th>
      <th>ScreenPorch</th>
      <th>PoolArea</th>
      <th>MiscVal</th>
      <th>MoSold</th>
      <th>YrSold</th>
      <th>SaleType</th>
      <th>SaleCondition</th>
      <th>SalePrice</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>1298</th>
      <td>1299</td>
      <td>60</td>
      <td>RL</td>
      <td>63887</td>
      <td>Pave</td>
      <td>IR3</td>
      <td>Bnk</td>
      <td>AllPub</td>
      <td>Corner</td>
      <td>Gtl</td>
      <td>...</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>480</td>
      <td>0</td>
      <td>1</td>
      <td>2008</td>
      <td>New</td>
      <td>Partial</td>
      <td>160000</td>
    </tr>
    <tr>
      <th>523</th>
      <td>524</td>
      <td>60</td>
      <td>RL</td>
      <td>40094</td>
      <td>Pave</td>
      <td>IR1</td>
      <td>Bnk</td>
      <td>AllPub</td>
      <td>Inside</td>
      <td>Gtl</td>
      <td>...</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>10</td>
      <td>2007</td>
      <td>New</td>
      <td>Partial</td>
      <td>184750</td>
    </tr>
  </tbody>
</table>
<p>2 rows × 63 columns</p>
</div>




<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df_train = df_train.drop(df_train[df_train[<span class="string">'Id'</span>] == <span class="number">1299</span>].index)</span><br><span class="line">df_train = df_train.drop(df_train[df_train[<span class="string">'Id'</span>] == <span class="number">523</span>].index)</span><br></pre></td></tr></table></figure>
<h2 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h2><p>testing for assumptions underlying the statistical bases for multivariate analysis.</p>
<div class="note default">
            <p>根据<a href="https://www.amazon.com/Multivariate-Data-Analysis-Joseph-Hair/dp/9332536503/ref=as_sl_pc_tf_til?tag=pmarcelino-20&amp;linkCode=w00&amp;linkId=5e9109fa2213fef911dae80731a07a17&amp;creativeASIN=9332536503" target="_blank" rel="noopener">Multivariate Data Analysis-Hair et al (2013)</a>，需要进行检验的假设有：</p><ol><li>正态性 Normality<ul><li>许多统计检验方法都基于正态分布的假设构建的</li><li>当样本量大于200时，正态性就不太影响了</li></ul></li><li>同方差性 Homoskedasticity<ul><li>误差项通常是独立同方差的</li></ul></li><li>线性性 Linearity<ul><li>因变量与自变量之间呈线性关系</li><li>如果不是线性关系，可能需要先进行数据变换（data transformation）</li></ul></li><li>序列自相关性<ul><li>通常存在于时间序列</li></ul></li></ol>
          </div>
<h3 id="正态性检验"><a href="#正态性检验" class="headerlink" title="正态性检验"></a>正态性检验</h3><ul>
<li>直方图</li>
<li>概率密度图(Q-Q图)</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sns.distplot(df_train[<span class="string">'SalePrice'</span>], fit=norm)</span><br><span class="line">fig = plt.figure()</span><br><span class="line">res = stats.probplot(df_train[<span class="string">'SalePrice'</span>], plot=plt)</span><br></pre></td></tr></table></figure>
<p><meta name="referrer" content="no-referrer"><br><img src="/%E6%95%B0%E6%8D%AE%E6%B8%85%E6%B4%97-kaggle-HousePrice/output_41_0.png" class title="密度曲线"></p>
<p><meta name="referrer" content="no-referrer"><br><img src="/%E6%95%B0%E6%8D%AE%E6%B8%85%E6%B4%97-kaggle-HousePrice/output_41_1.png" class title="Q-Q图"></p>
<ul>
<li>很显然，‘SalePrice’并不服从正态分布<ul>
<li>右偏</li>
<li>QQ图尾部（蓝点）与标准正态分布（红线）不一致</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 对数据进行对数变换</span></span><br><span class="line">df_train[<span class="string">'SalePrice'</span>] = np.log(df_train[<span class="string">'SalePrice'</span>])</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 检验对数变换后数据的正态性</span></span><br><span class="line">sns.distplot(df_train[<span class="string">'SalePrice'</span>], fit=norm)</span><br><span class="line">fig = plt.figure()</span><br><span class="line">res = stats.probplot(df_train[<span class="string">'SalePrice'</span>], plot=plt)</span><br></pre></td></tr></table></figure>
<p><meta name="referrer" content="no-referrer"><br><img src="/%E6%95%B0%E6%8D%AE%E6%B8%85%E6%B4%97-kaggle-HousePrice/output_44_0.png" class title="密度曲线图"></p>
<p><meta name="referrer" content="no-referrer"><br><img src="/%E6%95%B0%E6%8D%AE%E6%B8%85%E6%B4%97-kaggle-HousePrice/output_44_1.png" class title="Q-Q图"></p>
<p>Perfect！</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 再来看看'GrLivArea'</span></span><br><span class="line">sns.distplot(df_train[<span class="string">'GrLivArea'</span>], fit=norm)</span><br><span class="line">fig = plt.figure()</span><br><span class="line">res = stats.probplot(df_train[<span class="string">'GrLivArea'</span>], plot=plt)</span><br></pre></td></tr></table></figure>
<p><meta name="referrer" content="no-referrer"><br><img src="/%E6%95%B0%E6%8D%AE%E6%B8%85%E6%B4%97-kaggle-HousePrice/output_46_0.png" class title="密度曲线图"></p>
<p><meta name="referrer" content="no-referrer"><br><img src="/%E6%95%B0%E6%8D%AE%E6%B8%85%E6%B4%97-kaggle-HousePrice/output_46_1.png" class title="Q-Q图"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 进行对数变换</span></span><br><span class="line">df_train[<span class="string">'GrLivArea'</span>] = np.log(df_train[<span class="string">'GrLivArea'</span>])</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sns.distplot(df_train[<span class="string">'GrLivArea'</span>], fit=norm)</span><br><span class="line">fig = plt.figure()</span><br><span class="line">res = stats.probplot(df_train[<span class="string">'GrLivArea'</span>], plot=plt)</span><br></pre></td></tr></table></figure>
<p><meta name="referrer" content="no-referrer"><br><img src="/%E6%95%B0%E6%8D%AE%E6%B8%85%E6%B4%97-kaggle-HousePrice/output_48_0.png" class title="密度曲线图"></p>
<p><meta name="referrer" content="no-referrer"><br><img src="/%E6%95%B0%E6%8D%AE%E6%B8%85%E6%B4%97-kaggle-HousePrice/output_48_1.png" class title="Q-Q图"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 'TotalBsmtSF'</span></span><br><span class="line">sns.distplot(df_train[<span class="string">'TotalBsmtSF'</span>], fit=norm);</span><br><span class="line">fig = plt.figure()</span><br><span class="line">res = stats.probplot(df_train[<span class="string">'TotalBsmtSF'</span>], plot=plt)</span><br></pre></td></tr></table></figure>
<p><meta name="referrer" content="no-referrer"><br><img src="/%E6%95%B0%E6%8D%AE%E6%B8%85%E6%B4%97-kaggle-HousePrice/output_49_0.png" class title="密度曲线图"></p>
<p><meta name="referrer" content="no-referrer"><br><img src="/%E6%95%B0%E6%8D%AE%E6%B8%85%E6%B4%97-kaggle-HousePrice/output_49_1.png" class title="Q-Q图"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 'TotalBsmtSF'存在0值，无法直接进行对数变换</span></span><br><span class="line"><span class="comment">## 只将'TotalBsmtSF'非零值的数据进行对数变换</span></span><br><span class="line">df_train[<span class="string">'HasBsmt'</span>] = pd.Series(len(df_train[<span class="string">'TotalBsmtSF'</span>]), index=df_train.index)</span><br><span class="line">df_train[<span class="string">'HasBsmt'</span>] = <span class="number">0</span> </span><br><span class="line">df_train.loc[df_train[<span class="string">'TotalBsmtSF'</span>]&gt;<span class="number">0</span>,<span class="string">'HasBsmt'</span>] = <span class="number">1</span></span><br><span class="line">df_train.loc[df_train[<span class="string">'HasBsmt'</span>]==<span class="number">1</span>,<span class="string">'TotalBsmtSF'</span>] = np.log(df_train[<span class="string">'TotalBsmtSF'</span>])</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sns.distplot(df_train[df_train[<span class="string">'TotalBsmtSF'</span>]&gt;<span class="number">0</span>][<span class="string">'TotalBsmtSF'</span>], fit=norm);</span><br><span class="line">fig = plt.figure()</span><br><span class="line">res = stats.probplot(df_train[df_train[<span class="string">'TotalBsmtSF'</span>]&gt;<span class="number">0</span>][<span class="string">'TotalBsmtSF'</span>], plot=plt)</span><br></pre></td></tr></table></figure>
<p><meta name="referrer" content="no-referrer"><br><img src="/%E6%95%B0%E6%8D%AE%E6%B8%85%E6%B4%97-kaggle-HousePrice/output_51_0.png" class title="密度曲线图"></p>
<p><meta name="referrer" content="no-referrer"><br><img src="/%E6%95%B0%E6%8D%AE%E6%B8%85%E6%B4%97-kaggle-HousePrice/output_51_1.png" class title="Q-Q图"></p>
<h3 id="同方差性（同质性）"><a href="#同方差性（同质性）" class="headerlink" title="同方差性（同质性）"></a>同方差性（同质性）</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.scatter(df_train[<span class="string">'GrLivArea'</span>], df_train[<span class="string">'SalePrice'</span>])</span><br></pre></td></tr></table></figure>
<pre><code>&lt;matplotlib.collections.PathCollection at 0x16f7589eba8&gt;
</code></pre><p><meta name="referrer" content="no-referrer"><br><img src="/%E6%95%B0%E6%8D%AE%E6%B8%85%E6%B4%97-kaggle-HousePrice/output_53_1.png" class title="散点图"></p>
<ul>
<li>未进行对数变换前，’GrLivArea’和’SalePrice’散点图呈锥形</li>
<li>进行对数变换后，不再呈锥形（上图）</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.scatter(df_train[df_train[<span class="string">'TotalBsmtSF'</span>]&gt;<span class="number">0</span>][<span class="string">'TotalBsmtSF'</span>], df_train[df_train[<span class="string">'TotalBsmtSF'</span>]&gt;<span class="number">0</span>][<span class="string">'SalePrice'</span>])</span><br></pre></td></tr></table></figure>
<pre><code>&lt;matplotlib.collections.PathCollection at 0x16f7589ebe0&gt;
</code></pre><p><meta name="referrer" content="no-referrer"><br><img src="/%E6%95%B0%E6%8D%AE%E6%B8%85%E6%B4%97-kaggle-HousePrice/output_55_1.png" class title="散点图"></p>
<p>We can say that, in general, ‘SalePrice’ exhibit equal levels of variance across the range of ‘TotalBsmtSF’.</p>
<h3 id="类别变量"><a href="#类别变量" class="headerlink" title="类别变量"></a>类别变量</h3><p>需要将类别变量转化为哑变量（dummy）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df_train = pd.get_dummies(df_train)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df_train.head()</span><br></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Id</th>
      <th>MSSubClass</th>
      <th>LotArea</th>
      <th>OverallQual</th>
      <th>OverallCond</th>
      <th>YearBuilt</th>
      <th>YearRemodAdd</th>
      <th>BsmtFinSF1</th>
      <th>BsmtFinSF2</th>
      <th>BsmtUnfSF</th>
      <th>...</th>
      <th>SaleType_ConLw</th>
      <th>SaleType_New</th>
      <th>SaleType_Oth</th>
      <th>SaleType_WD</th>
      <th>SaleCondition_Abnorml</th>
      <th>SaleCondition_AdjLand</th>
      <th>SaleCondition_Alloca</th>
      <th>SaleCondition_Family</th>
      <th>SaleCondition_Normal</th>
      <th>SaleCondition_Partial</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>1</td>
      <td>60</td>
      <td>8450</td>
      <td>7</td>
      <td>5</td>
      <td>2003</td>
      <td>2003</td>
      <td>706</td>
      <td>0</td>
      <td>150</td>
      <td>...</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
    </tr>
    <tr>
      <th>1</th>
      <td>2</td>
      <td>20</td>
      <td>9600</td>
      <td>6</td>
      <td>8</td>
      <td>1976</td>
      <td>1976</td>
      <td>978</td>
      <td>0</td>
      <td>284</td>
      <td>...</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
    </tr>
    <tr>
      <th>2</th>
      <td>3</td>
      <td>60</td>
      <td>11250</td>
      <td>7</td>
      <td>5</td>
      <td>2001</td>
      <td>2002</td>
      <td>486</td>
      <td>0</td>
      <td>434</td>
      <td>...</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
    </tr>
    <tr>
      <th>3</th>
      <td>4</td>
      <td>70</td>
      <td>9550</td>
      <td>7</td>
      <td>5</td>
      <td>1915</td>
      <td>1970</td>
      <td>216</td>
      <td>0</td>
      <td>540</td>
      <td>...</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <th>4</th>
      <td>5</td>
      <td>60</td>
      <td>14260</td>
      <td>8</td>
      <td>5</td>
      <td>2000</td>
      <td>2000</td>
      <td>655</td>
      <td>0</td>
      <td>490</td>
      <td>...</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
    </tr>
  </tbody>
</table>
<p>5 rows × 222 columns</p>
</div>


]]></content>
      <tags>
        <tag>Data</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL | SQL语句执行顺序</title>
    <url>/sql-sql%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F.html</url>
    <content><![CDATA[<p><center></center><br><a id="more"></a></p>
<h1 id="SQL语句执行顺序"><a href="#SQL语句执行顺序" class="headerlink" title="SQL语句执行顺序"></a>SQL语句执行顺序</h1><pre class="mermaid">graph TB;
    id0(FROM)-->id1(JOIN);
    id1-->id2(ON);
    id2-->id3(WHERE);
    id3-->id4(GROUP BY);
    id4-->id5(AVG,SUM,...);
    id5-->id6(HAVING);
    id6-->id7(SELECT);
    id7-->id8(DISTINCT);
    id8-->id9(ORDER BY);</pre>

<ul>
<li>所有的查询语句都是从<code>FROM</code>开始执行的</li>
<li>在执行过程中，每个步骤都会为下一个步骤生成一个虚拟表，该虚拟表将作为下一个执行步骤的输入</li>
</ul>
<ol>
<li>执行<code>FROM</code>子句，生成虚拟表<code>vt1</code>(选择相对小的表做基础表)</li>
<li>应用<code>ON</code>筛选器，<code>ON</code>中的逻辑表达式将应用到<code>vt1</code>中的各个行，筛选出符合条件的行，生成虚拟表<code>vt2</code></li>
<li><p>执行<code>JOIN</code>语句，添加</p>
<ul>
<li>如果是<code>OUTER JOIN</code>，则添加外部行</li>
<li>如果是<code>LEFT OUTER JOIN</code>，则添加左表在第二步中过滤后得到的行</li>
<li>如果是<code>RIGHT OUTER JOIN</code>，则添加右表在第二步中过滤后得到的行</li>
</ul>
<p>生成虚拟表<code>vt3</code></p>
</li>
<li>如果<code>FROM</code>子句中的表数目多于2个表，则将<code>vt3</code>和第三个表重复1~3的步骤，得到的虚拟表记为<code>vt3</code>；将<code>vt3</code>和第四个表重复1~3的步骤，得到的虚拟表记为<code>vt3</code>；……直到处理完<code>FROM</code>子句中的所有的表</li>
<li>对虚拟表<code>vt3</code>应用<code>WHERE</code>筛选器，生成虚拟表<code>vt4</code></li>
<li><code>GROUP BY col_name</code>子句按<code>col_name</code>列聚合（<code>col_name</code>相同值为一组），得到虚拟<code>vt5</code>表<ul>
<li>如果应用了<code>GROUP BY</code>，则后面的步骤都只能得到<code>vt5</code>表的列或使用关于<code>vt5</code>表的列的聚合函数（<code>COUNT</code>,<code>SUM</code>,<code>AVG</code>等）</li>
<li><code>GROUP BY</code>将列中唯一的值分成一组，同时只为每一组返回一行记录</li>
</ul>
</li>
<li>Oracle特有：应用<code>CUBE</code>或<code>ROLLUP</code>选项，为<code>vt5</code>生成超组，得到虚拟表<code>vt6</code></li>
<li>应用<code>HAVING</code>筛选器，生成虚拟表<code>vt7</code><ul>
<li><code>HAVING</code>是第一个也是唯一一个应用到已分组数据的筛选器</li>
</ul>
</li>
<li>处理<code>SELECT</code>子句，将虚拟表<code>vt7</code>中出现的列筛选出来，生成虚拟表<code>vt8</code></li>
<li>应用<code>DISTINCT</code>子句，移除<code>vt8</code>中相同的行，生成虚拟表<code>vt9</code><ul>
<li>如果应用了<code>GROUP BY</code>子句，则<code>DISTINCT</code>子句是多余的</li>
<li><code>GROUP BY</code>的效率比<code>DISTINCT</code>高</li>
</ul>
</li>
<li>应用<code>ORDER BY</code>子句，返回一个游标，而不是虚拟表<ul>
<li>是第一个也是唯一一个可以使用<code>SELECT</code>列表中别名的步骤</li>
</ul>
</li>
<li>应用<code>TOP</code>，将返回结果给请求者</li>
</ol>
<div class="note default">
            <p>以MySQL为例，写的SQL语句顺序为</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT ... </span><br><span class="line">FROM ... JOIN ... ON ...</span><br><span class="line">WHERE ...</span><br><span class="line">GROUP BY ...</span><br><span class="line">HAVING ...</span><br><span class="line">ORDER BY ... </span><br><span class="line">LIMIT ... [OFFSET ...]</span><br></pre></td></tr></table></figure>执行顺序<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">FROM ... JOIN ... ON ...</span><br><span class="line">WHERE ... </span><br><span class="line">GROUP BY ...</span><br><span class="line">HAVING ...</span><br><span class="line"><span class="keyword">SELECT</span> ...</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> ...</span><br><span class="line"><span class="keyword">LIMIT</span> ... [<span class="keyword">OFFSET</span> ...]</span><br></pre></td></tr></table></figure>
          </div>
<h2 id="Oracle"><a href="#Oracle" class="headerlink" title="Oracle"></a>Oracle</h2><p>Oracle中，在进行多列分组统计时，如果直接使用<code>GROUP BY</code>子句指定分组列，则只能生成基于所有分组列的统计结果。</p>
<p>如果在<code>GROUP BY</code>子句中使用<code>ROLLUP</code>语句或<code>CUBE</code>语句，除了生成基于所有指定列的分组统计外，还可以生成基于指定列不同子集的统计结果。</p>
<h3 id="CUBE"><a href="#CUBE" class="headerlink" title="CUBE"></a>CUBE</h3><p>使用<code>CUBE</code>选项，除了生成基于所有指定列的分组统计外，还对指定分组列的所有子集进行统计</p>
<div class="note default">
            <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">GROUP BY CUBE(A,B,C)</span><br></pre></td></tr></table></figure><p>形成的统计包括以下内容：</p><ul><li><code>GROUP BY</code>：不基于任何列的整个查询结果的统计</li><li><code>GROUP BY A</code>：基于A列的分组统计</li><li><code>GROUP BY B</code>：基于B列的分组统计</li><li><code>GROUP BY C</code>：基于C列的分组统计</li><li><code>GROUP BY A,B</code>：基于A、B两列的分组统计</li><li><code>GROUP BY A,C</code>：基于A、C两列的分组统计</li><li><code>GROUP BY B,C</code>：基于B、C两列的分组统计</li><li><code>GROUP BY A,B,C</code>：基于A、B、C三列的分组统计</li></ul>
          </div>
<h3 id="ROLLUP"><a href="#ROLLUP" class="headerlink" title="ROLLUP"></a>ROLLUP</h3><p>使用<code>ROLLUP</code>选项，除了生成基于所有指定列的分组统计外，还对指定的分组列从左开始的每个子集进行统计。</p>
<div class="note default">
            <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">GROUP BY ROLLUP(A,B,C)</span><br></pre></td></tr></table></figure><p>形成的统计包括以下内容：</p><ul><li><code>GROUP BY</code>：不基于任何列的整个查询结果的统计</li><li><code>GROUP BY A</code>：基于A列的分组统计</li><li><code>GROUP BY A,B</code>：基于A、B两列的分组统计</li><li><code>GROUP BY A,B,C</code>：基于A、B、C三列的分组统计</li></ul>
          </div>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://www.cnblogs.com/yyjie/p/7788428.html" target="_blank" rel="noopener">关于sql和MySQL的语句执行顺序</a></li>
<li><a href="https://www.cnblogs.com/wangyonglong/p/5140728.html" target="_blank" rel="noopener">oracle中分组中的ROLLUP和CUBE选项</a></li>
</ul>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>SQL</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>Machine Learning | AdaBoost</title>
    <url>/%E7%AE%97%E6%B3%95-AdaBoost.html</url>
    <content><![CDATA[<p><center>Adaptive Boosting</center><br><a id="more"></a></p>
<p>自适应增强</p>
<p><strong>自适应</strong>在于：前一个分类器分错的样本会被用来训练下一个分类器——AdaBoost能够适应弱分类器各自的训练误差率</p>
<h1 id="AdaBoost"><a href="#AdaBoost" class="headerlink" title="AdaBoost"></a>AdaBoost</h1><p>由Yoav Freund和Robert Schapire提出</p>
<div class="note default">
            <p>Freund, Yoav , and R. E. Schapire . “<a href="https://www.cis.upenn.edu/~mkearns/teaching/COLT/adaboost.pdf" target="_blank" rel="noopener">A Decision-Theoretic Generalization of On-Line Learning and an Application to Boosting</a>.” <em>Proceedings of the Second European Conference on Computational Learning Theory</em>, 1995, pp. 23-37.</p>
          </div>
<ul>
<li>模型：加法模型</li>
<li>AdaBoost是损失函数为<strong>指数损失</strong>（exponential error loss）的Boosting算法</li>
<li>学习算法：前向分步算法的二分类学习算法</li>
<li>可用于分类，也可用于回归</li>
</ul>
<h2 id="基学习器"><a href="#基学习器" class="headerlink" title="基学习器"></a>基学习器</h2><p>在分类模型中称为<strong>基分类器</strong>（classifier）</p>
<p>可以是</p>
<ul>
<li>决策树<ul>
<li>AdaBoost分类用CART分类树</li>
<li>AdaBoost回归用CART回归树</li>
</ul>
</li>
<li>神经网络（neural networks）</li>
<li>线性判别（linear discriminants）</li>
<li>……</li>
</ul>
<p>其中使用最广泛的是决策树和神经网络。</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><ul>
<li>训练数据集特征$x_i\ (x_i\in \mathbb{R}^p;\ i=1,\cdots,N)$</li>
<li>训练数据集标签$y_i=\{-1,+1\}$</li>
</ul>
<p>在第$t$次迭代时，前面已经训练得到$t-1$个弱分类器$h_j(x)\quad(j=1,\cdots,t-1)$，且对应的重要性为$\alpha_j$。</p>
<p>此时已得到$t-1$个弱分类器的组合分类器</p>
<script type="math/tex; mode=display">H_{t-1}(x_i)=\alpha_1 h_1(x_i)+\alpha_2 h_2(x_i)+\cdots+\alpha_{t-1} h_{t-1}(x_i)</script><p>想要将该组合分类器继续扩展成</p>
<script type="math/tex; mode=display">H_{t}(x_i)=H_{t-1}(x_i)+\alpha_th_t(x_i)</script><p>AdaBoost的损失函数是指数损失：</p>
<ul>
<li>若分类器$h(\cdot)$将第$i$个样本正确分类（即$h(x_i)=y_i$），则损失为<script type="math/tex; mode=display">e^{-\alpha}</script></li>
<li>若分类器$h(\cdot)$将第$i$个样本错误分类（即$h(x_i)\neq y_i$），则损失为<script type="math/tex; mode=display">e^{\alpha}</script></li>
</ul>
<p>即</p>
<script type="math/tex; mode=display">e^{-\alpha y_ih(x_i)}</script><p>其中$\alpha&gt;0$保证“错误分类”的样本受到的“惩罚”更重。</p>
<p>则$H_{t}(x_i)$的损失函数为<br>\begin{aligned}<br>\mathrm{Loss}&amp;=\sum_{i=1}^Ne^{-y_iH_t(x_i)}\\<br>&amp;= \sum_{i=1}^N\exp\left\{-y_i\left(H_{t-1}(x_i)+\alpha_th_t(x_i) \right) \right\}\\<br>&amp;= \sum_{i=1}^N\exp\left\{-y_iH_{t-1}(x_i)\right\}\exp\left\{-y_i\alpha_th_t(x_i)\right\}\\<br>&amp;=\sum_{i=1}^N w_i^{(t)}\exp\left\{-y_i\alpha_th_t(x_i)\right\}\\<br>&amp;= \sum_{y_i=h_t(x_i)}w_i^{(t)}e^{-\alpha_t}+\sum_{y_i\neq h_t(x_i)}w_i^{(t)}e^{\alpha_t}\\<br>&amp;= \sum_{i=1}^Nw_i^{(t)}\left(\frac{\sum_{y_i=h_t(x_i)}w_i^{(t)}}{\sum_{i=1}^Nw_i^{(t)}}e^{-\alpha_t}+\frac{\sum_{y_i\neq h_t(x_i)}w_i^{(t)}}{\sum_{i=1}^Nw_i^{(t)}}e^{\alpha_t} \right)\\<br>&amp;= \sum_{i=1}^Nw_i^{(t)}\left((1-e_t)e^{-\alpha_t}+e_te^{\alpha_t}\right)<br>\end{aligned}<br>其中</p>
<ul>
<li>$w_i^{(t)}=e^{-y_iH_{t-1}(x_i)}$为第$t$次迭代中样本的权重，依赖于前一轮的迭代重分配</li>
<li>$\frac{\sum_{y_i\neq h_t(x_i)}w_i^{(t)}}{\sum_{i=1}^Nw_i^{(t)}}$为分类误差率$e_t$</li>
</ul>
<p>损失函数Loss关于$\alpha_t$求偏导并令导数为零，即$\frac{\partial{\mathrm{Loss}}}{\partial{\alpha_t}}=0$，得</p>
<script type="math/tex; mode=display">\alpha_t=\frac{1}{2}\ln\frac{1-e_t}{e_t}</script><div class="note default">
            <p>\begin{aligned}<br>\frac{\partial{\mathrm{Loss}}}{\partial{\alpha_t}}&amp;=0\\<br>\sum_{i=1}^Nw_i^{(t)}\left((e_t-1)e^{-\alpha_t}+e_te^{\alpha_t} \right)&amp;=0\\<br>(e_t-1)e^{-\alpha_t}+e_te^{\alpha_t}&amp;=0\\<br>e_t-1+e_te^{2\alpha_t}&amp;=0\\<br>e^{2\alpha_t}&amp;=\frac{1-e_t}{e_t}\\<br>\alpha_t&amp;=\frac{1}{2}\ln\frac{1-e_t}{e_t}<br>\end{aligned}</p>
          </div>
<div class="note danger">
            <h2 id="AdaBoost算法"><a href="#AdaBoost算法" class="headerlink" title="AdaBoost算法"></a>AdaBoost算法</h2><p><strong>输入</strong>：</p><ul><li><p>训练数据集$D=\{(x_1,y_1),\cdots,(x_N,y_N)\}$</p><p>其中$x_i\in X\subseteq \mathbb{R}^p,\quad y_i\in Y=\{-1,+1\}$</p></li><li>迭代次数$T$</li><li>初始化训练样本的权值分布<script type="math/tex; mode=display">D_1=(w_1^{(1)},w_2^{(1)},\cdots, w_N^{(1)})</script>其中$w_i^{(1)}=\frac{1}{N},\quad i=1,2,\cdots,N$。</li></ul><p><strong>输出</strong>：最终（强）分类器</p><script type="math/tex; mode=display">H(x)=\mathrm{sign}\left(\sum_{t=1}^T\alpha_t h_t(x)\right)</script><p>对于$t=1,\cdots,T$:</p><ol><li>使用具有权值分布$D_t$的训练数据集进行学习，得到弱分类器$h_t(x)$</li><li>计算$h_t(x)$在训练集上的分类误差率<script type="math/tex; mode=display">e_t=\sum_{i=1}^Nw_i^{(t)}\cdot \mathbf{I}\left(h_t(x_i)\neq y_i \right)=\sum_{h_t(x_i)\neq y_i}w_i^{(t)}</script></li><li>计算$h_t(x)$在强分类器中所占的比重<script type="math/tex; mode=display">\alpha_t=\frac{1}{2}\ln{\frac{1-e_t}{e_t}}</script></li><li>更新训练数据集的权值分布$w_i^{(t+1)}$<br>\begin{aligned}<br>w_i^{(t+1)}&amp;=\frac{w_i^{(t)}}{Z_t}e^{-\alpha_t y_i h_t(x_i)}\\<br>&amp;=\left\{\begin{array}{ll}<br>\frac{w_i^{(t)}}{Z_t}e^{-\alpha_t} &amp; \mathrm{if} \quad h_t(x_i)=y_i\\<br>\frac{w_i^{(t)}}{Z_t}e^{\alpha_t} &amp; \mathrm{if} \quad h_t(x_i)\neq y_i<br>\end{array}\right.\\<br>&amp;=\left\{\begin{array}{ll}<br>\frac{w_i^{(t)}}{Z_t}\sqrt{\frac{e_t}{1-e_t}} &amp; \mathrm{if} \quad h_t(x_i)=y_i\\<br>\frac{w_i^{(t)}}{Z_t}\sqrt{\frac{1-e_t}{e_t}} &amp; \mathrm{if} \quad h_t(x_i)\neq y_i<br>\end{array}\right.<br>\end{aligned}<br>其中$Z_t$是归一化因子（为了使样本的概率分布和为1）<script type="math/tex; mode=display">Z_t=\sum_{i=1}^Nw_i^{(t)}e^{-\alpha_t y_i h_t(x_i)}</script><script type="math/tex; mode=display">\sum_{i=1}^Nw_i^{(t+1)}=1</script></li></ol>
          </div>
<ul>
<li>$e_t=0$：完美分类器，分类器的权重为正无穷大</li>
<li>$e_t=\frac{1}{2}$：比随机猜的分类效果还差的分类器，分类器的权重为0</li>
<li>$e_t=1$：完美骗子（perfect liar），分类器的权重为负无穷大</li>
</ul>
<h2 id="正则化"><a href="#正则化" class="headerlink" title="正则化"></a>正则化</h2><p>为了防止AdaBoost过拟合，通常会在迭代过程中加入正则化项，称之为步长（learning rate）。</p>
<p>在前面的第$t$次迭代中，得到的组合学习器为</p>
<script type="math/tex; mode=display">H_t(x)=H_{t-1}(x)+\alpha_t h_t(x)</script><p>加入正则化项，为</p>
<script type="math/tex; mode=display">H_t(x)=H_{t-1}(x)+\nu \alpha_t h_t(x)</script><p>其中$0&lt; \nu \leq 1$为步长。</p>
<p>对于同一训练集，较小的$\nu$意味着需要更多的弱学习器的迭代次数（$T$需要更大）。</p>
<p>通常结合<strong>步长</strong>和<strong>迭代最大次数</strong>一起决定算法的拟合效果。</p>
<h1 id="训练误差分析"><a href="#训练误差分析" class="headerlink" title="训练误差分析"></a>训练误差分析</h1><div class="note success">
            <p>AdaBoost算法最终分类器的训练误差界为</p><script type="math/tex; mode=display">\frac{1}{N}\sum_{i=1}^N\mathbf{I}\left(H(x_i)\neq y_i \right)\leq \frac{1}{N}\sum_{i=1}^N \exp\left\{-y_i\sum_{t=1}^T\alpha_th_t(x_i) \right\}=\prod_{t=1}^TZ_t</script>
          </div>
<div class="note default">
            <p><strong>证明</strong>：<br>\begin{aligned}<br>\frac{1}{N}\sum_{i=1}^N \exp\left\{-y_i\sum_{t=1}^T\alpha_th_t(x_i) \right\} &amp;= \frac{1}{N}\sum_{i=1}^N\prod_{t=1}^T\exp\left\{-\alpha_ty_ih_t(x_i)\right\}\\<br>&amp;= \sum_{i=1}^N w_i^{(1)}\prod_{t=1}^T\exp\left\{-\alpha_ty_ih_t(x_i)\right\} \quad (w_1^{(1)}=\frac{1}{N})\\<br>&amp;= Z_1 \sum_{i=1}^N w_i^{(2)}\prod_{t=2}^T\exp\left\{-\alpha_ty_ih_t(x_i)\right\}\quad (Z_tw_i^{(t+1)}=w_i^{(t)}e^{-\alpha_ty_ih_t(x_i)})\\<br>&amp;= Z_1Z_2 \sum_{i=1}^N w_i^{(3)}\prod_{t=3}^T\exp\left\{-\alpha_ty_ih_t(x_i)\right\}\\<br>&amp;=\cdots\\<br>&amp;= Z_1Z_2\cdots Z_{T-1}\sum_{i=1}^N w_i^{(T)}e^{-\alpha_Ty_ih_T(x_i)}\\<br>&amp;=\prod_{t=1}^T Z_t<br>\end{aligned}</p>
          </div>
<div class="note success">
            <p>二分类问题AdaBoost的训练误差界为：</p><script type="math/tex; mode=display">\prod_{t=1}^T Z_t=\prod_{t=1}^T \left[2\sqrt{e_t(1-e_t)} \right]=\prod_{t=1}^T \sqrt{1-4\gamma_t^2}\leq \exp\left(-2\sum_{t=1}^T \gamma_t^2 \right)</script><p>其中$\gamma_t=\frac{1}{2}-e_t$</p>
          </div>
<div class="note default">
            <p><strong>证明</strong>：<br>因为$\alpha_t=\frac{1}{2}\ln{\frac{1-e_t}{e_t}}$，所以</p><script type="math/tex; mode=display">e^{\alpha_t}=\sqrt{\frac{1-e_t}{e_t}}</script><script type="math/tex; mode=display">e^{-\alpha_t}=\sqrt{\frac{e_t}{1-e_t}}</script><p>\begin{aligned}<br>Z_t &amp;= \sum_{i=1}^N w_i^{(t)}e^{-\alpha_ty_ih_t(x_i)}\\<br>&amp;= \sum_{y_i=h_t(x_i)}w_i^{(t)}e^{-\alpha_t}+\sum_{y_i\neq h_t(x_i)}w_i^{(t)}e^{\alpha_t}\\<br>&amp;= (1-e_t)e^{-\alpha_t}+e_te^{\alpha_t}\\<br>&amp;= 2\sqrt{e_t(1-e_t)}\\<br>&amp;= \sqrt{1-4\gamma_t^2}<br>\end{aligned}</p><p>$\sqrt{1-2x}$在$x=0$的泰勒展开为</p><script type="math/tex; mode=display">\sqrt{1-2x}=1-x-x^2+o(x^3)</script><p>$e^{-x}$在$x=0$的泰勒展开为</p><script type="math/tex; mode=display">e^{-x}=1-x+\frac{1}{2}x^2+o(x^3)</script><p>所以有$\sqrt{1-2x}\leq e^{-x}$。令这里$x=2\gamma_t^2$，则有</p><script type="math/tex; mode=display">\sqrt{1-4\gamma_t^2}\leq \exp(-2\gamma_t^2)</script>
          </div>
<div class="note success">
            <p><strong>训练误差指数下降</strong></p><p>如果存在$\gamma&gt;0$，对所有的$t$有$\gamma_t\geq \gamma$，则</p><script type="math/tex; mode=display">\frac{1}{N}\sum_{i=1}^N\mathbf{I}\left(H(x_i)\neq y_i \right)\leq \exp\left(-2T\gamma^2 \right)</script><p>AdaBoost算法不需要知道下界$\gamma$。</p>
          </div>
<h1 id="Python实现"><a href="#Python实现" class="headerlink" title="Python实现"></a>Python实现</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> AdaBoostClassifier</span><br><span class="line"></span><br><span class="line">clf = AdaBoostClassifier()</span><br><span class="line"><span class="comment">## n_estimators = 50 (默认)</span></span><br><span class="line"><span class="comment">## base_estimator = DecisionTreeClassifier  (默认)</span></span><br><span class="line">clf.fit(X_train, y_train)  <span class="comment">## 训练</span></span><br><span class="line">clf.predict(X_test)  <span class="comment">## 预测</span></span><br></pre></td></tr></table></figure>
<h1 id="Problems"><a href="#Problems" class="headerlink" title="Problems"></a>Problems</h1><div class="note primary">
            <h2 id="过拟合？"><a href="#过拟合？" class="headerlink" title="过拟合？"></a>过拟合？</h2><p>AdaBoost算法会尝试尽量拟合好每一点，这样不会导致过拟合吗？<br>The algorithm tries to fit every point, doesn’t it overfit?</p>
          </div>
<div class="note default">
            <p>No, it does not. The answer has been found out through experimental results, there has been speculations but no concrete reasoning available.</p><p>From: <em><a href="https://hackernoon.com/boosting-algorithms-adaboost-gradient-boosting-and-xgboost-f74991cad38c" target="_blank" rel="noopener">Boosting Algorithms: AdaBoost, Gradient Boosting and XGBoost</a></em></p>
          </div>
<div class="note primary">
            <h2 id="抗噪能力？"><a href="#抗噪能力？" class="headerlink" title="抗噪能力？"></a>抗噪能力？</h2><p>AdaBoost等几种基本机器学习算法哪个抗噪能力最强，哪个对重采样不敏感？</p>
          </div>
<div class="note default">
            <ol><li>抗噪能力强——对异常点不敏感</li><li>对重采样不敏感——对数据不均衡不敏感</li></ol><ul><li>聚类算法一般抗噪能力强；集成算法对重采样不敏感</li><li>AdaBoost对异常点敏感</li><li>K-Means对异常点敏感</li></ul>
          </div>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul>
<li>AdaBoost作为分类器时，分类精度很高</li>
<li>在AdaBoost的框架下，可以使用各种回归分类模型来构建弱学习器，非常灵活</li>
<li>作为简单的二分类器时，构造简单，结果可理解</li>
<li>不容易发生过拟合</li>
</ul>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul>
<li>对异常样本敏感<ul>
<li>异常样本在迭代中可能会获得较高的权重，影响最终的强学习器的预测准确性</li>
</ul>
</li>
</ul>
<h1 id="AdaBoost-vs-GBDT"><a href="#AdaBoost-vs-GBDT" class="headerlink" title="AdaBoost vs GBDT"></a>AdaBoost vs GBDT</h1><div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: center;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: center;">
      <th></th>
      <th>AdaBoost</th>
      <th>GBDT</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>共同点</th>
      <td colspan="2">目标都是优化偏差（Bias）</td>
    </tr>
    <tr>
      <th>每轮学习新的学习器</th>
      <td>通过改变样本的权值<br>关注上轮分类错误的样本的权值</td>
      <td>通过改变输出值<br>每轮拟合的值为真实值与已有的加法模型的差值（即残差）</td>
    </tr>
    <tr>
      <th>异常点</th>
      <td>敏感</td>
      <td>一定程度上优化了AdaBoost异常点敏感的问题</td>
    </tr>
    <tr>
      <th>树</th>
      <td></td>
      <td>CART树</td>
    </tr>
    <tr>
  </tr></tbody>
</table>
</div>


<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://zh.wikipedia.org/wiki/AdaBoost" target="_blank" rel="noopener">维基百科-AdaBoost</a></li>
<li><a href="https://louisscorpio.github.io/2017/11/28/AdaBoost%E5%85%A5%E9%97%A8%E8%AF%A6%E8%A7%A3/" target="_blank" rel="noopener">AdaBoost入门详解</a></li>
<li><a href="http://www.inf.fu-berlin.de/inst/ag-ki/adaboost4.pdf" target="_blank" rel="noopener">AdaBoost and the Super Bowl of Classifiers A Tutorial Introduction to Adaptive Boosting</a></li>
<li><a href="https://hackernoon.com/boosting-algorithms-adaboost-gradient-boosting-and-xgboost-f74991cad38c" target="_blank" rel="noopener">Boosting Algorithms: AdaBoost, Gradient Boosting and XGBoost</a></li>
<li><a href="https://cseweb.ucsd.edu/~yfreund/papers/IntroToBoosting.pdf" target="_blank" rel="noopener">A Short Introduction to Boosting</a></li>
<li><a href="https://book.douban.com/subject/10590856/" target="_blank" rel="noopener">李航-统计学习方法</a></li>
<li><a href="https://blog.csdn.net/qq_37792144/article/details/89374530" target="_blank" rel="noopener">机器学习树模型对比总结</a></li>
<li><a href="https://pre.nowcoder.com/discuss/100334?type=1" target="_blank" rel="noopener">牛客交流贴-在你所知的机器学习算法中，哪个抗噪能力最强？哪个对采样不敏感？</a></li>
<li><a href="https://www.cnblogs.com/pinard/p/6133937.html" target="_blank" rel="noopener">刘建平Pinard-集成学习之Adaboost算法原理小结</a></li>
</ul>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>机器学习</tag>
        <tag>分类</tag>
        <tag>集成学习</tag>
        <tag>回归</tag>
        <tag>Boosting</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL | 《SQL解惑》</title>
    <url>/sql-sql%E8%A7%A3%E6%83%91.html</url>
    <content><![CDATA[<p><center>《SQL解惑（第二版）》学习笔记</center><br><a id="more"></a></p>
<h1 id="财政年度表"><a href="#财政年度表" class="headerlink" title="财政年度表"></a>财政年度表</h1><ul>
<li>创建表格时需要添加约束，保证表格的正确性</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> FiscalYears</span><br><span class="line">(fiscal_year <span class="built_in">INTEGER</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> PRIMARY <span class="keyword">KEY</span>,   <span class="comment">-- 主键约束</span></span><br><span class="line">start_date <span class="built_in">DATE</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="keyword">CONSTRAINT</span> valid_start_date  <span class="comment">-- 判断start_date是否符合会计年度规定</span></span><br><span class="line">			<span class="keyword">CHECK</span> ( (<span class="keyword">EXTRACT</span>(<span class="keyword">YEAR</span> <span class="keyword">FROM</span> start_date)  = fiscal_year - <span class="number">1</span>)  <span class="comment">-- EXTRACT()从start_date中提取年份</span></span><br><span class="line">				 <span class="keyword">AND</span> (<span class="keyword">EXTRACT</span>(<span class="keyword">MONTH</span> <span class="keyword">FROM</span> start_date) = <span class="number">10</span>)</span><br><span class="line">                 <span class="keyword">AND</span> (<span class="keyword">EXTRACT</span>(<span class="keyword">DAY</span> <span class="keyword">FROM</span> start_date) = <span class="number">01</span>) ),</span><br><span class="line">end_date <span class="built_in">DATE</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="keyword">CONSTRAINT</span> valid_end_date  <span class="comment">-- 判断end_date是否符合会计年度规定</span></span><br><span class="line">			<span class="keyword">CHECK</span> ((<span class="keyword">EXTRACT</span>(<span class="keyword">YEAR</span> <span class="keyword">FROM</span> end_date) = fiscal_year)</span><br><span class="line">				<span class="keyword">AND</span> (<span class="keyword">EXTRACT</span>(<span class="keyword">MONTH</span> <span class="keyword">FROM</span> end_date) = <span class="number">09</span>)</span><br><span class="line">                <span class="keyword">AND</span> (<span class="keyword">EXTRACT</span>(<span class="keyword">DAY</span> <span class="keyword">FROM</span> end_date) = <span class="number">30</span>)));</span><br></pre></td></tr></table></figure>
<p>但是……错误的语句竟然成功插入了？？<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; INSERT INTO FiscalYears VALUES</span><br><span class="line">    -&gt; (1996, '1995-10-01', '1996-08-30');</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT * FROM FiscalYears;</span><br><span class="line">+<span class="comment">-------------+------------+------------+</span></span><br><span class="line">| fiscal_year | start_date | end_date   |</span><br><span class="line">+<span class="comment">-------------+------------+------------+</span></span><br><span class="line">|        1996 | 1995-10-01 | 1996-08-30 |</span><br><span class="line">+<span class="comment">-------------+------------+------------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></p>
<p>bug待解决……</p>
<h1 id="缺勤者"><a href="#缺勤者" class="headerlink" title="缺勤者"></a>缺勤者</h1>]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>TED | Why Do Cats Act so Weird</title>
    <url>/TED-WhyDoCatsActSoWeird.html</url>
    <content><![CDATA[<p><center>A New Week!</center><br><a id="more"></a></p>
<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>Last Week → <a href="/TED-TrySomethingNewfor30days.html" title="Try Something New for 30 Days">Try Something New for 30 Days</a></p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<h1 id="Why-Do-Cats-Act-so-Weird"><a href="#Why-Do-Cats-Act-so-Weird" class="headerlink" title="Why Do Cats Act so Weird?"></a>Why Do Cats Act so Weird?</h1><ul>
<li><a href="https://www.ted.com/talks/tony_buffington_why_do_cats_act_so_weird" target="_blank" rel="noopener">Why Do Cats Act so Weird?</a></li>
<li>2020.05.25</li>
</ul>
<p>They are cute, they are lovable. And judging by the 26 billion views of over 2 millon youtude videos of <del>they</del> <strong>them</strong> pouncing, bouncing, climbing, <del>criming</del><strong>cramming</strong>, <del>stacking</del><strong>stalking</strong>, chattering（喋喋不休） and purring（猫喘鸣）, one thing is certain<del>ed</del>, cats are very entertainning.</p>
<p><del>The someone</del> <strong>These somewhat</strong> strange <del>feel on</del> <strong>feline</strong>(猫科的) behaviors both amusing and <del>bathing</del><strong>baffling</strong>(令人困惑的), <del>maybe</del> <strong>leave many of us</strong> asking, why do cats do that?</p>
<p><del>The rough</del> <strong>Throughout</strong> time, cats were simultaneously <del>predictors</del><strong>predators</strong>(食肉动物；掠食者) <del>and</del> <strong>of smaller</strong> animals and prey（被捕食动物） for large <strong>carnivores</strong>(食肉动物；食虫植物) . As both <strong>predator</strong> and <del>prayer</del> <strong>prey</strong>, <del>survive</del> <strong>survival of their species depended</strong> <del>depends</del> on <del>their and uncrucious</del> <strong>crucial instinctual</strong>(关键本能) behaviors, which <strong>we</strong> still observe<del>d</del> in wild and <strong>domestic</strong> cats today.</p>
<p>While the <strong>feline</strong> actions <del>cats</del> <strong>of</strong> your house cat<del>s</del> <strong>Grizmo might seem perplexing(使困惑),</strong> in the wild<strong>, these</strong> <del>the</del> same behavior<strong>s</strong> naturally <del>bring in</del> <strong>bred into</strong> cats for million<strong>s of</strong> years<strong>,</strong> would <del>made</del> <strong>Grizmo</strong>  a super cat. </p>
<p>Enable by their unique <strong>muscular</strong> <del>mas</del> structure and keen <del>bouncing</del> <strong>balancing abilities</strong> <del>ability</del>, cats climb<strong>ed</strong> to high <del>adventure</del> <strong>vantage</strong>(优势，有利地位) point<strong>s</strong> to <strong>survey their territory</strong> <del>the</del> and <del>spout prayer</del> <strong>spot prey</strong> in the wild. <strong>Grizmo</strong> doesn’t need particular skill<strong>s</strong> to find and hunt down dinner in her food <del>ball</del> <strong>bowl</strong> today, but <strong>instinctually</strong>(本能地) <del>instantiously</del>, <del>even</del> <strong>viewing</strong> the living room from the top of the bookcase is exactly what she has <strong>evolved</strong> to do.</p>
<p>As wild <del>predictors</del> <strong>predators</strong>, cat has  <strong>opportunistic</strong> and hunt whenever <strong>prey</strong> <del>are</del> <strong>is</strong> available. Since most cat<del>s</del> prey <strong>are</strong> small<strong>, cats in the</strong> <del>catching</del> wild need<strong>ed to</strong> eat many times each day, and <strong>use a stalk, pounce, kill,</strong> <del>its stack pounching</del> eat strategy <del>is</del> stay <strong>fed</strong> . This is why <strong>Grizmo</strong> <del>cats</del> prefer<strong>s</strong> to <del>chess</del> <strong>chase</strong> and pounce on <strong>little</strong> toys and eat small meals over the <del>quarts</del> <strong>courses</strong> of day and night. Also<strong>,</strong> small prey <strong>tend to hide in</strong> <del>high and</del> tiny spaces in the natural environments, so one <strong>explanation for Grizmo’s propensity to reach into containers and</strong> <del>for for pensity for rich entercontrainer</del> opening is that she <strong>is compelled</strong> <del>compare</del> by the same curiosity <strong>that helped ensure the continuation of her species</strong> <del>they hope continue</del> for million<strong>s of</strong> years before.</p>
<p>In the wild, cats need<strong>ed</strong> to <strong>sharp claws</strong> <del>close</del> for climbing, <strong>hunting, and self-defense.</strong><del>pouncing,</del> <strong>Sharpening</strong> thier <strong>claws on nearby surfaces kept them conditioned and ready,</strong> <del>by cap them condition</del> help<strong>ed</strong> stretch their back and <del>like</del> <strong>leg</strong> muscle<strong>s</strong>, <strong>and relieve</strong> some <strong>stress,</strong> too. So it is <strong>not that Grizmo hates your</strong> <del>nothing</del> couch, chair, <strong>ottoman,</strong> pillows, curtains and everything <strong>else</strong> you put in their environment. She <strong>is ripping these things to shreds（碎片，破布）</strong> <del>needs to rip</del> and keep<strong>ing</strong> her <del>clause</del> <strong>claws in tip-top(极好的) shape</strong> <del>to top shade,</del> because this is exactly what her ancestor<strong>s</strong> did in order to survive. </p>
<p>As animals <del>to</del> <strong>that were preyed upon</strong> , cats <strong>evolved</strong> to not get <strong>caught, and</strong> <del>close</del> in the wild, <strong>the cats that were the best at avoiding predators thrived</strong>. So at your house today, <del>even</del> <strong>Grizmo is an</strong> expert at squeezing <del>in</del> <strong>into</strong> small spaces and seeking out and hiding <strong>in unconventonal(非传统地) spots</strong> <del>un</del>. It also <strong>explains why she</strong> prefer<strong>s</strong> <del>at</del> <strong>a</strong> clean<del>ing</del> and <del>older free</del> <strong>odor-free</strong>(无异味地) little box. That <strong>is less likely to</strong> give <strong>away</strong> her <del>vacation</del> <strong>location to any predactors that may be sniffing</strong>(嗅探) <del>and</del> around <del>you by</del> <strong>nearby</strong>.</p>
<p>Considering everything <del>you</del> <strong>we</strong> do know about cats, it seems <strong>that</strong> one of <del>the</del> <strong>their</strong> most <del>predominant</del> <strong>predominate</strong> behavior<strong>s is</strong> still one of the most <del>weird</del> <strong>mysterious</strong>(神秘的，难以理解的). Cats may pur<em>r</em> for any number of reasons, such as happiness, stress and hunger. But curiously, the frequency of they <del>pur</del> <strong>purrs</strong> between 25 and 150 <strong>hertz,</strong> is within a range <strong>that</strong> can <strong>promote</strong> tissue(组织，纸巾) <strong>re</strong>generation. So <del>why</del> <strong>while her</strong> purring <strong>makes Grizmo an</strong> <del>and</del> excellent <strong>nap companion</strong>, it is also possible that her pur<strong>r</strong> is healing <strong>her</strong> muscles and bones, and <del>even</del> maybe <strong>even yours,</strong> too.</p>
<p>They develope<strong>ed</strong> through time and <del>soli</del> <strong>solitary(孤独的，独居的) predactors that</strong> <del>predic</del> hunted and killed <strong>to eat, and stealthy（秘密的，鬼鬼祟祟的） prey that hid and escaped</strong> <del>they eat still feel</del> to survive. So cats today retain many <strong>of the</strong> same <del>things</del> <strong>instincts</strong> allow<strong>ed</strong> them to <del>fly</del> <strong>thrive</strong>(兴盛，茁壮) in the wild for millions of years. This explain<strong>s</strong> some of <strong>their seemlingly</strong> strange behaviors<strong>.</strong>  To them, our homes are their jungles. But <del>it fits</del> <strong>if this is</strong> the case<strong>, in</strong> our own cat’s eyes, who <strong>are we? Big, dumb, hairless cats</strong> <del>will</del> competing with them with resource <strong>?</strong><del>,</del> Terribly stupid <strong>predactors</strong> they <strong>are</strong> able to <strong>outsmart</strong>(用计谋打败) everyday<strong>?</strong> Or maybe they think we are the prey.</p>
<h1 id="How-Sugar-Affects-the-Brain"><a href="#How-Sugar-Affects-the-Brain" class="headerlink" title="How Sugar Affects the Brain"></a>How Sugar Affects the Brain</h1><ul>
<li><a href="https://www.ted.com/talks/nicole_avena_how_sugar_affects_the_brain/up-next#t-7442" target="_blank" rel="noopener">How Sugar Affects the Brain</a></li>
<li>2020.05.27</li>
</ul>
<p><del>Patient</del> <strong>Picture</strong> warm, <strong>gooey</strong>(蜜糖) cookies, <strong>crunchy</strong>(易碎的；发嘎吱嘎吱声的) candies, <strong>velvety</strong>(天鹅绒般柔软的) cakes, <del>walfe corns</del> <strong>waffle cones</strong>(华夫蛋筒) <strong>piled high with</strong> ice cream. Is your mouth watering? are you <strong>craving</strong>(渴望) desserts? Why? What happens in the brain that makes sugary foods so <del>hot</del> <strong>hard</strong> to <strong>resist</strong>? </p>
<p>Sugar is a general term you used to describe a class of molecules (分子) called carbohydrates （碳水化合物） and it is found in <strong>a</strong> wide <del>ated</del> <strong>variety of</strong> food<del>s</del> and drink<del>s</del>. Just check the labels on <del>three</del> <strong>sweet</strong> products you buy. Glucose( 葡萄糖), fructose (果糖), sucrose (蔗糖), maltose (麦芽糖), lactose (乳糖), dextrose (葡萄糖,右旋糖) and starch (淀粉) are all forms of sugar.<del>, such as</del> <strong>So are high-fructose</strong> corn syrup (玉米糖浆), fruit juice, raw sugar and honey. And sugar isn’t just in candies and in desserts, it is also <del>acted</del> <strong>added</strong> to <del>make</del> tomato sauce, yoghurt, <del>dry</del> <strong>dried</strong> fruit, flavor<strong>ed</strong> water<del>,</del> <strong>or granola</strong> (格兰诺拉麦片) bars.</p>
<p><strong>Since</strong> sugar is everywhere. It\’s important to understand how it affects the brain. What happends when sugar hits your tongue? And does eating a little bit <strong>of</strong> sugar make you crave more?</p>
<p>You take a bite of cereal (麦片粥), the sugar<strong>s</strong> that it contains <del>act</del> <strong>activate</strong> the sweet<strong>-taste receptors</strong> <del>tastal</del> , part of <strong>the</strong> taste <strong>buds</strong> (萌芽；蓓蕾) on the tongue.<del>, this was</del> <strong>These receptors</strong> send <strong>a</strong> signal up to the brain <strong>stem</strong> ((花草的)茎, (树木的)干) <del>stand</del>, and from there, it <strong>forks off into</strong> <del>and any</del> <strong>many</strong> area<strong>s of the forebrain</strong> <del>full brain</del>, one of which is the cerebral cortex (大脑皮层). Different sections of cerebral cortex <del>provide us</del> <strong>process</strong> different tastes: bitter, salty, umami (鲜味；甘味) ,and, in our case, sweet. From here, the signal <del>activative</del> <strong>activates</strong> the brain<strong>‘s</strong> <del>rewarm</del> <strong>reward</strong> system. This <del>rewarm</del> <strong>reward</strong> system is <del>ceres that</del> <strong>a series of electrical and</strong> chemical <del>pass away and</del> <strong>pathways across</strong>  several different <del>regimes</del> <strong>regions of</strong> <del>in</del> the brain. It is a compicated network, but it helps <strong>answer a</strong> <del>and</del> single <strong>, subconscious</strong> (下意识的;潜意识的) question, should I do that again? that warm <strong>fuzzy feeling</strong> you <del>get</del> <strong>got</strong> when you <del>takes</del> <strong>taste Grandma’s</strong> chocolate cake? that <strong>is</strong> your <del>rewarm</del> <strong>reward</strong> system saying, ‘Mmm, yes!’ And it’s not just <del>make it</del> <strong>activated</strong> by foods. Socializing, sex behavior and drugs are just <strong>a</strong> few examples <strong>of things and experiences that</strong> <del>but</del> also activative the <del>rewarm</del> <strong>reward</strong> system.But overactivating this <del>rewarm</del> <strong>reward</strong> system <strong>kickstarts a series of</strong> <del>ceres and</del> unfortunate <del>develops,</del> <strong>events:</strong> loss of control, <del>pre</del> <strong>craving,</strong> and increase<strong>d tolerance to</strong> sugar. </p>
<p>Let’s get back to our bite of cereal. It travels down <del>and to</del> <strong>into</strong> your stomach and eventually into your <strong>gut</strong> (内脏；肠子). And guess what? <strong>There are</strong> sugar <del>accepted ~~ <strong>receptors</strong> here, too. There are no taste ~~buts</del> <strong>buds,</strong> but they do <del>same</del> <strong>send</strong> signals telling your brain that you are full <strong>or that</strong> <del>all</del> your body should <strong>produce</strong> <del>put</del> more insulin (胰岛素) to deal with these extra sugars you <strong>are</strong> eating. </p>
<p>The ma<strong>jor</strong> currency of <strong>our reward</strong> <del>rewarm</del> system is dopamine (多巴胺（一种治脑神经病的药物）), <del>but</del> <strong>an important</strong> chemical or <del>neural</del> <strong>neurotransmitter</strong> . There are many dopamine <del>recepted</del> <strong>receptors</strong> in <del>whole</del> <strong>the fore</strong>brain but there are not evenly <del>should be</del> <strong>distributed</strong>. Certain areas contain<del>ing</del> <strong>dense clusters of receptors,</strong> <del>cost and , ~~ and ~~its</del> <strong>these</strong> dopamine <strong>hot</strong> spots <del>or</del> <strong>are a</strong> part of <strong>our reward</strong> <del>the rewarm</del> system. Drugs<del>, ,</del> <strong>likes</strong> alcohol<strong>, nicotine, or heroin</strong> send dopamine into overdrive, leading some people to sonstantly <del>sick</del> <strong>seek that</strong> high, in <del>another</del> <strong>other</strong> words, to be <strong>addicted.</strong> Sugar also causes dopamine to be <strong>released, though not as violently as grugs.</strong><del>don’t know it’s</del> And sugar is <del>very amount</del> <strong>rare among</strong> dopamine<strong>-inducing</strong> foods. <strong>Broccoli</strong> (花椰菜；西兰花), for sample, has no<del>t</del> affect<del>ed</del>, which probably explains why <strong>it’s</strong> so hard to <strong>get kids to</strong> eat their <strong>veggies</strong>(蔬菜).</p>
<p>Speaking of healthy foods, let’s <del>set</del> <strong>say</strong> you <strong>are</strong> hungry and decide to eat a balance<strong>d</strong> meal. You do, and dopamine levels sp<strong>ike</strong> <del>to</del> <strong>in the reward</strong> <del>rewarm</del> system <del>to</del> <strong>hot spots</strong> . But if you eat that same dish many days in a <strong>row</strong>(连续) <del>roll</del>, dopamine levels will <strong>spike</strong> less and less and eventually <del>level in</del> <strong>leveling</strong> out. That’s because when is comes to food, the brain <del>evolves</del> <strong>evolved</strong> to <del>its</del> <strong>pay</strong> special attention to new or different tastes. Why? Two reasons: First, to detect the food <del>is good or</del> <strong>that’s gone</strong> bad. And second, because <del>of</del> the <strong>more</strong> variety <del>that</del> we <strong>have in our</strong> diet, the more likely we are to get all the <strong>nutrients</strong> we need. To keep that variety up, we need to be able to recognise a new food and more importantly, we need to <strong>want to</strong> keep eating new foods, and that’s why the dopamine levels off when <del>the</del> <strong>a</strong> food becomes boring. </p>
<p>Now back to that meal, what happens if <strong>in</strong> place <strong>of the</strong> healthy, balanced dish, you eat sugar-rich food <del>and ,</del> <strong>instead？</strong> if you really eat sugar <strong>or don’t eat</strong> <del>your dopamine</del> much at <strong>a</strong> time, the <del>affect</del> <strong>effect</strong> is similar to <strong>that of</strong> the balanced meal. But if you eat too much, the dopamine response <strong>does not</strong> <del>just now</del> level off. In other words, eating lots of sugar<del>s</del> <strong>will continue to feel rewarding.</strong> <del>working continue to feel rewarming,</del> In this way, sugar <strong>behaves</strong> a little bit like <strong>a drug</strong> <del>your drugs</del>, it’s one reason people seem<del>ed</del> to be <strong>hooked</strong> <del>hold down</del> sugary foods.</p>
<p>So think back to all these different kinds of sugar, each one is <strong>unique,</strong> <del>you need</del> but every time any sugar is consumed, <del>a cake</del> <strong>it kickstarts a domino effect in</strong> <del>dopamine affecting</del> the brain that <del>spots</del> <strong>that sparks a rewarding</strong> feeling. Too much, <del>to</del> <strong>too</strong> often, and things can go <strong>in</strong>to overdrive. So yes, <del>often consumption</del> <strong>overconsumption</strong> of sugar can have <strong>addictive effects</strong> <del>affect</del> on <strong>the</strong> brain. But <del>eating a</del> <strong>a wedge (楔子) of</strong> cake once in a while <del>will</del> <strong>won’t</strong>  hurt you.</p>
<h1 id="Why-Do-People-Fear-the-Wrong-Things"><a href="#Why-Do-People-Fear-the-Wrong-Things" class="headerlink" title="Why Do People Fear the Wrong Things?"></a>Why Do People Fear the Wrong Things?</h1><ul>
<li><a href="https://www.ted.com/talks/gerd_gigerenzer_why_do_people_fear_the_wrong_things/up-next" target="_blank" rel="noopener">Why Do People Fear the Wrong Things?</a></li>
<li>2020.05.30</li>
</ul>
<p>“A new Drug reduces the risk of heart attacks by 40%”, “Shark attacks are up by a factor of two”, “Drinking a liter of soda per day doubles your chance of developeing cancer”.</p>
<p>These are all examples of relative risk. A common way, risk is presented in news articles. Risky evaluation is complicated tangle (乱糟糟的一堆, 混乱) of statistical thinking and personal preference. One common <del>sumpling</del> <strong>stumbling (摇摇晃晃或跌跌撞撞的) block</strong> <del>book, it</del> is the difference between relative risks like <del>to</del> <strong>these</strong> and what <del>they</del> <strong>are</strong> call<strong>ed</strong> <del>,</del> absolute risks. </p>
<p>Risk is the likelihood that <strong>an</strong> event will occur. It can be expressed <del>at</del> <strong>as either a</strong> percentages. For example, that heart attacks occur in 11% of men between <strong>the</strong> ages <strong>of</strong> 60 and 79, or as rate, that 1 in 2 million divers along Australia<strong>‘s</strong> west<strong>ern</strong> coast will suffer a <del>fear</del> <strong>fatal</strong> shark bite <del>in</del> each year. These numbers express the absolute risk of heart attacks and shark attacks in <del>its</del> <strong>these</strong> groups. Changes in risk can be expressed in relative or absolute terms. For example, <del>few</del> <strong>a review in</strong> 2009 found <del>the will</del> <strong>that mammography screenings</strong>(乳房X光检查) reduce<strong>d</strong> the number of <strong>breast cancer deaths</strong> <del>test</del> from 5 women in 1000 and to 4. The absolute risk <del>production</del> <strong>reduction</strong> was about 0.1%, but the relative <del>production</del> <strong>reduction</strong> from 5 <strong>case of</strong> cancer<del>s</del> mortality(死亡) to 4 is 20%. Based on <del>the</del> reports of <del>the</del> <strong>this</strong> higher number, people overestimate<strong>d</strong> the impact of <strong>screening</strong>.</p>
<p>To see why the difference between the two ways of expressing risks matters, let’s consider the <del>heart attacks</del> <strong>hypothetical</strong> example <strong>of a</strong> <del>. Offer the</del> drug that reduces heart attack<del>s</del> risk<del>s</del> by 40%. Imagine that <strong>out of a</strong> group of 1000 people who didn’t take the new drug, 10 would have heart attacks, the absolute <del>rate</del> <strong>risk</strong> is 10 out of 1000 or 1%. If a similar group of 1000 people did take the drug, the number of heart attacks would be 6, in other words, the drug could prevent 4 out of 10 <del>from</del> heart attacks, a relative risk <del>preduction</del> <strong>reduction</strong>  of 40%, meanwhile, the absolute risk only <del>drops</del> <strong>dropped</strong> from 1% to 0.6%, but the 40% relative risk decreased sound<em>8s*</em> a lot more significant. </p>
<p>Surely, preventing event <strong>a handful</strong> of <del>han</del> heart attacks or any other negative <del>about comes</del> <strong>outcome,</strong> is worthwhile, isn’t it? Not necessarily. The problem is that choices that reduce some risks can put you in the path of others, suppose the heart- attack drug<del>s of</del> cause<strong>d</strong> cancer one half to 1% to patient<strong>s</strong>, in our group of 1000 people, 4 heart attacks <del>will</del> <strong>would</strong> be prevented by taking the drug<del>s</del>, but there would be 5 new cases of cancer, the relative <del>preduction</del> <strong>reduction</strong> in heart attack<del>s</del> risk<del>s</del> sound<strong>s sustantial</strong> , and the absolute risks of cancer sound<strong>s</strong> small, but they work out <strong>to</strong> about the same number of cases.</p>
<p>In real life, everyone individual evaluation of risk <strong>will vary</strong> <del>very</del> depend<strong>ing</strong> on their personal <del>circustances</del> <strong>circumstances</strong>. If you know you have <strong>a</strong>family history of heart disease<del>s</del>, you might be more strongly <del>motivative</del> <strong>motivated</strong> to take the medication that will lower you heart-attack risk<del>s</del>. Even knowing <strong>it provided</strong> <del>the</del> only a small reduction in absolute risk<del>s</del>. Sometimes we have to decide between the <del>explosing</del> <strong>exposing ourselves</strong> to risks<del>,</del> that <strong>aren’t directly</strong> <del>to</del> comparable. If, for example, the heart attack<del>s</del> drug<del>s</del> <del>carry</del> <strong>carried</strong> a higher risk of <strong>debilitating</strong> but not <strong>life-threatening, side effect like migraines</strong> <del>rating affects and</del> <strong>rather than</strong> cancer, our evaluation of whether that <del>the</del> risk is worthy taking <strong>might change</strong>. And sometimes <del>that</del> <strong>there</strong> isn’t necessarily <strong>a</strong> right choice. Some might say<del>s</del>, even a <strong>minuscule</strong>(小写字；草写小字) shark attack is worth avoiding because all you <strong>‘d miss out on is an ocean swim</strong> <del>isn’t swimming</del> while others wouldn’t <strong>even</strong> consider skipping <strong>a</strong> swim to avoid <strong>an objectively</strong> tiny risk <strong>of</strong> shark attack. For all thest reasons, risk evaluation is tricky <strong>at baseline,</strong> <del>based on mind, at</del> <strong>and</strong> reporting on risk can be misleading, especially, when <strong>it</strong> <del>we</del> share<strong>s</strong> some numbers in absolute terms and others in relative terms. Understanding how these measures work will help you cut through <strong>some of</strong> the confusion and better evaluate risk.</p>
]]></content>
      <categories>
        <category>Everything</category>
      </categories>
      <tags>
        <tag>TED</tag>
        <tag>English</tag>
      </tags>
  </entry>
  <entry>
    <title>Algorithm | 背包问题</title>
    <url>/Algo-%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98.html</url>
    <content><![CDATA[<center>背包问题九讲学习</center>

<a id="more"></a>
<h1 id="0-1背包问题"><a href="#0-1背包问题" class="headerlink" title="0-1背包问题"></a>0-1背包问题</h1><ul>
<li>$N$个物品</li>
<li>一个容量为$V$的背包</li>
<li>每种物品仅有一个，可以选择“放入背包”或“不放入背包”</li>
<li>放入第$i$个物品耗费的费用为$C_i$（占用背包的空间容量），得到的价值为$W_i$</li>
</ul>
<script type="math/tex; mode=display">将哪些物品装入背包可使获得的价值总和最大</script><p>在线编程：<a href="https://www.acwing.com/problem/content/2/" target="_blank" rel="noopener">https://www.acwing.com/problem/content/2/</a></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>考虑$N$行$V$列的矩阵，第$i$行第$v$列的元素为$F(i,v)$表示<strong>前$i$个物品恰好放入一个容量为$v$的背包所能获得的最大价值</strong></p>
<ul>
<li>若不放第$i$个物品，则问题为“前$i-1$个物品放入容量为$v$的背包”，则能获得的最大价值为“前$i-1$个物品放入容量为$v$的背包”可获得的最大价值。即<script type="math/tex; mode=display">F(i,v)=F(i-1,v)</script></li>
<li>若放入第$i$个物品，则问题为“前$i-1$个物品放入容量为$v-C_i$的背包”，则能获得的最大价值为“前$i-1$个物品放入容量为$v-C_i$的背包”可获得的最大价值加上“放入第$i$个物品”可获得的价值。即<script type="math/tex; mode=display">F(i,v)=F(i-1,v-C_i)+W_i</script>因此<script type="math/tex; mode=display">F(i,v)=\max \left\{ F(i-1,v), F(i-1,v-C_i)+W_i \right\}</script></li>
</ul>
<p><strong>伪代码</strong></p>
<blockquote>
<ol>
<li>给定$N$行$V$列的空矩阵$F$，用于存储$F(i,v)$</li>
<li>对于$i=1,2,\cdots,N$， $v=C_i,\cdots,V$有<script type="math/tex; mode=display">F(i,v)=\max\left\{F(i-1,v), F(i-1,v-C_i)+W_i\right\}</script></li>
</ol>
</blockquote>
<ul>
<li>时间复杂度为$O(NV)$</li>
<li>空间复杂度为$O(NV)$</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 在线编程地址：https://www.acwing.com/problem/content/2/</span></span><br><span class="line"><span class="comment">## 二维数组实现</span></span><br><span class="line">N, V = list(map(int, input().split()))</span><br><span class="line">goods = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(N):</span><br><span class="line">    goods.append(list(map(int, input().split())))  <span class="comment">## 存放物品的体积、价值等信息</span></span><br><span class="line"></span><br><span class="line">F = [[<span class="number">0</span> <span class="keyword">for</span> j <span class="keyword">in</span> range(V+<span class="number">1</span>)] <span class="keyword">for</span> i <span class="keyword">in</span> range(N+<span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, N+<span class="number">1</span>):</span><br><span class="line">    <span class="keyword">for</span> v <span class="keyword">in</span> range(<span class="number">1</span>, V+<span class="number">1</span>):</span><br><span class="line">        F[i][v] = F[i<span class="number">-1</span>][v]  <span class="comment">## 不装入第i个物品</span></span><br><span class="line">        <span class="keyword">if</span> v &gt;= goods[i<span class="number">-1</span>][<span class="number">0</span>]:  <span class="comment">## 如果背包容量大于第i个物品的体积</span></span><br><span class="line">            F[i][v] = max(F[i][v], F[i<span class="number">-1</span>][v - goods[i<span class="number">-1</span>][<span class="number">0</span>]] + goods[i<span class="number">-1</span>][<span class="number">1</span>])  <span class="comment">## 选取价值最大的方案</span></span><br><span class="line"></span><br><span class="line">print(F[<span class="number">-1</span>][<span class="number">-1</span>])  <span class="comment">## 最后一个值为最大价值</span></span><br></pre></td></tr></table></figure>
<h2 id="思路优化"><a href="#思路优化" class="headerlink" title="思路优化"></a>思路优化</h2><p>考虑优化空间复杂度</p>
<p>上面的思路中，用$N$行$V$列的矩阵来存储信息，需要$NV$个存储位置，考虑将存储空间优化成$O(V)$</p>
<script type="math/tex; mode=display">只用长度为V的列表来存储信息</script><p><strong>伪代码</strong></p>
<blockquote>
<ol>
<li>给定长度为$V$的列表$F$</li>
<li>对于 $i=1,2,\cdots,N$:<ul>
<li>对于 $v=V, V-1, \cdots, C_i$:<script type="math/tex; mode=display">F[v]=\max\left\{F[v], F[v-C_i]+W_i \right\}</script></li>
</ul>
</li>
</ol>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 在线编程地址：https://www.acwing.com/problem/content/2/</span></span><br><span class="line"><span class="comment">## 一维数组实现</span></span><br><span class="line">N, V = list(map(int, input().split()))</span><br><span class="line">goods = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(N):</span><br><span class="line">    goods.append(list(map(int, input().split())))  <span class="comment">## 存放物品的体积、价值等信息</span></span><br><span class="line"></span><br><span class="line">F = [<span class="number">0</span> <span class="keyword">for</span> j <span class="keyword">in</span> range(V+<span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(N):</span><br><span class="line">    <span class="keyword">for</span> v <span class="keyword">in</span> range(V, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">        <span class="keyword">if</span> v &gt;= goods[i][<span class="number">0</span>]:</span><br><span class="line">            F[v] = max(F[v], F[v - goods[i][<span class="number">0</span>]] + goods[i][<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">print(F[<span class="number">-1</span>])</span><br></pre></td></tr></table></figure>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><blockquote>
<p>有个背包，可以装4磅的东西。怎样装以下的商品，可以使得背包里的东西价值最高？</p>
<ul>
<li>音响：3000美元，4磅</li>
<li>笔记本电脑：2000美元，3磅</li>
<li>吉他：1500美元，1磅</li>
</ul>
</blockquote>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">1</th>
<th style="text-align:center">2</th>
<th style="text-align:center">3</th>
<th style="text-align:center">4</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">吉他</td>
<td style="text-align:center">$1500</td>
<td style="text-align:center">$1500</td>
<td style="text-align:center">$1500</td>
<td style="text-align:center">$1500</td>
</tr>
<tr>
<td style="text-align:center">音响</td>
<td style="text-align:center">$1500</td>
<td style="text-align:center">$1500</td>
<td style="text-align:center">$1500</td>
<td style="text-align:center">$3000</td>
</tr>
<tr>
<td style="text-align:center">笔记本电脑</td>
<td style="text-align:center">$1500</td>
<td style="text-align:center">$1500</td>
<td style="text-align:center">$2000</td>
<td style="text-align:center">$3500</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<ul>
<li>只考虑第1个物品——吉他，1~4容量的背包最多可容纳1500美元的物品（只能装吉他）<script type="math/tex; mode=display">F(1,1)=F(1,2)=F(1,3)=F(1,4)=1500</script></li>
<li>考虑前2个物品——吉他和音响<ul>
<li>容量为1、2、3的背包都只能装吉他（1磅），获得的价值为1500美元<script type="math/tex; mode=display">F(2,1)=F(2,2)=F(2,3)=1500</script></li>
<li>若容量为4的背包装音响（4磅），就只能装音响了，获得的价值为3000美元</li>
<li>若容量为4的背包不装音响，可装吉他，获得的价值为1500美元</li>
<li>3000&gt;1500，因此选择装音响<script type="math/tex; mode=display">F(2,4)=3000</script></li>
</ul>
</li>
<li>考虑前3个物品——吉他、音响、笔记本电脑<ul>
<li>容量为1、2的背包都只能装吉他（1磅），获得的价值为1500美元<script type="math/tex; mode=display">F(3,1)=F(3,2)=1500</script></li>
<li>若容量为3的背包装笔记本电脑（3磅），则只能装笔记本电脑，获得的价值为2000美元</li>
<li>若容量为3的背包不装笔记本电脑，则只能装吉他（1磅），获得的价值为1500美元<script type="math/tex; mode=display">F(3,3)=2000</script></li>
<li>若容量为4的背包装笔记本电脑，则可装笔记本电脑和吉他（共4磅），获得的价值为2000+$F(2,1)$=3500</li>
<li>若容量为4的背包不装笔记本电脑，则可获得的最大价值为$F(2,4)$=3000<script type="math/tex; mode=display">F(3,4)=3500</script></li>
</ul>
</li>
</ul>
</blockquote>
<h1 id="完全背包问题"><a href="#完全背包问题" class="headerlink" title="完全背包问题"></a>完全背包问题</h1><h1 id="多重背包问题"><a href="#多重背包问题" class="headerlink" title="多重背包问题"></a>多重背包问题</h1><h1 id="混合背包问题"><a href="#混合背包问题" class="headerlink" title="混合背包问题"></a>混合背包问题</h1><h1 id="二维费用的背包问题"><a href="#二维费用的背包问题" class="headerlink" title="二维费用的背包问题"></a>二维费用的背包问题</h1><h1 id="分组背包问题"><a href="#分组背包问题" class="headerlink" title="分组背包问题"></a>分组背包问题</h1><h1 id="背包问题求方案数"><a href="#背包问题求方案数" class="headerlink" title="背包问题求方案数"></a>背包问题求方案数</h1><h1 id="最优方案"><a href="#最优方案" class="headerlink" title="最优方案"></a>最优方案</h1><h1 id="有依赖的背包问题"><a href="#有依赖的背包问题" class="headerlink" title="有依赖的背包问题"></a>有依赖的背包问题</h1><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://github.com/tianyicui/pack">背包问题九讲</a></li>
</ul>
]]></content>
      <categories>
        <category>基础算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Kaggle | Medical Cost Personal可视化</title>
    <url>/%E6%95%B0%E6%8D%AE%E6%B8%85%E6%B4%97-kaggle-MedicalCostPersonal.html</url>
    <content><![CDATA[<p><center>   <center><br><a id="more"></a></center></center></p>
<h1 id="数据说明"><a href="#数据说明" class="headerlink" title="数据说明"></a>数据说明</h1><ul>
<li>数据来源：<a href="https://www.kaggle.com/mirichoi0218/insurance" target="_blank" rel="noopener">Kaggle</a></li>
<li>可视化代码来源：<a href="https://www.kaggle.com/rockbt1189/eda-l-data-visualization?tdsourcetag=s_pctim_aiomsg" target="_blank" rel="noopener">EDA l Data Visualization</a></li>
<li>使用Kaggle在线Jupyter Notebook实现</li>
</ul>
<h1 id="载入数据"><a href="#载入数据" class="headerlink" title="载入数据"></a>载入数据</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># This Python 3 environment comes with many helpful analytics libraries installed</span></span><br><span class="line"><span class="comment"># It is defined by the kaggle/python Docker image: https://github.com/kaggle/docker-python</span></span><br><span class="line"><span class="comment"># For example, here's several helpful packages to load</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np <span class="comment"># linear algebra</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd <span class="comment"># data processing, CSV file I/O (e.g. pd.read_csv)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Input data files are available in the read-only "../input/" directory</span></span><br><span class="line"><span class="comment"># For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line">print(os.listdir(<span class="string">"../input"</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># You can write up to 5GB to the current directory (/kaggle/working/) that gets preserved as output when you create a version using "Save &amp; Run All" </span></span><br><span class="line"><span class="comment"># You can also write temporary files to /kaggle/temp/, but they won't be saved outside of the current session</span></span><br></pre></td></tr></table></figure>
<pre><code>[&#39;insurance&#39;]
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"><span class="keyword">import</span> warnings</span><br><span class="line"></span><br><span class="line">warnings.filterwarnings(<span class="string">"ignore"</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df = pd.read_csv(<span class="string">"../input/insurance/insurance.csv"</span>)  <span class="comment">## 加载数据</span></span><br><span class="line">df.head()  <span class="comment">## 预览前5行</span></span><br></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>age</th>
      <th>sex</th>
      <th>bmi</th>
      <th>children</th>
      <th>smoker</th>
      <th>region</th>
      <th>charges</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>19</td>
      <td>female</td>
      <td>27.900</td>
      <td>0</td>
      <td>yes</td>
      <td>southwest</td>
      <td>16884.92400</td>
    </tr>
    <tr>
      <th>1</th>
      <td>18</td>
      <td>male</td>
      <td>33.770</td>
      <td>1</td>
      <td>no</td>
      <td>southeast</td>
      <td>1725.55230</td>
    </tr>
    <tr>
      <th>2</th>
      <td>28</td>
      <td>male</td>
      <td>33.000</td>
      <td>3</td>
      <td>no</td>
      <td>southeast</td>
      <td>4449.46200</td>
    </tr>
    <tr>
      <th>3</th>
      <td>33</td>
      <td>male</td>
      <td>22.705</td>
      <td>0</td>
      <td>no</td>
      <td>northwest</td>
      <td>21984.47061</td>
    </tr>
    <tr>
      <th>4</th>
      <td>32</td>
      <td>male</td>
      <td>28.880</td>
      <td>0</td>
      <td>no</td>
      <td>northwest</td>
      <td>3866.85520</td>
    </tr>
  </tbody>
</table>
</div>


<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(df.shape)  <span class="comment">## 查看数据的维度</span></span><br><span class="line">print(df.describe())  <span class="comment">## 查看数据的描述统计</span></span><br><span class="line">print(<span class="string">"Total number of NULL value in the dataset:"</span>, df.isnull().sum())  <span class="comment">## 数据集中缺失数据的个数</span></span><br></pre></td></tr></table></figure>
<pre><code>(1338, 7)
               age          bmi     children       charges
count  1338.000000  1338.000000  1338.000000   1338.000000
mean     39.207025    30.663397     1.094918  13270.422265
std      14.049960     6.098187     1.205493  12110.011237
min      18.000000    15.960000     0.000000   1121.873900
25%      27.000000    26.296250     0.000000   4740.287150
50%      39.000000    30.400000     1.000000   9382.033000
75%      51.000000    34.693750     2.000000  16639.912515
max      64.000000    53.130000     5.000000  63770.428010
Total number of NULL value in the dataset: age         0
sex         0
bmi         0
children    0
smoker      0
region      0
charges     0
dtype: int64
</code></pre><h1 id="新建特征"><a href="#新建特征" class="headerlink" title="新建特征"></a>新建特征</h1><p>BMI:</p>
<ul>
<li>Normal: bmi &lt;= 24</li>
<li>OverWeight: 24 &lt; bmi &lt;30</li>
<li>Obese: bmi &gt;= 30</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 按照bmi划分</span></span><br><span class="line">df[<span class="string">'risk_type'</span>] = np.where(df.bmi&lt;=<span class="number">24</span>, <span class="string">"Normal"</span>, </span><br><span class="line">                          (np.where(df.bmi&lt;<span class="number">30</span>, <span class="string">"OverWeight"</span>, <span class="string">"Obese"</span>)))</span><br><span class="line"><span class="comment">## 按照age划分区组</span></span><br><span class="line">df[<span class="string">'Age_group'</span>] = np.where(df.age&lt;<span class="number">25</span>, <span class="string">"Age below 25 year"</span>, </span><br><span class="line">                          (np.where(df.age&lt;<span class="number">35</span>, <span class="string">"Age 25 to 34 year"</span>,</span><br><span class="line">                                   (np.where(df.age&lt;<span class="number">55</span>, <span class="string">"Age 35 to 54 year"</span>,</span><br><span class="line">                                            (np.where(df.age&lt;<span class="number">75</span>, <span class="string">"Age 55 to 74 year"</span>,</span><br><span class="line">                                                     <span class="string">"Age more than 75 year"</span>)))))))</span><br><span class="line">df.head()</span><br></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>age</th>
      <th>sex</th>
      <th>bmi</th>
      <th>children</th>
      <th>smoker</th>
      <th>region</th>
      <th>charges</th>
      <th>risk_type</th>
      <th>Age_group</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>19</td>
      <td>female</td>
      <td>27.900</td>
      <td>0</td>
      <td>yes</td>
      <td>southwest</td>
      <td>16884.92400</td>
      <td>OverWeight</td>
      <td>Age below 25 year</td>
    </tr>
    <tr>
      <th>1</th>
      <td>18</td>
      <td>male</td>
      <td>33.770</td>
      <td>1</td>
      <td>no</td>
      <td>southeast</td>
      <td>1725.55230</td>
      <td>Obese</td>
      <td>Age below 25 year</td>
    </tr>
    <tr>
      <th>2</th>
      <td>28</td>
      <td>male</td>
      <td>33.000</td>
      <td>3</td>
      <td>no</td>
      <td>southeast</td>
      <td>4449.46200</td>
      <td>Obese</td>
      <td>Age 25 to 34 year</td>
    </tr>
    <tr>
      <th>3</th>
      <td>33</td>
      <td>male</td>
      <td>22.705</td>
      <td>0</td>
      <td>no</td>
      <td>northwest</td>
      <td>21984.47061</td>
      <td>Normal</td>
      <td>Age 25 to 34 year</td>
    </tr>
    <tr>
      <th>4</th>
      <td>32</td>
      <td>male</td>
      <td>28.880</td>
      <td>0</td>
      <td>no</td>
      <td>northwest</td>
      <td>3866.85520</td>
      <td>OverWeight</td>
      <td>Age 25 to 34 year</td>
    </tr>
  </tbody>
</table>
</div>



<p>也可应用Pandas模块中的<code>cut()</code>函数进行分组，具体可见<a href="/python-pandas%E6%A8%A1%E5%9D%97.html" title="Pandas模块">Pandas模块</a>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 分组也可按如下操作</span></span><br><span class="line">bins1 = [<span class="number">0</span>, <span class="number">24</span>, <span class="number">29.99</span>, <span class="number">100</span>]</span><br><span class="line">df[<span class="string">'risk_bins'</span>] = df.cut(df[<span class="string">'bmi'</span>], bins1, labels=[<span class="string">'Normal'</span>, <span class="string">'OverWeight'</span>, <span class="string">'Obese'</span>])</span><br><span class="line"></span><br><span class="line">bins2 = [<span class="number">0</span>, <span class="number">25</span>, <span class="number">35</span>, <span class="number">55</span>, <span class="number">75</span>, <span class="number">100</span>]</span><br><span class="line">df[<span class="string">'age_bins'</span>] = df.cut(df[<span class="string">'age'</span>], bins2, </span><br><span class="line">                        labels=[<span class="string">"Age below 25 year"</span>, <span class="string">"Age 25 to 34 year"</span>, <span class="string">"Age 35 to 54 year"</span>, </span><br><span class="line">                               <span class="string">"Age 55 to 74 year"</span>, <span class="string">"Age more than 75 year"</span>])</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df[<span class="string">"Charge"</span>] = df[<span class="string">"charges"</span>]/<span class="number">1000</span></span><br></pre></td></tr></table></figure>
<h1 id="数据可视化"><a href="#数据可视化" class="headerlink" title="数据可视化"></a>数据可视化</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 相关图</span></span><br><span class="line">sns.pairplot(df, height=<span class="number">1.8</span>)</span><br></pre></td></tr></table></figure>
<pre><code>&lt;seaborn.axisgrid.PairGrid at 0x7f6074b5ced0&gt;
</code></pre><p><meta name="referrer" content="no-referrer"><br><img src="/%E6%95%B0%E6%8D%AE%E6%B8%85%E6%B4%97-kaggle-MedicalCostPersonal/output_10_1.png" class title="相关图"></p>
<ul>
<li>对角线上的是特征的样本数据直方图</li>
<li>非对角线的是两两特征之间的相关图（以两特征分别为横纵轴）</li>
<li><code>charges</code>是<code>Charge</code>除以1000得到的，二者完全正相关，因此相关图呈一条45度的直线</li>
<li><code>bmi</code>与<code>age</code>没有什么相关性</li>
<li>不同<code>charges</code>区间中，<code>charges</code>以及<code>Charge</code>与<code>age</code>呈正相关</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.rcParams[<span class="string">"figure.figsize"</span>] = (<span class="number">20</span>, <span class="number">14</span>)</span><br><span class="line">plt.subplot(<span class="number">421</span>)  <span class="comment">## 将画布裁成4行2列  ## 第1个子图</span></span><br><span class="line">df[<span class="string">'age'</span>].value_counts().sort_index().plot.line(color=<span class="string">"k"</span>)  <span class="comment">## 折线图</span></span><br><span class="line">plt.title(<span class="string">"Age distribution in the Data"</span>)  <span class="comment">## 标题</span></span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">422</span>)  <span class="comment">## 第2个子图</span></span><br><span class="line">df[<span class="string">'bmi'</span>].sort_index().plot.hist(color=<span class="string">"g"</span>)  <span class="comment">## 直方图</span></span><br><span class="line">plt.title(<span class="string">"bmi distribution in the Data"</span>)</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">423</span>)  <span class="comment">## 第3个子图</span></span><br><span class="line">df[<span class="string">'children'</span>].value_counts().plot.line(color=<span class="string">"b"</span>)  <span class="comment">## 折线图</span></span><br><span class="line">plt.title(<span class="string">"child distribution in the Data"</span>)</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">424</span>)</span><br><span class="line">df[<span class="string">'charges'</span>].plot.hist(color=<span class="string">"c"</span>)</span><br><span class="line">plt.title(<span class="string">"charges distribution in the Data"</span>)</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">425</span>)</span><br><span class="line">df[<span class="string">"risk_type"</span>].value_counts().plot.bar()  <span class="comment">## 条形图</span></span><br><span class="line">plt.title(<span class="string">"risk_type distribution in the Data"</span>)</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">426</span>)</span><br><span class="line">df[<span class="string">'smoker'</span>].value_counts().plot.bar()</span><br><span class="line">plt.title(<span class="string">"smoker distribution in the data"</span>)</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">427</span>)</span><br><span class="line">df[<span class="string">'Age_group'</span>].value_counts().plot.bar()</span><br><span class="line">plt.title(<span class="string">"Age_group distribution in the Data"</span>)</span><br></pre></td></tr></table></figure>
<pre><code>Text(0.5, 1.0, &#39;Age_group distribution in the Data&#39;)
</code></pre><p><meta name="referrer" content="no-referrer"><br><img src="/%E6%95%B0%E6%8D%AE%E6%B8%85%E6%B4%97-kaggle-MedicalCostPersonal/output_12_1.png" class></p>
<ul>
<li>样本中的年龄主要集中分布在“小于20岁”区间</li>
<li>样本中肥胖的样本较多</li>
<li>样本中，抽烟的样本较少，不抽样的样本较多</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.rcParams[<span class="string">'figure.figsize'</span>] = (<span class="number">18</span>, <span class="number">8</span>)</span><br><span class="line">plt.subplot(<span class="number">221</span>)  <span class="comment">## 将画布分成2行2列</span></span><br><span class="line">sns.lineplot(x=<span class="string">'age'</span>, y=<span class="string">'bmi'</span>, data=df, color=<span class="string">"b"</span>)</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">222</span>)</span><br><span class="line">sns.lineplot(x=<span class="string">'age'</span>, y=<span class="string">'Charge'</span>, data=df, color=<span class="string">"g"</span>)  <span class="comment">## 折线图</span></span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">223</span>)</span><br><span class="line">sns.scatterplot(x=<span class="string">"Charge"</span>, y=<span class="string">"bmi"</span>, data=df, color=<span class="string">"k"</span>)  <span class="comment">## 散点图</span></span><br></pre></td></tr></table></figure>
<pre><code>&lt;matplotlib.axes._subplots.AxesSubplot at 0x7f6069f93d90&gt;
</code></pre><p><meta name="referrer" content="no-referrer"><br><img src="/%E6%95%B0%E6%8D%AE%E6%B8%85%E6%B4%97-kaggle-MedicalCostPersonal/output_13_1.png" class></p>
<ul>
<li><code>bmi</code>有随<code>age</code>上升而上升的趋势</li>
<li><code>charges</code>有随<code>age</code>上升而上升的趋势</li>
</ul>
<p>下面按年龄段绘制<code>bmi</code>、<code>charges</code>与<code>age</code>的折线图：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.rcParams[<span class="string">'figure.figsize'</span>] = (<span class="number">18</span>, <span class="number">8</span>)</span><br><span class="line">plt.subplot(<span class="number">221</span>)</span><br><span class="line"><span class="comment">## 横轴是age，纵轴是bmi，按Age_group分段绘制</span></span><br><span class="line">sns.lineplot(x=<span class="string">'age'</span>, y=<span class="string">'bmi'</span>, data=df, hue=<span class="string">"Age_group"</span>)</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">222</span>)</span><br><span class="line">sns.lineplot(x=<span class="string">'age'</span>, y=<span class="string">'Charge'</span>, data=df, hue=<span class="string">'Age_group'</span>)</span><br></pre></td></tr></table></figure></p>
<pre><code>&lt;matplotlib.axes._subplots.AxesSubplot at 0x7f6069d0fad0&gt;
</code></pre><p><meta name="referrer" content="no-referrer"><br><img src="/%E6%95%B0%E6%8D%AE%E6%B8%85%E6%B4%97-kaggle-MedicalCostPersonal/output_14_1.png" class></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.rcParams[<span class="string">"figure.figsize"</span>]=(<span class="number">18</span>,<span class="number">8</span>)</span><br><span class="line">plt.subplot(<span class="number">221</span>)</span><br><span class="line">sns.lineplot(x=<span class="string">"age"</span>, y=<span class="string">"bmi"</span>, data=df, color=<span class="string">"b"</span>, hue=<span class="string">"smoker"</span>)</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">222</span>)</span><br><span class="line">sns.lineplot(x=<span class="string">"age"</span>, y=<span class="string">"Charge"</span>, data=df, color=<span class="string">"g"</span>, hue=<span class="string">"smoker"</span>)</span><br></pre></td></tr></table></figure>
<pre><code>&lt;matplotlib.axes._subplots.AxesSubplot at 0x7f6069c22150&gt;
</code></pre><p><meta name="referrer" content="no-referrer"><br><img src="/%E6%95%B0%E6%8D%AE%E6%B8%85%E6%B4%97-kaggle-MedicalCostPersonal/output_15_1.png" class></p>
<ul>
<li>不吸烟的人的<code>Charge</code>整体比吸烟的人低</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## region</span></span><br><span class="line">southwest = df[df[<span class="string">"region"</span>]==<span class="string">"southwest"</span>]</span><br><span class="line">southeast = df[df[<span class="string">"region"</span>]==<span class="string">"southeast"</span>]</span><br><span class="line">northwest = df[df[<span class="string">"region"</span>]==<span class="string">"northwest"</span>]</span><br><span class="line">northeast = df[df[<span class="string">"region"</span>]==<span class="string">"northeast"</span>]</span><br><span class="line"></span><br><span class="line">plt.rcParams[<span class="string">"figure.figsize"</span>]=(<span class="number">18</span>,<span class="number">8</span>)</span><br><span class="line">plt.subplot(<span class="number">421</span>)</span><br><span class="line">sns.lineplot(x=<span class="string">"age"</span>, y=<span class="string">"bmi"</span>, data=southwest, hue=<span class="string">"risk_type"</span>, hue_order=[<span class="string">"Normal"</span>,<span class="string">"OverWeight"</span>,<span class="string">"Obese"</span>])</span><br><span class="line">plt.title(<span class="string">"southwest region"</span>)</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">422</span>)</span><br><span class="line">sns.lineplot(x=<span class="string">"bmi"</span>, y=<span class="string">"Charge"</span>, data=southwest, hue=<span class="string">"risk_type"</span>, hue_order=[<span class="string">"Normal"</span>,<span class="string">"OverWeight"</span>,<span class="string">"Obese"</span>])</span><br><span class="line">plt.title(<span class="string">"southwest region"</span>)</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">423</span>)</span><br><span class="line">sns.lineplot(x=<span class="string">"age"</span>, y=<span class="string">"bmi"</span>, data=southeast, hue=<span class="string">"risk_type"</span>, hue_order=[<span class="string">"Normal"</span>,<span class="string">"OverWeight"</span>,<span class="string">"Obese"</span>])</span><br><span class="line">plt.title(<span class="string">"southeast region"</span>)</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">424</span>)</span><br><span class="line">sns.lineplot(x=<span class="string">"bmi"</span>, y=<span class="string">"Charge"</span>, data=southeast, hue=<span class="string">"risk_type"</span>, hue_order=[<span class="string">"Normal"</span>,<span class="string">"OverWeight"</span>,<span class="string">"Obese"</span>])</span><br><span class="line">plt.title(<span class="string">"southeast region"</span>)</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">425</span>)</span><br><span class="line">sns.lineplot(x=<span class="string">"age"</span>, y=<span class="string">"bmi"</span>, data=northwest, hue=<span class="string">"risk_type"</span>, hue_order=[<span class="string">"Normal"</span>,<span class="string">"OverWeight"</span>,<span class="string">"Obese"</span>])</span><br><span class="line">plt.title(<span class="string">"northwest region"</span>)</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">426</span>)</span><br><span class="line">sns.lineplot(x=<span class="string">"bmi"</span>, y=<span class="string">"Charge"</span>, data=northwest, hue=<span class="string">"risk_type"</span>, hue_order=[<span class="string">"Normal"</span>,<span class="string">"OverWeight"</span>,<span class="string">"Obese"</span>])</span><br><span class="line">plt.title(<span class="string">"northwest region"</span>)</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">427</span>)</span><br><span class="line">sns.lineplot(x=<span class="string">"age"</span>, y=<span class="string">"bmi"</span>, data=northeast, hue=<span class="string">"risk_type"</span>, hue_order=[<span class="string">"Normal"</span>,<span class="string">"OverWeight"</span>,<span class="string">"Obese"</span>])</span><br><span class="line">plt.title(<span class="string">"northeast region"</span>)</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">428</span>)</span><br><span class="line">sns.lineplot(x=<span class="string">"bmi"</span>, y=<span class="string">"Charge"</span>, data=northeast, hue=<span class="string">"risk_type"</span>, hue_order=[<span class="string">"Normal"</span>,<span class="string">"OverWeight"</span>,<span class="string">"Obese"</span>])</span><br><span class="line">plt.title(<span class="string">"northeast region"</span>)</span><br></pre></td></tr></table></figure>
<pre><code>Text(0.5, 1.0, &#39;northeast region&#39;)
</code></pre><p><meta name="referrer" content="no-referrer"><br><img src="/%E6%95%B0%E6%8D%AE%E6%B8%85%E6%B4%97-kaggle-MedicalCostPersonal/output_16_1.png" class></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.rcParams[<span class="string">"figure.figsize"</span>]=(<span class="number">16</span>,<span class="number">6</span>)</span><br><span class="line">plt.subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line">sns.violinplot(x=<span class="string">"sex"</span>, y=<span class="string">"bmi"</span>, data=df)  <span class="comment">## 小提琴图</span></span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line">sns.violinplot(x=<span class="string">"smoker"</span>, y=<span class="string">"bmi"</span>, data=df)</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">sns.violinplot(x=<span class="string">"risk_type"</span>, y=<span class="string">"bmi"</span>, data=df)</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>)</span><br><span class="line">sns.violinplot(x=<span class="string">"Age_group"</span>, y=<span class="string">"bmi"</span>, data=df)</span><br></pre></td></tr></table></figure>
<pre><code>&lt;matplotlib.axes._subplots.AxesSubplot at 0x7f60692f6590&gt;
</code></pre><p><meta name="referrer" content="no-referrer"><br><img src="/%E6%95%B0%E6%8D%AE%E6%B8%85%E6%B4%97-kaggle-MedicalCostPersonal/output_17_1.png" class></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.rcParams[<span class="string">"figure.figsize"</span>]=(<span class="number">16</span>,<span class="number">6</span>)</span><br><span class="line">plt.subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line">sns.violinplot(x=<span class="string">"sex"</span>, y=<span class="string">"Charge"</span>, data=df)</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line">sns.violinplot(x=<span class="string">"smoker"</span>, y=<span class="string">"Charge"</span>, data=df)</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">sns.violinplot(x=<span class="string">"risk_type"</span>, y=<span class="string">"Charge"</span>, data=df)</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>)</span><br><span class="line">sns.violinplot(x=<span class="string">"Age_group"</span>, y=<span class="string">"Charge"</span>, data=df)</span><br></pre></td></tr></table></figure>
<pre><code>&lt;matplotlib.axes._subplots.AxesSubplot at 0x7f6069128bd0&gt;
</code></pre><p><meta name="referrer" content="no-referrer"><br><img src="/%E6%95%B0%E6%8D%AE%E6%B8%85%E6%B4%97-kaggle-MedicalCostPersonal/output_18_1.png" class></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.rcParams[<span class="string">"figure.figsize"</span>]=(<span class="number">28</span>,<span class="number">10</span>)</span><br><span class="line">plt.subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line">sns.violinplot(x=<span class="string">"children"</span>, y=<span class="string">"bmi"</span>, data=df, hue=<span class="string">"smoker"</span>)</span><br><span class="line"></span><br><span class="line">plt.rcParams[<span class="string">"figure.figsize"</span>]=(<span class="number">28</span>,<span class="number">10</span>)</span><br><span class="line">plt.subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">sns.violinplot(x=<span class="string">"children"</span>, y=<span class="string">"Charge"</span>, data=df, hue=<span class="string">"smoker"</span>)</span><br></pre></td></tr></table></figure>
<pre><code>&lt;matplotlib.axes._subplots.AxesSubplot at 0x7f6069054ad0&gt;
</code></pre><p><meta name="referrer" content="no-referrer"><br><img src="/%E6%95%B0%E6%8D%AE%E6%B8%85%E6%B4%97-kaggle-MedicalCostPersonal/output_19_1.png" class></p>
]]></content>
      <tags>
        <tag>Data</tag>
      </tags>
  </entry>
  <entry>
    <title>Algorithm | 冒泡排序</title>
    <url>/Algo-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F.html</url>
    <content><![CDATA[<p><center>Bubble Sort</center><br><a id="more"></a></p>
<h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><ul>
<li>冒泡排序详解：<ul>
<li><a href="https://stackabuse.com/bubble-sort-in-python/" target="_blank" rel="noopener">Bubble Sort in Python</a></li>
</ul>
</li>
<li>动态演示冒泡排序：<a href="https://www.cs.usfca.edu/~galles/visualization/ComparisonSort.html" target="_blank" rel="noopener">Bubble Sort</a></li>
</ul>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><blockquote>
<p>以从小到大排序为例</p>
</blockquote>
<p>重复地走访要排序的元素列，依次比较两个相邻的元素，如果第一个元素比第二个元素大，就交换两个元素的位置。</p>
<ul>
<li>元素列$\{x_1,x_2,\cdots,x_n\}$的长度为$n$</li>
<li>第1步，遍历$i=1,2,\cdots,n-1$<ul>
<li>比较$x_i$和$x_{i+1}$，如果$x_i&gt;x_{i+1}$，则交换$x_i$和$x_{i+1}$的位置</li>
<li>需要比较前$n$个元素</li>
<li>遍历后的元素列记为$\{x_1,x_2,\cdots,x_n\}$</li>
</ul>
</li>
<li>第2步，遍历$i=1,2,\cdots,n-2$<ul>
<li>比较$x_i$和$x_{i+1}$，如果$x_i&gt;x_{i+1}$，则交换$x_i$和$x_{i+1}$的位置</li>
<li>需要比较前$n-1$个元素</li>
<li>遍历后的元素列记为$\{x_1,x_2,\cdots,x_n\}$</li>
</ul>
</li>
<li>$\cdots$</li>
<li>第$k$步，遍历$i=1,2,\cdots,n-k$<ul>
<li>比较$x_i$和$x_{i+1}$，如果$x_i&gt;x_{i+1}$，则交换$x_i$和$x_{i+1}$的位置</li>
<li>需要比较前$n-k+1$个元素</li>
<li>遍历后的元素列记为$\{x_1,x_2,\cdots,x_n\}$</li>
</ul>
</li>
<li>$\cdots$</li>
<li>第$n-1$步，比较$x_1$和$x_{2}$，如果$x_1&gt;x_{2}$，则交换$x_1$和$x_{2}$的位置<ul>
<li>需要比较前2个元素</li>
</ul>
</li>
</ul>
<h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><h3 id="时间复杂度-O-n-2"><a href="#时间复杂度-O-n-2" class="headerlink" title="时间复杂度$O(n^2)$"></a>时间复杂度$O(n^2)$</h3><ul>
<li><strong>最好的情况</strong>：元素列是正序的<ul>
<li>则只需要遍历一遍元素列即可完成排序</li>
<li>所需的比较次数为$n-1$</li>
<li>所需的变换元素位置测次数为0</li>
<li>冒泡排序在最好的情况下的时间复杂度为$O(n)$</li>
</ul>
</li>
<li>最坏的情况：元素列正好是完全反序的<ul>
<li>则需要进行$n-1$次遍历</li>
<li>其中第$k$次遍历需要进行$n-k$次比较，每次比较都需要变换元素位置3次</li>
<li>所需的比较次数为$\frac{n(n-1)}{2}=O(n^2)$</li>
<li>所需的变换元素位置测次数为$\frac{3n(n-1)}{2}=O(n^2)$</li>
<li>冒泡排序在最坏的情况下的时间复杂度为$O(n^2)$</li>
</ul>
</li>
<li>所以，冒牌排序的平均时间复杂度为$O(n^2)$</li>
</ul>
<h3 id="空间复杂度-O-1"><a href="#空间复杂度-O-1" class="headerlink" title="空间复杂度$O(1)$"></a>空间复杂度$O(1)$</h3><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>Python实现冒泡排序<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">BubbleSort</span><span class="params">(lst)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(lst)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(len(lst) - i <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> lst[j] &gt; lst[j+<span class="number">1</span>]:</span><br><span class="line">                lst[j], lst[j+<span class="number">1</span>] = lst[j+<span class="number">1</span>], lst[j]</span><br></pre></td></tr></table></figure></p>
<p>使用该函数对列表进行升序排序：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lst0 = [<span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">18</span>, <span class="number">25</span>, <span class="number">13</span>, <span class="number">11</span>, <span class="number">3</span>]</span><br><span class="line">BubbleSort(lst0)</span><br><span class="line">lst0</span><br><span class="line"><span class="comment"># [1, 2, 3, 4, 11, 13, 18, 25]</span></span><br></pre></td></tr></table></figure></p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://www.cnblogs.com/bigdata-stone/p/10464243.html" target="_blank" rel="noopener">三分钟彻底理解冒泡排序</a></li>
</ul>
]]></content>
      <categories>
        <category>基础算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL</title>
    <url>/MySQL.html</url>
    <content><![CDATA[<p><center></center><br><a id="more"></a></p>
<h1 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h1><p>MySQL在v5.1之前的默认存储引擎使MyISAM，在此之后的默认存储引擎是InnoDB</p>
<h1 id="表的类型"><a href="#表的类型" class="headerlink" title="表的类型"></a>表的类型</h1><ol>
<li><strong>永久表</strong><ul>
<li>创建以后用于长期保存数据的表</li>
</ul>
</li>
<li><strong>临时表</strong><ul>
<li>只保存临时数据</li>
<li>能够长久存在</li>
</ul>
</li>
<li><strong>虚表/视图</strong><h2 id="永久表"><a href="#永久表" class="headerlink" title="永久表"></a>永久表</h2></li>
</ol>
<h2 id="临时表"><a href="#临时表" class="headerlink" title="临时表"></a>临时表</h2><h3 id="内存临时表"><a href="#内存临时表" class="headerlink" title="内存临时表"></a>内存临时表</h3><ul>
<li>使用的是MEMORY存储引擎</li>
</ul>
<h3 id="磁盘临时表"><a href="#磁盘临时表" class="headerlink" title="磁盘临时表"></a>磁盘临时表</h3><h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><p>索引是存储在一张表中特定列上的数据结构</p>
<ul>
<li>索引是在列上创建的</li>
<li>索引是一种数据结构</li>
</ul>
<h2 id="全局索引"><a href="#全局索引" class="headerlink" title="全局索引"></a>全局索引</h2><p>FULLTEXT</p>
<ul>
<li>目前只有MyISAM引擎支持全局索引</li>
</ul>
<h2 id="哈希索引"><a href="#哈希索引" class="headerlink" title="哈希索引"></a>哈希索引</h2><p>HASH</p>
<ul>
<li>是MySQL中用到的唯一键值对（key-value）的数据结构</li>
<li>哈希索引适合应用于查找单个键的情况</li>
<li>在范围查找中，哈希索引的性能很低</li>
</ul>
<h2 id="B-Tree索引"><a href="#B-Tree索引" class="headerlink" title="B-Tree索引"></a>B-Tree索引</h2><p>平衡树索引</p>
<ul>
<li>存在很多变种<ul>
<li>B+Tree</li>
<li>……</li>
</ul>
</li>
</ul>
<h2 id="R-Tree索引"><a href="#R-Tree索引" class="headerlink" title="R-Tree索引"></a>R-Tree索引</h2><ul>
<li>在MySQL中较少使用</li>
<li>仅支持geometry数据类型</li>
<li>支持该类型的存储引擎有：<ul>
<li>MyISAM</li>
<li>BDb</li>
<li>InnoDb</li>
<li>NDb</li>
<li>Archive</li>
</ul>
</li>
<li>相对于B-Tree来说，R-Tree的优势在于范围查找</li>
</ul>
<h1 id="MySQL自带数据库"><a href="#MySQL自带数据库" class="headerlink" title="MySQL自带数据库"></a>MySQL自带数据库</h1><p>MySQL自带三个数据库：</p>
<ul>
<li>information_schema</li>
<li>performance_schema</li>
<li>mysql</li>
</ul>
<h2 id="information-schema"><a href="#information-schema" class="headerlink" title="information_schema"></a>information_schema</h2><p>提供访问数据库元数据的方式；可称information_schema是一个元数据库。</p>
<p><strong>元数据</strong>（meta data）：关于数据的数据（data about data）。也可称为“数据词典”、“系统目录”</p>
<ul>
<li>数据库名</li>
<li>表名</li>
<li>列的数据类型</li>
<li>访问权限</li>
<li>……</li>
</ul>
<p><strong>常见的表</strong>：</p>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: center;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: center;">
      <th>表</th>
      <th>表的含义</th>
      <th>表中字段</th>
      <th>字段含义</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="3">schemata</th>
      <td rowspan="3">提供数据库信息<br>相关命令：SHOW DATABASES;</td>
      <td>schema_name</td>
      <td>数据库名</td>
    </tr>
    <tr>
      <td>default_character_set_name</td>
      <td>字符集</td>
    </tr>
    <tr>
      <td>default_collation_name</td>
      <td>排序规则</td>
    </tr>
    <tr>
      <th rowspan="5">tables</th>
      <td rowspan="5">提供表的信息<br>相关命令：SHOW TABLES FROM schema_name;</td>
      <td>table_schema</td>
      <td>数据库名</td>
    </tr>
    <tr>
      <td>table_name</td>
      <td>表名</td>
    </tr>
    <tr>
      <td>table_type</td>
      <td>表的类型<br>base table, view, system view</td>
    </tr>
    <tr>
      <td>engine</td>
      <td>存储引擎</td>
    </tr>
    <tr>
      <td>create_time</td>
      <td>建表时间</td>
    </tr>
    <tr>
      <th rowspan="4">columns</th>
      <td rowspan="4">提供表中字段信息<br>相关命令：SHOW COLUMNS; 或 DESC TCTEST.EMP</td>
      <td>schema_schema</td>
      <td>数据库名</td>
    </tr>
    <tr>
      <td>table_name</td>
      <td>表名</td>
    </tr>
    <tr>
      <td>column_name</td>
      <td>字段名</td>
    </tr>
    <tr>
      <td>column_type</td>
      <td>字段类型</td>
    </tr>
    <tr>
      <th rowspan="6">statistics</th>
      <td rowspan="6">索引信息<br>相关命令：SHOW INDEX; </td>
      <td>schema_schema</td>
      <td>数据库名</td>
    </tr>
    <tr>
      <td>table_name</td>
      <td>表名</td>
    </tr>
    <tr>
      <td>index_schema</td>
      <td>数据库名</td>
    </tr>
    <tr>
      <td>index_name</td>
      <td>索引名</td>
    </tr>
    <tr>
      <td>column_name</td>
      <td>字段名</td>
    </tr>
    <tr>
      <td>index_type</td>
      <td>索引类型<br>一般是BTREE</td>
    </tr>
    <tr>
      <th rowspan="5">table_constraints</th>
      <td rowspan="5">约束信息</td>
      <td>constraint_schema</td>
      <td>数据库名</td>
    </tr>
    <tr>
      <td>constraint_name</td>
      <td>约束名</td>
    </tr>
    <tr>
      <td>table_schema</td>
      <td>数据库名</td>
    </tr>
    <tr>
      <td>table_name</td>
      <td>表名</td>
    </tr>
    <tr>
      <td>constraint_type</td>
      <td>约束类型<br>UNIQUE, PRIMARY KEY, FOREIGN KEY</td>
    </tr>
    <tr>
      <th rowspan="8">key_column_usage</th>
      <td rowspan="8">外键的参考信息</td>
      <td>constraint_schema</td>
      <td>数据库名</td>
    </tr>
    <tr>
      <td>constraint_name</td>
      <td>约束名</td>
    </tr>
    <tr>
      <td>table_schema</td>
      <td>数据库名</td>
    </tr>
    <tr>
      <td>table_name</td>
      <td>表名</td>
    </tr>
    <tr>
      <td>column_name</td>
      <td>字段名</td>
    </tr>
    <tr>
      <td>referenced_table_schema</td>
      <td>参考的数据库</td>
    </tr>
    <tr>
      <td>referenced_table_name</td>
      <td>参考的表</td>
    </tr>
    <tr>
      <td>referenced_column_name</td>
      <td>参考的列</td>
    </tr>
    <tr>
      <th rowspan="6">routines</th>
      <td rowspan="6">函数和存储过程</td>
      <td>specific_name</td>
      <td>程序名</td>
    </tr>
    <tr>
      <td>routine_schema</td>
      <td>数据库名</td>
    </tr>
    <tr>
      <td>routine_name</td>
      <td>程序名</td>
    </tr>
    <tr>
      <td>routine_type</td>
      <td>程序类型<br>PROCEDURE或FUNCTION</td>
    </tr>
    <tr>
      <td>routine_body</td>
      <td>函数体</td>
    </tr>
    <tr>
      <td>routine_definition</td>
      <td>具体的程序语句</td>
    </tr>
    <tr>
      <th rowspan="3">views</th>
      <td rowspan="3">视图</td>
      <td>table_schema</td>
      <td>数据库名</td>
    </tr>
    <tr>
      <td>table_name</td>
      <td>表名</td>
    </tr>
    <tr>
      <td>view_definition</td>
      <td>视图定义语句</td>
    </tr>
    <tr>
      <th rowspan="6">triggers</th>
      <td rowspan="6">触发器<br>相关命令：SHOW TRIGGERS FROM table_name;</td>
      <td>trigger_schema</td>
      <td>数据库名</td>
    </tr>
    <tr>
      <td>trigger_name</td>
      <td>触发器名</td>
    </tr>
    <tr>
      <td>event_object_schema</td>
      <td>触发的数据库</td>
    </tr>
    <tr>
      <td>event_object_table</td>
      <td>触发的表</td>
    </tr>
    <tr>
      <td>action_statement</td>
      <td>触发的语句</td>
    </tr>
    <tr>
      <td>action_timing</td>
      <td>触发的时机<br>BEFORE或AFTER</td>
    </tr>
    <tr>
      <th>engines</th>
      <td>当前数据库对InnoDB、Memory、MyISAM等存储引擎的支持情况<br>相关命令：SHOW ENGINES;</td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <th>global_variables</th>
      <td>服务器变量设置，一些开关和设置<br>相关命令：SHOW GLOBAL VARIABLES;</td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <th>plugins</th>
      <td>插件列表<br>相关命令：SHOW PLUGINS;</td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <th>processlist</th>
      <td>正在运行的线程<br>相关命令：SHOW FULL PROCESSLIST;</td>
      <td></td>
      <td></td>
    </tr>
    <tr>
  </tr></tbody>
</table>
</div>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">REPEAT</span>(<span class="string">'* '</span>, @<span class="built_in">NUMBER</span> := @<span class="built_in">NUMBER</span> - <span class="number">1</span>)</span><br><span class="line"><span class="keyword">FROM</span> information_schema.tables, </span><br><span class="line">(<span class="keyword">SELECT</span> @<span class="built_in">NUMBER</span>:= <span class="number">13</span>) t <span class="keyword">LIMIT</span> <span class="number">12</span>; </span><br><span class="line"><span class="comment">-- 输出：</span></span><br><span class="line">* * * * * * * * * * * * </span><br><span class="line">* * * * * * * * * * * </span><br><span class="line">* * * * * * * * * * </span><br><span class="line">* * * * * * * * * </span><br><span class="line">* * * * * * * * </span><br><span class="line">* * * * * * * </span><br><span class="line">* * * * * * </span><br><span class="line">* * * * * </span><br><span class="line">* * * * </span><br><span class="line">* * * </span><br><span class="line">* * </span><br><span class="line">* </span><br><span class="line"><span class="comment">-- from: https://www.hackerrank.com/challenges/draw-the-triangle-1/problem?h_r=profile</span></span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 输出1000以内的所有素数</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">GROUP_CONCAT</span>(<span class="keyword">NUMB</span> SEPARATOR <span class="string">'&amp;'</span>)</span><br><span class="line"><span class="keyword">FROM</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> @nun:=@<span class="keyword">num</span>+<span class="number">1</span> <span class="keyword">AS</span> <span class="keyword">NUMB</span> <span class="keyword">FROM</span></span><br><span class="line">    information_schema.tables t1,</span><br><span class="line">    information_schema.tables t2,</span><br><span class="line">    (<span class="keyword">SELECT</span> @<span class="keyword">num</span>:=<span class="number">1</span>) tmp</span><br><span class="line">) tempNum  <span class="comment">-- 所有的可能素数</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">NUMB</span> &lt;= <span class="number">1000</span> </span><br><span class="line"><span class="keyword">AND</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> </span><br><span class="line">    (</span><br><span class="line">        <span class="keyword">SELECT</span> @nu:=@nu+<span class="number">1</span> <span class="keyword">AS</span> NUMA <span class="keyword">FROM</span> </span><br><span class="line">        information_schema.tables t1,</span><br><span class="line">        information_schema.tables t2,</span><br><span class="line">        (<span class="keyword">SELECT</span> @nu:=<span class="number">1</span>) tmp1</span><br><span class="line">        <span class="keyword">LIMIT</span> <span class="number">1000</span></span><br><span class="line">    ) t  <span class="comment">-- NUMA是divisor</span></span><br><span class="line">    <span class="keyword">WHERE</span> <span class="keyword">FLOOR</span>(<span class="keyword">NUMB</span>/NUMA) = (<span class="keyword">NUMB</span>/NUMA)</span><br><span class="line">    <span class="keyword">AND</span> NUMA &lt; <span class="keyword">NUMB</span> </span><br><span class="line">    <span class="keyword">AND</span> NUMA &gt; <span class="number">1</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 或</span></span><br><span class="line"><span class="keyword">SET</span> @potential_prime = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">SET</span> @divisor = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">GROUP_CONCAT</span>(POTENTIAL_PRIME SEPARATOR <span class="string">'&amp;'</span>) <span class="keyword">FROM</span></span><br><span class="line">(</span><br><span class="line">    <span class="keyword">SELECT</span> @potential_prime := @potential_prime + <span class="number">1</span> <span class="keyword">AS</span> POTENTIAL_PRIME </span><br><span class="line">    <span class="keyword">FROM</span> </span><br><span class="line">        information_schema.tables t1,</span><br><span class="line">        information_schema.tables t2</span><br><span class="line">    <span class="keyword">LIMIT</span> <span class="number">1000</span></span><br><span class="line">) list_of_potential_primes</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>(</span><br><span class="line">    <span class="keyword">SELECT</span> * <span class="keyword">FROM</span></span><br><span class="line">    (</span><br><span class="line">        <span class="keyword">SELECT</span> @divisor := @divisor + <span class="number">1</span> <span class="keyword">AS</span> DIVISOR </span><br><span class="line">        <span class="keyword">FROM</span> </span><br><span class="line">            information_schema.tables t3,</span><br><span class="line">            information_schema.tables t4</span><br><span class="line">        <span class="keyword">LIMIT</span> <span class="number">1000</span></span><br><span class="line">    ) list_of_divisors</span><br><span class="line">    <span class="keyword">WHERE</span> <span class="keyword">MOD</span>(POTENTIAL_PRIME, DIVISOR) = <span class="number">0</span></span><br><span class="line">    <span class="keyword">AND</span> POTENTIAL_PRIME &lt;&gt; DIVISOR</span><br><span class="line">    );</span><br><span class="line"><span class="comment">-- 参考：https://www.hackerrank.com/challenges/print-prime-numbers/forum</span></span><br></pre></td></tr></table></figure>
<h1 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h1><p>允许用户定义一组操作，这些操作通过对指定的表进行删除、更新等命令来执行或激活</p>
<h1 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h1><ul>
<li>时间不能写为<code>&lt;=&#39;2020-07-12&#39;</code>的形式<ul>
<li><code>&lt;&#39;2020-07-12&#39;</code>是指2020年07月12日之前，不包括2020年07月12日</li>
<li><code>&lt;=&#39;2020-07-12&#39;</code>包含了2020年07月12日00时00分00秒，但不包含2020年07月12日一整天</li>
<li>如果要包含2020年07月12日这一天，则应写为<code>&lt;&#39;2020-07-13&#39;</code></li>
</ul>
</li>
</ul>
<h1 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h1><h2 id="不等于"><a href="#不等于" class="headerlink" title="不等于"></a>不等于</h2><ul>
<li>以不等于排除某些记录时，也会排除该字段为空的数据</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> student</span><br><span class="line"><span class="keyword">WHERE</span> Sname != <span class="string">'王五'</span>;</span><br><span class="line"><span class="comment">-- 该查询语句的返回结果不包含包含Sname为空的记录</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 严谨的写法：</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> student</span><br><span class="line"><span class="keyword">WHERE</span> Sname != <span class="string">'王五'</span> <span class="keyword">OR</span> Sname <span class="keyword">IS</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">-- 返回结果不包括Sname为“王五”的记录，但包括Sname为空的记录</span></span><br></pre></td></tr></table></figure>
<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h2 id="REPLACE"><a href="#REPLACE" class="headerlink" title="REPLACE()"></a>REPLACE()</h2><ul>
<li><code>LEFT</code>, <code>RIGHT</code>, <code>SUBSTRING</code>应习惯性与<code>REPLACE()</code>嵌套使用；因为有些数据中间可能含有意料之外的空格，导致字符串切片出错。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">SUBSTRING(<span class="keyword">REPLACE</span>(字段, <span class="string">' '</span>, <span class="string">''</span>), <span class="number">7</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure>
<h2 id="SUBTRING"><a href="#SUBTRING" class="headerlink" title="SUBTRING()"></a>SUBTRING()</h2><p>提取字符串的子串</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">SUBSTRING(S, 3, 5)  <span class="comment">-- 提取字符串S的从左数第3个字母起（包括第3个）的5个字母</span></span><br><span class="line">SUBSTRING(S, -3)  <span class="comment">-- 提取字符串S的从右倒数第3个字母起（包括第3个）、向右的所有的字母</span></span><br></pre></td></tr></table></figure>
<div class="note default">
            <p>相关在线练习：</p><ul><li><a href="https://www.hackerrank.com/challenges/weather-observation-station-6/problem" target="_blank" rel="noopener">HackerRank1</a></li><li><a href="https://www.hackerrank.com/challenges/weather-observation-station-7/problem" target="_blank" rel="noopener">HackerRank2</a></li><li><a href="(https://www.hackerrank.com/challenges/weather-observation-station-8/problem">HackerRank3</a></li><li><a href="https://www.hackerrank.com/challenges/weather-observation-station-9/problem" target="_blank" rel="noopener">HackerRank4</a></li><li><a href="https://www.hackerrank.com/challenges/weather-observation-station-10/problem" target="_blank" rel="noopener">HackerRank5</a></li><li><a href="https://www.hackerrank.com/challenges/weather-observation-station-11" target="_blank" rel="noopener">HackerRank6</a></li></ul>
          </div>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="SET"><a href="#SET" class="headerlink" title="SET"></a>SET</h2><p><code>SET @变量名称=变量值</code>：可以快速替换重复的代码</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> @DT=<span class="string">'2020-07-12'</span>;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> table_1 <span class="keyword">WHERE</span> <span class="built_in">date</span>&gt;@DT;</span><br></pre></td></tr></table></figure>
<h2 id><a href="#" class="headerlink" title="@"></a>@</h2><p><code>SELECT (@i:=@i+1) AS num</code>生成一列递增序列 </p>
<h2 id="延时注入"><a href="#延时注入" class="headerlink" title="延时注入"></a>延时注入</h2><p>MySQL中使用延时注入常用的语句：</p>
<ul>
<li><code>sleep(5)</code></li>
<li><code>BENCHMARK(10000000, MDG(1))</code>：第一个参数是执行的次数，第二个参数是要执行的函数/表达式</li>
</ul>
<p>但是使用<code>BENCHMARK() (M)</code>会让MySQL停一下，会大量消耗web服务器资源</p>
<h1 id="其他注意事项"><a href="#其他注意事项" class="headerlink" title="其他注意事项"></a>其他注意事项</h1><ul>
<li>注意字段的格式，数字和字符串不会隐式转换</li>
<li>以 MySQL 5.7 或更低版本为准的数据库中，如何正确选择和使用合适的数据类：<ul>
<li>更小通常更好</li>
<li>尽量用最简单的数据类型</li>
<li>尽量不适用NULL作为字段值</li>
</ul>
</li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzA3MTg4NjY4Mw==&amp;mid=2457305755&amp;idx=2&amp;sn=764158cf905b0622e1697f51baa718f2&amp;chksm=88a590afbfd219b98bd7d83c2f4ea4d572654b5889eff254bbbb60f2189f61aee393e1801510&amp;mpshare=1&amp;scene=1&amp;srcid=&amp;sharer_sharetime=1590150427096&amp;sharer_shareid=b539221659d6ecf12200314308b58dd3&amp;key=21ed68970b00e8fc75b1e914e6c754e962a5fcec08d9c1e0fb5bfcb82d495aac1ab014508f15a5ebb1eaf6e1c2a2036cecc7516e989e5f1bd3b3615846e67437d7d0ad461bc0ca4d28139dc860680c5b&amp;ascene=1&amp;uin=MjAwNDUzMjgxNw%3D%3D&amp;devicetype=Windows+10+x64&amp;version=62090070&amp;lang=zh_CN&amp;exportkey=AbupEngztSgB4dsmRHvGbpk%3D&amp;pass_ticket=iLa2XiZaCBS2XSrbXAnYFAIdgj9HEiggWqWDoDR8tX5Ckgf6sdWkU3%2BCxbmiJIYM" target="_blank" rel="noopener">9 道 MySQL 面试题</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzA3MTg4NjY4Mw==&amp;mid=2457307570&amp;idx=2&amp;sn=c8a3f3f45fa2ed9998be713528272ad9&amp;chksm=88a59b86bfd21290bf9dc79be9bebfe57bffcc1352682b152bb354c7177449021777f6fcb1ca&amp;mpshare=1&amp;scene=24&amp;srcid=&amp;sharer_sharetime=1592959329103&amp;sharer_shareid=b539221659d6ecf12200314308b58dd3&amp;key=41f971365debdfe9cf3f83cd39b1b1e3392a61f125626cee8d56db3cf1d9e8674ec2fb0399a4cedb0f3b12737250e9ccd8423a5f76c71a1e27a8026edf2de8c86538603ff9370d460020772e5dfff60d&amp;ascene=14&amp;uin=MjAwNDUzMjgxNw%3D%3D&amp;devicetype=Windows+10+x64&amp;version=62090529&amp;lang=zh_CN&amp;exportkey=AXttlvqiichHWPtD4HqdOrU%3D&amp;pass_ticket=ws7WEjys7meG8tQvR9%2BINrP5RKEp1Mus1mqNfeaPYCNHYnD2%2FhjK5ZF3mONasy7H" target="_blank" rel="noopener">那些SQL里面踩过的坑</a></li>
<li><a href="https://www.jianshu.com/p/ea15158f39f7" target="_blank" rel="noopener">MySQL的information_schema库</a></li>
<li><a href="https://www.cnblogs.com/postnull/p/6697077.html" target="_blank" rel="noopener">MySQL元数据库——information_schema</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/88342863" target="_blank" rel="noopener">MySQL information_schema 详解</a></li>
</ul>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>SQL</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>NoSQL</title>
    <url>/NoSQL.html</url>
    <content><![CDATA[<p><center>Not Only SQL</center><br><a id="more"></a></p>
<p>非关系型数据库</p>
<p>不仅仅是SQL</p>
<h1 id="非关系型数据库"><a href="#非关系型数据库" class="headerlink" title="非关系型数据库"></a>非关系型数据库</h1><ul>
<li>内部存储方式是键值对（key-value）形式</li>
<li>不需要经过SQL的重重解析，性能很高</li>
<li>可扩展性比较强</li>
<li>数据之间没有耦合性</li>
</ul>
<h2 id="HBase"><a href="#HBase" class="headerlink" title="HBase"></a>HBase</h2><h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><h2 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h2><h1 id="NoSQL-vs-SQL"><a href="#NoSQL-vs-SQL" class="headerlink" title="NoSQL vs SQL"></a>NoSQL vs SQL</h1><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:left">NoSQL</th>
<th style="text-align:left">SQL</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">内部存储形式</td>
<td style="text-align:left">键值对</td>
<td style="text-align:left">表格</td>
</tr>
<tr>
<td style="text-align:center">常见数据库</td>
<td style="text-align:left">HBase<br>Redis<br>MongoDB</td>
<td style="text-align:left">Oracle<br>DB2<br>MySQL<br>Microsoft SQL Server</td>
</tr>
</tbody>
</table>
</div>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzA3MTg4NjY4Mw==&amp;mid=2457305755&amp;idx=2&amp;sn=764158cf905b0622e1697f51baa718f2&amp;chksm=88a590afbfd219b98bd7d83c2f4ea4d572654b5889eff254bbbb60f2189f61aee393e1801510&amp;mpshare=1&amp;scene=1&amp;srcid=&amp;sharer_sharetime=1590150427096&amp;sharer_shareid=b539221659d6ecf12200314308b58dd3&amp;key=21ed68970b00e8fc75b1e914e6c754e962a5fcec08d9c1e0fb5bfcb82d495aac1ab014508f15a5ebb1eaf6e1c2a2036cecc7516e989e5f1bd3b3615846e67437d7d0ad461bc0ca4d28139dc860680c5b&amp;ascene=1&amp;uin=MjAwNDUzMjgxNw%3D%3D&amp;devicetype=Windows+10+x64&amp;version=62090070&amp;lang=zh_CN&amp;exportkey=AbupEngztSgB4dsmRHvGbpk%3D&amp;pass_ticket=iLa2XiZaCBS2XSrbXAnYFAIdgj9HEiggWqWDoDR8tX5Ckgf6sdWkU3%2BCxbmiJIYM" target="_blank" rel="noopener">9 道 MySQL 面试题</a></li>
<li><a href></a></li>
</ul>
]]></content>
      <tags>
        <tag>NoSQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Machine Learning | ADMM</title>
    <url>/%E7%AE%97%E6%B3%95-ADMM.html</url>
    <content><![CDATA[<p><center>Alternating Direction Method of Multipliers</center><br><a id="more"></a></p>
<p>ADMM</p>
<p>交替方向乘子法</p>
<ul>
<li>一种求解可分离的凸优化问题的重要方法</li>
<li>处理速度快</li>
<li>收敛性能好</li>
</ul>
<blockquote>
<p>原文：Boyd S, Parikh N, Chu E, et al. <a href="http://web.stanford.edu/~boyd/papers/pdf/admm_distr_stats.pdf" target="_blank" rel="noopener">Distributed optimization and statistical learning via the alternating direction method of multipliers</a>[J]. Foundations and Trends® in Machine learning, 2011, 3(1): 1-122.</p>
</blockquote>
<h1 id="Basic"><a href="#Basic" class="headerlink" title="Basic"></a>Basic</h1><h2 id="共轭函数"><a href="#共轭函数" class="headerlink" title="共轭函数"></a>共轭函数</h2><p>Fenchel conjugate function</p>
<p>函数$f(x)$的共轭函数定义为</p>
<script type="math/tex; mode=display">f^*(y)=\max_x\left\{y^Tx-f(x)\right\}</script><ul>
<li>几何意义：共轭函数是切线簇的截距的负值簇<ul>
<li>如果$f(x)$是凸（convex）的：<br>考虑$f(x)$上的点$(x^*,f(x^*))$处的斜率为$y^T$的切线<script type="math/tex; mode=display">z=y^T(x-x^*)+f(x^*)</script>该切线的截距项（$x=0$）为<script type="math/tex; mode=display">-y^Tx^*+f(x^*)</script>截距项的负数就是$f(x)$的共轭。</li>
<li>如果$f(x)$不是凸（convex）的：<br>则切线可能会对应多个截距项</li>
</ul>
</li>
</ul>
<p><meta name="referrer" content="no-referrer"><br><img src="/%E7%AE%97%E6%B3%95-ADMM/conjugate1.jpg" class title="来自：最强Fenchel对偶解读"></p>
<p><meta name="referrer" content="no-referrer"><br><img src="/%E7%AE%97%E6%B3%95-ADMM/conjugate2.jpg" class title="来自：最强Fenchel对偶解读"></p>
<p>当$f(x)$是严格凸的时，取$z=\arg\max_x{\{y^Tx-f(x)\}}$，则有</p>
<script type="math/tex; mode=display">f^*(y)=\max_x{\{y^Tx-f(x)\}}=y^Tz-f(z)</script><p>因此</p>
<script type="math/tex; mode=display">\nabla f^*(y)=z=\arg\max_x{\{y^Tx-f(x)\}}=\arg\min_x{\{f(x)-y^Tx\}}</script><h2 id="带线性约束的优化问题"><a href="#带线性约束的优化问题" class="headerlink" title="带线性约束的优化问题"></a>带线性约束的优化问题</h2><p>考虑带线性约束的优化问题<br>\begin{equation}<br>\begin{aligned}<br>\min &amp; \quad f(x)\\<br>\mathrm{s.t.} &amp; \quad Ax=b<br>\end{aligned}<br>\end{equation}<br>其中$f(x)$是严格凸函数（strictly convex function）。</p>
<p>构造该优化问题的拉格朗日函数</p>
<script type="math/tex; mode=display">L(x,y)=f(x)+y^T(Ax-b)</script><p>这里$y$是拉格朗日乘子（Lagrangian multiplier）。</p>
<p>求解原优化问题等价于求解</p>
<script type="math/tex; mode=display">\min_x\max_y{L(x,y)}</script><ul>
<li>当$Ax=b$不成立时，总可以找到$y$使得 $\max_y L(x,y)=\infty$</li>
<li>当$Ax=b$成立时，$\min_x\max_y{L(x,y)}=\min_x f(x)$</li>
</ul>
<p>当$f(x)$可导（differentiable）时，$L(x,y)$分别关于$x,y$求偏导并令偏导数为零，得</p>
<script type="math/tex; mode=display">\left\{
    \begin{array}{l}
    \nabla_x L(x,y) =\nabla f(x)+A^Ty=0\\
    \nabla_y L(x,y) =Ax-b=0
    \end{array}
    \right.</script><blockquote>
<p>$\frac{\mathrm{d}(\beta^Tx)}{\mathrm{d}x}=\beta$</p>
</blockquote>
<p>$\min_x\max_y{L(x,y)}$的对偶问题（dual problem）是$\max_y\min_x{L(x,y)}$。</p>
<p>当强对偶性<sup><a href="#fn_1" id="reffn_1">1</a></sup>（duality）满足时，$\min_x\max_y{L(x,y)}$与$\max_y\min_x{L(x,y)}$有相同的解。</p>
<blockquote id="fn_1">
<sup>1</sup>. <a href="https://baike.baidu.com/item/%E5%BC%BA%E5%AF%B9%E5%81%B6%E6%80%A7/17194045?fr=aladdin" target="_blank" rel="noopener">强对偶性</a>：若原始问题（对偶问题）有一个确定的最优解，那么对偶问题（原始问题）也有一个确定的最优解，而且这两个最优解所对应的目标函数值相等。<a href="#reffn_1" title="Jump back to footnote [1] in the text."> &#8617;</a>
</blockquote>
<blockquote>
<ul>
<li><strong><a href="https://en.wikipedia.org/wiki/Strong_duality" target="_blank" rel="noopener">Strong duality</a></strong>: Strong duality holds if and only if the duality gap is equal to 0.<script type="math/tex; mode=display">p^*=d^*</script></li>
<li><strong><a href="https://en.wikipedia.org/wiki/Duality_gap" target="_blank" rel="noopener">Duality gap</a></strong>: 原始问题（primal problem）的最优解$p^*$与对偶问题（dual problem）的最优解$d^*$之间的差异。</li>
<li>强对偶性的充分条件：<ul>
<li>原始问题是线性优化问题</li>
<li>$F$是原始函数的<a href="https://en.wikipedia.org/wiki/Perturbation_function" target="_blank" rel="noopener">perturbation function</a>,$F^{**}$是$F$的<a href="https://en.wikipedia.org/wiki/Perturbation_function" target="_blank" rel="noopener">biconjugate</a><script type="math/tex; mode=display">F=F^{**}</script></li>
<li>$F$ is convex and lower semi-continuous</li>
<li>凸优化问题的<a href="https://en.wikipedia.org/wiki/Perturbation_function" target="_blank" rel="noopener">Slater’s condition</a>成立</li>
</ul>
</li>
</ul>
</blockquote>
<p>定义<br>\begin{equation}<br>\begin{aligned}<br>g(y) &amp;= \min_x L(x,y) \\<br>&amp;= \min_x\left\{f(x)+y^T(Ax-b)\right\}\\<br>&amp;= \min_x\left\{f(x)-(-A^Ty)^Tx-y^Tb \right\}\\<br>&amp;= \underline{\min_x\left\{f(x)-(-A^Ty)^Tx \right\}}-y^Tb\\<br>&amp;= \underline{-f^*(-A^Ty)}-y^Tb<br>\end{aligned}<br>\end{equation}</p>
<p>由于$f^*(y)=\max_x{\{y^Tx-f(x)\}}=-\min_x{\{f(x)-y^Tx \}}$。</p>
<p>\begin{equation}<br>\begin{aligned}<br>\nabla g(y) &amp;= A\nabla f^*(-A^Ty)-b\\<br>&amp;= A\arg\min_x\left\{f(x)+y^TAx \right\}-b\\<br>&amp;= A\arg\min_x\left\{f(x)+y^T(Ax-b) \right\}-b\\<br>&amp;= A\arg\min_x L(x,y)-b<br>\end{aligned}<br>\end{equation}</p>
<blockquote>
<p>$\frac{\mathrm{d}(x^T\beta)}{\mathrm{d}x}=\beta$</p>
</blockquote>
<h3 id="DAM"><a href="#DAM" class="headerlink" title="DAM"></a>DAM</h3><p>Dual Decomposition<br>Dual Ascent Algorithm<br>对偶上升算法</p>
<p>算法的第$k+1$步迭代为</p>
<p>\begin{equation}<br>\begin{aligned}<br>x^{k+1}&amp;=\arg\min_x L(x,y^k)\\<br>y^{k+1}&amp;=y^{k} + \alpha^k\nabla g(y^k) \quad \mathrm{(Gradient Ascent Update)}\\<br>&amp;= y^k + \alpha^k(Ax^{k+1}-b)<br>\end{aligned}<br>\end{equation}<br>其中</p>
<ul>
<li>$\alpha^k&gt;0$是步长</li>
<li>$\nabla g(y^k)=A\arg\min_x L(x,y^k)-b$</li>
</ul>
<p>当$f(x)$可分时，即</p>
<script type="math/tex; mode=display">f(x)=\sum_{i=1}^nf_i(x_i)</script><p>则<br>\begin{equation}<br>\begin{aligned}<br>L(x,y^k) &amp;= f(x)+y^T(Ax-b)\\<br>&amp;= \sum_{i=1}^nf_i(x) + y^T\left(\sum_{i=1}^nA_ix_i-b\right)\\<br>&amp;=\sum_{i=1}^n\left(f_i(x)+y^TA_ix_i-\frac{1}{n}y^Tb \right)\\<br>&amp;= \sum_{i=1}^nL_i(x_i,y^k)<br>\end{aligned}<br>\end{equation}</p>
<p>则分成了$n$个平行计算</p>
<script type="math/tex; mode=display">x_i^{k+1}=\arg\min_{x_i} L_i(x_i, y^k)</script><h3 id="ALM"><a href="#ALM" class="headerlink" title="ALM"></a>ALM</h3><p>Augmented Lagrangian Method<br>Method of Multipliers<br>增广的拉格朗日乘子法</p>
<p>当$f(x)$不是严格凸时，Dual Ascent Algorithm不适用。</p>
<p>增广的拉格朗日函数为</p>
<script type="math/tex; mode=display">L_\rho(x,y)=f(x)+y^T(Ax-b)+\frac{\rho}{2}||Ax-b||^2</script><p>即解决优化问题<br>\begin{equation}<br>\begin{aligned}<br>\min &amp; \quad f(x)+\frac{\rho}{2}||Ax-b||^2\\<br>\mathrm{s.t.} &amp;\quad Ax=b<br>\end{aligned}<br>\end{equation}</p>
<p>则<br>\begin{equation}<br>\begin{aligned}<br>x^{k+1} &amp;= \arg\min_x{L_\rho(x,y^k)}\\<br>y^{k+1} &amp;= y^k + \rho(Ax^{k+1}-b)<br>\end{aligned}<br>\end{equation}</p>
<blockquote>
<p>为什么步长为$\rho$？<br>我们只考虑$f(x)$可导的特殊情况。<br>原始优化问题如果满足：<br>\begin{equation}<br>\begin{aligned}<br>\nabla_x L(x^*,y^*) &amp;= \nabla f(x^*)+A^Ty^*=0\\<br>\nabla_y L(x^*,y^*) &amp;= Ax^*-b=0<br>\end{aligned}<br>\end{equation}<br>则称为primal and dual feasibility。<br>因为$x^{k+1}=\arg\min_xL_\rho(x,y^k)$，所以<br>\begin{equation}<br>\begin{aligned}<br>0 &amp;= \nabla_x L_\rho(x^{k+1},y^k)\\<br>&amp;= \nabla_x f(x^{k+1})+A^T(y^k+\rho(Ax^{k+1}-b))<br>\end{aligned}<br>\end{equation}<br>如果取$y^{k+1}=y^k+\rho(Ax^{k+1}-b)$，则有</p>
<script type="math/tex; mode=display">\nabla_xf(x^{k+1})+A^Ty^{k+1}=0</script><p>所以，如果取步长为$\rho$，则可以保证每一次迭代后的解都满足dual feasible.</p>
</blockquote>
<p>与Dual Ascent Method相比，</p>
<ul>
<li>ALM需要的假设相对比较不严格，且有更好的收敛性</li>
<li>但是ALM不能并行计算，即使$f(x)$可分</li>
</ul>
<h1 id="ADMM"><a href="#ADMM" class="headerlink" title="ADMM"></a>ADMM</h1><p>用于解决如下问题<br>\begin{equation}<br>\begin{aligned}<br>\min &amp; \quad f(x)+g(z)\\<br>\mathrm{s.t.} &amp; \quad Ax+Bz=c<br>\end{aligned}<br>\end{equation}</p>
<p>该优化问题的扩展拉格朗日函数为</p>
<script type="math/tex; mode=display">L_\rho(x,y,z)=f(x)+g(z)+y^T(Ax+Bz-c)+\frac{\rho}{2}||Ax+Bz-c||^2</script><p>其中$\frac{\rho}{2}||Ax+Bz-c||^2$是扩展项（augmented term）。</p>
<p>使用ALM解上述问题：<br>\begin{equation}<br>\begin{aligned}<br>(x^{k+1},z^{k+1}) &amp;= \arg\min_{x,z} L_\rho (x,z,y^k)\\<br>y^{k+1} &amp;= y^k + \rho (Ax^{k+1}+Bz^{k+1}-c)<br>\end{aligned}<br>\end{equation}</p>
<p>ADMM与ALM的区别：<br>ADMM将ALM中的$(x,z)-$最小化步骤拆分成两步：</p>
<ul>
<li>x-minimization</li>
<li>z-minimization<br>\begin{equation}<br>\begin{aligned}<br>x^{k+1} &amp;= \arg\min_x L_\rho(x,z^k,y^k)\\<br>z^{k+1} &amp;= \arg\min_z L_\rho(x^{k+1}, z,y^k)\\<br>y^{k+1} &amp;= y^k+\rho(Ax^{k+1}+Bz^{k+1}-c)<br>\end{aligned}<br>\end{equation}</li>
</ul>
<p>定义残差项$r=Ax+Bz-c$，则$L_\rho(x,y,z)$可改写为<br>\begin{equation}<br>\begin{aligned}<br>L_\rho(x,y,z) &amp;= f(x)+g(z)+y^T(Ax+Bz-c)+\frac{\rho}{2}||Ax+Bz-c||^2\\<br>&amp;= f(x)+g(z)+y^Tr+\frac{\rho}{2}||r||^2\\<br>&amp;= f(x)+g(z)+\frac{\rho}{2}||r+\frac{1}{\rho}y||^2-\frac{1}{2\rho}||y||^2\\<br>&amp;= f(x)+g(z)+\frac{\rho}{2}||r+u||^2-\frac{\rho}{2}||u||^2<br>\end{aligned}<br>\end{equation}<br>其中</p>
<ul>
<li>$u=\frac{1}{\rho}y$称为scaled dual variable</li>
<li>\begin{aligned}<br>\frac{\rho}{2}||r+\frac{1}{\rho}y||^2 &amp;= \frac{\rho}{2}\left(||r||^2+\frac{2}{\rho}y^Tr+\frac{1}{\rho^2}||y||^2 \right)\\<br>&amp;= \frac{\rho}{2}||r||^2+y^Tr+\frac{1}{2\rho}||y||^2<br>\end{aligned}</li>
</ul>
<p>则ADMM的迭代步骤变为<br>\begin{aligned}<br>x^{k+1} &amp;= \arg\min_x \left\{f(x)+\frac{\rho}{2}||Ax+Bz^k-c+u^k||^2 \right\}\\<br>z^{k+1} &amp;= \arg\min_z \left\{g(z)+\frac{\rho}{2}||Ax^{k+1}+Bz-c+u^k||^2 \right\}\\<br>u^{k+1} &amp;= u^k+Ax^{k+1}+Bz^{k+1}-c<br>\end{aligned}</p>
<h2 id="收敛性"><a href="#收敛性" class="headerlink" title="收敛性"></a>收敛性</h2><p>基于两个假设证明ADMM的收敛性</p>
<ul>
<li><strong>假设1</strong>：函数$f:\mathbb{R}^n\rightarrow \mathbb{R}\cup \{+\infty\}$和函数$g:\mathbb{R}^m\rightarrow\cup \{+\infty\}$是closed, proper and convex.<blockquote>
<p>该假设保证了x-minimization step和z-minimization step有解</p>
</blockquote>
</li>
<li><strong>假设2</strong>：非增广德拉格朗日函数$L_0$有一个鞍点（saddle point）<blockquote>
<p>该假设意味着存在$(x^*,z^*,y^*)$（并不要求唯一）。</p>
<script type="math/tex; mode=display">L_0(x^*,z^*,y)\leq L_0(x^*, z^*, y^*) \leq L_0(x, z, y^*)</script><p>对所有的$x,z,y$成立</p>
<ul>
<li>$y^*=\arg\max L_0(x^*,z^*,y)$</li>
<li>$(x^*,z^*)=\arg\min L_0(x,z,y^*)$</li>
</ul>
</blockquote>
</li>
</ul>
<p>基于上述两个假设，ADMM迭代满足：</p>
<ul>
<li>残差收敛：<script type="math/tex; mode=display">r^k\rightarrow 0\quad (k\rightarrow \infty)</script></li>
<li>目标函数收敛：<script type="math/tex; mode=display">f(x^k)+g(x^k)\rightarrow p^* \quad (k\rightarrow\infty)</script></li>
<li>对偶变量(Dual Variable)收敛：<script type="math/tex; mode=display">y^k\rightarrow y^* \quad (k\rightarrow \infty)</script></li>
</ul>
<h2 id="Optimality-Conditions"><a href="#Optimality-Conditions" class="headerlink" title="Optimality Conditions"></a>Optimality Conditions</h2><p>ADMM<strong>最优化的充要条件</strong>是primal feasibility</p>
<script type="math/tex; mode=display">Ax^*+Bz^*-c=0</script><p>和dual feasibility</p>
<script type="math/tex; mode=display">\nabla f(x^*)+A^Ty^*=0</script><script type="math/tex; mode=display">\nabla g(z^*)+B^Ty^*=0</script><blockquote>
<script type="math/tex; mode=display">L_\rho(x,y,z) = f(x)+g(z)+y^T(Ax+Bz-c)+\frac{\rho}{2}||Ax+Bz-c||^2</script><ul>
<li>因为$z^{k+1}=\arg\min_z L_\rho(x^{k+1}, z, y^k)$，所以有<br>\begin{aligned}<br>0 &amp;= \nabla_z L_\rho(x^{k+1}, z^{k+1}, y^k)\\<br>&amp;= \nabla g(z^{k+1})+B^Ty^k+\rho B^T(Ax^{k+1}+Bz^{k+1}-c)\\<br>&amp;= \nabla g(z^{k+1})+B^Ty^k+\rho B^Tr^{k+1}\\<br>&amp; \left(因为y^{k+1}=y^k+\rho(Ax^{k+1}+Bz^{k+1}-c)=y^k+\rho r^{k+1}\right)\\<br>&amp;= \nabla g(z^{k+1})+B^Ty^{k+1}<br>\end{aligned}<br>所以，每次迭代结束后总满足$\nabla g(z)+B^Ty=0$。</li>
<li>因为$x^{k+1}=\arg\min_x L_\rho(x,z^k,y^k)$，所以有<br>\begin{aligned}<br>0 &amp;= \nabla_x L_\rho(x^{k+1},z^k,y^k)\\<br>&amp;= \nabla f(x^{k+1}) + A^Ty^k+\rho A^T(Ax^{k+1}+Bz^k-c)\\<br>&amp;= \nabla f(x^{k+1})+A^T(y^k+\rho r^{k+1}+\rho B(z^k-z^{k+1}))\\<br>&amp;= \nabla f(x^{k+1})+A^Ty^{k+1}+\rho A^TB(z^k-z^{k+1})<br>\end{aligned}<br>等价于<script type="math/tex; mode=display">\rho A^TB(z^{k+1}-z^k)=\nabla f(x^{k+1})+A^Ty^{k+1}</script></li>
</ul>
</blockquote>
<h2 id="Stopping-Criterion"><a href="#Stopping-Criterion" class="headerlink" title="Stopping Criterion"></a>Stopping Criterion</h2><script type="math/tex; mode=display">||Ax^k+Bz^k-c||^2=||r^k||^2\leq \epsilon^{pri}</script><script type="math/tex; mode=display">||\rho A^TB(z^{k+1}-z^k)||^2=||s^k||^2\leq \epsilon^{dual}</script><p>其中$\epsilon^{pri}&gt;0$,$\epsilon^{dual}&gt;0$是feasibility tolerances。<br>可取<br>\begin{aligned}<br>\epsilon^{pri} &amp;= \sqrt{p}\epsilon^{abs}+\epsilon^{real}\max\{||Ax^k||^2, ||Bz^k||^2, ||c||^2 \}\\<br>\epsilon^{dual} &amp;= \sqrt{n}\epsilon^{abs}+\epsilon^{real}||A^Ty^k||^2<br>\end{aligned}<br>其中$\epsilon^{real}$可取$\epsilon^{real}=\frac{1}{10}$。</p>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="求解LASSO"><a href="#求解LASSO" class="headerlink" title="求解LASSO"></a>求解LASSO</h3><p>给定$y\in \mathbb{R}^n,\mathbf{X}\in\mathbb{R}^{n\times p}$，LASSO问题为</p>
<script type="math/tex; mode=display">\min \quad \frac{1}{2}||y-\mathbf{X}\beta||^2+\lambda||\beta||_1</script><p>可以写成<br>\begin{aligned}<br>\min &amp; \quad \frac{1}{2}||y-\mathbf{X}\beta||^2+\lambda||\alpha||_1\\<br>\mathrm{s.t.} &amp; \quad \beta-\alpha=0<br>\end{aligned}</p>
<p>对应的拉格朗日函数为</p>
<script type="math/tex; mode=display">L_\rho(\alpha,\beta,\phi)=\frac{1}{2}||y-\mathbf{X}\beta||^2+\lambda||\alpha||_1+\phi^T(\beta-\alpha)+\frac{\rho}{2}||\beta-\alpha||^2</script><p>其中$\phi$是拉格朗日乘子,$y$是response。</p>
<p>增广的拉格朗日函数为</p>
<script type="math/tex; mode=display">L_\rho(\alpha,\beta,u)=\frac{1}{2}||y-\mathbf{X}\beta||^2+\lambda||\alpha||_1+\phi^T(\beta-\alpha+u)-\frac{1}{2\rho}||u||^2</script><p>LASSO问题的ADMM为<br>\begin{aligned}<br>\beta^{k+1} &amp;= \arg\min_\beta\left\{\frac{1}{2}||y-\mathbf{X}\beta||^2+\frac{\rho}{2}||\beta-\alpha^k+u^k||^2\right\}\\<br>\alpha^{k+1} &amp;= \arg\min_\alpha\left\{\lambda||\alpha||_1+\frac{\rho}{2}||\beta^{k+1}-\alpha+u^k||^2\right\}\\<br>u^{k+1} &amp;= u^k+\beta^{k+1}-\alpha^{k+1}<br>\end{aligned}<br>其中$u^k=\frac{1}{\rho}\phi^k$。</p>
<p>对于$\beta^{k+1} = \arg\min_\beta\left\{\frac{1}{2}||y-\mathbf{X}\beta||^2+\frac{\rho}{2}||\beta-\alpha^k+u^k||^2\right\}$有<br>\begin{aligned}<br>&amp; \frac{\partial{\left\{\frac{1}{2}||y-\mathbf{X}\beta||^2+\frac{\rho}{2}||\beta-\alpha^k+u^k||^2\right\}}}{\partial{\beta}}\\<br>= &amp; \mathbf{X}(\mathbf{X}\beta-y)+\rho(\beta-\alpha^k+u^k)\\<br>= &amp; (\mathbf{X}^T\mathbf{X}+\rho\mathbf{I} )\beta-\left[\mathbf{X}^Ty+\rho(\alpha^k-u^k) \right]\\<br>= &amp; 0<br>\end{aligned}<br>则有</p>
<script type="math/tex; mode=display">\beta^{k+1}\triangleq(\mathbf{X}^T\mathbf{X}+\rho\mathbf{I})^{-1}\left(\mathbf{X}^Ty+\rho(\alpha^k-u^k) \right)</script><p>对于$\alpha^{k+1} = \arg\min_\alpha\left\{\lambda||\alpha||_1+\frac{\rho}{2}||\beta^{k+1}-\alpha+u^k||^2\right\}$有<br>\begin{aligned}<br>&amp; \frac{\partial{\lambda|\alpha_j|+\frac{\rho}{2}(\beta_j^{k+1}-\alpha_j+u_j^k)^2}}{\partial{\alpha_j}}\\<br>= &amp; \lambda \mathrm{sgn}(\alpha_j)-\rho(\beta_j^{k+1}+u_j^k-\alpha_j)<br>\end{aligned}</p>
<ul>
<li>当$\alpha_j&gt;0$时，如果有$\beta_j^{k+1}+u_j^k&gt;\frac{\lambda}{\rho}$，则有<script type="math/tex; mode=display">\alpha_j^{k+1}=\beta_j^{k+1}+u_j^k-\frac{\lambda}{\rho}</script></li>
<li>当$\alpha_j=0$时，$\alpha_j^{k+1}=0$</li>
<li>当$\alpha_j&lt;0$时，如果有$\beta_j^{k+1}+u_j^k+\frac{\lambda}{\rho}&lt;0$，则有<script type="math/tex; mode=display">\alpha_j^{k+1}=\beta_j^{k+1}+u_j^k+\frac{\lambda}{\rho}</script></li>
</ul>
<p>最后，有</p>
<script type="math/tex; mode=display">\alpha_j^{k+1}=S_{\frac{\lambda}{\rho}}\left(\beta_j^{k+1}+u_j^k \right)</script><p>其中$S_{\frac{\lambda}{\rho}}$为soft thresholding function</p>
<script type="math/tex; mode=display">S_{\kappa}(a)=\left\{
  \begin{array}{ll}
  a-\kappa & a>\kappa\\
  0 & |a|\leq\kappa\\
  a+\kappa & a<-\kappa
  \end{array}
  \right.</script><p>其中$\kappa=\frac{\lambda}{\rho}$。</p>
<p>因此，LASSO问题的ADMM(显式)迭代过程为<br>\begin{aligned}<br>\beta^{k+1} &amp;= (\mathbf{X}^T\mathbf{X}+\rho\mathbf{I})^{-1}\left(\mathbf{X}^Ty+\rho(\alpha^k-u^k) \right)\\<br>\alpha^{k+1} &amp;= S_{\frac{\lambda}{\rho}}\left(\beta^{k+1}+u^k \right)\\<br>u^{k+1} &amp;= u^k+\beta^{k+1}-\alpha^{k+1}<br>\end{aligned}<br>Stopping Criterion可以为</p>
<script type="math/tex; mode=display">||\beta^{k+1}-\alpha^{k+1}||<\epsilon</script><p>或</p>
<script type="math/tex; mode=display">\rho ||\alpha^{k+1}-\alpha^k||<\epsilon</script><h3 id="求解Fused-LASSO"><a href="#求解Fused-LASSO" class="headerlink" title="求解Fused LASSO"></a>求解Fused LASSO</h3><p>Fused LASSO为</p>
<script type="math/tex; mode=display">\min\quad \frac{1}{2}||y-\mathbf{X}\beta||^2+\lambda_1||\beta||_1+\lambda_2\sum_{i=2}^p|\beta_i-\beta_{i-1}|</script><p>是广义LASSO的一般形式。</p>
<p>可以改写为</p>
<script type="math/tex; mode=display">\min\quad \frac{1}{2}||y-\mathbf{X}\beta||^2+\lambda_1||D\beta||^2</script><p>其中</p>
<script type="math/tex; mode=display">D=\left(
  \begin{array}{c}
  \mathbf{I}_p\\
  B
  \end{array}
  \right)</script><script type="math/tex; mode=display">B=\frac{\lambda_2}{\lambda_1}\left(
  \begin{array}{cccccc}
  -1 & 1 & 0 & \cdots & 0 & 0\\
  0 & -1 & 1 & \cdots & 0 & 0\\
  0 & 0 & -1 & \cdots & 0 & 0\\
  \vdots & \vdots & \vdots & \ddots & \vdots & \vdots\\
  0 & 0 & 0 & \cdots & 1 & 0\\
  0 & 0 & 0 & \cdots & -1 & 1
  \end{array}
  \right)</script><p>Fused LASSO可以进一步写为<br>\begin{aligned}<br>\min &amp; \quad \frac{1}{2}||y-\mathbf{X}\beta||^2+\lambda||\alpha||_1\\<br>\mathrm{s.t.} &amp; \quad D\beta-\alpha=0<br>\end{aligned}</p>
<p>则Fused LASSO的ADMM迭代步骤为<br>\begin{aligned}<br>\beta^{k+1} &amp;= (\mathbf{X}^T\mathbf{X}+\rho D^TD)^{-1}\left(\mathbf{X}^Ty+\rho D^T(\alpha^k-u^k) \right)\\<br>\alpha^{k+1} &amp;= S_{\frac{\lambda}{\rho}}(D\beta^{k+1}+u^k)\\<br>u^{k+1} &amp;= u^k+D\beta^{k+1}-\alpha^{k+1}<br>\end{aligned}</p>
<p>上述算法可以解决不同的广义LASSO问题（$D$不同）。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li>W. Zhong, J. Lin - Statistical Data Analysis</li>
<li><a href="https://zhuanlan.zhihu.com/p/32202419" target="_blank" rel="noopener">最强Fenchel对偶解读</a></li>
<li><a href="https://www.cnblogs.com/wildkid1024/p/11041756.html" target="_blank" rel="noopener">[Algorithm]ADMM简明理解</a></li>
<li><a href="https://www.zhihu.com/question/36566112" target="_blank" rel="noopener">交替方向乘子法（ADMM）算法的流程和原理是怎样的？</a></li>
</ul>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Python | missingno</title>
    <url>/python-missingno.html</url>
    <content><![CDATA[<p><center>用于可视化缺失值</center><br><a id="more"></a></p>
<h1 id="missingno"><a href="#missingno" class="headerlink" title="missingno"></a>missingno</h1><p>安装：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install missingno</span><br></pre></td></tr></table></figure></p>
<p>首先下载样本数据：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install quilt</span><br><span class="line">quilt install ResidentMario/missingno_data</span><br></pre></td></tr></table></figure></p>
<p>加载数据：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> quilt.data.ResidentMario <span class="keyword">import</span> missingno_data</span><br><span class="line"></span><br><span class="line">collisions = missingno_data.nyc_collision_factors()</span><br><span class="line">collisions = collisions.replace(<span class="string">'nan'</span>, np.nan)</span><br><span class="line">collisions.head()</span><br></pre></td></tr></table></figure></p>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Unnamed: 0</th>
      <th>DATE</th>
      <th>TIME</th>
      <th>BOROUGH</th>
      <th>ZIP CODE</th>
      <th>LATITUDE</th>
      <th>LONGITUDE</th>
      <th>LOCATION</th>
      <th>ON STREET NAME</th>
      <th>CROSS STREET NAME</th>
      <th>OFF STREET NAME</th>
      <th>NUMBER OF PERSONS INJURED</th>
      <th>NUMBER OF PERSONS KILLED</th>
      <th>NUMBER OF PEDESTRIANS INJURED</th>
      <th>NUMBER OF PEDESTRIANS KILLED</th>
      <th>NUMBER OF CYCLISTS INJURED</th>
      <th>NUMBER OF CYCLISTS KILLED</th>
      <th>CONTRIBUTING FACTOR VEHICLE 1</th>
      <th>CONTRIBUTING FACTOR VEHICLE 2</th>
      <th>CONTRIBUTING FACTOR VEHICLE 3</th>
      <th>CONTRIBUTING FACTOR VEHICLE 4</th>
      <th>CONTRIBUTING FACTOR VEHICLE 5</th>
      <th>VEHICLE TYPE CODE 1</th>
      <th>VEHICLE TYPE CODE 2</th>
      <th>VEHICLE TYPE CODE 3</th>
      <th>VEHICLE TYPE CODE 4</th>
      <th>VEHICLE TYPE CODE 5</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>0</td>
      <td>11/10/2016</td>
      <td>16:11:00</td>
      <td>BROOKLYN</td>
      <td>11208.0</td>
      <td>40.662514</td>
      <td>-73.872007</td>
      <td>(40.6625139, -73.8720068)</td>
      <td>WORTMAN AVENUE</td>
      <td>MONTAUK AVENUE</td>
      <td>NaN</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>Failure to Yield Right-of-Way</td>
      <td>Unspecified</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>TAXI</td>
      <td>PASSENGER VEHICLE</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>1</th>
      <td>1</td>
      <td>11/10/2016</td>
      <td>05:11:00</td>
      <td>MANHATTAN</td>
      <td>10013.0</td>
      <td>40.721323</td>
      <td>-74.008344</td>
      <td>(40.7213228, -74.0083444)</td>
      <td>HUBERT STREET</td>
      <td>HUDSON STREET</td>
      <td>NaN</td>
      <td>1</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>Failure to Yield Right-of-Way</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>PASSENGER VEHICLE</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>2</th>
      <td>2</td>
      <td>04/16/2016</td>
      <td>09:15:00</td>
      <td>BROOKLYN</td>
      <td>11201.0</td>
      <td>40.687999</td>
      <td>-73.997563</td>
      <td>(40.6879989, -73.9975625)</td>
      <td>HENRY STREET</td>
      <td>WARREN STREET</td>
      <td>NaN</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>Lost Consciousness</td>
      <td>Lost Consciousness</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>PASSENGER VEHICLE</td>
      <td>VAN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>3</th>
      <td>3</td>
      <td>04/15/2016</td>
      <td>10:20:00</td>
      <td>QUEENS</td>
      <td>11375.0</td>
      <td>40.719228</td>
      <td>-73.854542</td>
      <td>(40.7192276, -73.8545422)</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>67-64 FLEET STREET</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>Failure to Yield Right-of-Way</td>
      <td>Failure to Yield Right-of-Way</td>
      <td>Failure to Yield Right-of-Way</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>PASSENGER VEHICLE</td>
      <td>PASSENGER VEHICLE</td>
      <td>PASSENGER VEHICLE</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>4</th>
      <td>4</td>
      <td>04/15/2016</td>
      <td>10:35:00</td>
      <td>BROOKLYN</td>
      <td>11210.0</td>
      <td>40.632147</td>
      <td>-73.952731</td>
      <td>(40.6321467, -73.9527315)</td>
      <td>BEDFORD AVENUE</td>
      <td>CAMPUS ROAD</td>
      <td>NaN</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>Failure to Yield Right-of-Way</td>
      <td>Failure to Yield Right-of-Way</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>PASSENGER VEHICLE</td>
      <td>PASSENGER VEHICLE</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
  </tbody>
</table>
</div>

<h2 id="bar"><a href="#bar" class="headerlink" title="bar()"></a>bar()</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">msno.bar(collisions.sample(<span class="number">1000</span>))</span><br></pre></td></tr></table></figure>
<p><meta name="referrer" content="no-referrer"><br><img src="/python-missingno/output_4_1.png" class title="条形图"></p>
<h2 id="Dendrogram"><a href="#Dendrogram" class="headerlink" title="Dendrogram()"></a>Dendrogram()</h2><p>谱系图/系统树图</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">msno.dendrogram(collisions)</span><br></pre></td></tr></table></figure>
<p><meta name="referrer" content="no-referrer"><br><img src="/python-missingno/output_6_1.png" class title="谱系图"></p>
<ul>
<li><code>NUMBER OF CYCLISTS INJURED</code>,<code>NUMBER OF CYCLISTS SKILLED</code>,<code>CONTRIBUTING FACTOR VEHICLE 1</code>,<code>NUMBER OF PEDESTRIANS SKILLED</code>,<code>NUMBER OF PEDESTRIANS INJURED</code>,<code>NUMBER OF PERSONS KILLED</code>等数据完整，没有缺失值，他们的距离为零，聚为一类。</li>
<li><code>BOROUGH</code>,<code>ZIP CODE</code>缺失相关性为1（同时缺失），距离为零；且缺失数据最少（除完整数据外），所以在完整数据后聚为一类。</li>
<li>……</li>
</ul>
<h2 id="heatmap"><a href="#heatmap" class="headerlink" title="heatmap()"></a>heatmap()</h2><p>热力图<br>体现一个变量的存在或不存在如何强烈影响另一个变量的存在</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">msno.heatmap(collisions)</span><br></pre></td></tr></table></figure>
<p><meta name="referrer" content="no-referrer"><br><img src="/python-missingno/output_5_1.png" class title="热力图"></p>
<p><code>ZIP CODE</code>与<code>BOROUGH</code>的缺失相关性为1，说明：只要<code>BOROUGH</code>发生了缺失，<code>ZIP CODE</code>也会缺失。</p>
<h2 id="matrix"><a href="#matrix" class="headerlink" title="matrix()"></a>matrix()</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> missingno <span class="keyword">as</span> msno</span><br><span class="line">%matplotlib inline</span><br><span class="line"></span><br><span class="line">msno.matrix(collisions.sample(<span class="number">250</span>))</span><br></pre></td></tr></table></figure>
<p><meta name="referrer" content="no-referrer"><br><img src="/python-missingno/output_1_2.png" class title="矩阵图"></p>
<p>白色的为缺失</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">null_pattern = (np.random.random(<span class="number">1000</span>).reshape((<span class="number">50</span>, <span class="number">20</span>)) &gt; <span class="number">0.5</span>).astype(bool)</span><br><span class="line">null_pattern = pd.DataFrame(null_pattern).replace(&#123;<span class="literal">False</span>: <span class="literal">None</span>&#125;)</span><br><span class="line">msno.matrix(null_pattern.set_index(pd.period_range(<span class="string">'1/1/2011'</span>, <span class="string">'2/1/2015'</span>, freq=<span class="string">'M'</span>)), freq=<span class="string">'BQ'</span>)</span><br></pre></td></tr></table></figure>
<p><meta name="referrer" content="no-referrer"><br><img src="/python-missingno/output_3_1.png" class title="矩阵图"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://github.com/ResidentMario/missingno">GitHub-missingno</a></li>
<li><a href="https://blog.csdn.net/Andy_shenzl/article/details/81633356" target="_blank" rel="noopener">缺失值可视化处理—missingno</a></li>
</ul>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>数据分析 | ABtest</title>
    <url>/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90-ABtest.html</url>
    <content><![CDATA[<p><center></center><br><a id="more"></a></p>
<h1 id="双盲测试"><a href="#双盲测试" class="headerlink" title="双盲测试"></a>双盲测试</h1><p>将病人随机分为两组，病人在不知情的情况下分别服用安慰剂和测试用药，经过一段时间的实验后，比较两组病人的表现是否具有显著差异，以确定测试用药是否具有疗效。</p>
<h1 id="ABtest"><a href="#ABtest" class="headerlink" title="ABtest"></a>ABtest</h1><p>AB测试</p>
<p>将Web或App界面或流程的两个或多个版本，在同一时间维度，分别让两个或多个属性或组成成分相同（相似）的访客群组访问，收集各群组的用户体验数据和业务数据，最后分析评估出最好版本正式采用。</p>
<p>一个简单的AB测试系统：<br>用户进入网站后，流量分配自同决定用户是否需要被进行AB测试，如果需要，流量分配系统会给用户打上在测试中属于什么分组的标签；然后用户浏览网页；用户在浏览网页时的行为都会被通过日志系统发回后台的日志数据库。</p>
<p>实验人员的工作：</p>
<ol>
<li>配置流量分配系统，决定满足什么条件的用户参加什么样的测试</li>
<li>需要统计日志数据库中的数据，通过测评系统生成不同分组用户的实验报告，并比较和评测实验结果</li>
</ol>
<h2 id="测试要点"><a href="#测试要点" class="headerlink" title="测试要点"></a>测试要点</h2><ul>
<li>两个关键<ol>
<li>同一时间维度</li>
<li>成分相同（相似）的访客群组</li>
</ol>
</li>
<li>一个任务<ul>
<li>收集各群组的用户体验数据和业务数据</li>
</ul>
</li>
<li>一个目标<ul>
<li>分析评估出最好版本正式采用</li>
</ul>
</li>
</ul>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>ABtest的主要应用场景有两个：</p>
<ol>
<li>界面设计<ul>
<li>调整界面颜色</li>
<li>调整按钮颜色</li>
<li>调整界面外观</li>
<li>……</li>
</ul>
</li>
<li>算法优化<br>重点针对页面中现实的元素进行优化<ul>
<li>根据推荐算法向用户推荐一些高频搜索或关注的内容</li>
<li>调整不同小版块的出现顺序或者所在位置，帮助用户在最短时间内到达自己需要的内容</li>
</ul>
</li>
</ol>
<h2 id="测试流程"><a href="#测试流程" class="headerlink" title="测试流程"></a>测试流程</h2><ol>
<li>分析实际业务场景，明确改进关键点，制定优化建议</li>
<li>与项目经历确定优化目标，设计优化方案</li>
<li>根据优化目标及方案搭建数据分析指标体系，明确数据口径</li>
<li>由UI设计师或算法工程师根据方案完成样例开发，并设定数据埋点</li>
<li>调整流量池，在同一时间内对目标用户进行测试</li>
<li>根据时间进度及时收集数据，并根据数据情况调整流量池或重新进行测试</li>
<li>经过多次试验取得成功后，确定新版本功能，正式发布</li>
</ol>
<pre class="mermaid">graph LR;
    id0(分析现状<br>推测假设) --> id1(制定目标<br>设计方案);
    id1 --> id2(搭建数据<br>指标体系);
    id2 --> id3(界面设计);
    id2 --> id4(算法优化);
    id3 --> id5(调整流量<br>实施方案);
    id4 --> id5;
    id5 --> id6(收集数据<br>计算指标);
    id6 --> id7(确定版本<br>正式发布);
    id6 --优化方案<br>重新开始--> id1;
    id6 --调整流量<br>继续测试-->id5;</pre>

<p><strong>灰度测试</strong>：调整版本对企业影响极大，设定目标中的两个版本可能都不是有效版本，故不能将所有用户直接一分为二全部进行AB测试，对此可以采用灰度发布的方式——只选择其中极小部分用户AB测试，并逐步推广到所有用户。</p>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul>
<li>AB测试需要分析参与测试用户的整体分布情况，而不仅是个别用户的情况</li>
<li>数据的有效性<ul>
<li>正常情况下，在推进AB测试时，前三天的数据波动会比较大，不建议直接使用</li>
<li>一般进行AB测试需要大约7~14天为周期进行推进</li>
<li>需要注意工作日与节假日影响的不同</li>
</ul>
</li>
<li>若AB测试开始后用户反馈反方向发展：<ul>
<li>先缩小测试用的流量池，减少测试的用户数量</li>
<li>同时分析目前的用户反馈情况，跟进反馈背后问题的真实原因，优化调整AB测试方案</li>
<li>不要着急直接停止AB测试</li>
</ul>
</li>
</ul>
<h2 id="样本量"><a href="#样本量" class="headerlink" title="样本量"></a>样本量</h2><ul>
<li><a href="https://abtestguide.com/abtestsize/" target="_blank" rel="noopener">AB测试样本量在线计算器</a></li>
<li><a href="https://www.evanmiller.org/ab-testing/sample-size.html" target="_blank" rel="noopener">Evan’s Awesome Sample Size Calculator</a></li>
</ul>
<h1 id="其他AB测试"><a href="#其他AB测试" class="headerlink" title="其他AB测试"></a>其他AB测试</h1><h2 id="ABN-test"><a href="#ABN-test" class="headerlink" title="ABN test"></a>ABN test</h2><h2 id="ANB-test"><a href="#ANB-test" class="headerlink" title="ANB test"></a>ANB test</h2><h1 id="多维测试"><a href="#多维测试" class="headerlink" title="多维测试"></a>多维测试</h1><p>正常情况下，完成一个AB测试的整个周期为15天~1个月，这样一年内能完成的测试数目较为有限，为了保证高速迭代，可以在多个维度内同时推进AB测试</p>
<ul>
<li>一定要保证任意两个维度互不影响</li>
</ul>
<h1 id="辛普森悖论"><a href="#辛普森悖论" class="headerlink" title="辛普森悖论"></a>辛普森悖论</h1><p>辛普森悖论<sup><a href="#fn_1" id="reffn_1">1</a></sup>（Simpson’s Paradox）：在某个条件下的两组数据，分别讨论时都会满足某种性质，可是一旦合并考虑，可能导致相反的结论。</p>
<blockquote id="fn_1">
<sup>1</sup>. 辛普森悖论为英国统计学家E.H.Simpson于1951年提出的悖论<a href="#reffn_1" title="Jump back to footnote [1] in the text."> &#8617;</a>
</blockquote>
<div class="note default">
            <h2 id="性别歧视问题"><a href="#性别歧视问题" class="headerlink" title="性别歧视问题"></a>性别歧视问题</h2><p>假设一所高校只有两个学院（法学院和商学院），两个学院某年的考研录取情况如下：</p><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: center;    }</style><table border="1" class="dataframe">  <thead>    <tr style="text-align: center;">      <th></th>      <th colspan="2">法学院</th>      <th colspan="2">商学院</th>    </tr>    <tr style="text-align: center;">      <th></th>      <th>男生</th>      <th>女生</th>      <th>男生</th>      <th>女生</th>    </tr>  </thead>  <tbody>    <tr>      <th>录取</th>      <td>8</td>      <td>51</td>      <td>201</td>      <td>92</td>    </tr>    <tr>      <th>未录取</th>      <td>45</td>      <td>101</td>      <td>50</td>      <td>9</td>    </tr>    <tr>      <th>录取率</th>      <td>15.09%</td>      <td>33.55%</td>      <td>80.08%</td>      <td>91.09%</td>    </tr>    <tr>  </tr></tbody></table></div><p>单独看每个学院，都是女生的录取比例高于男生。但是如果看全校的录取情况：</p><div class="table-container"><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">全校男生</th><th style="text-align:center">全校女生</th><th style="text-align:center">总人数</th></tr></thead><tbody><tr><td style="text-align:center">录取</td><td style="text-align:center">209</td><td style="text-align:center">143</td><td style="text-align:center">352</td></tr><tr><td style="text-align:center">未录取</td><td style="text-align:center">95</td><td style="text-align:center">110</td><td style="text-align:center">205</td></tr><tr><td style="text-align:center">总人数</td><td style="text-align:center">304</td><td style="text-align:center">253</td><td style="text-align:center">557</td></tr><tr><td style="text-align:center">录取率</td><td style="text-align:center">68.75%</td><td style="text-align:center">56.52%</td></tr></tbody></table></div><p>则会发现男生的录取比例高于女生。这就是辛普森悖论。</p>
          </div>
<p>误区产生的原因主要在于——将“值与量”两个维度的数据，归纳成了“值”一个维度的数据，并进行了合并。</p>
<p>我们要避免辛普森悖论带来的误区，要斟酌个别分组的权重，以一定系数去消除分组资料基树差异带来的影响。</p>
<h1 id="数据分析师的任务与职责"><a href="#数据分析师的任务与职责" class="headerlink" title="数据分析师的任务与职责"></a>数据分析师的任务与职责</h1><ol>
<li>针对业务场景，制定专题分析，明确分析目标</li>
<li>AB测试初期，分析业务场景，提出优化方向</li>
<li>与产品经理沟通设计解决方案，制定数据分析体系，明确数据口径<ul>
<li>围绕核心目标，先行制定出最重要的指标</li>
<li>指标体系需要由核心指标进行拆解，逐步到可落地实施</li>
<li>在制定指标时，需要结合实际业务场景</li>
<li>在明确指标的同时，明确取数的口径以及推算要求</li>
</ul>
</li>
<li>与测试人员明确流量分配情况，确保流量分配方式有效</li>
<li>及时收集数据，分析并对测试过程不断优化<ul>
<li>加强注意数据的收集与整理，判断收集来的数据是否完整、能否支持分析</li>
<li>对数据进行整理与分析，确定数据情况能否反映真实业务、与预期情况的匹配程度</li>
<li>通过数据结果，判断是否需要对流量分配情况进行调整，是否需要加大测试量</li>
<li>如果有一段时间的数据情况并不理想，找出真实原因并进行方案调整</li>
<li>注意收集测试期间用户的反馈，为下一次测试提前做好准备</li>
</ul>
</li>
<li>跟进测试过程，了解测试用户的反馈情况，分析其他优化点</li>
<li>完成测试后，撰写专题报告，整理测试方案、测试数据、测试报告等，完成文件归档<br>需要归档的文件：<ul>
<li>测试启动会议记录</li>
<li>测试方案研讨会会议记录</li>
<li>测试实施方案及进度甘特图</li>
<li>测试目标及数据指标体系</li>
<li>测试过程数据集和数据口径</li>
<li>测试最终总结报告</li>
<li>……</li>
</ul>
</li>
</ol>
<h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><h2 id="转化率"><a href="#转化率" class="headerlink" title="转化率"></a>转化率</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">A组</th>
<th style="text-align:center">B组</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">转化率</td>
<td style="text-align:center">$p_A$</td>
<td style="text-align:center">$p_B$</td>
</tr>
<tr>
<td style="text-align:center">用户数</td>
<td style="text-align:center">$n_A$</td>
<td style="text-align:center">$n_B$</td>
</tr>
</tbody>
</table>
</div>
<p>零假设为</p>
<script type="math/tex; mode=display">H_0:p_A\leq p_B</script><p>备择假设为</p>
<script type="math/tex; mode=display">H_1:p_A > p_B</script><p>则AB测试的$Z$值为</p>
<script type="math/tex; mode=display">Z=\frac{p_B-p_A}{\sqrt{\frac{p_A(1-p_A)}{n_A}+\frac{p_B(1-p_B)}{n_B}}}</script><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><div class="note default">
            <p><strong>题目</strong>：项目上线要AB测试(测试CTR是否大于原来的CTR)，假设每天测试有10000人，现在我只统计里面1000人的CTR，问我要连续测试多少天，才能让得到的结论有95%的置信度？</p><p><strong>参考答案</strong>：<a href="http://24xi.org/sofasofa/forum_main_post.php?postid=1007525" target="_blank" rel="noopener">SofaSofa-AB测试样本量的问题</a><br>根据以下公式计算：</p><script type="math/tex; mode=display">n = \frac{\frac{z^2p(1-p)}{e^2}}{1+\frac{z^2p(1-p)}{Ne^2}}</script><p>其中</p><ul><li>$N$是样本总数，即10000</li><li>$z$是标准正态分布的$95\%$置信区间</li><li>$e$是边际误差，如1%</li><li>$p$是CTR，如0.05</li></ul><p>代入数值，求得$n\approx 1543&gt;1000$，则只测一天得话，数据量不够。如果连续测两天，则样本总数为20000，此时计算得到$n\approx 1672&lt;2000$。因此，测2天即可。</p>
          </div>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzUzODYwMDAzNA==&amp;mid=2247490797&amp;idx=3&amp;sn=5eeb1eeac5facb704c77c21eb1c703a6&amp;chksm=fad46be0cda3e2f6738947f9ce7dca4f60796870453d1222f51ba44cecbb321e0cbcaa881289&amp;mpshare=1&amp;scene=24&amp;srcid=&amp;sharer_sharetime=1589846450651&amp;sharer_shareid=b539221659d6ecf12200314308b58dd3&amp;key=e224f213fcbe84759f79aacb516d4bf8e8fa647879ab62d1eb6fd667e362e3ab352226749e8c5a94c9d72a3123286a45310529e7ab57c50dbece5f0296aa536ff328b1637c3af7f351a13bd2c7e76b00&amp;ascene=14&amp;uin=MjAwNDUzMjgxNw%3D%3D&amp;devicetype=Windows+10+x64&amp;version=62090070&amp;lang=zh_CN&amp;exportkey=AT3GI1XwfMzd87mEXW7wlLk%3D&amp;pass_ticket=vCOnZ86B9zjbSGFnUl2pZh2C3sFfxo%2BAKXmGUdzX1teUg6KzXE86GrBP%2Fo1Z8BFC" target="_blank" rel="noopener">数据分析师必知必会：AB测试项目复盘</a></li>
<li><a href="http://20bits.com/article/speed-vs-certainty-in-ab-testing" target="_blank" rel="noopener">Speed vs. Certainty in A/B Testing</a></li>
<li><a href="http://20bits.com/article/statistical-analysis-and-ab-testing" target="_blank" rel="noopener">Statistical Analysis and A/B Testing</a></li>
<li><a href="https://signalvnoise.com/posts/3004-ab-testing-tech-note-determining-sample-size" target="_blank" rel="noopener">A/B Testing Tech Note: determining sample size</a></li>
<li><a href="https://www.evanmiller.org/how-not-to-run-an-ab-test.html" target="_blank" rel="noopener">How Not To Run an A/B Test</a></li>
<li><a href="https://www.evanmiller.org/sequential-ab-testing.html" target="_blank" rel="noopener">Simple Sequential A/B Testing</a></li>
<li><a href="http://www.woshipm.com/data-analysis/1061642.html" target="_blank" rel="noopener">数据分析必须警惕的坑：辛普森悖论</a></li>
<li><a href="http://24xi.org/sofasofa/forum_main_post.php?postid=1007525" target="_blank" rel="noopener">SofaSofa-AB测试样本量的问题</a></li>
</ul>
]]></content>
      <categories>
        <category>数据分析</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
        <tag>业务向</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>数据分析 | 波特五力模型</title>
    <url>/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90-%E6%B3%A2%E7%89%B9%E4%BA%94%E5%8A%9B%E6%A8%A1%E5%9E%8B.html</url>
    <content><![CDATA[<p><center>Michael Porter Five Forces Model</center><br><a id="more"></a></p>
<h1 id="波特五力模型"><a href="#波特五力模型" class="headerlink" title="波特五力模型"></a>波特五力模型</h1><ul>
<li>被广泛应用于很多行业得战略制定</li>
</ul>
<p>Michael Porter于20世纪80年代初提出。他认为行业中存在着决定竞争规模和程度的五种力量，这五种力量综合起来影响着产业的吸引力以及现有企业的竞争战略决策。</p>
<p>这五种力量包括：</p>
<ol>
<li>同业竞争者的竞争程度（Rivalry）</li>
<li>潜在新竞争者的进入（the threat of new entrants）</li>
<li>潜在替代品的威胁（the threat of substitute offerings）</li>
<li>供应商的议价能力（the bargaining power of suppliers）</li>
<li>购买者的议价能力（the bargaining power of buyers）</li>
</ol>
<pre class="mermaid">graph
    id1(潜在进入者) --> id0(同业竞争者)
    id2(与顾客（下游）的谈判能力) --> id0
    id3(与供方（上游）的谈判能力) --> id0
    id4(替代品威胁) --> id0</pre>

<h2 id="同业竞争者"><a href="#同业竞争者" class="headerlink" title="同业竞争者"></a>同业竞争者</h2><p>企业必须在市场、价格、质量、产量、功能、服务、研发等方面建立自己的核心竞争优势。</p>
<p>影响行业内企业竞争的因素有：</p>
<ul>
<li>产业增加</li>
<li>固定成本/附加价值周期性生产过剩</li>
<li>产品差异</li>
<li>商标专有</li>
<li>转换成本</li>
<li>售后服务</li>
<li>集中与平衡</li>
<li>信息复杂性</li>
<li>竞争者的多样性</li>
<li>退出堡垒</li>
<li>……</li>
</ul>
<p>意味着行业中现有企业之间竞争加剧的情况有：</p>
<ul>
<li>行业进入障碍较低，势均力敌竞争对手较多，竞争参与者范围广泛</li>
<li>市场趋于成熟，产品需求增长缓慢</li>
<li>竞争者企图采用降价等手段促销</li>
<li>竞争者提供几乎相同的产品或服务，用户转换成本很低</li>
<li>退出障碍较高（退出竞争比继续参与竞争的代价更高）。退出障碍具体包括：<ul>
<li>资产的专用性</li>
<li>退出的固定费用</li>
<li>战略上的互相牵制</li>
<li>情绪上的难以接受</li>
<li>政府和社会的限制</li>
<li>……</li>
</ul>
</li>
</ul>
<h2 id="新进入者的威胁"><a href="#新进入者的威胁" class="headerlink" title="新进入者的威胁"></a>新进入者的威胁</h2><p>影响潜在新竞争者进入的因素有：</p>
<ul>
<li>经济规模</li>
<li>专卖产品的差别</li>
<li>商标转悠</li>
<li>资本需求</li>
<li>分销渠道</li>
<li>绝对成本优势</li>
<li>政府政策</li>
<li>行业内企业的预期反击</li>
<li>……</li>
</ul>
<h2 id="替代品的威胁"><a href="#替代品的威胁" class="headerlink" title="替代品的威胁"></a>替代品的威胁</h2><p>决定替代品威胁程度的因素：</p>
<ul>
<li>替代品的相对价格表现</li>
<li>转换成本</li>
<li>客户对替代品的使用倾向</li>
</ul>
<h2 id="供应商的议价能力"><a href="#供应商的议价能力" class="headerlink" title="供应商的议价能力"></a>供应商的议价能力</h2><p>决定供应商议价能力的因素有：</p>
<ul>
<li>投入的差异</li>
<li>产品中供方和企业的转换成本</li>
<li>替代品投入的现状</li>
<li>供方的集中程度</li>
<li>批量大小对供方的重要性</li>
<li>与产业总购买量的相关成本</li>
<li>投入对成本和特色的影响</li>
<li>产业中企业前向整合相对于后向整合的威胁</li>
<li>……</li>
</ul>
<h2 id="购买者的议价能力"><a href="#购买者的议价能力" class="headerlink" title="购买者的议价能力"></a>购买者的议价能力</h2><p>购买者主要通过压价与要求提供较高的产品或服务质量的能力，来影响行业中现有企业的盈利能力。</p>
<p>购买者议价能力主要取决于：</p>
<ul>
<li>购买者的集中程度或业务量的大小</li>
<li>产品差异化程度与资产专用性程度</li>
<li>纵向一体化（后向整合能力）<ul>
<li>如果购买者实行了部分一体化或后向一体化的现实威胁，则在议价中购买者处于有利地位</li>
</ul>
</li>
<li>购买者转换成本相对企业转换成本</li>
</ul>
<p>一般来说，满足以下条件的购买者可能具有较强的议价能力：</p>
<ul>
<li>购买者的总数较少，且每个购买者的购买量较大</li>
<li>卖方行业由大量的规模相对较小的企业组成</li>
<li>购买者所购买的主要是标准化产品，同时向多个供应商购买产品在经济上完全可行</li>
<li>购买者有能力实现后向一体化，而供应商不可能前向一体化</li>
</ul>
<blockquote>
<ul>
<li><a href="https://baike.baidu.com/item/%E5%89%8D%E5%90%91%E4%B8%80%E4%BD%93%E5%8C%96/3216356?fr=aladdin" target="_blank" rel="noopener">前向一体化</a>就是企业沿产业链向下游的用户方向扩展，即企业在被动接受用户委托进行快件传递的现有业务经营的基础上，向服务的应用层拓展，通过收购、自建、联合等方式进军网络购物市场，或与业有显著关联效应的出口导向型经贸企业和相关组织单位开展合作，根据市场需求，主动设计并向客户提供定制化、个性化的业务与延伸服务，以提高企业业务量并增加业务收入。实施前向一体化的一种有效方式是特许经营（franchising ）。</li>
</ul>
</blockquote>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://baike.baidu.com/item/%E6%B3%A2%E7%89%B9%E4%BA%94%E5%8A%9B%E6%A8%A1%E5%9E%8B/9495965?fromtitle=%E6%B3%A2%E7%89%B9%E4%BA%94%E5%8A%9B&amp;fromid=10805232&amp;fr=aladdin" target="_blank" rel="noopener">百度百科-波特五力模型</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/134238096" target="_blank" rel="noopener">如何进行波特五力分析？</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU5Mjg2OTQ1MA==&amp;mid=2247485604&amp;idx=1&amp;sn=6132243e552196c5357f7be5661a2fbc&amp;chksm=fe186981c96fe097090839cac38109670803301d3af2e6cb7e3aa1fb4dbe3643f5cdd1fc7a74&amp;mpshare=1&amp;scene=24&amp;srcid=&amp;sharer_sharetime=1589809278889&amp;sharer_shareid=b539221659d6ecf12200314308b58dd3&amp;key=61d9a55bd4b13250d9d9b72c926e31f3c963fa7004ed53af86ab53fe1f6b5801bf460986f5969cc4d9ddf3fd098c904d6f1b8f640c0d7aca9f572945246ccea42c22b5d804b881a7955b74528f2f0865&amp;ascene=14&amp;uin=MjAwNDUzMjgxNw%3D%3D&amp;devicetype=Windows+10+x64&amp;version=62090070&amp;lang=zh_CN&amp;exportkey=AYkajeOrvqQzbnEaJ%2BpPxfA%3D&amp;pass_ticket=3hFOenbHRrI0XNiw95BJRgPjuKhLFRWJBVANkKsJrq9CYNi1R7fJlSrcHa4V3zgz" target="_blank" rel="noopener">10大经典数据分析模型，你知道几个？</a></li>
<li><a href="https://iask.sina.com.cn/b/bHe4XXEqVr1.html" target="_blank" rel="noopener">购买者部分一体化或存在后向一体化</a></li>
</ul>
]]></content>
      <categories>
        <category>数据分析</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
        <tag>业务向</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>TED | Try Something New for 30 days</title>
    <url>/TED-TrySomethingNewfor30days.html</url>
    <content><![CDATA[<p><center>Try Something New!</center><br><a id="more"></a></p>
<h1 id="初衷"><a href="#初衷" class="headerlink" title="初衷"></a>初衷</h1><p>2020年05月18日，做了个重要的决定，解决了一个困扰了我许久的问题，虽然转而需要在有限的时间里完成一个重要又艰巨的任务，但是我很欣慰自己做出的改变。</p>
<p>2020年05月18日晚上，久违地点开邮箱里的TED Recommends，听了一个TED演讲，萌生了一个念头——养成听TED演讲的习惯。</p>
<p>但我很可能又只是一时脑热，没坚持几天就又停止了。</p>
<p>于是乎，想到了一个能扩宽视野+能提高英语水平+能督促自我的方式——听写。</p>
<script type="math/tex; mode=display">听写TED</script><p>该系列就诞生啦~</p>
<p>初步设定：</p>
<ul>
<li>尽量做到每周完整听完2~3个TED视频</li>
<li>listen and write down all I recognised</li>
<li>check out with subtitles</li>
<li><del>删除线</del>删除错误的词句，<strong>粗体</strong>补充遗漏的词句</li>
</ul>
<h1 id="1st-Try-Something-New-for-30-Days"><a href="#1st-Try-Something-New-for-30-Days" class="headerlink" title="1st - Try Something New for 30 Days"></a>1st - Try Something New for 30 Days</h1><ul>
<li><a href="https://www.ted.com/talks/matt_cutts_try_something_new_for_30_days/transcript?referrer=playlist-great_ted_talks_for_language_practice" target="_blank" rel="noopener">Try Something New for 30 Days</a></li>
<li>2020.05.19</li>
</ul>
<p>A few years ago, I <del>thought</del> <strong>felt</strong> that I was stuck <del>and rot</del> <strong>in a rut</strong>, so I decided to follow <del>some steps</del> <strong>in the footsteps of the great</strong> <del>Great an</del>  Ameriacan <del>fellow</del> <strong>philosopher, Morgan Spurlock, and</strong> try something new for 30 days. The idea is actually pretty simple. Think about something <del>you</del> <strong>you’ve</strong> always <del>want</del> <strong>wanted</strong> to <strong>add to</strong> your life and try <strong>it</strong> for the next 30 days. It turns out, 30 day is just about <strong>the right amount of time</strong> to add <del>your</del> <strong>a new</strong> habit or substract <del>your</del> <strong>a</strong> habit <strong>—</strong> like watching the news <strong>—</strong> from your life.</p>
<p>There is <strong>a</strong> few thing<strong>s</strong> that I learned <strong>while doing thest</strong> <del>from</del> 30-day challenges. <strong>The first</strong> <del>First</del> was, instead <strong>of the months</strong> <del>month</del> flying by<strong>,</strong> forgotten, the time <del>is</del> <strong>was</strong> much more <del>mememble</del><strong>memorable</strong>. This <strong>was</strong> part of <strong>a</strong> challenge I <strong>did to</strong> take pictures every day for a month<del>,</del><strong>.</strong> and I remember exactly where I was and what was I doing that day. I also notice<strong>d</strong><del>,</del> that <strong>as</strong> I <strong>started to do</strong> more and harder 30 <strong>-</strong>day challenges, my self-confidence grew. I went <strong>rom desk-dwelling</strong> <del>to dual desk</del> computer <del>room too,</del> <strong>nerd to</strong> the kind <strong>of guy who</strong> bike<strong>s</strong> to work for fun.</p>
<p>Even last year, I<del>‘d piking mountain</del> <strong>ended up hikiing up Mt.Kilianjaro,</strong> the highest mountain in Africa. I would never have been that adventure<strong>s</strong> before <strong>I started</strong> my 30 <strong>-</strong>day challenges.<br>I also figure<strong>ed</strong> out that if you really want something <del>mad</del> <strong>badly</strong> enough, you can do anything for 30 days. <del>If</del> <strong>Have</strong> you <strong>ever</strong> want<strong>ed</strong> to write a novel<del>,</del><strong>?</strong> every November <strong>,</strong> tens of thousands of people try to write <strong>their own</strong> <del>a</del> 50,000 <strong>-</strong> word novel <strong>,</strong> from <del>Scritch</del> <strong>scratch,</strong> in 30 days. It turns out, all you have to do is write <del>1,600 and 60 more</del> <strong>1,667 words</strong> a day for a month. So I did, by the way, the secret is not to go to sleep until you <strong>‘ve</strong> written your <del>work</del> <strong>words for the</strong> <del>this</del> day. You might be <del>sleepy bread</del> <strong>sleep-deprived</strong>, but you<strong>‘ll</strong> finish<del>ed a</del> <strong>your</strong> novel.</p>
<p>Now, it’s my book the next great American novel? Nooooo, I wrote it in a month, it’s awful.<br>But, for the rest of my life, if I meet John <strong>Hodgman</strong> <del>in a tech</del> <strong>at a TED</strong> party, I don’t have to say &lsquo;I’am a computer scientist’, no, no, if I want to, I can say, ‘I’am a novelist’.</p>
<p>So here is one last thing I’d like to mention. I learned <strong>that</strong> when I <del>make</del> <strong>made</strong> small sustainable changes, things I <del>can</del> <strong>could</strong> keep doing, they <del>would</del> <strong>were</strong> more likely <del>sticked</del> <strong>to stick</strong>. There is nothing wrong with <strong>big,</strong> crazy challenges <strong>.In</strong> <del>and</del> fact, they are <strong>a ton of fun.</strong><del>,</del> but they <strong>‘re less</strong> likely to stick<del>ed</del>. When I <del>give</del> <strong>gave</strong> up sugar for 30 days, <del>then</del> <strong>day</strong> 31 <del>looks</del> <strong>looked</strong> like this (picture).</p>
<p>So here is my question to you, what are you waiting for? I gurantee to you the next 30 days are going to pass <del>when you and I get</del> <strong>whether you like it or</strong> not. So why not think about something you have always want<strong>ed</strong> to try and <del>get to finish it</del> <strong>give it a shot</strong> for the next 30 days.<br>Thanks.</p>
<h1 id="2nd-Lies-damned-lies-and-statistics"><a href="#2nd-Lies-damned-lies-and-statistics" class="headerlink" title="2nd - Lies, damned lies and statistics"></a>2nd - Lies, damned lies and statistics</h1><ul>
<li><a href="https://www.ted.com/talks/sebastian_wernicke_lies_damned_lies_and_statistics_about_tedtalks" target="_blank" rel="noopener">Lies, damned lies and statistics</a></li>
<li>2020.05.19</li>
</ul>
<p>If you go on the TED website, you can currently find there over a full week of TED talk videos, over 1.3 million words of transcript<strong>s</strong> and millions of <strong>user</strong> ratings. And that<strong>‘s</strong> <del>was</del> huge <del>managed</del> <strong>amount of</strong> data and <strong>it</strong> got me wondering, if <strong>you</strong> took all <del>these</del> <strong>this</strong> data and put it through <del>the</del> statistical analysis, could you reverse engineer a TED talk, could you create the <strong>ultimate</strong> TED talk, and also, could you create the <del>worse</del> <strong>worst</strong> possible TED talk that <del>I</del> <strong>they would still let</strong> <del>get</del> you <strong>get</strong> away with.</p>
<p>To find this out, I looked at three things. I looked at the topic, that <del>it</del> <strong>you</strong> should <del>truth</del> <strong>choose, I looked at</strong> how <del>it</del> <strong>you</strong> should <del>deliberately</del> <strong>deliver it and the visuals onstage</strong> <del>the videos on stage</del>. Now, with <del>a</del> <strong>the</strong> topic <strong>: there is a</strong> <del>at the</del> whole range of the topics you can choose, but you should choose wisely, because <del>if</del> your topic strongly <del>correlated</del> <strong>correlates</strong> with how users <strong>will</strong> react~ed~ to <del>the</del> <strong>your</strong> talk. Now, to make this more <del>concreat</del> <strong>concrete</strong>, let’s look at the list of top 10 words that statistically stick<del>ed</del> out <del>and</del> <strong>in the</strong> most favorite TED talks and <strong>in</strong> the least favorite TED talks. So if you came here to talk about how French coffee <strong>will</strong> spread<del>s</del> happiness in <del>your</del> <strong>our</strong> brain<strong>s</strong>, that’s a <del>goal</del> <strong>go</strong>! Whereas, if you want<strong>ed</strong> to talk about your project involving oxygen, girls, aircraft, <del>and ~~ actually I ~~will</del> <strong>would like to</strong> hear that talk, but statistics say<del>s</del> it is not <strong>so</strong> good.</p>
<p>If you <del>generalise</del> <strong>generalize</strong> this<strong>,</strong> the most favorite TED talks <strong>those</strong> that feature topic<strong>s</strong> can <strong>conn</strong>net with<strong>,</strong> both easily and deeply, such as<del>,</del> happiness,our own body, food and emotions, and the more technical topics such as architecture, materials and strange<strong>ly</strong> enough, men <strong>, those</strong> are not good topics to talk about.</p>
<p>How should you <del>deliberate</del> <strong>deliver</strong> your talk<strong>?</strong> <del>and</del> TED <del>it</del> is famous for keeping a very <del>short</del> <strong>sharp</strong> eye on the clock, so there’re going to hate me for revealing this, because actually you should talk as long as they <del>would</del> <strong>let</strong> let you, because the most favorite TED talks are on average <del>are</del> <strong>over</strong> <del>15%</del> <strong>50 percent</strong> longer than the least favorite ones. And <del>it is</del> <strong>this holds</strong> true for all ranking <strong>lists</strong> on TED <strong>.com</strong> <del>talks come</del> except if you want to have a talk that is beautiful, inspiring <del>and</del> <strong>or</strong> funny then you should <strong>be brief</strong> <del>breath</del>, <del>and after</del> <strong>But other than</strong> that, talk<del>s</del> until they drag you off <del>this</del> <strong>the</strong> stage.</p>
<ul>
<li>TO BE CONTINUE.</li>
</ul>
<h1 id="3rd-What-is-depression"><a href="#3rd-What-is-depression" class="headerlink" title="3rd - What is depression?"></a>3rd - What is depression?</h1><ul>
<li><a href="https://www.ted.com/talks/helen_m_farrell_what_is_depression/up-next#t-3329" target="_blank" rel="noopener">What is depression?</a></li>
<li>2020.05.21</li>
<li>暑期实习终破0 offer，学习动力更加高涨！加油啊！</li>
</ul>
<p>Depression is the leading cause of disability in the world. In the United States, <del>cause</del> <strong>close</strong> 10 percent of <del>dogs</del> <strong>adults</strong> struggl<del>ed</del> with depression. But <del>the of</del> <strong>because it’s a</strong> mental illness <strong>,</strong> it can be <del>lard</del> <strong>a lot harder</strong> to understand <strong>than</strong>,<del>and said</del> <strong>say</strong>, <strong>high cholesterol</strong>(胆固醇).</p>
<p>One major <del>sauce</del> <strong>source</strong> of confusion is the difference between having depression and just feeling depressed. Almost everyone feels down from time to time<del>,</del> <strong>G</strong>etting a bad grade, losing a job, having an argument, even the rainy day can bring on feeling of sadness. Sometimes there was not trigger at all, it just <del>pass about</del> <strong>pops up out of the</strong> blue, then <del>circustance</del> <strong>circumstances</strong> change<del>d</del>, <strong>and</strong> those sad feeling<strong>s</strong> disappeared.</p>
<p>Clinical depression is different, it is medical disorder, and it won’t go away just because you want it to. It <del>rankered to</del> <strong>lingers for at least</strong> two <del>and</del> <strong>consecutive</strong> weeks and significantly <del>enters</del> <strong>interferes with one’s</strong> <del>your feels with</del> ability to work, play or love.</p>
<p>Depression can have a lot of different symptoms, <del>alone</del> <strong>a low</strong> mood, <del>lots</del> <strong>loss</strong> of interest<del>ing</del> <strong>in</strong> things you<strong>‘d normally</strong> <del>no more</del> enjoy, changes in appetite, feeling worthless or <strong>excessively</strong> guilty, sleeping <del>at</del> <strong>either</strong> too much or too little, poor concentration, rest<strong>less</strong>ness or slowness, loss of energy, or recurrent thoughts of suicide. If you have at least 5 of those symptoms, according to <strong>psychiatric</strong>（精神病学的） guideline<strong>s</strong>, you <del>qualified</del> <strong>qualify</strong> for a diagnose of depression. </p>
<p>And it<strong>‘s not</strong> just <del>not behaviored your</del> <strong>behavioral</strong> symptoms, depression has physical manifestation<strong>s</strong> inside the brain. First of all, <del>they wolud</del> <strong>there are</strong> change<strong>s</strong> <del>as they would</del> <strong>that could</strong> be seen <del>in</del> <strong>with</strong> the naked eyes in X.Ray vision<strong>.</strong> <del>,</del> <strong>There include</strong> small<strong>er</strong> frontal lobe<strong>s</strong>（耳垂；脑叶） and <del>hippocampus</del> <strong>hippocampal</strong>（海马趾的） <del>volumn</del> <strong>volumes</strong>. On a more microscale, depression is <strong>associated</strong> with <strong>a</strong> few things, the abnormal <del>transmition</del> <strong>transmission</strong> or <strong>depletion（消耗;用尽） of certain neurotransmitters（神经传递素）,</strong> especially serotonin（血清素）, norepinephrine（降肾上腺素,去甲肾上腺素） and dopamine（多巴胺） <strong>, blunted（钝的，不锋利的；生硬的） circadian（昼夜节奏的） rhythms,</strong> or <del>speficity</del> <strong>specific</strong> changes in the <strong>REM</strong> and slow<strong>-wave</strong> <del>ways</del> parts <strong>of your</strong> sleep cycle and <del>homo</del> <strong>hormone abnormalities,</strong>  such as high <strong>crotisol</strong> and deregulation of <strong>thyroid hormones</strong>（甲状腺激素）.</p>
<p>But neuralscientist<strong>s still don’t</strong> have a complete <strong>picture</strong> of <strong>what</strong> causes <del>of</del> depression, it seems to have to do with a complex interaction between genes and environment. But we don’t have a <del>diagnose</del> <strong>diagnostic</strong> tool that can accurately predict where or when it <del>would</del> <strong>will</strong> show up.</p>
<p>And because <del>of</del> depression symptoms are <strong>intangible</strong>（难以捉摸的, 难以理解的, 无法确定的）, it is hard to know who might look<del>ed</del> fine but actually struggling. According to the <strong>National Institute of Mental Health</strong> <del>into health</del>, it takes <strong>the</strong> average <del>per</del> person suffering with <strong>a</strong> mental illness over 10 years to ask for help. But there are very effective teatments, medication<strong>s</strong> and therapy<del>,</del> <strong>complement</strong> each other<del>, the</del> <strong>to</strong> boost <del>bring</del> <strong>chemicals</strong> . In <strong>extreme</strong> cases, <del>electrical</del> <strong>electroconvulsive</strong>（电惊厥的,电休克的） therapy<strong>,</strong> which is like <strong>a</strong> control<strong>ed</strong> <del>and bring</del> <strong>seizure（夺取；捕获；没收） in the patient’s brain</strong> , it is also very helpful. Other pro<strong>missing</strong> treatments, like transcranial magnetic stimulation（经颅磁刺激）, are being investigated <strong>,</strong> too.</p>
<p>So if you know someone struggling with depression, encourage them, <strong>gently</strong> <del>Ja</del>, to seek out <strong>some of these</strong> <del>this</del> options, you might <del>be</del> <strong>even</strong> offer<del>ed</del> to help with <strong>specific</strong> task, like looking up <del>therapy</del> <strong>therapists</strong> in the area, or making a list of questions to ask a doctor. To someone with depression, <del>this</del> <strong>these</strong> first step<strong>s</strong> <del>to</del> <strong>can seem insurmountable（不可逾越的）.</strong><del>,</del> <strong>I</strong>f they feel guilty or ashamed, point out <del>the</del> <strong>that</strong> depression is a medical condition, just like <del>asoma</del> <strong>asthma</strong> or <del>that</del> <strong>diabetes.</strong> <del>,</del> <strong>It’s not a</strong> weakness or a person<strong>ality trait,</strong> and they should<strong>n’t</strong> <del>explain</del> <strong>expect</strong> themsleves to just get over <del>them</del> <strong>it</strong> <del>, any themselves</del> <strong>anymore than they could will themselves</strong> to get over a broken arm. If you <del>have to express</del> <strong>haven’t experienced</strong> depression <del>to</del> yourself, avoid <del>to</del> comparing <strong>it to times</strong> <del>your</del> <strong>you’ve felt</strong> <del>feel</del> down, comparing what they<strong>‘re</strong> <del>expressing</del> <strong>experiencing</strong> to normal<strong>,</strong> temporary feelings of sadness can make them feel guilty <strong>f</strong>or struggling. Even just talking about depression openly can help. For example, research<del>er</del> <strong>shows</strong> <del>said they asked</del> <strong>that asking</strong> someone about <del>suicide</del> <strong>suicidal thoughts</strong> <del>or faults</del> actually reduce<strong>s</strong> their suicide risk. Open conversation<strong>s</strong> about mental illness help <strong>erode stigma</strong> <del>you</del> and make it easier for people to ask for help, and the more patient<strong>s seek treatment</strong> <del>to desecret them then</del> <strong>the</strong> more scientists <del>would</del> <strong>will</strong> learn<del>ed</del> about depression, and the better treatments <del>would</del> <strong>will</strong> get.</p>
]]></content>
      <categories>
        <category>Everything</category>
      </categories>
      <tags>
        <tag>TED</tag>
        <tag>English</tag>
      </tags>
  </entry>
  <entry>
    <title>Machine Learning | 神经网络</title>
    <url>/%E7%AE%97%E6%B3%95-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C.html</url>
    <content><![CDATA[<p><center>Neural Network</center><br><a id="more"></a></p>
<p>NN<br>神经网络</p>
<h1 id="神经网络"><a href="#神经网络" class="headerlink" title="神经网络"></a>神经网络</h1><p><meta name="referrer" content="no-referrer"><br><img src="/%E7%AE%97%E6%B3%95-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/neural-network.png" class title="简单神经网络"></p>
<p>上图的每个圆圈都是一个神经元，每条线表示神经元之间的连接。</p>
<h2 id="激活函数"><a href="#激活函数" class="headerlink" title="激活函数"></a>激活函数</h2><p>神经网络的激活函数</p>
<h3 id="sigmoid"><a href="#sigmoid" class="headerlink" title="sigmoid"></a>sigmoid</h3><ul>
<li>取值范围：$(0,1)$<script type="math/tex; mode=display">sigmoid(x)=\frac{1}{1+e^{-x}}</script></li>
</ul>
<h3 id="tanh"><a href="#tanh" class="headerlink" title="tanh"></a>tanh</h3><ul>
<li>取值范围：$(-1,1)$<script type="math/tex; mode=display">\tanh(x)=\frac{\sinh{x}}{\cosh{x}}=\frac{e^x-e^{-x}}{e^x+e^{-x}}=\frac{1+e^{-2x}}{1-e^{-2x}}</script></li>
</ul>
<h3 id="relu"><a href="#relu" class="headerlink" title="relu"></a>relu</h3><ul>
<li>线性整流函数（Rectified Linear Unit, <strong>ReLU</strong>）</li>
<li>取值范围：$(0,+\infty)$<script type="math/tex; mode=display">f(x)=\max{(0,x)}</script>在神经网络中为<script type="math/tex; mode=display">f(x)=\max{(0, w^Tx+b)}</script></li>
</ul>
<h1 id="BP神经网络"><a href="#BP神经网络" class="headerlink" title="BP神经网络"></a>BP神经网络</h1><p>反向传播神经网络（Back Propagation Neural Network）</p>
<ul>
<li>David Rumelhart和J.McClelland于1985年提出</li>
<li>有监督学习</li>
</ul>
<p>BP神经网络分为2个过程：</p>
<ol>
<li>工作信号正向传递子过程</li>
<li>误差信号反向传递子过程</li>
</ol>
<blockquote>
<p>1989年Robert Hecht-Nielsen证明<strong>万能逼近定理</strong>：对于任何闭区间内的一个连续函数，都可以用一个隐含层的BP网络来逼近</p>
</blockquote>
<ul>
<li>一个三层的BP网络就可以完成任意的$m$维到$n$维的映射；这三层分别是：输入层（Input Layer）、隐含层（Hidden Layer）、输出层（Output Layer）</li>
</ul>
<p><meta name="referrer" content="no-referrer"><br><img src="/%E7%AE%97%E6%B3%95-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/neural-network.png" class title="简单神经网络"></p>
<ul>
<li><p>在BP神经网络中，单个样本有$m$个输入，有$n$个输出，在输入层（Input Layer）和输出层（Output Layer）之间通常还有若干个隐含层（Hidden Layer）</p>
<ul>
<li>输入层和输出层的节点个数都是确定的，而隐含层节点个数不确定</li>
</ul>
</li>
<li><p>BP神经网络在训练数据时，可以采用<strong>增量学习</strong>或<strong>批量学习</strong></p>
<ul>
<li>增量学习要求输入模式要有足够的随机性，对输入模式的噪声比较敏感；对于剧烈变化的输入模式，训练效果比较差；适合在线处理</li>
<li>批量学习不存在输入模式次序问题，稳定性好，但是只适合离线处理</li>
</ul>
</li>
<li>通常，BP神经网络在训练之前会对数据进行归一化处理，将数据映射到更小的区间内，比如$[0,1]$或$[-1,1]$</li>
</ul>
<h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><h3 id="正向传递子过程"><a href="#正向传递子过程" class="headerlink" title="正向传递子过程"></a>正向传递子过程</h3><p>假设节点$i$和节点$j$之间的权值（adjusting weight）为$w_{ij}$，节点$j$的阈值（deviation）为$b_j$，每个节点的输出值为$x_j$；每个节点的输出值是根据上层所有节点的输出值、当前节点与上层所有节点的权值、当前节点的阈值、激活函数来实现的，计算方式如下：<br>\begin{equation}<br>\begin{aligned}<br>S_j &amp;= \sum_{i=0}^{m-1}w_{ij}x_i+b_j\\<br>x_j &amp;= f(S_j)<br>\end{aligned}<br>\end{equation}</p>
<p>其中，$f(\cdot)$是激活函数，一般选择Sigmoid函数或线性函数。</p>
<ul>
<li>在BP神经网络中，输入层节点没有阈值</li>
</ul>
<h3 id="反向传递子过程"><a href="#反向传递子过程" class="headerlink" title="反向传递子过程"></a>反向传递子过程</h3><ul>
<li>误差信号反向传播子过程是基于Widrow-Hoff学习规则的</li>
<li>BP神经网络的主要目的是：反复修正权值和阈值，使得误差函数达到最小</li>
</ul>
<p>假设输出层的结果为$d_j$，误差函数为</p>
<script type="math/tex; mode=display">E(w,b)=\frac{1}{2}\sum_{j=0}^{n-1}(d_j-y_j)^2</script><p>Widrow-Hoff学习规则是通过沿着相对误差平方和的最速下降方向，连续调整网络的权值和阈值。根据梯度下降法，权值矢量的修正正比于当前位置上$E(w,b)$的梯度，对于第$j$个输出节点有</p>
<script type="math/tex; mode=display">\Delta w(i,j)=-\eta\frac{\partial{E(w,b)}}{\partial{w(i,j)}}</script><p>如果选择Sigmoid函数作为激活函数</p>
<script type="math/tex; mode=display">f(x)=\frac{A}{1+e^{-\frac{x}{B}}}</script><p>则有<br>\begin{aligned}<br>f^\prime(x) &amp;= \frac{Ae^{-\frac{x}{B}}}{B(1+e^{-\frac{x}{B}})^2}\\<br>&amp;= \frac{1}{AB}\cdot \frac{A}{1+e^{-\frac{x}{B}}}\cdot\left(A-\frac{A}{1+e^{-\frac{x}{B}}}\right)\\<br>&amp;= \frac{f(x)\left[A-f(x) \right]}{AB}<br>\end{aligned}</p>
<p>对于$w_{ij}$有<br>\begin{aligned}<br>\frac{\partial{E(w,b)}}{\partial{w_{ij}}} &amp;= \frac{1}{\partial{w_{ij}}}\cdot\frac{1}{2}\sum_{j=0}^{n-1}(d_j-y_j)^2\\<br>&amp;= (d_j-y_j)\cdot\frac{\partial{d_j}}{\partial{w_{ij}}}\\<br>&amp;= (d_j-y_j)\cdot f^\prime(S_j)\cdot\frac{\partial{S_j}}{\partial{w_{ij}}}\\<br>&amp;= (d_j-y_j)\cdot \frac{f(S_j)\left[A-f(S_j) \right]}{AB}\cdot \frac{\partial{S_j}}{\partial{w_{ij}}}\\<br>&amp;= (d_j-y_j)\cdot \frac{f(S_j)\left[A-f(S_j) \right]}{AB}\cdot x_i\\<br>&amp;= \delta_{ij}\cdot x_i<br>\end{aligned}<br>其中</p>
<script type="math/tex; mode=display">\delta_{ij}=(d_j-y_j)\cdot \frac{f(S_j)\left[A-f(S_j) \right]}{AB}</script><p>对$b_j$有</p>
<script type="math/tex; mode=display">\frac{\partial{E(w,b)}}{\partial{b_j}}=\delta_{ij}</script><p>此即$\delta$<strong>学习规则</strong>，或称<strong>Widrow-Hoff学习规则</strong>或<strong>纠错学习规则</strong>（通过改变神经元之间的连接权值来减少系统实际输出和期望输出的误差）。</p>
<p>以上是通过对隐含层和输出层之间的权值、输出层的阈值计算调整量</p>
<ul>
<li>隐含层和输出层之间的权值调整：<script type="math/tex; mode=display">w_{ij} = w_{ij} - \eta_1\cdot \frac{\partial{E(w,b)}}{\partial{w_{ij}}} = w_{ij} - \eta_1\cdot \delta_{ij}\cdot x_i</script></li>
<li>输出层的阈值调整：<script type="math/tex; mode=display">b_j = b_j - \eta_2 \cdot\frac{\partial{E(w,b)}}{\partial{b_j}} = b_j - \eta)2\cdot\delta_{ij}</script></li>
</ul>
<p>下面针对输入层和隐含层之间的权值、隐含层的阈值计算调整量。</p>
<p>假设$w_{ki}$是输入层第$k$个节点和隐含层第$i$个节点之间的权值，则有<br>\begin{aligned}<br>\frac{\partial{E(w,b)}}{\partial{w_{ki}}} &amp;= \frac{1}{\partial{w_{ki}}}\cdot\frac{1}{2}\sum_{j=0}^{n-1}(d_j-y_j)^2\\<br>&amp;= \sum_{j=0}^{n-1}(d_j-y_j)\cdot f^\prime(S_j)\cdot \frac{\partial{S_j}}{\partial{w_{ki}}}\\<br>&amp;= \sum_{j=0}^{n-1}(d_j-y_j)\cdot f^\prime(S_j)\cdot \frac{\partial{S_j}}{\partial{x_i}}\cdot \frac{\partial{x_i}}{\partial{S_i}}\cdot \frac{\partial{S_i}}{\partial{w_{ki}}}\\<br>&amp;= \sum_{j=0}^{n-1}\delta_{ij}\cdot w_{ij}\cdot \frac{f(S_i)\left[A-f(S_i) \right]}{AB}\cdot x_k\\<br>&amp;= x_k\cdot \sum_{j=0}^{n-1}\delta_{ij}\cdot w_{ij}\cdot \frac{f(S_i)\left[A-f(S_i) \right]}{AB}\\<br>&amp;= \delta_{ki}\cdot x_k<br>\end{aligned}<br>其中</p>
<script type="math/tex; mode=display">\delta_{ki}=\sum_{j=0}^{n-1}\delta_{ij}\cdot w_{ij}\cdot \frac{f(S_i)\left[A-f(S_i) \right]}{AB}</script><ul>
<li>输入层和隐含层之间的权值调整：<script type="math/tex; mode=display">w_{ki} = w_{ki} - \eta_1\cdot\frac{\partial{E(w,b)}}{\partial{w_{ki}}} = w_{ki} - \eta_1\cdot\delta_{ki}\cdot x_k</script></li>
<li>隐含层的阈值调整：<script type="math/tex; mode=display">b_i = b_i - \eta_2\cdot\frac{\partial{E(w,b)}}{\partial{b_i}} = b_i - \eta_2\cdot\delta_{ki}</script></li>
</ul>
<h2 id="隐含层的选取"><a href="#隐含层的选取" class="headerlink" title="隐含层的选取"></a>隐含层的选取</h2><p>在BP神经网络中，输入层和输出层的节点个数都是确定的，而隐含层节点个数不确定。</p>
<ul>
<li>隐含层节点个数的多少对神经网络的性能是有影响的</li>
</ul>
<p>可以使用下述经验公式确定隐含层的节点个数：</p>
<script type="math/tex; mode=display">h = \sqrt{m+n}+a</script><p>或者，使用下述经验公式确定隐含层的节点个数：</p>
<script type="math/tex; mode=display">h = \log_2{m}</script><p>其中：</p>
<ul>
<li>$h$：隐含层节点数目</li>
<li>$m$：输入层节点数目</li>
<li>$n$：输出层节点数目</li>
<li>$a$：为$1~10$之间的调节常数</li>
</ul>
<h2 id="激活函数-1"><a href="#激活函数-1" class="headerlink" title="激活函数"></a>激活函数</h2><p>激活函数（activation function / transfer function）：将神经网络的输入转换为输出</p>
<ul>
<li>BP神经网络的激活函数要求处处可导</li>
<li>BP神经网络一般用于分类或逼近问题<ul>
<li>如果用于<strong>分类</strong>，激活函数一般使用<strong>Sigmoid函数</strong>或<strong>硬极限函数</strong></li>
<li>如果用于<strong>函数逼近</strong>，则输出层节点用线性函数，即$f(x)=x$</li>
</ul>
</li>
</ul>
<p>当使用<strong>Sigmoid函数</strong>作为激活函数时，BP神经网络的输入与输出关系为：</p>
<ul>
<li>输入：<script type="math/tex; mode=display">net = z = w_1x_1+w_2x_2+\cdots+w_nx_n</script></li>
<li>输出：<script type="math/tex; mode=display">y=f(z)=\frac{1}{1+e^{-z}}</script></li>
<li><p>输出的导数：</p>
<script type="math/tex; mode=display">f^\prime(z)=\frac{1}{1+e^{-z}}-\frac{1}{(1+e^{-z})^2}=y(1-y)</script></li>
<li><p>$z$在$[-5,0]$时，导数为正，且导数的值随着$z$的增大而增大，说明：$f(z)$在逐渐变大且变大的速度越来越快</p>
</li>
<li>$z$在$[0,5]$时，导数为正，且导数的值随着$z$的增大而减小，说明：$f(z)$在逐渐变大但变大的速度越来越慢</li>
</ul>
<h2 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h2><ul>
<li>容易形成局部极小值而得不到全局最优值<ul>
<li>对初始权值和阈值有要求，要使得初始权值和阈值随机性足够好（可以多次随机来实现）</li>
</ul>
</li>
<li>训练次数多使得学习效率低，收敛速度慢</li>
<li>隐含层的选取缺乏理论的指导</li>
<li>训练时，学习新样本有遗忘旧样本的趋势</li>
</ul>
<h2 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h2><ul>
<li>增加动量项：加速算法收敛<ul>
<li>动量因子$\alpha$一般选取$[0.1,0.8]$<script type="math/tex; mode=display">w_{ij}=w_{ij}-\eta_1\cdot \delta_{ij}\cdot x_i+\alpha \Delta w_{ij}</script></li>
</ul>
</li>
<li>自适应调节学习率</li>
<li>引入陡度因子</li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="http://www.texample.net/media/tikz/examples/PDF/neural-network.pdf" target="_blank" rel="noopener">图-简单神经网络</a></li>
<li><a href="https://blog.csdn.net/acdreamers/article/details/44657439" target="_blank" rel="noopener">BP神经网络</a></li>
</ul>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>神经网络</tag>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Machine Learning | 感知器</title>
    <url>/%E7%AE%97%E6%B3%95-%E6%84%9F%E7%9F%A5%E6%9C%BA.html</url>
    <content><![CDATA[<p><center>Perceptron</center><br><a id="more"></a></p>
<p>感知机/感知器/人工神经元</p>
<h1 id="感知器"><a href="#感知器" class="headerlink" title="感知器"></a>感知器</h1><p><strong>神经元</strong>——神经网络的组成单元——也称<strong>感知机</strong>/<strong>感知器</strong>。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://www.zybuluo.com/hanbingtao/note/433855" target="_blank" rel="noopener">零基础入门深度学习(1) - 感知器</a></li>
<li><a href></a></li>
</ul>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>神经网络</tag>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Machine Learning | DBSCAN</title>
    <url>/%E7%AE%97%E6%B3%95-DBSCAN.html</url>
    <content><![CDATA[<p><center>Density-Based Spatial Clustering of Applications with Noise</center><br><a id="more"></a></p>
<p>DBSCAN<br>具有噪声的基于密度的聚类方法</p>
<h1 id="DBSCAN"><a href="#DBSCAN" class="headerlink" title="DBSCAN"></a>DBSCAN</h1><p>DBSCAN是一种基于密度的空间聚类算法。该算法将具有足够密度的区域划分为簇，并在具有噪声的空间数据库中发现任意形状的簇，将簇定义为“密度相连的点的最大集合”。</p>
<blockquote>
<p>Martin Ester等人于1996年提出。<br>原文：<a href="https://www.researchgate.net/publication/44250717_A_Density_Based_Algorithm_for_Discovering_Density_Varied_Clusters_in_Large_Spatial_Databases" target="_blank" rel="noopener">A density-based algorithm for discovering clusters in large spatial databases with noise.</a><br>（截至2020年01月9日，被引用次数已达16602次）</p>
</blockquote>
<ul>
<li>聚类的时候不需要事先指定簇的个数</li>
<li>最终的簇的个数不确定</li>
</ul>
<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><p>DBSCAN算法首先要确定两个参数：</p>
<ol>
<li>半径（Eps或epsilon）<br>在一个点周围邻近区域的半径。若两点之间的距离小于或等于该值，则这些点被认为是相邻的。如果选择的eps值太小，则很大一部分数据不会聚集，将被视为异常点；如果选择的eps太大，则群集会被合并，会造成大多数对象处于同一群集中。因此，应该根据数据集的距离来选择eps；一般，eps的取值尽量取小。</li>
<li>MinPts<br>邻近区域内至少包含点的个数。对于具有噪声的数据集，应考虑较大的MinPts；MinPts的最小值必须为3。数据集越大，对应选择的MinPts应越大。</li>
</ol>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://blog.csdn.net/huacha__/article/details/81094891" target="_blank" rel="noopener">DBSCAN聚类算法——机器学习（理论+图解+python代码）</a></li>
<li><a href="https://www.cnblogs.com/bonelee/p/8692336.html" target="_blank" rel="noopener">DBSCAN方法及应用</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU5NzkxODMxOA==&amp;mid=2247485595&amp;idx=1&amp;sn=830a5f9ac8d3e9966ae36859fbcdab0b&amp;chksm=fe4d5f9ac93ad68cae44a066ab689b9f6178618d2b2420473de316fe95c85ebb8789c5f5abb8&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">DBSCAN密度聚类</a></li>
</ul>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>机器学习</tag>
        <tag>聚类</tag>
      </tags>
  </entry>
  <entry>
    <title>Machine Learning | t-SNE</title>
    <url>/%E7%AE%97%E6%B3%95-t-SNE.html</url>
    <content><![CDATA[<p><center>t-Distributed Stochastic Neighbor Embedding</center><br><a id="more"></a></p>
<p>t-SNE<br>t分布随机邻域嵌入算法</p>
<h1 id="降维"><a href="#降维" class="headerlink" title="降维"></a>降维</h1><p>Dimensionality Reduction<br>把数据或特征的维数降低</p>
<p>一般分为2种：</p>
<ol>
<li><strong>线性降维</strong><ul>
<li>主成分分析（PCA，Principal Components Analysis）</li>
<li>线性判别分析（LDA，Linear Discriminant Analysis）</li>
<li>多维尺度变换（MDS，Classical Multidimensional Scaling）</li>
</ul>
</li>
<li><strong>非线性降维</strong><ul>
<li>等距特征映射（IsoMap，Isometric Mapping）</li>
<li>局部线性嵌入（LLE，Locally Linear Embedding）</li>
<li>拉普拉斯特征映射（LE，Laplacian Eigenmaps）</li>
<li>t-SNE</li>
</ul>
</li>
</ol>
<h1 id="t-SNE"><a href="#t-SNE" class="headerlink" title="t-SNE"></a>t-SNE</h1><ul>
<li>是一种非线性降维方法</li>
<li>但主要被用于可视化</li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="http://bindog.github.io/blog/2016/06/04/from-sne-to-tsne-to-largevis/" target="_blank" rel="noopener">从SNE到t-SNE再到LargeVis</a></li>
<li><a href="https://www.sohu.com/a/204249302_465975" target="_blank" rel="noopener">机器之心-深度 | 详解可视化利器t-SNE算法：数无形时少直觉</a></li>
<li><a href="https://www.jianshu.com/p/8c20b975a174" target="_blank" rel="noopener">t-SNE和PCA介绍</a></li>
</ul>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>机器学习</tag>
        <tag>降维</tag>
      </tags>
  </entry>
  <entry>
    <title>Machine Learning | 欠拟合</title>
    <url>/%E7%AE%97%E6%B3%95-%E6%AC%A0%E6%8B%9F%E5%90%88.html</url>
    <content><![CDATA[<p><center>Underfitting</center><br><a id="more"></a></p>
<h1 id="欠拟合"><a href="#欠拟合" class="headerlink" title="欠拟合"></a>欠拟合</h1><h2 id="如何改善欠拟合"><a href="#如何改善欠拟合" class="headerlink" title="如何改善欠拟合"></a>如何改善欠拟合</h2><ul>
<li>尝试减小正则项参数$\lambda$</li>
<li>尝试增加交叉特征</li>
<li>增加模型的复杂度<ul>
<li>线性模型：添加高次项</li>
<li>神经网络模型：增加网络层数、增加神经元个数</li>
</ul>
</li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href></a></li>
</ul>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Machine Learning | 熵</title>
    <url>/Machine-Learning-%E7%86%B5.html</url>
    <content><![CDATA[<p><center>Entropy</center><br><a id="more"></a></p>
<h1 id="信息量"><a href="#信息量" class="headerlink" title="信息量"></a>信息量</h1><p>信息量是对信息的度量；有时也叫作<strong>自信息</strong>（self-information）。</p>
<ul>
<li><p>信息的大小与随机事件发生的概率有关</p>
<ul>
<li><p>概率越小的事件发生了，产生的信息量越大</p>
<blockquote>
<p>如：处于非地震带的地方发生了地震</p>
</blockquote>
</li>
<li><p>概率越大的事件发生了，产生的信息量越小</p>
<blockquote>
<p>如太阳从东边升起</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<p>因此，事件的信息量随着其发生概率而递减，且不为负</p>
<p><strong>信息量</strong>的公式：</p>
<script type="math/tex; mode=display">I(x)=-\log{p(x)}</script><p>其中，$p(x)$为随机事件$x$发生的概率；负号保证了信息量一定不为负。</p>
<ul>
<li><strong>联合自信息量</strong><script type="math/tex; mode=display">I(x_i,y_j)=-\log{p(x_i,y_j)}</script></li>
<li><strong>条件自信息量</strong><script type="math/tex; mode=display">I(y_j|x_i)=-\log{p(y_j|x_i)}</script></li>
</ul>
<h1 id="信息熵-香农熵"><a href="#信息熵-香农熵" class="headerlink" title="信息熵/香农熵"></a>信息熵/香农熵</h1><p>Entropy</p>
<ul>
<li>熵是表示随机变量不确定性的度量</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"><strong>信息量</strong></th>
<th style="text-align:center"><strong>信息熵</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">度量一个具体事件发生了所带来的信息</td>
<td style="text-align:center">在事件发生之前对其结果可能产生的信息量求期望</td>
</tr>
<tr>
<td style="text-align:center">对事件不确定性的度量</td>
<td style="text-align:center">事件所有可能结果的自信息的期望值</td>
</tr>
</tbody>
</table>
</div>
<p><strong>信息熵</strong>的公式如下：</p>
<script type="math/tex; mode=display">H(X)=-\sum_{i=1}^np(x_i)\log{p(x_i)}</script><p>其中$p(x_i)$表示随机事件$x_i\ (i=1,\cdots,n)$的概率。</p>
<p>假设一组数据由$D=\{d_1,d_2,\cdots,d_n\}$构成，则这组数据的信息熵为</p>
<script type="math/tex; mode=display">H(D)=-\sum_{i=1}^n\frac{d_i}{S_D}\log{\frac{d_i}{S_D}}</script><p>其中，$S_D=\sum_{i=1}^nd_i$。</p>
<h2 id="对数的底"><a href="#对数的底" class="headerlink" title="对数的底"></a>对数的底</h2><p>信息熵公式中的对数的底的选择是任意的</p>
<ul>
<li>信息论中，一般选取<strong>2</strong>作为对数的底，则信息的单位为<u>比特（bits）</u></li>
<li>机器学习中，一般选取<strong>自然常数e</strong>作为对数的底，则单位为<u>奈特（nats）</u></li>
</ul>
<h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><p>信息熵的一个性质为：<br><div class="note success">
            <script type="math/tex; mode=display">0\leq H(X)\leq\log{n}</script><p>这里$n$表示事件的个数。</p><blockquote><p>即：当随机分布为均匀分布时，熵最大</p></blockquote>
          </div><br><div class="note default">
            <p>证明：使用拉格朗日乘子法<br>因为$p(x_1)+p(x_2)+\cdots+p(x_n)=1$，所以目标函数为</p><script type="math/tex; mode=display">f\left(p(x_1),\cdots,p(x_n)\right)=-\left[p(x_1)\log{p(x_1)}+p(x_2)\log{p(x_2)}+\cdots+p(x_n)\log{p(x_n)} \right]</script><p>约束条件为</p><script type="math/tex; mode=display">g\left(p(x_1),\cdots,p(x_n)\right)=p(x_1)+p(x_2)+\cdots+p(x_n)-1=0</script><p>定义拉格朗日函数：<br>\begin{aligned}<br>L(p(x_1),\cdots,p(x_n);\lambda)&amp;=-\left[p(x_1)\log{p(x_1)}+p(x_2)\log{p(x_2)}+\cdots+p(x_n)\log{p(x_n)} \right]\\<br>&amp;+\lambda\left[p(x_1)+p(x_2)+\cdots+p(x_n)-1 \right]<br>\end{aligned}<br>$L(p(x_1),\cdots,p(x_n);\lambda)$分别对$p(x_1),p(x_2),\cdots,p(x_n),\lambda$求偏导，并令偏导数为0，得到</p><script type="math/tex; mode=display">\left\{\begin{array}{l}\lambda-\log p(x_1)-1=0\\\lambda-\log p(x_2)-1=0\\\cdots\\\lambda-\log p(x_n)-1=0\\p(x_1)+p(x_2)+\cdots+p(x_n)-1=0\end{array}\right.</script><p>解上述方程组，可得</p><script type="math/tex; mode=display">p(x_1)=p(x_2)=\cdots=p(x_n)=\frac{1}{n}</script><p>所以目标函数的极大值为</p><script type="math/tex; mode=display">f\left(\frac{1}{n},\frac{1}{n},\cdots,\frac{1}{n}\right)=-\left[\frac{1}{n}\log\frac{1}{n}+\frac{1}{n}\log\frac{1}{n}+\cdots+\frac{1}{n}\log\frac{1}{n} \right]=-\log\frac{1}{n}=\log n</script><p>即：当随机分布为均匀分布时，熵最大。</p>
          </div></p>
<h1 id="联合熵-复合熵"><a href="#联合熵-复合熵" class="headerlink" title="联合熵/复合熵"></a>联合熵/复合熵</h1><p>联合熵/复合熵：度量两个随机变量$X$和$Y$在一起时的不确定性</p>
<p>假设</p>
<ul>
<li>离散情况：随机变量$(X,Y)$的联合概率分布为<script type="math/tex; mode=display">P(X=x_i,Y=y_j)=p_{ij},\ i=1,\cdots,n;\ j=1,\cdots,m</script></li>
<li>连续情况：随机变量$(X,Y)$的联合密度函数为<script type="math/tex; mode=display">f(x,y)\quad (x\in \Omega_X;\ y\in \Omega_Y)</script></li>
</ul>
<p><strong>复合熵/联合熵</strong>为</p>
<script type="math/tex; mode=display">H(X,Y)=-\sum_{i=1}^n\sum_{j=1}^mp_{ij}\log{p_{ij}}</script><script type="math/tex; mode=display">H(X,Y)=-\int_{\Omega_X}\int_{\Omega_Y}f(x,y)\log{f(x,y)}\mathrm{dx}\mathrm{dy}</script><h2 id="性质-1"><a href="#性质-1" class="headerlink" title="性质"></a>性质</h2><div class="note success">
            <p>联合熵大于独立熵的和<br>\begin{aligned}<br>  H(X,Y)&amp;\geq\max{\left[H(X),H(Y) \right]}\\<br>  H(X_1,\cdots,X_N)&amp;\geq\max{\left[H(X_1),\cdots,H(X_N) \right]}<br>\end{aligned}</p>
          </div>
<div class="note success">
            <p>联合熵小于各独立熵的和<br>\begin{aligned}<br>H(X,Y)&amp;\leq H(X)+H(Y)\\<br>H(X_1,\cdots,X_N)&amp;\leq H(X_1)+\cdots+H(X_N)<br>\end{aligned}</p>
          </div>
<h1 id="条件熵"><a href="#条件熵" class="headerlink" title="条件熵"></a>条件熵</h1><p>条件熵：代表在某一个条件$X$下，随机变量$Y$的复杂度（不确定度）</p>
<blockquote>
<p>即：在给定条件X下，Y的条件概率分布的熵关于X的数学期望</p>
</blockquote>
<p><strong>条件熵</strong>$H(Y|X)$表示在已知随机变量$X$的条件下、随机变量$Y$ 的不确定性。<br>\begin{equation}<br>\begin{aligned}<br>  H(Y|X) &amp;= \sum_{i=1}^np(x_i)H(Y|X=x_i)\\<br>&amp;= -\sum_{i=1}^np(x_i)\sum_{j=1}^mp(y_j|x_i)\log{p(y_j|x_i)}\\<br>&amp;= -\sum_{i=1}^n\sum_{j=1}^mp(x_i,y_j)\log{p(y_j|x_i)}\\<br>H(Y|X)&amp;= \int_{x\in\Omega_X}f(x)H(Y|X=x)\mathrm{dx}\\<br>&amp;= -\int_{x\in\Omega_X}f(x)\int_{y\in\Omega_Y}f(y|x)\log{f(y|x)}\mathrm{dy}\\<br>&amp;= -\int_{x\in\Omega_X}\int_{y\in\Omega_Y}f(x)f(y|x)\log{f(y|x)}\mathrm{dx}\mathrm{dy}<br>\end{aligned}<br>\end{equation}</p>
<p>当信息熵和条件熵中的概率由样本数据估计而得时，所对应的信息熵与条件熵称为<strong>经验熵</strong>（empirical entropy）和<strong>经验条件熵</strong>（empirical conditional entropy）。</p>
<h2 id="性质-2"><a href="#性质-2" class="headerlink" title="性质"></a>性质</h2><div class="note success">
            <script type="math/tex; mode=display">H(Y|X)=H(X,Y)-H(X)</script>
          </div>
<div class="note default">
            <p>证明：（仅证明离散情况）<br>\begin{equation}<br>\begin{aligned}<br>H(Y|X)&amp;= -\sum_{i=1}^n\sum_{j=1}^mp(x_i,y_j)\log{p(y_j|x_i)}\\<br>&amp;= -\sum_{i=1}^n\sum_{j=1}^mp(x_i,y_j)\log{\frac{p(x_i,y_j)}{p(x_i)}}\\<br>&amp;= -\sum_{i=1}^n\sum_{j=1}^mp(x_i,y_j)\left(\log{p(x_i,y_j)}-\log{p(x_i)}\right)\\<br>&amp;= -\sum_{i=1}^n\sum_{j=1}^m\left(p(x_i,y_j)\log{p(x_i,y_j)}-p(x_i,y_j)\log{p(x_i)}\right)\\<br>&amp;= -\sum_{i=1}^n\sum_{j=1}^mp(x_i,y_j)\log{p(x_i,y_j)}-\left(-\sum_{i=1}^n\sum_{j=1}^mp(x_i,y_j)\log{p(x_i)}\right)\\<br>&amp;= H(X,Y)-H(X)<br>\end{aligned}<br>\end{equation}<br>同理可得</p><script type="math/tex; mode=display">H(X|Y)=H(X,Y)-H(Y)</script><p>合并上述两个公式可得</p><script type="math/tex; mode=display">H(Y|X)+H(X)=H(X,Y)=H(X|Y)+H(Y)</script><p>体现了熵的对称性。</p>
          </div>
<h1 id="相对熵-KL散度"><a href="#相对熵-KL散度" class="headerlink" title="相对熵/KL散度"></a>相对熵/KL散度</h1><p><strong>相对熵</strong>，又称互熵、鉴别信息、Kullback熵、<strong>Kullback-Leible散度</strong>（KL散度），是两个概率分布间差异的非对称性度量；常常用来度量两个随机变量的“距离”。在信息论中，相对熵等价于两个概率分布的信息熵的差值。如果其中一个概率分布为真实分布，另一个为理论分布/拟合分布，则相对熵等于交叉熵与真实分布的信息熵之差，表示使用理论分布拟合真实分布时的信息损耗。</p>
<p>设$p(x)$和$q(x)$是两个概率分布，则$p$对$q$的相对熵为</p>
<script type="math/tex; mode=display">D_{KL}(p||q)=E_{p(x)}\left(\log{\frac{p(x)}{q(x)}}\right)=\sum_{i=1}^np(x_i)\log{\frac{p(x_i)}{q(x_i)}}</script><p>相对熵不具有对称性：</p>
<script type="math/tex; mode=display">D(p||q)\neq D(q||p)</script><h2 id="性质-3"><a href="#性质-3" class="headerlink" title="性质"></a>性质</h2><div class="note success">
            <p>相对熵不为负：</p><script type="math/tex; mode=display">D(p||q)\geq0,\ D(q||p)\geq0</script><p>且相对熵公式只有在$p(x_i)$等于$q(x_i)$时等于0。</p>
          </div>
<div class="note default">
            <p>证明：要证明</p><script type="math/tex; mode=display">D_{KL}(p||q)=\sum_{i=1}^n\left(p(x_i)\log{p(x_i)}-p(x_i)\log{q(x_i)}\right)\geq0</script><p>即证</p><script type="math/tex; mode=display">\sum_{i=1}^np(x_i)\log{\frac{q(x_i)}{p(x_i)}}\leq0</script><p>因为$\ln{x}\leq x-1$当且仅当$x=1$时等号成立，所以</p><script type="math/tex; mode=display">\sum_{i=1}^np(x_i)\log{\frac{q(x_i)}{p(x_i)}}\leq\sum_{i=1}^np(x_i)\left(\frac{q(x_i)}{p(x_i)}-1\right)=\sum_{i=1}^n\left(q(x_i)-p(x_i)\right)</script><p>当且仅当$p(x_i)=q(x_i)$（对所有的$i,\ i=1,2,\cdots,n$）时有</p><script type="math/tex; mode=display">\sum_{i=1}^np(x_i)\log{\frac{q(x_i)}{p(x_i)}}=\sum_{i=1}^n\left[q(x_i)-p(x_i)\right]=0</script>
          </div>
<h1 id="交叉熵"><a href="#交叉熵" class="headerlink" title="交叉熵"></a>交叉熵</h1><p>交叉熵（Cross entropy）：是一种损失函数/代价函数，用于描述模型预测值与真实值的差距大小。</p>
<p>真实概率分布$p(x)$和预测概率分布$q(x)$之间的交叉熵为</p>
<script type="math/tex; mode=display">H(p,q)=-\sum_{i=1}^np(x_i)\log{q(x_i)}</script><p>交叉熵在分类问题中，常常与softmax搭配使用，softmax将输出的结果进行处理，使多个分类类别的预测值的和为1，再使用交叉熵计算损失。</p>
<p>将KL散度公式拆开：<br>\begin{equation}<br>\begin{aligned}<br>  D_{KL}(p||q)&amp;=\sum_{i=1}^np(x_i)\log{\frac{p(x_i)}{q(x_i)}}\\<br>&amp;= \underline{\sum_{i=1}^np(x_i)\log{p(x_i)}}-\sum_{i=1}^np(x_i)\log{q(x_i)}\\<br>&amp;= \underline{-H\left(p(x)\right)}+\left[-\sum_{i=1}^np(x_i)\log{q(x_i)} \right]<br>\end{aligned}<br>\end{equation}<br>其中，$H\left(p(x)\right)$表示真实分布的信息熵，后者即为交叉熵。</p>
<script type="math/tex; mode=display">KL散度=交叉熵-信息熵</script><p>KL散度（相对熵）衡量的是真实概率分布与预测概率分布之间的差异；KL散度越小，表明预测的效果越好。在机器学习训练模型时，输入数据（Input）与标签（Label）通常已确定，那么真实概率分布$p$也已确定，信息熵$H\left(p(x)\right)$就是一个常量。因此，最小化KL散度等价于最小化交叉熵。所以，在机器学习中常常使用交叉熵作为损失函数。</p>
<h1 id="互信息"><a href="#互信息" class="headerlink" title="互信息"></a>互信息</h1><p>互信息（Mutual Information）：也是信息论中的一种信息度量，是一个随机变量中包含的关于另一个随机变量的信息量，或者说，是一个随机变量由于已知另一个随机变量而减少的不确定性。</p>
<ul>
<li>两个<strong>离散</strong>随机变量$X$和$Y$的互信息定义为<script type="math/tex; mode=display">I(X,Y)=\sum_{y\in Y}\sum_{x\in X}p(x,y)\log{\frac{p(x,y)}{p(x)p(y)}}</script>其中，$p(x,y)$是$X$和$Y$的联合概率分布函数，$p(x)$、$p(y)$分别是$X$和$Y$的边缘概率分布函数。</li>
<li><p>两个<strong>连续</strong>随机变量的互信息定义为</p>
<script type="math/tex; mode=display">I(X,Y)=\int_Y\int_Xp(x,y)\log{\frac{p(x,y)}{p(x)p(y)}}\mathrm{d}x\mathrm{d}y</script><p>其中，$p(x,y)$是$X$和$Y$的联合概率密度函数，$p(x)$、$p(y)$分别是$X$和$Y$的边缘概率密度函数。</p>
</li>
<li><p>互信息是互信息量$I(x_i,y_j)$在联合概率空间中的统计平均值。</p>
</li>
<li>（平均）互信息克服了互信息量$I(x_i,y_j)$的随机性，是一个确定的量。</li>
<li>互信息是$X$和$Y$的联合分布相对于假定$X$和$Y$独立情况下的联合分布之间的内在依赖性。</li>
<li>$I(X,Y)=0$当且仅当$X$和$Y$独立时成立。</li>
<li>当$X$和$Y$独立时，$p(x,y)=p(x)p(y)$。因此<script type="math/tex; mode=display">\log{\frac{p(x,y)}{p(x)p(y)}}=\log1=0</script></li>
</ul>
<div class="note success">
            <p>互信息和条件熵的关系为</p><script type="math/tex; mode=display">I(X,Y)=H(X)-H(Y|X)=H(Y)-H(Y|X)</script>
          </div>
<div class="note default">
            <p>证明:<br>\begin{aligned}<br>H(X)-H(X,Y) &amp;= -\sum_{x\in X}\underline{p(x)}\log{p(x)}+\sum_{x\in X}\sum_{y\in Y}p(x,y)\log{p(x|y)}\\<br>&amp;= \sum_{x\in X}\sum_{y\in Y}p(x,y)\log{p(x|y)}-\sum_{x\in X}\underline{\sum_{y\in Y}p(x,y)}\log{p(x)}\\<br>&amp;= \sum_{x\in X}\sum_{y\in Y}p(x,y)\left(\log{p(x|y)}-\log{p(x)} \right)\\<br>&amp;= \sum_{x\in X}\sum_{y\in Y}p(x,y)\log{\frac{p(x|y)}{p(x)}}\\<br>&amp;= \sum_{x\in X}\sum_{y\in Y}\log{\frac{p(x,y)}{p(x)p(y)}}\\<br>&amp;= I(X,Y)<br>\end{aligned}</p>
          </div>
<p><meta name="referrer" content="no-referrer"><br><img src="/Machine-Learning-%E7%86%B5/mi.png" class title="信息熵、联合熵、条件熵、互信息的关系"></p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://zhuanlan.zhihu.com/p/26486223" target="_blank" rel="noopener">通俗理解信息熵</a></li>
<li><a href="http://blog.sina.com.cn/s/blog_6e85bf420100ohma.html" target="_blank" rel="noopener">ID3算法</a></li>
<li><a href="https://ask.julyedu.com/question/6897" target="_blank" rel="noopener">“熵”的通俗解释</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/26551798" target="_blank" rel="noopener">通俗理解条件熵</a></li>
<li><a href="https://blog.csdn.net/xierhacker/article/details/53463567" target="_blank" rel="noopener">机器学习笔记十：各种熵总结</a></li>
<li><a href="https://blog.csdn.net/weixinhum/article/details/85064685" target="_blank" rel="noopener">相对熵（KL散度）</a></li>
<li><a href="https://blog.csdn.net/BigData_Mining/article/details/81279612" target="_blank" rel="noopener">互信息的深度理解</a></li>
<li><a href="https://blog.csdn.net/NeilGY/article/details/98216164" target="_blank" rel="noopener">机器学习中各种熵</a></li>
<li><a href="https://www.cnblogs.com/kyrieng/p/8694705.html" target="_blank" rel="noopener">详解机器学习中的熵、条件熵、相对熵和交叉熵</a></li>
<li><a href="https://www.jiqizhixin.com/graph/technologies/1786086f-5b63-4eee-b9ed-dad4d64cdc86" target="_blank" rel="noopener">交叉熵</a></li>
<li><a href="https://blog.csdn.net/b1055077005/article/details/100152102" target="_blank" rel="noopener">交叉熵损失函数原理详解</a></li>
<li><a href="https://www.zhihu.com/question/65288314/answer/244557337" target="_blank" rel="noopener">为什么交叉熵可以用于计算代价</a></li>
</ul>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>机器学习</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Machine Learning | 决策树</title>
    <url>/%E7%AE%97%E6%B3%95-DecisionTree.html</url>
    <content><![CDATA[<p><center>Decision Tree</center><br><a id="more"></a></p>
<div class="note default">
            <p>基础阅读：<br><a href="/Machine-Learning-%E7%86%B5.html" title="Machine Learning | 熵">Machine Learning | 熵</a></p>
          </div>
<h1 id="Decision-Tree"><a href="#Decision-Tree" class="headerlink" title="Decision Tree"></a>Decision Tree</h1><ul>
<li>是一种基本的<strong>分类</strong>与<strong>回归</strong>方法</li>
<li>决策树由节点和有向边组成<ul>
<li><u>内部节点</u>表示一个特征/属性</li>
<li><u>叶子节点</u>表示一个分类</li>
<li><u>有向边</u>表示一个划分规则</li>
</ul>
</li>
<li>决策树从根节点到子节点的有向边代表了一条路径(一条分类规则)<ul>
<li>决策树的路径是互斥的且是完备的<ul>
<li><strong>互斥</strong>：每一个样本不会同时匹配上两条分类规则</li>
<li><strong>完备</strong>：每一个样本都能在决策树中匹配上一条规则</li>
</ul>
</li>
</ul>
</li>
<li>决策树学习通常包括3个步骤：<ol>
<li>特征选择</li>
<li>决策树生成</li>
<li>决策树剪枝</li>
</ol>
</li>
<li>决策树表示给定特征条件下类的条件概率分布</li>
</ul>
<p>决策树的组成：</p>
<ul>
<li><strong>根节点</strong>：第一个选择点</li>
<li><strong>非叶子节点与分支</strong>：中间过程</li>
<li><strong>叶子节点</strong>：最终的决策结果</li>
</ul>
<p><meta name="referrer" content="no-referrer"><br><img src="/%E7%AE%97%E6%B3%95-DecisionTree/%E5%86%B3%E7%AD%96%E6%A0%91.jpg" class title="决策树"></p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><h2 id="特征选择"><a href="#特征选择" class="headerlink" title="特征选择"></a>特征选择</h2><p>特征选择指选择最大化所定义目标函数的特征。</p>
<p>为了衡量类别分布概率的倾斜程度，定义决策树节点node的<strong>不纯度</strong>（impurity）</p>
<ul>
<li>不纯度越小，则类别的分布概率越倾斜</li>
</ul>
<p>不纯度的三种度量：</p>
<ol>
<li>熵（Entropy）<script type="math/tex; mode=display">\mathrm{Entropy}(\mathrm{node})=-\sum_{k=1}^Kp_k\log{p_k}</script></li>
<li>基尼不纯度（Gini Impurity）<script type="math/tex; mode=display">\mathrm{Gini}(\mathrm{node})=\sum_{k=1}^K p_k(1-p_k)</script></li>
<li>分类误差率<script type="math/tex; mode=display">\mathrm{Classification\_error}(\mathrm{node})=1-\max_k\ p_k</script></li>
</ol>
<p>其中$p_k$表示样本中类别$k$的占比；共有$K$个类别。</p>
<p><meta name="referrer" content="no-referrer"><br><img src="/%E7%AE%97%E6%B3%95-DecisionTree/three.png" class title="熵、基尼不纯度、分类误差率之间的关系"></p>
<p>其中</p>
<ul>
<li>为了更好地反映变量关系，曲线中的熵除以2</li>
<li>横轴是$p$</li>
<li>$p$为0或1时，熵、基尼不纯度、分类误差率都为0，表示不存在不确定性</li>
<li>当$p=0.5$时，熵、基尼不纯度、分类误差率最大，表示不确定性最大</li>
</ul>
<h3 id="信息增益"><a href="#信息增益" class="headerlink" title="信息增益"></a>信息增益</h3><div class="note info">
            <p>熵与条件熵：<br><a href="/Machine-Learning-%E7%86%B5.html" title="Machine Learning | 熵">Machine Learning | 熵</a></p>
          </div>
<p><strong>信息增益</strong>（Information Gain）：表示已知特征$X$的信息而使得类$Y$的信息的不确定性减少的程度。</p>
<div class="note warning">
            <p><strong>定义</strong>：特征$A$对训练数据集$D$的信息增益$g(D,A)$，定义为数据集$D$的经验熵$H(D)$与特征$A$给定条件下$D$的经验条件熵$H(D|A)$之差。即</p><script type="math/tex; mode=display">g(D,A)=H(D)-H(D|A)</script>
          </div>
<p>一般地，熵$H(Y)$与条件熵$H(Y|X)$之差称为<a href="/Machine-Learning-%E7%86%B5.html" title="互信息（Mutual Information）">互信息（Mutual Information）</a>。</p>
<ul>
<li>决策树学习中的信息增益等价于训练数据集中类与特征的互信息</li>
<li>给定训练数据集$D$和特征$A$，经验熵$H(D)$表示对数据集$D$进行分类的不确定性</li>
<li>$g(D,A)$表示由于特征$A$而使得对数据集$D$的分类的不确定性减少的程度</li>
<li>对于数据集$D$而言，信息增益依赖于特征</li>
<li>不同的特征往往具有不同的信息增益</li>
<li><strong>信息增益大的特征具有更强的分类能力</strong></li>
</ul>
<p>考虑训练数据集$D$，$n=|D|$为样本容量。</p>
<ul>
<li>有$K$个类$C_k,\ (k=1,\cdots,K)$</li>
<li>$|C_k|$为属于类$C_k$的样本个数<script type="math/tex; mode=display">\sum_{k=1}^K|C_k|=n</script></li>
<li>设特征$A$有$m$个不同的取值$a_1,\cdots,a_m$</li>
<li>根据特征$A$的取值将$D$划分为$m$个子集$D_1,\cdots,D_m$</li>
<li>$|D_i|$为$D_i$的样本个数<script type="math/tex; mode=display">\sum_{i=1}^m|D_i|=|D|</script></li>
<li>记子集$D_i$中属于类$C_k$的样本的集合为$D_{ik}$<script type="math/tex; mode=display">D_{ik}=D_i\cap C_k</script>$|D_{ik}|$为$D_{ik}$的样本个数</li>
</ul>
<div class="note danger">
            <p><strong>信息增益算法</strong><br>输入：训练数据集$D$和特征$A$</p><p>输出：特征$A$对训练数据集$D$的信息增益$g(D,A)$</p><ol><li>计算训练集$D$的经验熵$H(D)$<script type="math/tex; mode=display">H(D)=-\sum_{k=1}^K\frac{|C_k|}{|D|}\log{\frac{|C_k|}{|D|}}</script></li><li>计算特征$A$对数据集$D$的经验条件熵$H(D|A)$<br>\begin{aligned}<br>H(D|A)&amp;=\sum_{i=1}^m\frac{|D_i|}{|D|}H(D_i)\\<br>&amp;=-\sum_{i=1}^m\frac{|D_i|}{|D|}\sum_{k=1}^K\frac{|D_{ik}|}{|D_i|}\log{\frac{|D_{ik}|}{|D_i|}}\\<br>&amp;= -\sum_{i=1}^m\sum_{k=1}^K\frac{|D_{ik}|}{|D|}\log{\frac{|D_{ik}|}{|D_i|}}<br>\end{aligned}</li><li>计算信息增益<script type="math/tex; mode=display">g(D,A)=H(D)-H(D|A)</script></li></ol>
          </div>
<ul>
<li>可用信息增益来进行决策树的划分属性选择<script type="math/tex; mode=display">a^*=\arg\max_{a\in A} g(D,a)</script></li>
</ul>
<div class="note default">
            <p>ID3决策树学习算法就是以<u>信息增益</u>为准则来选择划分属性</p>
          </div>
<h1 id="决策树算法"><a href="#决策树算法" class="headerlink" title="决策树算法"></a>决策树算法</h1><p>包括</p>
<ul>
<li>ID3</li>
<li>C4.5</li>
<li>CART</li>
</ul>
<h2 id="ID3"><a href="#ID3" class="headerlink" title="ID3"></a>ID3</h2><ul>
<li>以<strong>信息增益</strong>为准则来划分属性</li>
</ul>
<div class="note default">
            <p>示例：<br><a href="https://mp.weixin.qq.com/s?__biz=MzA4MjYwMTc5Nw==&amp;mid=2648935296&amp;idx=2&amp;sn=cb77cd47a0189804ba9b16ba10415100&amp;chksm=879419aab0e390bcf14a8eb3f56f1ce31750b5d9566263d93269d47e4674bc7600cc1d1636fb&amp;mpshare=1&amp;scene=24&amp;srcid=&amp;sharer_sharetime=1590479772805&amp;sharer_shareid=b539221659d6ecf12200314308b58dd3&amp;key=e224f213fcbe8475f9ef285bb7bf11ea118733d485a2e0a1bf5d71cd8212cc36e61414400a348229bd6398ffdf35e8ca97536ef45b6ba48e523107c1ff2b6bae4b84605a9a810ef0e8ccfb3381a96097&amp;ascene=14&amp;uin=MjAwNDUzMjgxNw%3D%3D&amp;devicetype=Windows+10+x64&amp;version=62090070&amp;lang=zh_CN&amp;exportkey=AXXj%2FLKyq7BwO492ReB6hMg%3D&amp;pass_ticket=UotHILlosru6hQjR77K5QFOqbs0ufoaaTOgd804mZ9Zj6ebPR%2BPzibBO9ORmuQZQ" target="_blank" rel="noopener">数据来源</a></p><p>共4个特征：</p><ol><li>天气</li><li>温度</li><li>湿度</li><li>风</li></ol><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: center;    }</style><table border="1" class="dataframe">  <thead>    <tr style="text-align: center;">      <th>特征</th>      <th>特征的不同取值</th>      <th>样本数</th>      <th>`yes`样本数</th>      <th>`no`样本数</th>    </tr>  </thead>  <tbody>    <tr>      <th rowspan="3">outlook</th>      <td>sunny</td>      <td>5</td>      <td>2</td>      <td>3</td>    </tr>    <tr>      <td>overcast</td>      <td>4</td>      <td>4</td>      <td>0</td>    </tr>    <tr>      <td>rainy</td>      <td>5</td>      <td>3</td>      <td>2</td>    </tr>    <tr>      <th rowspan="3">temperature</th>      <td>hot</td>      <td>4</td>      <td>2</td>      <td>2</td>    </tr>    <tr>      <td>mild</td>      <td>6</td>      <td>4</td>      <td>2</td>    </tr>    <tr>      <td>cool</td>      <td>4</td>      <td>3</td>      <td>1</td>    </tr>    <tr>      <th rowspan="2">humidity</th>      <td>high</td>      <td>7</td>      <td>3</td>      <td>4</td>    </tr>    <tr>      <td>normal</td>      <td>7</td>      <td>6</td>      <td>1</td>    </tr>    <tr>      <th rowspan="2">windy</th>      <td>false</td>      <td>8</td>      <td>6</td>      <td>2</td>    </tr>    <tr>      <td>true</td>      <td>6</td>      <td>3</td>      <td>3</td>    </tr>    <tr>  </tr></tbody></table></div><p>标签为“打球”<code>yes</code>或“不打球”<code>no</code>，原始数据共有14个样本，其中9个为<code>yes</code>、5个为<code>no</code>，原始数据集的熵为</p><script type="math/tex; mode=display">H(D)=-\frac{9}{14}\log_2{\frac{9}{14}}-\frac{5}{14}\log_2{\frac{5}{14}}=0.940286</script><p>接着计算经验条件熵：</p><ol><li>天气：<br>\begin{aligned}<br>H(sunny)&amp;=-\frac{2}{5}\log_2{\frac{2}{5}}-\frac{3}{5}\log_2{\frac{3}{5}}=0.970951\\<br>H(overcast)&amp;=0\\<br>H(rainy)&amp;=-\frac{3}{5}\log_2{\frac{3}{5}}-\frac{2}{5}\log_2{\frac{2}{5}}=0.970951\\<br>H(D|outlook)&amp;=\frac{5}{14}H(sunny)+\frac{4}{14}H(overcast)+\frac{5}{14}H(rainy)=0.693536<br>\end{aligned}</li><li>温度<br>\begin{aligned}<br>H(hot)&amp;=-\frac{2}{4}\log_2{\frac{2}{4}}-\frac{2}{4}\log_2{\frac{2}{4}}=1\\<br>H(mild)&amp;=-\frac{4}{6}\log_2{\frac{4}{6}}-\frac{2}{6}\log_2{\frac{2}{6}}=0.918296\\<br>H(cool)&amp;=-\frac{3}{4}\log_2{\frac{3}{4}}-\frac{1}{4}\log_2{\frac{1}{4}}=0.811278\\<br>H(D|temperture)&amp;=\frac{4}{14}H(hot)+\frac{6}{14}H(mild)+\frac{4}{14}H(cool)=0.911063<br>\end{aligned}</li><li>湿度<br>\begin{aligned}<br>H(high)&amp;=\cdots=0.985228\\<br>H(normal)&amp;=\cdots=0.591673\\<br>H(D|humidity)&amp;=\frac{7}{14}H(high)+\frac{7}{14}H(normal)=0.788451<br>\end{aligned}</li><li>风<br>\begin{aligned}<br>H(false)&amp;=\cdots=0.811278\\<br>H(true)&amp;=\cdots=1\\<br>H(D|windy)&amp;=\frac{8}{14}H(false)+\frac{6}{14}H(true)=0.892159<br>\end{aligned}</li></ol><p>接着计算信息增益：<br>\begin{aligned}<br>H(D,outlook)&amp;=0.940286-0.693536=0.24675\\<br>H(D,temperature)&amp;=0.940286-0.911063=0.029223\\<br>H(D,humidity)&amp;=0.940286-0.788451=0.151835\\<br>H(D,windy)&amp;=0.940286-0.892159=0.048127<br>\end{aligned}</p><p>其中outlook的信息增益最大，所以应选择特征<code>outlook</code>为根节点。</p>
          </div>
<h2 id="ID4"><a href="#ID4" class="headerlink" title="ID4"></a>ID4</h2><h2 id="C4-5"><a href="#C4-5" class="headerlink" title="C4.5"></a>C4.5</h2><ul>
<li>基于ID3</li>
<li>ID3使用的是<u>信息增益</u>，而C4.5使用的是<strong>信息增益比</strong></li>
</ul>
<h2 id="CART"><a href="#CART" class="headerlink" title="CART"></a>CART</h2><p><strong>C</strong>lassification <strong>a</strong>nd <strong>R</strong>egression <strong>T</strong>ree / Regression Tree<br>分类和回归树</p>
<ul>
<li>与C4.5不同，CART的决策树由二元逻辑问题生成，每个树节点只有两个分支</li>
</ul>
<blockquote>
<p>regression tree is a function that maps the attributes to the score. —— from Tianqi Chen - Introduction to Boosted Tree</p>
</blockquote>
<h3 id="CHAID"><a href="#CHAID" class="headerlink" title="CHAID"></a>CHAID</h3><p>Chi-squared Automatic Interaction Detector</p>
<h3 id="MARS"><a href="#MARS" class="headerlink" title="MARS"></a>MARS</h3><h3 id="条件推断树"><a href="#条件推断树" class="headerlink" title="条件推断树"></a>条件推断树</h3><h2 id="过拟合"><a href="#过拟合" class="headerlink" title="过拟合"></a>过拟合</h2><p>当训练误差（training error）很小，泛化误差（generalization error / test error）较大时，说明决策树模型发生了过拟合。</p>
<p>发生过拟合的根本原因是决策树模型过于复杂，可能的原因有：</p>
<ul>
<li>训练数据集中有异常点（噪音样本点），异常点影响了模型的分类效果</li>
<li>决策树的叶节点中缺乏有分类价值的样本记录（需要进行剪枝）</li>
</ul>
<p>如何避免决策树过拟合？</p>
<ul>
<li>限制树的深度max_depth</li>
<li>剪枝prune</li>
<li>限制叶子节点数量</li>
<li>正则化项</li>
<li>增加样本数据</li>
<li>bagging（subsample、subfeature、低维空间投影）</li>
<li>数据增加（加入有噪声的数据）</li>
<li>early stopping</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>决策树的优点：</p>
<ul>
<li>可读性强</li>
<li>分类速度快</li>
<li>推理过程完全依赖于属性变量的取值特点</li>
<li>可自动忽略对目标变量没有贡献的属性变量</li>
</ul>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><h1 id="笔试题目"><a href="#笔试题目" class="headerlink" title="笔试题目"></a>笔试题目</h1><div class="note default">
            <p>当在一个决策树中划分一个节点时，以下关于“信息增益”的论述正确的是（2、3）<br>1.较不纯的节点需要更多的信息来描述总体<br>2.信息增益可以通过熵来推导<br>3.信息增益偏向于选择大量值的属性</p><p>[<font face="宋体" color="grey">来自：<a href="https://www.nowcoder.com/questionTerminal/c8af2b7b74d74c65b6e5d58b5c607dc3" target="_blank" rel="noopener">牛客试题广场</a></font>]</p>
          </div>
<ul>
<li>不纯度指的是基尼系数</li>
</ul>
<div class="note default">
            <p>以下机器学习中，在数据预处理时，不需要考虑归一化处理的是：</p><ul><li>树形模型</li></ul><p>[<font face="宋体" color="grey">来自：<a href="https://www.nowcoder.com/test/question/done?tid=36064816&amp;qid=370007#summary" target="_blank" rel="noopener">牛客试题广场</a></font>]</p>
          </div>
<ul>
<li>不需要归一化处理的模型：决策树、随机森林<ul>
<li>因为它们不关心变量的值，而是关心变量的分布和变量之间的条件概率</li>
</ul>
</li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://homes.cs.washington.edu/~tqchen/data/pdf/BoostedTree.pdf" target="_blank" rel="noopener">Tianqi Chen - Introduction to Boosted Trees</a></li>
<li><a href="http://www.huaxiaozhuan.com/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0/chapters/4_decision_tree.html" target="_blank" rel="noopener">决策树</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzUzODYwMDAzNA==&amp;mid=2247490797&amp;idx=2&amp;sn=e4488e6ae078fd04992ee19c3ea43e0d&amp;chksm=fad46be0cda3e2f606f3faffe800c819c2cacb5ded2c4bb6e1b0b061bc2c06d276bd18a4a9f4&amp;mpshare=1&amp;scene=24&amp;srcid=&amp;sharer_sharetime=1589846441823&amp;sharer_shareid=b539221659d6ecf12200314308b58dd3&amp;key=391433877af29848d80eb268dfdb67e70c94dbc8461e647ef4fd9cf863b97fcbf05fe3cc098469dd0eed236ecaa0ce9b4afa6518cb6c2e116156d348ec25c79484217b352893ff4b5a26e8f3fd8d7f35&amp;ascene=14&amp;uin=MjAwNDUzMjgxNw%3D%3D&amp;devicetype=Windows+10+x64&amp;version=62090070&amp;lang=zh_CN&amp;exportkey=AYJS0mHna0hF6l9GD1%2B%2BuCY%3D&amp;pass_ticket=hSPy%2FUU8oxUcSxTs%2F5nB1TD0Hf4oMyJJiFtHAk4RLQ6enp8U%2FMNrC0H1aJAXQF7t" target="_blank" rel="noopener">24个「数据分析师」岗位面试题和答案解析</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzA4MjYwMTc5Nw==&amp;mid=2648935296&amp;idx=2&amp;sn=cb77cd47a0189804ba9b16ba10415100&amp;chksm=879419aab0e390bcf14a8eb3f56f1ce31750b5d9566263d93269d47e4674bc7600cc1d1636fb&amp;mpshare=1&amp;scene=24&amp;srcid=&amp;sharer_sharetime=1590479772805&amp;sharer_shareid=b539221659d6ecf12200314308b58dd3&amp;key=e224f213fcbe8475f9ef285bb7bf11ea118733d485a2e0a1bf5d71cd8212cc36e61414400a348229bd6398ffdf35e8ca97536ef45b6ba48e523107c1ff2b6bae4b84605a9a810ef0e8ccfb3381a96097&amp;ascene=14&amp;uin=MjAwNDUzMjgxNw%3D%3D&amp;devicetype=Windows+10+x64&amp;version=62090070&amp;lang=zh_CN&amp;exportkey=AXXj%2FLKyq7BwO492ReB6hMg%3D&amp;pass_ticket=UotHILlosru6hQjR77K5QFOqbs0ufoaaTOgd804mZ9Zj6ebPR%2BPzibBO9ORmuQZQ" target="_blank" rel="noopener">决策树算法的原理（接地气版）</a></li>
<li><a href="https://divinerhjf.github.io/2019/05/24/shu-ju-wa-jue-jue-ce-shu/#toc-heading-8" target="_blank" rel="noopener">数据挖掘|决策树</a></li>
<li><a href="https://www.jiqizhixin.com/articles/2017-07-31-3" target="_blank" rel="noopener">从决策树到随机森林：树型算法的原理与实现</a></li>
<li><a href="https://www.cnblogs.com/en-heng/p/5013995.html" target="_blank" rel="noopener">【十大经典数据挖掘算法】C4.5</a></li>
<li><a href="https://book.douban.com/subject/10590856/" target="_blank" rel="noopener">李航-统计学习方法</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/76667156" target="_blank" rel="noopener">熵、基尼系数、分类误差率之间的关系-图片来源</a></li>
</ul>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>机器学习</tag>
        <tag>分类</tag>
        <tag>有监督学习</tag>
        <tag>回归</tag>
      </tags>
  </entry>
  <entry>
    <title>Machine Learning | Logistic Regression</title>
    <url>/%E7%AE%97%E6%B3%95-LogisticRegression.html</url>
    <content><![CDATA[<p><center>逻辑回归</center><br><a id="more"></a></p>
<h1 id="Logistic-Regression"><a href="#Logistic-Regression" class="headerlink" title="Logistic Regression"></a>Logistic Regression</h1><p>逻辑回归（<strong>LR</strong>，Logistic Regression），是一种<u>对数几率模型</u>（Logit Model），常用于二分类问题（binary classification problems）</p>
<ul>
<li>逻辑回归和线性回归（Linear Regression）都是一种广义线性模型（GLM，Generalized Linear Model）</li>
<li>属于<strong>有监督学习</strong>（Supervised Learning）</li>
<li>是一种分类器（Classifier）</li>
<li>因变量是分类变量（Qualitative response）</li>
</ul>
<blockquote>
<p>其他分类器有：</p>
<ul>
<li>判别分析（Discriminant Analysis）</li>
<li>决策树（Decision Tree）</li>
<li>随机森林（Random Forest）</li>
<li>支持向量机（Support Vector Machine）</li>
<li>神经网络（Neural Network）</li>
<li>……</li>
</ul>
</blockquote>
<h2 id="逻辑分布"><a href="#逻辑分布" class="headerlink" title="逻辑分布"></a>逻辑分布</h2><p>Logistic分布是一种连续型分布，其分布函数（Cumulative distribution function）为</p>
<script type="math/tex; mode=display">F(x)=P(X\leq x)=\frac{1}{1+e^{-(x-\mu)/s}}=\frac{1}{2}+\frac{1}{2}\tanh\left(\frac{x-\mu}{2s}\right)</script><p><meta name="referrer" content="no-referrer"><br><img src="/%E7%AE%97%E6%B3%95-LogisticRegression/LR-CDF.png" class title="不同取值参数对应的CDF"></p>
<p>概率密度函数为<br>\begin{equation}<br>f(x)=F^\prime(x)=\frac{e^{-(x-\mu)/s}}{s\left(1+e^{-(x-\mu)/s}\right)^2}=\frac{1}{4s}\mathrm{sech}^2\left(\frac{x-2\mu}{2s}\right),\quad -\infty&lt; x&lt; +\infty<br>\end{equation}<br>其中</p>
<ul>
<li>$\mu$为位置参数（location parameter）</li>
<li>$s$为尺度参数（scale parameter）</li>
<li>期望<script type="math/tex; mode=display">\mathrm{E(X)}=\mu</script></li>
<li>中位数<script type="math/tex; mode=display">\mathrm{Median(X)}=\mu</script></li>
<li>方差<script type="math/tex; mode=display">\mathrm{Var}(X)=\frac{s^2\pi^2}{3}</script></li>
</ul>
<p><meta name="referrer" content="no-referrer"><br><img src="/%E7%AE%97%E6%B3%95-LogisticRegression/LR-pdf.png" class title="不同取值参数对应的pdf"></p>
<h2 id="逻辑函数"><a href="#逻辑函数" class="headerlink" title="逻辑函数"></a>逻辑函数</h2><p>一个简单的Logistic函数：</p>
<script type="math/tex; mode=display">P(t)=\frac{1}{1+e^{-t}}</script><p><meta name="referrer" content="no-referrer"><br><img src="/%E7%AE%97%E6%B3%95-LogisticRegression/LR-slog.png" class title="标准Logistic函数"></p>
<p>广义Logistic曲线可以模拟一些人口增长的S形曲线：初始阶段大致是指数增长；然后开始变得饱和，增加变慢；最后，达到成熟时增加停止。</p>
<h2 id="逻辑回归"><a href="#逻辑回归" class="headerlink" title="逻辑回归"></a>逻辑回归</h2><p>逻辑回归通常用于二分类问题（因变量是分类变量），用来表示某件事发生的可能性。</p>
<p>Andrew Ng的CS229中的例子：根据肿瘤的大小（Tumor Size）$X$来判断肿瘤是否是恶性的（Malignant）$Y$。</p>
<p>考虑构建线性回归模型$h_\theta(x)$，$h_\theta(x)\geq 0.5$ 为恶性肿瘤，$h_\theta(x)&lt;0.5$为良性肿瘤。<br>\begin{equation}<br>  Y=\left\{<br>\begin{array}{ll}<br>1, &amp; \mbox{如果} h_\theta(x)\geq 0.5\\<br>0, &amp; \mbox{如果} h_\theta(x)&lt;0.5<br>\end{array}\right.<br>\end{equation}</p>
<p>Logistic函数/<strong>Sigmoid函数</strong>可以将任意实数值映射到(0,1)区间（不包括0和1，但可以无限接近）。因此，使用Sigmoid函数来将线性回归的结果按照一定的阈值分为2类（二分类问题）或更多类（多分类问题）。</p>
<p><meta name="referrer" content="no-referrer"><br><img src="/%E7%AE%97%E6%B3%95-LogisticRegression/LR-heart.png" class title="来自：机器之心-从原理到应用-简述Logistic回归算法"></p>
<p>令</p>
<script type="math/tex; mode=display">h_\theta(x)=g(\theta^Tx)=\frac{1}{1+e^{-\theta^Tx}}=\frac{e^{\theta^Tx}}{1+e^{\theta^Tx}}</script><p>其中$z=\theta^Tx$（这里$x$包含截距项），Sigmoid函数为</p>
<script type="math/tex; mode=display">g(z)=\frac{1}{1+e^{-z}}=\frac{e^z}{1+e^z}</script><p>Sigmoid保证$h_\theta(x)$取值在0和1之间（概率取值范围为[0,1]）。</p>
<p><strong>Log-odds</strong>，也称<strong>Logit</strong>（Logit transformation / Link function）表示为</p>
<script type="math/tex; mode=display">\log\frac{p}{1-p}=\log\frac{h_\theta(x)}{1-h_\theta(x)}=\theta^Tx</script><p>其中$p=h_\theta(x)$表示概率。</p>
<p>$h_\theta(x)$表示输入$x$后分类结果为1的概率</p>
<script type="math/tex; mode=display">P(Y=1|x;\theta)=h_\theta(x)</script><script type="math/tex; mode=display">P(Y=0|x;\theta)=1-h_\theta(x)</script><p>因此，因变量$Y$服从Bernoulli分布</p>
<script type="math/tex; mode=display">Y|X=x_i\sim \mathrm{Bernoulli}\left(h_\theta(x_i)\right)</script><p>概率函数为</p>
<script type="math/tex; mode=display">P(y|x;\theta)=\left[h_\theta(x) \right]^y\left[1-h_\theta(x) \right]^{1-y}</script><p>使用训练数据集$x=\{x_1,x_2,\cdots,x_n\}$（特征数据）和$y=\{y_1,y_2\cdots,y_n\}$（分类数据）构建回归模型。</p>
<h3 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h3><p>对于单个样本，其损失函数可以表示为<br>\begin{equation}<br>\mathrm{Cost}(h_\theta(X),y)=\left\{<br>  \begin{array}{ll}<br>  -\log{h_\theta(X)},&amp; \mathrm{if}\quad y=1\\<br>  -\log{\left(1-h_\theta(X)\right)}, &amp; \mathrm{if }\quad y=0\end{array}<br>  \right.<br>\end{equation}</p>
<p>即</p>
<script type="math/tex; mode=display">\mathrm{Cost}(h_\theta(X),y)=-\left[y\log{h_\theta(X)}+(1-y)\log{\left(1-h_\theta(X)\right)} \right]</script><p>该式被称为<strong>交叉熵代价函数</strong>（cross entropy cost function）。</p>
<p>对于训练集的所有样本(样本量为$n$)来说，共同造成的损失函数的均值为</p>
<p>\begin{equation}<br>\begin{aligned}<br>  H_{\theta(X)} &amp;=\frac{1}{n} \sum_{i=1}^n \mathrm{Cost} \left( h_{\theta}(X^{(i)}),y^{(i)} \right)\\<br>  &amp;= -\frac{1}{n} \sum_{i=1}^n \left[ y^{(i)} \log{h_\theta(X^{(i)})}+(1-y^{(i)}) \log{ \left(1-h_\theta(X^{(i)})\right) } \right]<br>\end{aligned}<br>\end{equation}</p>
<p>如何求解逻辑回归方程中的参数？通常使用极大似然法。</p>
<h3 id="极大似然法"><a href="#极大似然法" class="headerlink" title="极大似然法"></a>极大似然法</h3><p>$n$个独立样本的似然函数为</p>
<script type="math/tex; mode=display">L(\theta)=\Pi_{i=1}^nP(y_i|x_i;\theta)=\Pi_{i=1}^nh_\theta(x_i)^{y_i}\left[1-h_\theta(x_i) \right]^{1-y_i}</script><p>对数似然函数为<br>\begin{equation}<br>\begin{aligned}<br>  l(\theta)=\log{L(\theta)}&amp;=\sum_{i=1}^n\left\{y_i\log{h_\theta(x_i)}+(1-y_i)\log{\left[1-h_\theta(x_i) \right]}\right\}\\<br>  &amp;= \sum_{i=1}^n\left\{y_i\theta^Tx_i-\log{\left[1+e^{\theta^Tx_i} \right]}\right\}<br>\end{aligned}<br>\end{equation}</p>
<p>其中</p>
<script type="math/tex; mode=display">\log{h_\theta(x_i)}=\log{\frac{e^{\theta^Tx_i}}{1+e^{\theta^Tx_i}}}=\theta^Tx_i-\log{\left[1+e^{\theta^Tx_i}\right]}</script><script type="math/tex; mode=display">\log{\left[1-h_\theta(x_i) \right]}=\log{\frac{1}{1+e^{\theta^Tx_i}}}=-\log{\left[1+e^{\theta^Tx_i} \right]}</script><script type="math/tex; mode=display">\max{L(\theta)} \Leftrightarrow \max{l(\theta)} \Leftrightarrow \min \{ -l(\theta)\}</script><p>其中$-l(\theta)=-\log{L(\theta)}$称为<strong>交叉熵误差函数</strong>（cross-entropy error function）/交叉熵代价函数。</p>
<p>考虑$p+1$维的参数$\theta=(\theta_0,\theta_1,\cdots,\theta_p)^T$，其中$\theta_0$ 为线性回归方程$z=\theta^Tx$的截距。<br>\begin{equation}<br>\theta=\left(<br>\begin{array}{c}<br>  \theta_0\\<br>  \theta_1\\<br>  \theta_2\\<br>  \vdots\\<br>  \theta_p<br>\end{array}<br>\right),<br>\quad<br>x_i=\left(<br>\begin{array}{c}<br>  1\\<br>  x_{i1}\\<br>  x_{i2}\\<br>  \vdots\\<br>  x_{ip}<br>\end{array}<br>\right)<br>\end{equation}<br>对数似然函数$l(\theta)$分别对$\theta_j\ (j=0,1,\cdots,p)$求偏导，并令导数为零</p>
<script type="math/tex; mode=display">\frac{\partial{l(\theta)}}{\partial{\theta_j}}=\sum_{i=1}^n\left\{y_ix_{ij}-\frac{e^{\theta^Tx_i}}{1+e^{\theta^Tx_i}}x_{ij}\right\}=\sum_{i=1}^n\left\{x_{ij}\left[y_i-h_\theta(x_i) \right]\right\}=0</script><p>写成向量形式</p>
<script type="math/tex; mode=display">\frac{\partial{l(\theta)}}{\partial{\theta}}=\sum_{i=1}^n\left\{x_i\left[y_i-h_\theta(x_i) \right]\right\}=0</script><p>该式也被称为<strong>score equation</strong>。</p>
<p>这里$x_i$的第一个元素为1，因此由上式可得</p>
<script type="math/tex; mode=display">\sum_{i=1}^ny_i=\sum_{i=1}^nh_\theta(x_i)</script><p>表示$Y$取值为1的样本量（$n$个样本中得恶性肿瘤的人数）等于“事件”（如肿瘤为恶性肿瘤）发生的概率和。</p>
<p>当$p$较小时，score equation可得到解析解（精确解）；但当$p$较大时，score equation 往往得不到解析解。这时，可以考虑使用Newton-Raphson算法求得数值解（numerical solution）。</p>
<h3 id="Newton-Raphson算法"><a href="#Newton-Raphson算法" class="headerlink" title="Newton-Raphson算法"></a>Newton-Raphson算法</h3><p>首先计算二阶偏导（Hessian Matrix）：<br>\begin{equation}<br>\begin{aligned}<br>\frac{\partial^2l(\theta)}{\partial{\theta_k}\partial{\theta_j}}&amp;=\frac{\partial}{\partial{\theta_k}}\sum_{i=1}^n\left\{x_{ij}\left[y_i-h_\theta(x_i)\right]\right\}\\<br>&amp;=\frac{\partial}{\partial{\theta_k}}\sum_{i=1}^n\left\{x_{ij}\left[y_i-\frac{e^{\theta^Tx_i}}{1+e^{\theta^Tx_i}}\right]\right\}\\<br>&amp;=\sum_{i=1}^nx_{ij}\left\{-\frac{e^{\theta^Tx_i}x_{ik}(1+e^{\theta^Tx_i})-e^{\theta^Tx_i}e^{\theta^Tx_i}x_{ik}}{\left(1+e^{\theta^Tx_i}\right)^2}\right\}\\<br>&amp;=-\sum_{i=1}^nx_{ij}x_{ik}\frac{e^{\theta^Tx_i}}{1+e^{\theta^Tx_i}}\left(1-\frac{e^{\theta^Tx_i}}{1+e^{\theta^Tx_i}}\right)\\<br>&amp;=-\sum_{i=1}^nx_{ij}x_{ij}h_\theta(x_i)\left[1-h_\theta(x_i)\right]<br>\end{aligned}<br>\end{equation}<br>其中$j,k=0,1,\cdots,p$。</p>
<p><strong>Hessian Matrix</strong>为</p>
<script type="math/tex; mode=display">\frac{\partial^2l(\theta)}{\partial\theta\partial\theta^T}=-\sum_{i=1}^nx_ix_i^Th_\theta(x_i)[1- h_\theta(x_i)]</script><p>由$\theta^{old}$开始，Newton-Raphson的更新步骤（updating step）为</p>
<script type="math/tex; mode=display">\theta^{new}=\theta^{old}-\left[\frac{\partial^2l(\theta)}{\partial\theta\partial\theta^T}\right]^{-1}\frac{\partial{l(\theta)}}{\partial\theta}</script><p>这里考虑步长为1的pure Newton’s Method。即</p>
<script type="math/tex; mode=display">\theta^{new}=\theta^{old}-\alpha\left[\frac{\partial^2l(\theta)}{\partial\theta\partial\theta^T}\right]^{-1}\frac{\partial{l(\theta)}}{\partial\theta}\quad \mbox{with}\ \alpha=1</script><p>用矩阵形式表示<br>\begin{equation}<br>\mathbf{y}=\left(<br>\begin{array}{c}<br>  y_1\\<br>  y_2\\<br>  \vdots\\<br>  y_n<br>\end{array}<br>\right),\quad<br>\mathbf{X}=\left(<br>\begin{array}{c}<br>  x_1^T\\<br>  x_2^T\\<br>  \vdots\\<br>  x_n^T<br>\end{array}<br>\right)=<br>\left(<br>\begin{array}{ccccc}<br>  1 &amp; x_{11} &amp; x_{12} &amp; \cdots &amp; x_{1p}\\<br>  1 &amp; x_{21} &amp; x_{22} &amp; \cdots &amp; x_{2p}\\<br>  \vdots &amp; \vdots &amp; \vdots &amp;\ddots &amp; \vdots \\<br>  1 &amp; x_{n1} &amp; x_{n2} &amp; \cdots &amp; x_{np}<br>\end{array}<br>\right)<br>\end{equation}</p>
<p>\begin{equation}<br>\mathbf{P}=\left(<br>\begin{array}{c}<br>  h_{\theta^{old}}(x_1)\\<br>  h_{\theta^{old}}(x_2)\\<br>  \vdots\\<br>  h_{\theta^{old}}(x_n)<br>\end{array}<br>\right),\quad<br>\mathbf{W}=\mathrm{diag}\left\{<br>  h_{\theta^{old}}(x_i)(1-h_{\theta^{old}}(x_i))<br>\right\}<br>\end{equation}</p>
<p>则有</p>
<script type="math/tex; mode=display">\frac{\partial{l(\theta)}}{\partial\theta}=\mathbf{X}^T(\mathbf{y}-\mathbf{P})</script><script type="math/tex; mode=display">\frac{\partial^2l(\theta)}{\partial\theta\partial\theta^T}=-\mathbf{X}^T\mathbf{W}\mathbf{X}</script><p>因此<br>\begin{equation}<br>\begin{aligned}<br>\theta^{new}&amp;=\theta^{old}-\left[\frac{\partial^2l(\theta)}{\partial\theta\partial\theta^T} \right]^{-1}\frac{\partial{l(\theta)}}{\partial\theta}\\<br>&amp;= \theta^{old}+\left(\mathbf{X}^T\mathbf{W}\mathbf{X}\right)^{-1}\mathbf{X}^T(\bf{y}-\bf{P})\\<br>&amp;= \left(\mathbf{X}^T\mathbf{W}\mathbf{X}\right)^{-1}\mathbf{X}^T\mathbf{W}\left[\mathbf{X}\theta^{old}+\mathbf{W}^{-1}(\mathbf{y}-\mathbf{P}) \right]\\<br>&amp;= \left(\mathbf{X}^T\mathbf{W}\mathbf{X}\right)^{-1}\mathbf{X}^T\mathbf{W}\mathbf{z}<br>\end{aligned}<br>\end{equation}</p>
<p>其中$\mathbf{z}=\mathbf{X}\theta^{old}+\mathbf{W}^{-1}(\mathbf{y}-\mathbf{P})$。</p>
<p>每次迭代中，$\bf{P}$更新，$\bf{W}$和$\bf{z}$也随之更新。</p>
<p>$\theta^{new}$可以看作是$\bf{z}$关于$\bf{X}$回归的加权最小二乘（weighted least square）。</p>
<p>式</p>
<script type="math/tex; mode=display">\theta^{new}=\left(\mathbf{X}^T\mathbf{W}\mathbf{X}\right)^{-1}\mathbf{X}^T\mathbf{W}\mathbf{z}</script><p>这种迭代法也称为<u>迭代重加权最小二乘</u>（iteratively reweighted least squares，IRLS）。</p>
<h1 id="逻辑回归-vs-线性回归"><a href="#逻辑回归-vs-线性回归" class="headerlink" title="逻辑回归 vs 线性回归"></a>逻辑回归 vs 线性回归</h1><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center"><strong>逻辑回归</strong></th>
<th style="text-align:center"><strong>线性回归</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">分类</td>
<td style="text-align:center">回归</td>
</tr>
<tr>
<td style="text-align:center"><strong>变量分布</strong></td>
<td style="text-align:center">无要求</td>
<td style="text-align:center">要求服从正态分布</td>
</tr>
<tr>
<td style="text-align:center"><strong>因变量</strong></td>
<td style="text-align:center">离散的变量</td>
<td style="text-align:center">连续的变量</td>
</tr>
<tr>
<td style="text-align:center"><strong>自变量与因变量</strong></td>
<td style="text-align:center">可以不符合线性关系</td>
<td style="text-align:center">符合线性关系</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">无法直观表达变量关系</td>
<td style="text-align:center">直观表达变量关系</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">分析因变量取某个值的概率与自变量的关系</td>
<td style="text-align:center">直接分析因变量与自变量的关系</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">$\theta^TX=0$为决策边界</td>
<td style="text-align:center">$\theta^TX$为预测值的拟合函数</td>
</tr>
<tr>
<td style="text-align:center"><strong>损失函数</strong></td>
<td style="text-align:center">交叉熵损失函数</td>
<td style="text-align:center">残差平方和</td>
</tr>
</tbody>
</table>
</div>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://zh.wikipedia.org/wiki/%E9%82%8F%E8%BC%AF%E8%BF%B4%E6%AD%B8" target="_blank" rel="noopener">维基百科-逻辑回归</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/28408516" target="_blank" rel="noopener">逻辑回归（Logistic Regression）（一）</a></li>
<li><a href="https://en.wikipedia.org/wiki/Logistic_distribution" target="_blank" rel="noopener">维基百科-逻辑分布</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E9%82%8F%E8%BC%AF%E5%87%BD%E6%95%B8" target="_blank" rel="noopener">维基百科-逻辑函数</a></li>
<li><a href="https://www.jiqizhixin.com/articles/2018-05-13-3" target="_blank" rel="noopener">从原理到应用-简述Logistic回归算法</a></li>
<li><a href="https://www.cnblogs.com/sparkwen/p/3441197.html" target="_blank" rel="noopener">逻辑回归模型基础</a></li>
<li><a href="https://easyai.tech/ai-definition/logistic-regression/" target="_blank" rel="noopener">逻辑回归</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/67842740" target="_blank" rel="noopener">Logistic回归，梯度下降法，牛顿法，IRLS算法</a></li>
<li><a href="https://blog.csdn.net/u012526120/article/details/48897135" target="_blank" rel="noopener">Logistic和牛顿法</a></li>
<li><a href="https://www.afenxi.com/56409.html" target="_blank" rel="noopener">如何在R中执行Logistic回归？</a></li>
<li><a href="https://www.cnblogs.com/nxld/p/6170690.html" target="_blank" rel="noopener">如何在R语言中使用Logistic回归模型</a></li>
<li><a href="https://blog.csdn.net/zllnau66/article/details/81742798" target="_blank" rel="noopener">Python3常用的数据清洗方法</a></li>
<li><a href="https://www.cnblogs.com/wuchuanying/p/6243987.html" target="_blank" rel="noopener">Python_Sklearn机器学习库学习笔记（三）</a></li>
<li><a href="https://www.cnblogs.com/wmr95/articles/9698475.html" target="_blank" rel="noopener">线性回归于逻辑回归的区别</a></li>
</ul>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>机器学习</tag>
        <tag>回归</tag>
        <tag>判别式模型</tag>
      </tags>
  </entry>
  <entry>
    <title>Machine Learning | Supervised Learning</title>
    <url>/%E7%AE%97%E6%B3%95-SupervisedLearning.html</url>
    <content><![CDATA[<p><center>有监督学习</center><br><a id="more"></a></p>
<h1 id="Supervised-Learning"><a href="#Supervised-Learning" class="headerlink" title="Supervised Learning"></a>Supervised Learning</h1><h2 id="Model"><a href="#Model" class="headerlink" title="Model"></a>Model</h2><h2 id="Parameters"><a href="#Parameters" class="headerlink" title="Parameters"></a>Parameters</h2><h2 id="Objective-Function"><a href="#Objective-Function" class="headerlink" title="Objective Function"></a>Objective Function</h2><p>目标函数</p>
<script type="math/tex; mode=display">Obj(\Theta)=L(\Theta)+\Omega(\Theta)</script><script type="math/tex; mode=display">Training Loss + Regularization</script><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:left"><strong>Training Loss</strong></th>
<th style="text-align:left"><strong>Regularization</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>measure</strong></td>
<td style="text-align:left">how well model fit on training data</td>
<td style="text-align:left">complexity of model</td>
</tr>
<tr>
<td style="text-align:center">optimize…to encourages</td>
<td style="text-align:left">predictive models<sup><a href="#fn_1" id="reffn_1">1</a></sup></td>
<td style="text-align:left">simple models<sup><a href="#fn_2" id="reffn_2">2</a></sup></td>
</tr>
</tbody>
</table>
</div>
<blockquote id="fn_1">
<sup>1</sup>. Fitting well in training data at least get you close to training data which is hopefully close to the underlying distribution. ——from <a href="https://homes.cs.washington.edu/~tqchen/data/pdf/BoostedTree.pdf" target="_blank" rel="noopener">Tianqi Chen - Introduction to Boosted Trees</a><a href="#reffn_1" title="Jump back to footnote [1] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_2">
<sup>2</sup>. Simpler models tends to have smaller variance in future predictions, making prediction stable. ——from <a href="https://homes.cs.washington.edu/~tqchen/data/pdf/BoostedTree.pdf" target="_blank" rel="noopener">Tianqi Chen - Introduction to Boosted Trees</a><a href="#reffn_2" title="Jump back to footnote [2] in the text."> &#8617;</a>
</blockquote>
<h3 id="Training-Loss"><a href="#Training-Loss" class="headerlink" title="Training Loss"></a>Training Loss</h3><p>训练误差<strong>Training Loss</strong>: measures <u>how well model fit on training data</u></p>
<script type="math/tex; mode=display">L(\Theta)=\sum_{i=1}^nl(y_i,\hat{y}_i)</script><ul>
<li>Square Loss<script type="math/tex; mode=display">l(y_i,\hat{y}_i)=(y_i-\hat{y}_i)^2</script></li>
<li>Log-Loss<script type="math/tex; mode=display">l(y_i,\hat{y}_i)=y_i\ln{(1+e^{-\hat{y}_i})}+(1-y_i)\ln{(1+e^{\hat{y}_i})}</script></li>
</ul>
<h3 id="Regularization"><a href="#Regularization" class="headerlink" title="Regularization"></a>Regularization</h3><p>正则化<strong>Regularization</strong>: measures <u>complexity of model</u></p>
<script type="math/tex; mode=display">\Omega(\Theta)</script><ul>
<li>$l1$-norm <script type="math/tex; mode=display">\Omega(\omega)=\lambda||w||_1</script></li>
<li>$l2$-norm<script type="math/tex; mode=display">\Omega(\omega)=\lambda||w||^2</script></li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://homes.cs.washington.edu/~tqchen/data/pdf/BoostedTree.pdf" target="_blank" rel="noopener">Tianqi Chen - Introduction to Boosted Trees</a></li>
<li><a href></a></li>
<li><a href></a></li>
</ul>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Machine Learning | Boosting Tree</title>
    <url>/%E7%AE%97%E6%B3%95-BoostingTree.html</url>
    <content><![CDATA[<p><center>提升树</center><br><a id="more"></a></p>
<p>Tree Ensemble methods</p>
<ul>
<li>不需要归一化（normalization)</li>
<li>能够学习到特征之间的高阶交互</li>
<li>可用于分类、回归、排序、……</li>
</ul>
<h1 id="Boosting-Tree"><a href="#Boosting-Tree" class="headerlink" title="Boosting Tree"></a>Boosting Tree</h1><ul>
<li>提升树是以分类树或回归树为基本分类器的提升方法</li>
<li>模型：加法模型<sup><a href="#fn_1" id="reffn_1">1</a></sup>与前向分步算法</li>
<li>基学习器：决策树，即决策树桩<sup><a href="#fn_2" id="reffn_2">2</a></sup></li>
</ul>
<ol>
<li><strong>二叉分类树</strong>：分类问题决策树</li>
<li><strong>二叉回归树</strong>：回归问题决策树</li>
</ol>
<blockquote id="fn_1">
<sup>1</sup>. 加法模型即基学习器的线性组合<a href="#reffn_1" title="Jump back to footnote [1] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_2">
<sup>2</sup>. 决策树桩（decision stump）：由一个根结点直接连接两个叶节点的简单决策树<a href="#reffn_2" title="Jump back to footnote [2] in the text."> &#8617;</a>
</blockquote>
<div class="note danger">
            <h2 id="前向分步算法"><a href="#前向分步算法" class="headerlink" title="前向分步算法"></a>前向分步算法</h2><p><strong>输入</strong>: </p><ul><li>样本特征数据$x_1,\cdots,x_N$</li><li>样本因变量数据$y_1,\cdots,y_N$</li><li>初始提升树$H_0(x)=h_0(x)=0$</li></ul><p><strong>输出</strong>： 提升树</p><script type="math/tex; mode=display">H(x)=\sum_{t=1}^Th_t(x;\theta_t)</script><ul><li>对于$t=1,2,\cdots,T$，<ol><li>要训练一棵决策树$h_t(x;\theta_t)$</li><li>提升树为<script type="math/tex; mode=display">H_t(x)=H_{t-1}(x)+h_t(x;\theta_t)</script></li><li>通过经验风险最小化确定该棵决策树的参数$\theta_t$<script type="math/tex; mode=display">\hat{\theta}_t=\arg{\min_{\theta_t}{\sum_{i=1}^NL\left(y_i, H_{t-1}(x_i)+h_t(x_i;\theta_t) \right)}}</script></li></ol></li></ul>
          </div>
<h2 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h2><p>针对不同问题的提升树学习算法，使用的损失函数不同</p>
<ul>
<li>回归问题：平方误差损失函数</li>
<li>分类问题：指数损失函数</li>
<li>一般决策问题：一般损失函数</li>
</ul>
<div class="note default">
            <p>对于二分类问题，若将<a href="/%E7%AE%97%E6%B3%95-AdaBoost.html" title="AdaBoost算法">AdaBoost算法</a>中的基分类器限定为<strong>二类决策树</strong>，则为提升树。<br>此时，Boosting Tree是AdaBoost的特殊情况。</p>
          </div>
<div class="note danger">
            <h2 id="回归提升树"><a href="#回归提升树" class="headerlink" title="回归提升树"></a>回归提升树</h2><p><strong>输入</strong>：训练数据集$\{(x_1,y_1),\cdots, (x_N,y_N)\}$<br>  $x_i\in X\subseteq \mathbb{R}^p,\quad y_i\in Y\subseteq \mathbb{R}$</p><p><strong>输出</strong>：提升树</p><script type="math/tex; mode=display">H(x)=\sum_{t=1}^Th_t(x)</script><ol><li>初始化提升树$H_0(x)=0$</li><li>对$t=1,\cdots,T$($T$为迭代次数)，<ol><li>计算上一轮迭代的残差<script type="math/tex; mode=display">r_i^{(t)}=y_i-H_{t-1}(x_i),\quad i=1,\cdots,N.</script></li><li>拟合残差$r_i^{(t)}$学习得到一棵回归树<script type="math/tex; mode=display">h_t(x;\theta_t)</script></li><li>更新提升树<script type="math/tex; mode=display">H_t(x)=H_{t-1}(x)+h_t(x;\theta_t)</script></li></ol></li></ol>
          </div>
<h2 id="Objective"><a href="#Objective" class="headerlink" title="Objective"></a>Objective</h2><script type="math/tex; mode=display">Obj=\sum_{i=1}^nl(y_i,\hat{y}_i)+\sum_{k=1}^K\Omega(f_k)</script><ul>
<li><p>如何定义树的复杂度$\Omega(f_k)$？</p>
<ul>
<li>树的结点数、树的深度</li>
<li>叶子权重的$l2$范数</li>
<li>……</li>
</ul>
</li>
<li><p>信息增益information gain → 训练误差</p>
</li>
<li>剪枝prunning → 由结点数定义的正则化</li>
<li>最大深度max depth → 函数空间的约束</li>
<li>smoothing leaf values → 叶子权重的$l2$正则</li>
</ul>
<h2 id="类别"><a href="#类别" class="headerlink" title="类别"></a>类别</h2><ul>
<li><strong>Gradient Boosted Machine</strong>：使用平方损失$l(y_i,\hat{y}_i)=(y_i-\hat{y}_i)^2$</li>
<li><strong>LogitBoost</strong>：使用Logistic损失<script type="math/tex; mode=display">l(y_i,\hat{y}_i)=y_i\ln{(1+e^{-\hat{y}_i})}+(1-y_i)\ln{(1+e^{\hat{y}_i})}</script></li>
</ul>
<h2 id="Pre-stopping"><a href="#Pre-stopping" class="headerlink" title="Pre-stopping"></a>Pre-stopping</h2><ul>
<li>stop split if the best split have negative gain</li>
<li>but maybe a split can benefit future splits</li>
</ul>
<h2 id="Post-Prunning"><a href="#Post-Prunning" class="headerlink" title="Post-Prunning"></a>Post-Prunning</h2><p>事后剪枝</p>
<ul>
<li>grow a tree to maximum depth, recursively prune all the leaf splits with negative gain</li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://homes.cs.washington.edu/~tqchen/data/pdf/BoostedTree.pdf" target="_blank" rel="noopener">Tianqi Chen - Introduction to Boosted Trees</a></li>
<li><a href="https://book.douban.com/subject/10590856/" target="_blank" rel="noopener">李航-统计学习方法</a></li>
<li><a href></a></li>
</ul>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>机器学习</tag>
        <tag>分类</tag>
        <tag>集成学习</tag>
        <tag>回归</tag>
        <tag>Boosting</tag>
      </tags>
  </entry>
  <entry>
    <title>Machine Learning | XGBoost</title>
    <url>/%E7%AE%97%E6%B3%95-XGBoost.html</url>
    <content><![CDATA[<p><center>eXtreme Gradient Boosting</center><br><a id="more"></a></p>
<h1 id="XGBoost"><a href="#XGBoost" class="headerlink" title="XGBoost"></a>XGBoost</h1><blockquote>
<p>作者：陈天奇<br>论文：<a href="http://dmlc.cs.washington.edu/data/pdf/XGBoostArxiv.pdf" target="_blank" rel="noopener">XGBoost: A Scalable Tree Boosting System</a></p>
<ul>
<li>是梯度提升树框架下的一种机器学习算法</li>
</ul>
</blockquote>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><ul>
<li><a href="https://github.com/dmlc/xgboost/blob/master/demo/README.md">Awesome XGBoost</a></li>
</ul>
<h1 id="XGBoost-vs-GBDT"><a href="#XGBoost-vs-GBDT" class="headerlink" title="XGBoost vs GBDT"></a>XGBoost vs GBDT</h1><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">GBDT</th>
<th style="text-align:center">XGBoost</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>基分类器</strong></td>
<td style="text-align:center">CART</td>
<td style="text-align:center">还支持线性分类器</td>
</tr>
<tr>
<td style="text-align:center"><strong>优化</strong></td>
<td style="text-align:center">梯度下降法<sup><a href="#fn_1" id="reffn_1">1</a></sup></td>
<td style="text-align:center">牛顿法<sup><a href="#fn_2" id="reffn_2">2</a></sup></td>
</tr>
<tr>
<td style="text-align:center"><strong>正则项</strong><sup><a href="#fn_3" id="reffn_3">3</a></sup></td>
<td style="text-align:center">没有</td>
<td style="text-align:center">有</td>
</tr>
<tr>
<td style="text-align:center"><strong>Learning rate</strong></td>
<td style="text-align:center"></td>
<td style="text-align:center">Shrinkage</td>
</tr>
<tr>
<td style="text-align:center"><strong>列抽样</strong></td>
<td style="text-align:center"></td>
<td style="text-align:center">支持列抽样<sup><a href="#fn_4" id="reffn_4">4</a></sup></td>
</tr>
<tr>
<td style="text-align:center"><strong>缺失值</strong></td>
<td style="text-align:center"></td>
<td style="text-align:center">可以自动学习出缺失值的分裂方向</td>
</tr>
</tbody>
</table>
</div>
<blockquote id="fn_1">
<sup>1</sup>. 在优化时只用到一阶导数信息<a href="#reffn_1" title="Jump back to footnote [1] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_2">
<sup>2</sup>. XGBoost对代价函数进行了二阶泰勒展开，同时使用了一阶导数和二阶导数的信息；XGBoost还支持自定义代价函数<a href="#reffn_2" title="Jump back to footnote [2] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_3">
<sup>3</sup>. 正则项降低了模型的Variance，学习得到的模型复杂度更低（防止过拟合）<a href="#reffn_3" title="Jump back to footnote [3] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_4">
<sup>4</sup>. XGBoost借鉴了随机森林的做法，支持列抽样（column sampling），既能降低过拟合，还能减少计算<a href="#reffn_4" title="Jump back to footnote [4] in the text."> &#8617;</a>
</blockquote>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://homes.cs.washington.edu/~tqchen/2016/03/10/story-and-lessons-behind-the-evolution-of-xgboost.html" target="_blank" rel="noopener">Story and Lessons Behind the Evolution of XGBoost</a></li>
<li><a href="https://www.zhihu.com/question/41354392" target="_blank" rel="noopener">机器学习算法中 GBDT 和 XGBOOST 的区别有哪些？</a></li>
<li><a href></a></li>
</ul>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>机器学习</tag>
        <tag>集成学习</tag>
        <tag>Boosting</tag>
      </tags>
  </entry>
  <entry>
    <title>数据分析 | 游戏类名词和指标</title>
    <url>/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90-%E6%B8%B8%E6%88%8F%E7%B1%BB%E5%90%8D%E8%AF%8D%E5%92%8C%E6%8C%87%E6%A0%87.html</url>
    <content><![CDATA[<p><center>Let's Playing Games!</center><br><a id="more"></a></p>
<h1 id="游戏数据名词"><a href="#游戏数据名词" class="headerlink" title="游戏数据名词"></a>游戏数据名词</h1><h2 id="A"><a href="#A" class="headerlink" title="A"></a>A</h2><h3 id="ACU"><a href="#ACU" class="headerlink" title="ACU"></a>ACU</h3><p>Average Concurrent Users<br>平均同时在线用户数</p>
<h3 id="APA"><a href="#APA" class="headerlink" title="APA"></a>APA</h3><p>Active Payment Account<br>活跃付费用户数</p>
<h3 id="ARPU"><a href="#ARPU" class="headerlink" title="ARPU"></a>ARPU</h3><p>Average Revenue Per User<br>平均每用户收入</p>
<script type="math/tex; mode=display">ARPU=\frac{总收入}{活跃用户AU}</script><h3 id="ARPPU"><a href="#ARPPU" class="headerlink" title="ARPPU"></a>ARPPU</h3><p>Average Revenue Per Paying User<br>平均每付费用户收入</p>
<script type="math/tex; mode=display">ARPPU=\frac{总收入}{活跃付费用户数APA}</script><h3 id="AU"><a href="#AU" class="headerlink" title="AU"></a>AU</h3><p>Active Users<br>活跃用户</p>
<ul>
<li>日活跃用户（DAU）</li>
<li>周活跃用户（WAU）</li>
<li>月活跃用户（MAU）</li>
</ul>
<h2 id="D"><a href="#D" class="headerlink" title="D"></a>D</h2><h3 id="DNU"><a href="#DNU" class="headerlink" title="DNU"></a>DNU</h3><p>Daily New Users<br>每日游戏中的新登入用户数量</p>
<h2 id="L"><a href="#L" class="headerlink" title="L"></a>L</h2><h3 id="LTV"><a href="#LTV" class="headerlink" title="LTV"></a>LTV</h3><p>Life Time Value<br>生命周期价值<br>平均一个用户在首次登录游戏到最后一个登录游戏期间内，为该游戏创造的收入总计</p>
<h2 id="P"><a href="#P" class="headerlink" title="P"></a>P</h2><h3 id="PU"><a href="#PU" class="headerlink" title="PU"></a>PU</h3><p>Paying User<br>付费用户</p>
<h3 id="PUR"><a href="#PUR" class="headerlink" title="PUR"></a>PUR</h3><p>Pay User Rate<br>付费比率</p>
<script type="math/tex; mode=display">PUR=\frac{活跃付费用户数APA}{活跃用户数AU}</script><h3 id="PCU"><a href="#PCU" class="headerlink" title="PCU"></a>PCU</h3><p>Peak Concurrent Users<br>最高同时在线玩家人数</p>
<h1 id="游戏类型"><a href="#游戏类型" class="headerlink" title="游戏类型"></a>游戏类型</h1><h2 id="ABA"><a href="#ABA" class="headerlink" title="ABA"></a>ABA</h2><p>Asymmetrical Battle Arena<br>非对称性对抗竞技类</p>
<blockquote>
<p>第五人格（网易）</p>
</blockquote>
<h2 id="ACT"><a href="#ACT" class="headerlink" title="ACT"></a>ACT</h2><p>Action Game<br>动作游戏</p>
<blockquote>
<ul>
<li>战神</li>
<li>鬼泣</li>
</ul>
</blockquote>
<h2 id="A-RPG"><a href="#A-RPG" class="headerlink" title="A-RPG"></a>A-RPG</h2><p>Action Role Playing Game<br>动作角色扮演游戏</p>
<blockquote>
<ul>
<li>真三国无双</li>
<li>剑灵</li>
<li>贪玩蓝月</li>
</ul>
</blockquote>
<h2 id="AVG"><a href="#AVG" class="headerlink" title="AVG"></a>AVG</h2><p>Adventure Game<br>冒险游戏、解谜游戏</p>
<blockquote>
<ul>
<li>纪念碑谷</li>
<li>机械迷城</li>
<li>饥荒</li>
<li>热血无赖</li>
</ul>
</blockquote>
<h2 id="A-AVG"><a href="#A-AVG" class="headerlink" title="A-AVG"></a>A-AVG</h2><p>Action Adventure Game<br>动作冒险游戏</p>
<blockquote>
<ul>
<li>古墓丽影</li>
<li>生化危机</li>
</ul>
</blockquote>
<h2 id="EDU"><a href="#EDU" class="headerlink" title="EDU"></a>EDU</h2><p>Education<br>养成类游戏</p>
<blockquote>
<ul>
<li>美少女梦工厂</li>
<li>明星志愿</li>
<li>奇迹暖暖</li>
</ul>
</blockquote>
<h2 id="ETC"><a href="#ETC" class="headerlink" title="ETC"></a>ETC</h2><p>Et Cetra<br>其他类型游戏；无法归入类型的游戏、玩家互动内容较少的游戏、作品类型不明了的游戏</p>
<blockquote>
<ul>
<li>恐怖惊魂夜</li>
<li>潘多拉魔盒</li>
</ul>
</blockquote>
<h2 id="FLY"><a href="#FLY" class="headerlink" title="FLY"></a>FLY</h2><p>模拟飞行</p>
<blockquote>
<ul>
<li>微软模拟飞行</li>
<li>飞行俱乐部</li>
</ul>
</blockquote>
<h2 id="FPS"><a href="#FPS" class="headerlink" title="FPS"></a>FPS</h2><p>First-person Shooter<br>第一人称视角射击游戏</p>
<blockquote>
<ul>
<li>CS</li>
<li>绝地求生（吃鸡）</li>
<li>守望先锋（网易代理）</li>
<li>使命召唤</li>
<li>荒野行动（网易研发；射击求生手游）</li>
</ul>
</blockquote>
<h2 id="FTG"><a href="#FTG" class="headerlink" title="FTG"></a>FTG</h2><p>Fighting Game<br>格斗游戏</p>
<blockquote>
<ul>
<li>拳皇</li>
<li>街霸</li>
<li>双截龙</li>
</ul>
</blockquote>
<h2 id="LVG"><a href="#LVG" class="headerlink" title="LVG"></a>LVG</h2><p>Love Game<br>恋爱游戏</p>
<blockquote>
<ul>
<li>恋与制作人</li>
</ul>
</blockquote>
<h2 id="MMORPG"><a href="#MMORPG" class="headerlink" title="MMORPG"></a>MMORPG</h2><p>Massive Multiplayer Online Role-playing Game<br>大型多人在线角色扮演游戏</p>
<blockquote>
<ul>
<li>魔兽世界（网易独家代理）</li>
<li>剑网3（西山居）</li>
<li>天下3</li>
<li>上古世纪</li>
<li>逆水寒（扮演类、角色类；网易开发）</li>
<li>梦幻西游（网易自行开发并营运）</li>
</ul>
</blockquote>
<h2 id="MMOARPG"><a href="#MMOARPG" class="headerlink" title="MMOARPG"></a>MMOARPG</h2><p>大型多人在线动作角色扮演游戏</p>
<h2 id="MOBA"><a href="#MOBA" class="headerlink" title="MOBA"></a>MOBA</h2><p>Multiplayer Online Battle Arena<br>多人联机在线竞技游戏；也可叫ARTS或类dota游戏</p>
<blockquote>
<ul>
<li><a href="http://dz.blizzard.cn/" target="_blank" rel="noopener">魔兽争霸</a><ul>
<li>暴雪娱乐开发</li>
<li><a href="http://dz.blizzard.cn/" target="_blank" rel="noopener">魔兽争霸官方对战平台</a>：网易研发运营，暴雪官方正式授权；平台提供1v1,2v2,Dota,RPG地图等游戏方式</li>
</ul>
</li>
<li>英雄联盟<ul>
<li>简称LOL（League of Legends）</li>
<li>美国拳头游戏开发</li>
<li>中国大陆地区腾讯游戏代理运营</li>
</ul>
</li>
<li>王者荣耀<ul>
<li>腾讯</li>
<li>腾讯第一5v5团队公平竞技手游</li>
</ul>
</li>
<li>决战！平安京<ul>
<li>网易首款MOBA手游</li>
<li>杭州网易雷火科技有限公司</li>
<li>2018年1月12日公测</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="MUD"><a href="#MUD" class="headerlink" title="MUD"></a>MUD</h2><p>Multiple User Domain<br>多用户虚拟空间游戏；文字网游的统称；没有图形</p>
<blockquote>
<ul>
<li>风云</li>
<li>书剑</li>
<li>英雄坛</li>
</ul>
</blockquote>
<h2 id="MUG"><a href="#MUG" class="headerlink" title="MUG"></a>MUG</h2><p>Music Game<br>音乐游戏</p>
<blockquote>
<ul>
<li>节奏大师</li>
<li>初音未来歌姬</li>
<li>古树旋律</li>
</ul>
</blockquote>
<h2 id="RAC"><a href="#RAC" class="headerlink" title="RAC"></a>RAC</h2><p>Race Game<br>赛车游戏、竞速游戏</p>
<blockquote>
<ul>
<li>极品飞车</li>
<li>狂野飙车</li>
<li>QQ跑跑卡丁车</li>
</ul>
</blockquote>
<h2 id="RPG"><a href="#RPG" class="headerlink" title="RPG"></a>RPG</h2><p>Role-Playing Game<br>角色扮演游戏</p>
<blockquote>
<ul>
<li>天下3</li>
<li>永恒之塔</li>
<li>魔兽世界</li>
<li>激战2</li>
<li>阴阳师<ul>
<li>RPG、卡牌类、即时类、扮演类、角色类</li>
<li>网易自主研发</li>
<li>2016年6月1日11:00开放Android首测；9月9日全平台公测</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="RTS"><a href="#RTS" class="headerlink" title="RTS"></a>RTS</h2><p>Real-Time Strategy Game<br>即时战略游戏；难度高，注意力集中</p>
<blockquote>
<ul>
<li>红色警戒</li>
<li>星际争霸</li>
<li>魔兽争霸</li>
<li>三国群英传</li>
<li>红警</li>
</ul>
</blockquote>
<h2 id="PUZ"><a href="#PUZ" class="headerlink" title="PUZ"></a>PUZ</h2><p>Puzzle Game<br>益智类游戏</p>
<blockquote>
<ul>
<li>俄罗斯方块</li>
<li>天天爱消除</li>
</ul>
</blockquote>
<h2 id="SIM"><a href="#SIM" class="headerlink" title="SIM"></a>SIM</h2><p>Simulation Game<br>模拟经营</p>
<blockquote>
<ul>
<li>模拟人生</li>
<li>模拟城市</li>
</ul>
</blockquote>
<h2 id="SLG"><a href="#SLG" class="headerlink" title="SLG"></a>SLG</h2><p>Strategy Game<br>策略游戏</p>
<blockquote>
<ul>
<li>汉王纷争</li>
<li>三国志</li>
<li>部落冲突</li>
<li>植物大战僵尸</li>
<li>保卫萝卜</li>
</ul>
</blockquote>
<h2 id="SPG"><a href="#SPG" class="headerlink" title="SPG"></a>SPG</h2><p>Sports Game<br>体育运动类游戏；也叫做SPT</p>
<blockquote>
<ul>
<li>热血篮球</li>
<li>热血足球</li>
<li>实况足球</li>
</ul>
</blockquote>
<h2 id="STG"><a href="#STG" class="headerlink" title="STG"></a>STG</h2><p>Shooting Game<br>射击游戏</p>
<blockquote>
<ul>
<li>求生之路</li>
<li>狙击英雄</li>
</ul>
</blockquote>
<h2 id="TAB"><a href="#TAB" class="headerlink" title="TAB"></a>TAB</h2><p>Table Game<br>桌面游戏、卡牌游戏</p>
<blockquote>
<ul>
<li>三国杀</li>
<li>游戏王</li>
<li>麻将</li>
<li>斗地主</li>
<li>大富翁</li>
<li>飞行棋</li>
</ul>
</blockquote>
<h2 id="TCG"><a href="#TCG" class="headerlink" title="TCG"></a>TCG</h2><p>Trading Card Game<br>集换式卡牌游戏</p>
<blockquote>
<ul>
<li>万智牌</li>
<li>炉石传说<ul>
<li>网易独家代理</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="TD"><a href="#TD" class="headerlink" title="TD"></a>TD</h2><p>Tower Defence<br>塔防游戏</p>
<blockquote>
<ul>
<li>梦塔防</li>
<li>植物大战僵尸</li>
</ul>
</blockquote>
<h2 id="TPS"><a href="#TPS" class="headerlink" title="TPS"></a>TPS</h2><p>Third-person Shooter<br>第三人称射击游戏</p>
<blockquote>
<ul>
<li>绝地求生<ul>
<li>韩国蓝洞开发</li>
<li>中国区<a href="https://pubg.qq.com/#section1" target="_blank" rel="noopener">腾讯</a>独家代理</li>
<li>战术竞技、沙盒、生存</li>
</ul>
</li>
<li>全球使命</li>
</ul>
</blockquote>
<h2 id="回合制"><a href="#回合制" class="headerlink" title="回合制"></a>回合制</h2><p>以回合算，轮流出招</p>
<blockquote>
<ul>
<li>梦幻西游</li>
<li>阴阳师</li>
</ul>
</blockquote>
<h2 id="挂机游戏、放置类游戏"><a href="#挂机游戏、放置类游戏" class="headerlink" title="挂机游戏、放置类游戏"></a>挂机游戏、放置类游戏</h2><blockquote>
<ul>
<li>旅行青蛙</li>
</ul>
</blockquote>
<h2 id="沙盒游戏"><a href="#沙盒游戏" class="headerlink" title="沙盒游戏"></a>沙盒游戏</h2><p>自由度高、随机时间多、创造性强</p>
<blockquote>
<ul>
<li>我的世界<ul>
<li>网易代理</li>
</ul>
</li>
</ul>
</blockquote>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://www.nowcoder.com/questionTerminal/c2922a68c6814e908a5a9a6c6c2c2e39" target="_blank" rel="noopener">对游戏数据名词“ACU”的正确解释</a></li>
<li><a href="https://www.cnblogs.com/batsing/p/8945299.html" target="_blank" rel="noopener">游戏类型术语</a></li>
<li><a href="https://baijiahao.baidu.com/s?id=1590728706876159827&amp;wfr=spider&amp;for=pc" target="_blank" rel="noopener">涨知识！游戏分类简称大全，你能说出几个？</a></li>
<li><a href="http://m.shouji.tgbus.com/view/167479/" target="_blank" rel="noopener">ARPU ARPPU傻傻分不清楚？手游收入指标名词解释</a></li>
</ul>
<h1 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h1><ul>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzUwOTg5MzE4OA==&amp;mid=2247488312&amp;idx=1&amp;sn=15cead99527e08af918f73a32c316d52&amp;chksm=f90a1c13ce7d95059d476d01dd8253fb3c1d434b46df724e02503fb1f2e5ff26809d3c524105&amp;scene=126&amp;sessionid=1590376367&amp;key=e224f213fcbe8475be62c0fcaeb46d561705d9b3b2b96aec55e6951c968a4144d43ade7fcd8c26ed6f649963fdb7075f37a80b2637f8f03a8eed837d1f0393e643f225279c447ef816eea9250b3a3734&amp;ascene=1&amp;uin=MjAwNDUzMjgxNw%3D%3D&amp;devicetype=Windows+10+x64&amp;version=62090070&amp;lang=zh_CN&amp;exportkey=AUNNELfk9ZRH2RYlfDCiNh4%3D&amp;pass_ticket=dumMe3Tdy3VO0qIoGgtupqmfKcMRb2kALcjVjgyoVh5XRcrNH2drjEVDLTpmJT%2Fl" target="_blank" rel="noopener">业务数据分析实战思路 —— 网络游戏</a></li>
</ul>
]]></content>
      <categories>
        <category>数据分析</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
        <tag>业务向</tag>
      </tags>
  </entry>
  <entry>
    <title>数据分析 | 业务分析主要指标</title>
    <url>/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90-%E4%B8%BB%E8%A6%81%E6%8C%87%E6%A0%87.html</url>
    <content><![CDATA[<p><center></center><br><a id="more"></a></p>
<blockquote>
<p>优先按照英文排序；若无英文，则按中文排序</p>
</blockquote>
<h1 id="不同行业的常见指标"><a href="#不同行业的常见指标" class="headerlink" title="不同行业的常见指标"></a>不同行业的常见指标</h1><h2 id="电商"><a href="#电商" class="headerlink" title="电商"></a>电商</h2><ul>
<li><strong>核心指标</strong><ul>
<li>PV、UV、成交用户数、成交订单数、GMV、客单价、退款率</li>
</ul>
</li>
<li><strong>流量数据</strong><ul>
<li>PV、UV、登录用户数、新访客数、商详页PV、商详页UV、店铺UV、点击地图（即各模块流量）</li>
</ul>
</li>
<li><strong>转化数据</strong><ul>
<li>成交转化率：通常为成交订单数/UV</li>
<li>支付率：下单数/支付数</li>
<li>动销率</li>
<li>收藏率</li>
<li>加购率</li>
</ul>
</li>
<li><strong>商品数据</strong><ul>
<li>店铺数、类目数、品牌数、在线商品数、SKU、SPU</li>
</ul>
</li>
<li><strong>用户数据</strong><ul>
<li>用户基础数据：地址、性别、年龄等</li>
<li>行为数据：访问留存、复购情况、会员数、人均购买次数、客单价、月活等</li>
</ul>
</li>
<li><strong>售后数据</strong><ul>
<li>售后反馈订单数、客服回复率、24h发货率、评价订单数、退单数（退单率）、退款金额（退款率）、退款原因</li>
</ul>
</li>
<li><strong>优惠券数据</strong><ul>
<li>优惠券领取量、使用量、优惠金额、优惠订单数、ROI(投资回报率)</li>
</ul>
</li>
<li><strong>活动数据</strong><ul>
<li>日常秒杀、双十一、618等大促活动</li>
<li>新增访客、新增注册</li>
<li>总UV、成交订单数、转化率、ROI</li>
</ul>
</li>
<li><strong>市场数据</strong><ul>
<li>市场占有率</li>
<li>用户份额</li>
<li>交易额排名</li>
<li>流量排名</li>
</ul>
</li>
</ul>
<h2 id="游戏"><a href="#游戏" class="headerlink" title="游戏"></a>游戏</h2><ul>
<li><strong>APP数据</strong><ul>
<li>推广页点击、下载、安装、激活、注册、进入游戏</li>
</ul>
</li>
<li><strong>流量数据</strong><ul>
<li>启动UV、新增账号、创角账号、活跃账号、付费账号、平均同时在线人数（ACU）、最高同时在线人数（PCU）、日/周/月活</li>
</ul>
</li>
<li><strong>用户数据</strong><ul>
<li>累计用户数</li>
<li>用户成长：等级分布、角色分布、升级时长</li>
<li>在线时长</li>
<li>启动次数</li>
<li>任务完成率</li>
<li>流失情况</li>
</ul>
</li>
<li><strong>收入数据</strong><ul>
<li>付费金额、付费人数、付费率、首充人数、首充金额、ARPU、LTV（生命周期价值）</li>
</ul>
</li>
<li><strong>粘性/留存</strong><ul>
<li>次日留存、总在线时长、平均在线时长、流失数据</li>
</ul>
</li>
</ul>
<h2 id="金融"><a href="#金融" class="headerlink" title="金融"></a>金融</h2><ol>
<li><strong>借贷</strong><ul>
<li><strong>核心数据</strong></li>
<li>访问UV、注册人数、申请人数、授信人数、授信总额、放款人数、放款总额</li>
<li><strong>细分数据</strong></li>
<li>借款金额分布、借款期限分布、首贷人数、复贷人数、平均完件时间、平均审批时间</li>
<li><strong>还款</strong></li>
<li>到期还款人数、到期还款率、预期人数、逾期率、净坏账</li>
<li><strong>用户数据</strong></li>
<li>性别、年龄、地址、学历、职业、征信情况等等</li>
</ul>
</li>
<li><strong>投资/理财</strong><ul>
<li>开户人数、累计总金额、当日存入总金额、当日取出总金额（到期兑付）、当日取出总金额（提取赎回）、存入订单数、存入人数、件均金额、当日收益</li>
</ul>
</li>
</ol>
<h2 id="直播"><a href="#直播" class="headerlink" title="直播"></a>直播</h2><ol>
<li><strong>用户端</strong><ul>
<li>UV、登录UV、直播间UV、弹幕发送UV、观看总时长、人均时长、观看时长分布、消费金额、充值金额、道具使用情况</li>
</ul>
</li>
<li><strong>主播端</strong><ul>
<li>主播人数、新增主播人数、签约主播人数、活跃开播主播人数、主播演出总场次、主播开播时长、直播时长、观看UV、峰值UV、粉丝数、播放视频个数、点赞人数、评论数、转发数、收藏数</li>
</ul>
</li>
<li><strong>留存</strong><ul>
<li>次日留存、周启动次数（如7日登录3日）、新用户留存情况</li>
</ul>
</li>
</ol>
<h2 id="阅读"><a href="#阅读" class="headerlink" title="阅读"></a>阅读</h2><ul>
<li><strong>流量数据</strong><ul>
<li>启动UV、新增UV、点击量、阅读PV、阅读UV</li>
</ul>
</li>
<li><strong>阅读数据</strong><ul>
<li>阅读UV、阅读总时长、人均阅读时长、作品收藏、作品评论数、阅读时长分布、书评数</li>
<li>书单数据：创建数、访问数、点赞数、收藏、分享</li>
<li>付费章节阅读UV、免费章节阅读UV、阅读字数、5分钟阅读人数占比、30天阅读天频、阅读章节数、人均阅读字数</li>
</ul>
</li>
<li><strong>收入数据</strong><ul>
<li>购买人数、购买章节数、人均付费收入、章节收入</li>
</ul>
</li>
</ul>
<h1 id="指标分类"><a href="#指标分类" class="headerlink" title="指标分类"></a>指标分类</h1><p>可将数据指标分为三大类：</p>
<ol>
<li>综合性指标<ul>
<li>非交易型网站：<ul>
<li><a href="#DAU">DAU</a></li>
<li>留存率</li>
<li>人均使用时长</li>
</ul>
</li>
<li>交易型网站：<ul>
<li><a href="#GMV">GMV</a></li>
<li>支付UV</li>
<li>人均订单数</li>
<li>人均客单价</li>
</ul>
</li>
</ul>
</li>
<li>流程性指标<ul>
<li>点击率</li>
<li>转化率</li>
<li>流失率</li>
<li>完成率</li>
</ul>
</li>
<li>业务性指标<ul>
<li>人均评论数</li>
<li>人均点赞数</li>
<li>人均分享数</li>
<li>人均播放数</li>
<li>……</li>
</ul>
</li>
</ol>
<h1 id="指标汇总"><a href="#指标汇总" class="headerlink" title="指标汇总"></a>指标汇总</h1><h2 id="ACU"><a href="#ACU" class="headerlink" title="ACU"></a>ACU</h2><p>平均同时在线人数（ACU，Average Concurrent Users）</p>
<h2 id="APA"><a href="#APA" class="headerlink" title="APA"></a>APA</h2><p>活跃付费用户数（Active Payment Account）</p>
<script type="math/tex; mode=display">活跃付费用户数（APA）=月活跃用户数（MAU）\times 月付费率（MPR）</script><div class="note info">
            <p>解决问题：</p><ul><li>产品的付费用户规模</li><li>APA的构成情况</li><li>付费群体的价值（整体稳定性分析）</li></ul>
          </div>
<h2 id="ARPU"><a href="#ARPU" class="headerlink" title="ARPU"></a>ARPU</h2><p>客单价/平均每用户收入（Average Revenue Per User）</p>
<ul>
<li>在统计时间内，活跃用户产生的平均收入（一般以月计）</li>
<li>ARPU用于产品定位初期的不同规模下的收入估计，也是LTV的重要参考依据</li>
</ul>
<script type="math/tex; mode=display">ARPU=\frac{总收入}{活跃用户AU}=\frac{Revenue}{User}</script><script type="math/tex; mode=display">Monthly\ ARPU=\frac{Revenue}{MAU}</script><div class="note info">
            <p>解决问题：</p><ul><li>不同渠道用户质量分析</li><li>产品收益贡献分析</li><li>活跃用户人均收入与投放成本的关系</li></ul>
          </div>
<h2 id="ARPPU"><a href="#ARPPU" class="headerlink" title="ARPPU"></a>ARPPU</h2><p>平均每付费用户收入（Average Revenue Per Paying User）</p>
<ul>
<li>在统计时间内，付费用户产生的平均收入（一般以月计）</li>
</ul>
<script type="math/tex; mode=display">ARPPU=\frac{总收入}{活跃付费用户数APA}</script><div class="note info">
            <p>解决问题：</p><ul><li>付费用户的付费能力和梯度变化</li><li>付费用户的整体付费趋势和不同付费阶层差异</li><li>对高付费用户的价值挖掘</li></ul>
          </div>
<h2 id="AU"><a href="#AU" class="headerlink" title="AU"></a>AU</h2><p>活跃用户（Active Users）</p>
<h3 id="DAU"><a href="#DAU" class="headerlink" title="DAU"></a>DAU</h3><p>日活跃用户数（DAU，Daily Active Users）：反映网站/APP/游戏的运营情况</p>
<div class="note info">
            <p>解决问题：</p><ul><li>核心用户规模</li><li>产品生命周期分析</li><li>产品活跃用户流失，分解活跃用户</li><li>用户活跃率</li></ul>
          </div>
<h3 id="MAU"><a href="#MAU" class="headerlink" title="MAU"></a>MAU</h3><p>月活跃用户数（MAU，Monthly Active Users）：最近一个月（30日，含当日）登录过应用的用户数；一般按照自然月计算</p>
<div class="note info">
            <p>解决问题：</p><ul><li>用户规模稳定性</li><li>推广效果评估</li><li>总体用户规模变化</li></ul>
          </div>
<h3 id="WAU"><a href="#WAU" class="headerlink" title="WAU"></a>WAU</h3><p>周活跃用户数（WAU，Weekly Active Users）：最近7日（含当日）登录过应用的用户数；一般按照自然周计算</p>
<div class="note info">
            <p>解决问题：</p><ul><li>周期性用户规模</li><li>周期性变化趋势（eg：推广期和非推广期的比较）</li></ul>
          </div>
<h2 id="CAC"><a href="#CAC" class="headerlink" title="CAC"></a>CAC</h2><ul>
<li><strong>获客成本</strong>（CAC，Customer Acquisition Cost）</li>
</ul>
<p>相关内容：<a href="#LTV">LTV</a></p>
<h2 id="DAOT"><a href="#DAOT" class="headerlink" title="DAOT"></a>DAOT</h2><p>活跃用户日均使用时长（DAOT，Daily Average Online Time）：了解参与黏性</p>
<script type="math/tex; mode=display">DAOT=\frac{日总在线时长}{日活跃用户数}</script><p>时长指标可分为</p>
<ul>
<li>单次使用时长</li>
<li>日使用时长</li>
<li>周使用时长</li>
<li>……</li>
</ul>
<div class="note info">
            <p>解决问题：</p><ul><li>分析产品的质量问题</li><li>观察不同时间维度的平均使用时长，了解不同用户群的习惯</li><li>渠道质量的衡量标准之一</li><li>留存分析的依据</li></ul>
          </div>
<h2 id="DNU"><a href="#DNU" class="headerlink" title="DNU"></a>DNU</h2><p>日新登用户数（DNU，Day New User）：每日注册并登录（游戏）的用户数 / 每日首次登录或启动APP的用户数</p>
<div class="note info">
            <p>解决问题：</p><ul><li>不同渠道贡献的用户份额</li><li>是否存在大量垃圾用户</li><li>注册转化率分析</li><li>宏观走势，确定投放策略</li></ul>
          </div>
<h2 id="DOU"><a href="#DOU" class="headerlink" title="DOU"></a>DOU</h2><p>日老用户（Day Old User）：每日登录的老用户。</p>
<h2 id="Enquiry"><a href="#Enquiry" class="headerlink" title="Enquiry"></a>Enquiry</h2><ul>
<li>询盘（Enquiry / Inquiry）：买方（或卖方）为了购买（或销售）某项商品，向对方询问有关交易条件的表示。在国际贸易的实际业务中，一般多由买方主动向卖方发出询盘。</li>
<li>询盘量：有意向购买的卖家发给卖家的询盘的数量</li>
</ul>
<h2 id="FR"><a href="#FR" class="headerlink" title="FR"></a>FR</h2><p>访问路径（FR，Flow Report）：用户在网站上的访问行为，各个页面的进入率和跳出率</p>
<h2 id="GMV"><a href="#GMV" class="headerlink" title="GMV"></a>GMV</h2><p>成交总额（GMV，Gross Merchandise Volume）：下单产生的总金额</p>
<script type="math/tex; mode=display">GMV=销售额+取消订单金额+退款金额</script><h2 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h2><p><strong>IP</strong>（Internet Protocol）：访问过该网站的IP总数；以用户的IP地址作为统计依据。</p>
<ul>
<li>同一天00:00-24:00内相同IP地址仅计算一次</li>
</ul>
<h2 id="LT"><a href="#LT" class="headerlink" title="LT"></a>LT</h2><p><strong>用户生命周期</strong>（LT，Life Time）：也称留存天数，从用户第一天使用产品到最后一天使用产品的天数。</p>
<p>LT计算方法：</p>
<ol>
<li>全样本统计</li>
<li>倒推法</li>
<li>经验公式</li>
<li>月活跃天数</li>
</ol>
<h3 id="全样本统计"><a href="#全样本统计" class="headerlink" title="全样本统计"></a>全样本统计</h3><p>加总所有用户的留存天数，并取平均，即留存天数。</p>
<p>优点：</p>
<ul>
<li>能够反映当前留存天数</li>
</ul>
<p>缺点：</p>
<ul>
<li>该方法非常不灵敏；通常要求样本要足够大、时间跨度要足够长，得到的留存天数才会相对准确一些</li>
</ul>
<h3 id="倒推法"><a href="#倒推法" class="headerlink" title="倒推法"></a>倒推法</h3><h3 id="月活跃天数"><a href="#月活跃天数" class="headerlink" title="月活跃天数"></a>月活跃天数</h3><p>$\frac{DAU}{MAU}\times 该月的天数$：可以看出用户每月访问应用的平均天数；但是只用某天的DAU来计算月活跃天数，可能会因为周期性或特殊日期造成偏差，应该使用下面的公式计算月活跃天数：</p>
<script type="math/tex; mode=display">\frac{当月每天DAU的总和}{MAU}</script><ul>
<li>月活跃天数是用于评估<strong>用户黏性</strong>的一个重要指标</li>
<li>DAU/MAU一般介于3.33%~100%</li>
<li>结合产品属性、时间考量、版本更新、运营活动、用户维度等进行分析<blockquote>
<p>移动游戏一般以20%为基线，工具类APP会以40%为基线</p>
</blockquote>
</li>
</ul>
<h2 id="LTV"><a href="#LTV" class="headerlink" title="LTV"></a>LTV</h2><p><strong>用户生命周期价值</strong>（LTV，Life Time Value）：公司从用户的互动中得到的全部经济收益的总和（获客至流失所得的收益总和）；不区分付费与非付费用户</p>
<ol>
<li><p>每日的留存率乘以每日的用户平均收入</p>
<script type="math/tex; mode=display">LTV = \sum_{t=1}^TR(t)\cdot ARPU(t)</script></li>
<li><p>生命周期总长度乘以每用户平均收入</p>
<script type="math/tex; mode=display">LTV = ARPU \times LT（按天或月计算的平均生命周期）</script></li>
</ol>
<p>两个公式是等价的，后面的公式是前面的公式的简化。</p>
<div class="note default">
            <p>实际计算：跟踪某日或某周的新增用户，计算该批用户在随后的7日、14日、30日的累积收入贡献，除以该批新增用户数，即为累积收入/新增用户数=累积ARPU（LTV）</p>
          </div>
<div class="note info">
            <p>解决问题：</p><ul><li>用户收益贡献周期（回报周期）</li><li>用户群与渠道的利润贡献</li><li>验证盈利模式</li></ul><p>作用：</p><ul><li>辅助决策</li></ul>
          </div>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">LTV</th>
<th style="text-align:center"><a href="#cac">CAC</a></th>
<th style="text-align:left">决策</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">高</td>
<td style="text-align:center">低</td>
<td style="text-align:left">加入投入</td>
</tr>
<tr>
<td style="text-align:center">低</td>
<td style="text-align:center">高</td>
<td style="text-align:left">放弃投入</td>
</tr>
<tr>
<td style="text-align:center">低</td>
<td style="text-align:center">低</td>
<td style="text-align:left">控制比例投入，用于提升用户规模</td>
</tr>
<tr>
<td style="text-align:center">高</td>
<td style="text-align:center">高</td>
<td style="text-align:left">控制比例投入，用于提升付费率</td>
</tr>
</tbody>
</table>
</div>
<h2 id="MVP"><a href="#MVP" class="headerlink" title="MVP"></a>MVP</h2><p>最小可行性产品（MVP）</p>
<h2 id="PCT"><a href="#PCT" class="headerlink" title="PCT"></a>PCT</h2><p><strong>客单价</strong>（Per Customer Transaction）：平均交易金额/顾客平均购买商品的金额</p>
<script type="math/tex; mode=display">客单价=销售总额/成交总笔数</script><p> 或</p>
<script type="math/tex; mode=display">客单价=商品平均单价\times每一个顾客平均购买商品个数</script><p> 或</p>
<script type="math/tex; mode=display">客单价=动线长度\times停留率\times注目率\times购买率\times购买个数\times商品单价</script><h2 id="PCU"><a href="#PCU" class="headerlink" title="PCU"></a>PCU</h2><p>最高同时在线人数（PCU，Peak Concurrent Users）</p>
<h2 id="PMF"><a href="#PMF" class="headerlink" title="PMF"></a>PMF</h2><p>PMF（Product/Market Fit）：产品与市场相契合的状态</p>
<h2 id="PPC"><a href="#PPC" class="headerlink" title="PPC"></a>PPC</h2><p>点击付费广告（PPC，Pay Per Click）</p>
<h2 id="PR-PUR"><a href="#PR-PUR" class="headerlink" title="PR/PUR"></a>PR/PUR</h2><p>付费比率（Pay User Rate）/付费率/付费渗透率（PR，Payment Ratio）：付费用户数占活跃用户的比例</p>
<script type="math/tex; mode=display">PUR=\frac{活跃付费用户数APA}{活跃用户数AU}</script><ul>
<li><strong>日付费率</strong>（DPR，Daily Payment Ratio）</li>
<li><strong>月付费率</strong>（MPR，Monthly Payment Ratio）</li>
</ul>
<div class="note info">
            <p>解决问题：</p><ul><li>产品的收益转化能力标准</li><li>用户付费关键点和转化周期</li><li>付费转化效果评估</li></ul>
          </div>
<ul>
<li><strong>月付费用户数</strong>（MPU，Month Payment Users）</li>
<li><strong>活跃付费用户数</strong>（APA）=月活跃用户数（MAU）×月付费率（MPR）</li>
</ul>
<h2 id="PV"><a href="#PV" class="headerlink" title="PV"></a>PV</h2><p><strong>页面浏览量</strong>（PV，Page View）：网站在某一段时间内的页面浏览量是多少</p>
<ul>
<li>用户每一次对网站中的每个网页访问均被记录一个PV</li>
</ul>
<h2 id="Retention"><a href="#Retention" class="headerlink" title="Retention"></a>Retention</h2><p>留存率：用户在某段时间开始使用应用，经过一段时间后，仍然继续使用该应用的用户占当时新增用户的比例，即留存率</p>
<ul>
<li>留存用户和留存率体现了应用的质量和保留用户的能力</li>
<li><p>包括新增用户留存、活跃用户留存</p>
</li>
<li><p>$次日留存率=\frac{在t日注册并在t+1日还登录的用户数}{t日新增用户数}$</p>
</li>
<li>$第3日留存率=\frac{在t日注册并在t+3日还登录的用户数}{t日新增用户数}$</li>
<li>$第7日留存率=\frac{在t日注册并在t+7日还登录的用户数}{t日新增用户数}$</li>
<li>$第30日留存率=\frac{在t日注册并在t+30日还登录的用户数}{t日新增用户数}$</li>
</ul>
<blockquote>
<p>+3、+7、+30，强调新增当日不计入</p>
</blockquote>
<div class="note info">
            <p>解决问题：</p><ul><li>应用质量评估</li><li>用户质量评估</li><li>用户规模衡量</li></ul>
          </div>
<ul>
<li><strong>日流失率</strong>（Day 1 Churn Ratio）=$\frac{t日登录应用但随后7日未登录应用的活跃用户数}{t日活跃用户数}$</li>
<li><strong>周流失率</strong>（Week Churn Ratio）=$\frac{t周登录过应用但随后一周未登录应用的用户数}{t周周活跃用户数}$</li>
<li><strong>月流失率</strong>（Month Churn Ratio）=$\frac{t月登录过应用但随后一个月未登录应用的用户数}{t月月活跃用户数}$</li>
</ul>
<div class="note info">
            <p>解决问题：</p><ul><li>活跃用户生命周期分析</li><li>渠道的变化情况</li><li>版本更新对用户流失的影响评估</li><li>拉动收入的运营手段变化对用户流失的影响评估</li><li>行业比较</li><li>产品中期评估</li></ul>
          </div>
<h2 id="ROI"><a href="#ROI" class="headerlink" title="ROI"></a>ROI</h2><p>投资回报率（ROI，Return On Investment）</p>
<script type="math/tex; mode=display">ROI=\frac{利润总额}{投入成本总额}\times 100%</script><h2 id="SEO"><a href="#SEO" class="headerlink" title="SEO"></a>SEO</h2><ul>
<li>搜索引擎优化（SEO，Search Engine Optimization）</li>
</ul>
<h2 id="SKU-SPU"><a href="#SKU-SPU" class="headerlink" title="SKU | SPU"></a>SKU | SPU</h2><ul>
<li><strong>SKU</strong>（Stock Keeping Unit）库存量单位：也称最小库存单元、最小库存单位、最小存货单位、单品等，<ul>
<li>对电商而言，SKU是指一款商品；一款商品多色，则有多个SKU</li>
</ul>
</li>
<li><strong>SPU</strong>（Standard Product Unit）标准产品单位：商品信息聚合的最小单位<ul>
<li>商品的特性可以由多个“属性/属性值对”进行描述；属性/属性值对完全相同的商品，可以抽象为一个SPU<blockquote>
<p>eg：HUAWEI MATE 50 可以确定一个产品，即为一个SPU</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h2 id="TGI"><a href="#TGI" class="headerlink" title="TGI"></a>TGI</h2><p>目标群体指数（TGI，Target Group Index）</p>
<script type="math/tex; mode=display">TGI指数=\frac{目标群体中具有某一特征的群体所占比例}{总体中具有相同特征的群体所占比例}\times 标准数100</script><ul>
<li>TGI越大，目标人群对该领域的偏好越强</li>
<li>$TGI &gt; 100$说明该人群在整体人群中偏好度偏高</li>
<li>$TGI &lt; 100$说明该人群在整体人群中偏好度偏低</li>
<li>$TGI$越接近100，越说明该人群与整体人群偏好度相当。<blockquote>
<p>标准数是100，不是100%。</p>
</blockquote>
</li>
</ul>
<p>TGI<br>需要明确下面三者分别是什么：</p>
<ul>
<li>目标群体</li>
<li>特征</li>
<li>总体</li>
</ul>
<div class="note default">
            <p>假设XX学校内的小王麻辣烫，每天光顾的顾客男女比例1:1，XX学校的男女比例为4:6，则男生还是女生更倾向于光顾小王麻辣烫呢？</p><ul><li>目标：小王麻辣烫当天光顾的顾客</li><li>特征：男性顾客</li><li>总体：XX学校的学生</li><li>$男生的TGI=\frac{男生光顾这家店的比例}{整体上男生的比例}\times 100=\frac{50\%}{40\%}\times 100=125$</li><li>$女生的TGI=\frac{女生光顾这家店的比例}{整体上女生的比例}\times 100=\frac{50\%}{60\%}\times 100=83.33$</li></ul><p>男生的TGI大于女生的TGI，说明男生光顾这家麻辣烫的倾向性大于女生。</p>
          </div>
<blockquote>
<p>淘宝关于喜好度的定义：<br>喜好度（TGI）：反映不同人群对该搜索词的偏好程度，数值越大则偏好程度越高。</p>
<ul>
<li>数据为100时，表示无明显偏好</li>
<li>该数值不受人群基数的影响<script type="math/tex; mode=display">喜好度（TGI）=\frac{搜索词的该人群占比}{全网的该人群占比}\times 100</script></li>
</ul>
</blockquote>
<h2 id="TS"><a href="#TS" class="headerlink" title="TS"></a>TS</h2><p>渠道来源（Traffic Sources）：用户流量来源于哪些不同的渠道</p>
<h2 id="UD"><a href="#UD" class="headerlink" title="UD"></a>UD</h2><p>访客特征（UD，User Demographics）：访问用户具有哪些特征值，可用来做用户分类</p>
<h2 id="UV"><a href="#UV" class="headerlink" title="UV"></a>UV</h2><ul>
<li><p><strong>UV</strong>（Unique Visitor）：通过互联网访问、浏览该网站的自然人；一台电脑客户端视为一个访客。</p>
<ul>
<li>独立UV以浏览器cookie为依据；只要cookie不清除，同一天00:00-24:00内相同的客户端只被计算一次（2个人用不同的账号登录同一台电脑的同一个浏览器，只记录一个UV）</li>
<li>一天内同个访客多次访问仅计算一个UV</li>
<li>月UV等于日UV之和</li>
</ul>
</li>
<li><p><strong>用户浏览量</strong>（UV，User View）：网站在某一段时间内的用户浏览量是多少</p>
</li>
</ul>
<h2 id="VV"><a href="#VV" class="headerlink" title="VV"></a>VV</h2><p>VV（Visit View）：统计所有访客一天内访问网站的次数</p>
<ul>
<li>访客完成浏览并最终关掉该网站的所有页面即完成一次访问（Visit）</li>
<li>同一访客一天内可能有多次访问行为</li>
</ul>
<h2 id><a href="#" class="headerlink" title=" "></a> </h2><ul>
<li>VIP顾客销售额占比（%）：用于判断店铺会员贡献<script type="math/tex; mode=display">VIP顾客销售额占比=\frac{会员顾客消费金额}{总销售额}\times100\%</script></li>
</ul>
<h1 id="如何获取指标"><a href="#如何获取指标" class="headerlink" title="如何获取指标"></a>如何获取指标</h1><p><strong>埋点！！！</strong></p>
<a href="/%E6%95%B0%E6%8D%AE-%E6%95%B0%E6%8D%AE%E5%9F%8B%E7%82%B9.html" title="埋点">埋点</a>是数据采集的基础，通过埋点，可以：
- 获得用户的行为轨迹
- 追踪任一时间段数据的变化
- 验证策略可行性
- 找出产品设计漏洞
- ……

# 数据分析与设计方法
- 事件分析
- 留存分析
- 漏斗分析
- 用户分群分析
- 对比分析
- 多维度拆解

## 事件分析
事件即追踪或记录的用户行为或业务过程。
- 事件是通过<a href="/%E6%95%B0%E6%8D%AE-%E6%95%B0%E6%8D%AE%E5%9F%8B%E7%82%B9.html" title="埋点">埋点</a>记录、通过SDK上传的用户行为或业务过程记录
- 一个事件可能包含多个事件属性

> 一个视频内容的产品可能包含的事件有：播放视频、暂停播放、继续播放、分享视频、发表评论、点赞等
> 事件“播放视频”可能包含的属性有：视频来源、视频标题、是否自动播放、视频时长等

## 留存分析
- 留存率是验证用户粘性的关键指标
- 可以利用留存率与竞品对标，衡量用户的粘性和忠诚度
- 通常重点关注次日留存率、3日留存率、7日留存率、30日留存率，并观察留存率的衰减程度

## 漏斗分析
漏斗分析，即转化率分析，通过计算目标流程中的起点，到最后完成目标节点的用户量与留存率
- 衡量每一节点的转化率，通过异常数据找出异常节点
- 确定各个环节的流失率，分析用户怎么流失、为什么流失、在哪里流失
- 根据数据改进产品，从而提升整体转化率
- 经典的流量漏斗模型：<a href="/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90-AARRR%E6%A8%A1%E5%9E%8B.html" title="AARRR模型">AARRR模型</a>
<h2 id="用户分群分析"><a href="#用户分群分析" class="headerlink" title="用户分群分析"></a>用户分群分析</h2><p>用户在某个特定条件下的用户分组或占比</p>
<h2 id="对比分析"><a href="#对比分析" class="headerlink" title="对比分析"></a>对比分析</h2><p>将不同时段的数据进行对比，找出差异，进行产品优化或验证设计</p>
<ul>
<li>自身产品对比：对比产品不同模块相似场景的数据，找出问题点</li>
<li>行业产品对比：与同行业产品进行对比，找出优劣势，并持续优化</li>
</ul>
<h2 id="多维度拆解"><a href="#多维度拆解" class="headerlink" title="多维度拆解"></a>多维度拆解</h2><p>用不同维度视角拆分分析同一类数据指标</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://baijiahao.baidu.com/s?id=1611777819781232073&amp;wfr=spider&amp;for=pc" target="_blank" rel="noopener">SPU和SKU都是什么意思</a></li>
<li><a href="https://www.jianshu.com/p/a94d6f102108" target="_blank" rel="noopener">电商业务中大家都说的SKU是啥</a></li>
<li><a href="https://www.zhihu.com/question/20448467" target="_blank" rel="noopener">如何清楚易懂地解释“UV”和“PV”的定义？</a></li>
<li><a href="http://m.shouji.tgbus.com/view/167479/" target="_blank" rel="noopener">ARPU ARPPU傻傻分不清楚？手游收入指标名词解释</a></li>
<li>《精益数据分析》</li>
<li><a href="http://www.woshipm.com/operate/2439119.html" target="_blank" rel="noopener">用户分析 | 如何建立超详细的AARRR模型数据指标体系？</a></li>
<li><a href="http://shanzhaozhang.lofter.com/post/1e096217_f735a93" target="_blank" rel="noopener">用户留存率及DNU,DAU,WAU,MAU关系</a></li>
<li><a href="https://baike.baidu.com/item/AARRR/6962373?fr=aladdin" target="_blank" rel="noopener">百度百科-AARRR</a></li>
<li><a href="http://www.woshipm.com/operate/1518912.html" target="_blank" rel="noopener">AARRR已是过去式，而RARRA才是更好的增长黑客模型</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU5NDgyMjc0OQ==&amp;mid=2247488624&amp;idx=2&amp;sn=920c8875c2f3d33566e8c9de98a64406&amp;chksm=fe7a0742c90d8e540391f59924a3300cf917a89421d095d6e96d3bc88c447ed18c2275d119f9&amp;mpshare=1&amp;scene=24&amp;srcid=&amp;sharer_sharetime=1590564263763&amp;sharer_shareid=b539221659d6ecf12200314308b58dd3&amp;key=f35cd863eee202dce2e28017bc4094d1b2859bf5881092f4a055994b9e3467a965866061333034fb99b5cc0c774872ef04131c5755d1a55d542f19d23d6b377059875500a47021443c87f06051d831a4&amp;ascene=14&amp;uin=MjAwNDUzMjgxNw%3D%3D&amp;devicetype=Windows+10+x64&amp;version=62090070&amp;lang=zh_CN&amp;exportkey=AWstGTboQZQZLrI9jEzLFvs%3D&amp;pass_ticket=xoArabHCscAdV4DACRCVDCInO%2Bwgm6vCxCiSKNK2RM55GLTfFThL1GA6XQ9Qdhep" target="_blank" rel="noopener">数据分析：不同行业的常见指标</a></li>
<li><a href="www.woshipm.com/pmd/645579.html">浅谈计算留存天数的三种方法</a></li>
<li><a href="http://mp.weixin.qq.com/s?__biz=MzU4OTQ1MTA4OQ==&amp;mid=2247487676&amp;idx=2&amp;sn=f688d183f0621b21a871d89fcb5a8d48&amp;chksm=fdcc0a82cabb839402dc2b3fb7e6d56401183808545f47b98fae230b084f99050785a103d6fe&amp;mpshare=1&amp;scene=24&amp;srcid=0818Yq9tldgFJGEiMxsGjYyy&amp;sharer_sharetime=1597725059037&amp;sharer_shareid=b539221659d6ecf12200314308b58dd3#rd" target="_blank" rel="noopener">数据指标基础知识汇总</a></li>
<li><a href="zhihu.com/question/27115577">偏好度（TGI）是如何计算的，以及如何理解这个指标？</a></li>
</ul>
]]></content>
      <categories>
        <category>数据分析</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
        <tag>业务向</tag>
      </tags>
  </entry>
  <entry>
    <title>如何防止过拟合？</title>
    <url>/%E7%AE%97%E6%B3%95-%E8%BF%87%E6%8B%9F%E5%90%88.html</url>
    <content><![CDATA[<p><center>Overfitting</center><br><a id="more"></a></p>
<h1 id="过拟合"><a href="#过拟合" class="headerlink" title="过拟合"></a>过拟合</h1><p>随着模型训练的进行，模型的复杂度增加，模型在训练数据集上的训练误差（training error）逐渐减小，但是在模型的复杂度达到一定程度时，模型在验证数据集上的误差反而随着模型的复杂度增加而增大，此时便发生了<strong>过拟合</strong>。</p>
<h2 id="防止过拟合"><a href="#防止过拟合" class="headerlink" title="防止过拟合"></a>防止过拟合</h2><ul>
<li>early stopping</li>
<li>Data augmentation</li>
<li>Regularization</li>
<li>Dropout</li>
</ul>
<h3 id="Early-Stopping"><a href="#Early-Stopping" class="headerlink" title="Early Stopping"></a>Early Stopping</h3><p>迭代次数截断，在模型对训练数据集迭代收敛之前停止迭代来防止过拟合。</p>
<p>具体做法：<br>在每一个Epoch<sup><a href="#fn_1" id="reffn_1">1</a></sup>结束时，计算验证数据集的准确率（accuracy），当准确率不再提高时，就停止训练。</p>
<blockquote>
<p>一般的做法：在训练的过程中，记录到目前为止最好的验证集准确率，当连续n次Epoch没有达到最佳准确率时，则可认为准确率不再提高了，此时便可停止迭代。<br>即：</p>
<script type="math/tex; mode=display">No-improvement-in-n</script><p>$n$是Epoch的次数，根据实际情况选取。</p>
</blockquote>
<blockquote id="fn_1">
<sup>1</sup>. 一个Epoch集：对所有的训练数据的一轮遍历<a href="#reffn_1" title="Jump back to footnote [1] in the text."> &#8617;</a>
</blockquote>
<h3 id="扩增数据集"><a href="#扩增数据集" class="headerlink" title="扩增数据集"></a>扩增数据集</h3><p>获得更多的符合要求的数据</p>
<p>获取方法：</p>
<ul>
<li>从数据源头采集更多数据</li>
<li>复制原有数据并加上随机噪声</li>
<li>重采样（Bootstrap）</li>
<li>根据当前数据集估计数据分布参数，使用该分布生成更多数据</li>
</ul>
<h3 id="正则化"><a href="#正则化" class="headerlink" title="正则化"></a>正则化</h3><p>在对目标函数/代价函数优化时，在目标函数/代价函数后添加一个正则项（惩罚项）——降低模型的复杂度</p>
<ul>
<li>$l1$正则<ul>
<li>使用$l1$正则可以得到稀疏的权值</li>
</ul>
</li>
<li>$l2$正则<ul>
<li>使用$l2$正则可以得到平滑的权值</li>
</ul>
</li>
</ul>
<h4 id="l1-正则"><a href="#l1-正则" class="headerlink" title="$l1$正则"></a>$l1$正则</h4><h4 id="l2-正则"><a href="#l2-正则" class="headerlink" title="$l2$正则"></a>$l2$正则</h4><h3 id="Dropout"><a href="#Dropout" class="headerlink" title="Dropout"></a>Dropout</h3><p>通过修改ANN（人工神经网络）中隐藏层的神经元个数来防止ANN的过拟合</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://blog.csdn.net/heyongluoyao8/article/details/49429629" target="_blank" rel="noopener">机器学习中防止过拟合的处理方法</a></li>
<li><a href="https://juejin.im/post/5b441583f265da0fb01854c4" target="_blank" rel="noopener">机器学习中用来防止过拟合的方法有哪些？</a></li>
</ul>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Machine Learning | CLARANS</title>
    <url>/%E7%AE%97%E6%B3%95-CLARANS.html</url>
    <content><![CDATA[<p><center>A Clustering Algorithm based in Randomized Search</center><br><a id="more"></a></p>
<p>CLARANS</p>
<p>基于随机选择的聚类算法/随机搜索聚类算法</p>
<h1 id="CLARANS"><a href="#CLARANS" class="headerlink" title="CLARANS"></a>CLARANS</h1><ul>
<li>一种分割聚类算法</li>
<li>在CLARA算法的基础上提出的</li>
<li>时间复杂度大约是$O(n^2)$</li>
<li>计算效率较低</li>
<li>对数据输入顺序敏感</li>
<li>只能聚类凸形或球形边界</li>
</ul>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><ol>
<li>随机选择一个点作为当前点</li>
<li>随机检查它周围不超过MaxNeighbor个的邻接点</li>
</ol>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://zhuanlan.zhihu.com/p/22417979" target="_blank" rel="noopener">聚类分析中几种算法的比较</a></li>
<li><a href="https://blog.csdn.net/u011955252/article/details/50805095" target="_blank" rel="noopener">文本挖掘之聚类算法之CLARANS（基于随机选择的聚类算法）</a></li>
</ul>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>机器学习</tag>
        <tag>聚类</tag>
      </tags>
  </entry>
  <entry>
    <title>Python | sklearn</title>
    <url>/python-sklearn.html</url>
    <content><![CDATA[<p><center>Scikit-learn</center><br><a id="more"></a></p>
<h1 id="Scikit-learn"><a href="#Scikit-learn" class="headerlink" title="Scikit-learn"></a>Scikit-learn</h1><h2 id="liner-model"><a href="#liner-model" class="headerlink" title="liner_model"></a>liner_model</h2><h3 id="LinearRegression"><a href="#LinearRegression" class="headerlink" title="LinearRegression()"></a>LinearRegression()</h3><p>LinearRegression()：用于拟合线性回归模型。在sklearn库中的linear_model模块中。</p>
<ul>
<li><code>.fit()</code>：拟合模型</li>
<li><code>.predict()</code>：预测结果</li>
<li><code>.coef_[0]</code>：一元线性回归中，特征变量的参数估计值</li>
<li><code>.coef_[:]</code> ：多元线性回归中，特征变量的参数估计值</li>
<li><code>.intercept_</code> ：一元线性回归中，截距项的估计值</li>
<li><code>.score()</code>：看测试集的表现得分</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">###导入线性回归模型</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LinearRegression</span><br><span class="line"></span><br><span class="line">%matplotlib inline</span><br><span class="line"></span><br><span class="line">X = [[<span class="number">1</span>], [<span class="number">4</span>]]   <span class="comment">###两个点的横坐标</span></span><br><span class="line">y = [<span class="number">3</span>, <span class="number">5</span>]   <span class="comment">###两个点的纵坐标</span></span><br><span class="line"></span><br><span class="line">lr = LinearRegression().fit(X, y)</span><br><span class="line">z = np.linspace(<span class="number">0</span>, <span class="number">5</span>, <span class="number">20</span>)</span><br><span class="line">plt.scatter(X, y, s= <span class="number">50</span>)   <span class="comment">###参数s设置点的大小</span></span><br><span class="line">plt.plot(z, lr.predict(z.reshape(<span class="number">-1</span>, <span class="number">1</span>)), c=<span class="string">'green'</span>)</span><br><span class="line">plt.title(<span class="string">"Straight Line"</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><meta name="referrer" content="no-referrer"><br><img src="/python-sklearn/output_0_0.png" class></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="string">"y = &#123;:.4f&#125;"</span>.format(lr.coef_[<span class="number">0</span>]),<span class="string">"x"</span>,<span class="string">"+&#123;:.4f&#125;"</span>.format(lr.intercept_))</span><br></pre></td></tr></table></figure>
<pre><code>y = 0.6667 x +2.3333
</code></pre><p>考虑多个数据点的线性回归：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment">###首先生成数据集</span></span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> make_regression</span><br><span class="line"></span><br><span class="line">X ,y = make_regression(n_samples=<span class="number">100</span>, n_features=<span class="number">1</span>, </span><br><span class="line">                      n_informative=<span class="number">1</span>, noise=<span class="number">50</span>, random_state=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LinearRegression</span><br><span class="line"><span class="comment">###拟合</span></span><br><span class="line">reg = LinearRegression()</span><br><span class="line">reg.fit(X, y)</span><br><span class="line">z = np.linspace(<span class="number">-3</span>, <span class="number">3</span>, <span class="number">200</span>).reshape(<span class="number">-1</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">plt.scatter(X, y, c=<span class="string">'blue'</span>, s=<span class="number">50</span>)</span><br><span class="line">plt.plot(z, reg.predict(z), c=<span class="string">'k'</span>)</span><br><span class="line">plt.title(<span class="string">"Linear Regression"</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><meta name="referrer" content="no-referrer"><br><img src="/python-sklearn/output_2_0.png" class></p>
<p>糖尿病数据，线性回归：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">###加载糖尿病数据集</span></span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_diabetes</span><br><span class="line"></span><br><span class="line">X, y = load_diabetes().data, load_diabetes().target</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(X, y, random_state=<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LinearRegression</span><br><span class="line">lr = LinearRegression().fit(X_train, y_train)</span><br><span class="line"></span><br><span class="line">print(<span class="string">"训练数据集得分：&#123;:.3f&#125;"</span>.format(lr.score(X_train, y_train)))</span><br><span class="line">print(<span class="string">"测试数据集得分：&#123;:.3f&#125;"</span>.format(lr.score(X_test, y_test)))</span><br></pre></td></tr></table></figure>
<pre><code>训练数据集得分：0.530
测试数据集得分：0.459
</code></pre><ul>
<li><strong>损失函数</strong>（Loss Function），也称<strong>成本函数</strong>（Cost Function），用于定义模型预测值与观测值的误差。</li>
<li><strong>残差</strong>（residuals）/<strong>训练误差</strong>（training errors）：模型预测值与训练集数据的差异。</li>
<li><strong>预测误差</strong>（prediction errors）/<strong>测试误差</strong>（test errors）：模型预测值与测试集数据的差异。</li>
</ul>
<p>考虑带损失函数的模型拟合结果评估（标注残差、计算残差平方和）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X = [[<span class="number">6</span>], [<span class="number">8</span>], [<span class="number">10</span>], [<span class="number">14</span>], [<span class="number">18</span>]]</span><br><span class="line">y = [[<span class="number">7</span>], [<span class="number">9</span>], [<span class="number">13</span>], [<span class="number">17.5</span>], [<span class="number">18</span>]]</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LinearRegression</span><br><span class="line">model = LinearRegression()</span><br><span class="line">model.fit(X, y)</span><br><span class="line">X2 = [[<span class="number">0</span>], [<span class="number">10</span>], [<span class="number">14</span>], [<span class="number">25</span>]]</span><br><span class="line">y2 = model.predict(X2)</span><br><span class="line"></span><br><span class="line"><span class="comment">###残差</span></span><br><span class="line">yr = model.predict(X)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">%matplotlib inline</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">plt.plot(X, y, <span class="string">'k.'</span>)</span><br><span class="line">plt.plot(X2, y2, <span class="string">'g-'</span>)</span><br><span class="line"><span class="keyword">for</span> idx, x <span class="keyword">in</span> enumerate(X):</span><br><span class="line">    plt.plot([x, x], [y[idx], yr[idx]], <span class="string">'r-'</span>)</span><br><span class="line"></span><br><span class="line">plt.xlabel(<span class="string">"X"</span>)</span><br><span class="line">plt.ylabel(<span class="string">"y"</span>)</span><br><span class="line">plt.axis([<span class="number">0</span>, <span class="number">25</span>, <span class="number">0</span>, <span class="number">25</span>])</span><br><span class="line">plt.grid(<span class="literal">True</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><meta name="referrer" content="no-referrer"><br><img src="/python-sklearn/output_4_0.png" class></p>
<h2 id="preprocessing"><a href="#preprocessing" class="headerlink" title="preprocessing"></a>preprocessing</h2><p>sklearn模块中的preprocessing包含许多用于encoding的函数。</p>
<h3 id="LabelBinarizer"><a href="#LabelBinarizer" class="headerlink" title="LabelBinarizer()"></a>LabelBinarizer()</h3><p>使用One-Hot Encoding将类别数据二进制化</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> preprocessing</span><br><span class="line">lb = preprocessing.LabelBinarizer()</span><br><span class="line"></span><br><span class="line">c_list = [<span class="string">'Quanzhou'</span>, <span class="string">'Xiamen'</span>, <span class="string">'Zhangzhou'</span>, <span class="string">'Quanzhou'</span>]</span><br><span class="line"></span><br><span class="line">lb.fit(c_list)</span><br><span class="line">lb.classes_</span><br><span class="line"><span class="comment">#array(['Quanzhou', 'Xiamen', 'Zhangzhou'], dtype='&lt;U9')</span></span><br><span class="line"></span><br><span class="line">c_list_lb = lb.transform(c_list)  <span class="comment">##Encoding</span></span><br><span class="line">c_list_lb</span><br><span class="line"><span class="comment">#array([[1, 0, 0],</span></span><br><span class="line"><span class="comment">#       [0, 1, 0],</span></span><br><span class="line"><span class="comment">#       [0, 0, 1],</span></span><br><span class="line"><span class="comment">#       [1, 0, 0]])</span></span><br><span class="line"></span><br><span class="line">c_list_new = lb.inverse_transform(c_list_lb)  <span class="comment">##Decoding</span></span><br><span class="line">c_list_new</span><br><span class="line"><span class="comment">#array(['Quanzhou', 'Xiamen', 'Zhangzhou', 'Quanzhou'], dtype='&lt;U9')</span></span><br></pre></td></tr></table></figure>
<h3 id="LabelEncoder"><a href="#LabelEncoder" class="headerlink" title="LabelEncoder()"></a>LabelEncoder()</h3><p>进行Label encoding。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> preprocessing</span><br><span class="line">le = preprocessing.LabelEncoder()</span><br><span class="line">le.fit([<span class="string">"paris"</span>, <span class="string">"paris"</span>, <span class="string">"tokyo"</span>, <span class="string">"amsterdam"</span>])  <span class="comment">##进行编码</span></span><br><span class="line"><span class="comment"># LabelEncoder()</span></span><br><span class="line"></span><br><span class="line">list(le.classes_)  <span class="comment">##编码类别；paris重复；</span></span><br><span class="line"><span class="comment"># ['amsterdam', 'paris', 'tokyo']</span></span><br><span class="line"></span><br><span class="line">le.transform([<span class="string">"tokyo"</span>, <span class="string">"tokyo"</span>, <span class="string">"paris"</span>])</span><br><span class="line"><span class="comment"># array([2, 2, 1], dtype=int64)</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> LabelEncoder</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">d = defaultdict(LabelEncoder)</span><br><span class="line"></span><br><span class="line">df = pd.DataFrame(&#123;</span><br><span class="line">    <span class="string">'pets'</span>:[<span class="string">'cat'</span>, <span class="string">'dog'</span>, <span class="string">'cat'</span>, <span class="string">'monkey'</span>, <span class="string">'dog'</span>, <span class="string">'cat'</span>],</span><br><span class="line">    <span class="string">'owner'</span>:[<span class="string">'Champ'</span>, <span class="string">'Ron'</span>, <span class="string">'Jane'</span>, <span class="string">'Champ'</span>, <span class="string">'Veronica'</span>, <span class="string">'Ron'</span>],</span><br><span class="line">    <span class="string">'location'</span>:[<span class="string">'San_Diego'</span>, <span class="string">'New_York'</span>, <span class="string">'New_York'</span>, <span class="string">'San_Diego'</span>, <span class="string">'San_Diego'</span>, <span class="string">'New_York'</span>]</span><br><span class="line">&#125;)</span><br><span class="line">df</span><br><span class="line"><span class="comment">#     pets     owner   location</span></span><br><span class="line"><span class="comment">#0     cat     Champ  San_Diego</span></span><br><span class="line"><span class="comment">#1     dog       Ron   New_York</span></span><br><span class="line"><span class="comment">#2     cat      Jane   New_York</span></span><br><span class="line"><span class="comment">#3  monkey     Champ  San_Diego</span></span><br><span class="line"><span class="comment">#4     dog  Veronica  San_Diego</span></span><br><span class="line"><span class="comment">#5     cat       Ron   New_York</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## Encoding</span></span><br><span class="line">fit = df.apply(<span class="keyword">lambda</span> x: d[x.name].fit_transform(x))  <span class="comment">##按列操作</span></span><br><span class="line">fit</span><br><span class="line"><span class="comment">#   pets  owner  location</span></span><br><span class="line"><span class="comment">#0     0      0         1</span></span><br><span class="line"><span class="comment">#1     1      2         0</span></span><br><span class="line"><span class="comment">#2     0      1         0</span></span><br><span class="line"><span class="comment">#3     2      0         1</span></span><br><span class="line"><span class="comment">#4     1      3         1</span></span><br><span class="line"><span class="comment">#5     0      2         0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## Decoding </span></span><br><span class="line">dec = fit.apply(<span class="keyword">lambda</span> x: d[x.name].inverse_transform(x))</span><br><span class="line">dec</span><br><span class="line"><span class="comment">#     pets     owner   location</span></span><br><span class="line"><span class="comment">#0     cat     Champ  San_Diego</span></span><br><span class="line"><span class="comment">#1     dog       Ron   New_York</span></span><br><span class="line"><span class="comment">#2     cat      Jane   New_York</span></span><br><span class="line"><span class="comment">#3  monkey     Champ  San_Diego</span></span><br><span class="line"><span class="comment">#4     dog  Veronica  San_Diego</span></span><br><span class="line"><span class="comment">#5     cat       Ron   New_York</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### Using the dictionary to label future data</span></span><br><span class="line">df.apply(<span class="keyword">lambda</span> x: d[x.name].transform(x))</span><br></pre></td></tr></table></figure>
<h4 id="inverse-transform"><a href="#inverse-transform" class="headerlink" title="inverse_transform()"></a>inverse_transform()</h4><p>对LabelEncoder()进行解码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">##解码decode</span></span><br><span class="line">list(le.inverse_transform([<span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>]))</span><br><span class="line"><span class="comment"># ['tokyo', 'tokyo', 'paris']</span></span><br></pre></td></tr></table></figure>
<h3 id="OneHotEncoder"><a href="#OneHotEncoder" class="headerlink" title="OneHotEncoder()"></a>OneHotEncoder()</h3><p>One-Hot Encoding（独热编码）<br><code>OneHotEncoder(n_values=None, categorical_features=None, 
    categories=None, sparse=True, dtype=&lt;class &#39;numpy.float64&#39;&gt;, 
    handle_unknown=&#39;error&#39;)</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> preprocessing</span><br><span class="line">ohe = preprocessing.OneHotEncoder()</span><br><span class="line">ohe.fit([[<span class="number">0</span>, <span class="number">0</span>, <span class="number">3</span>],</span><br><span class="line">        [<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>],</span><br><span class="line">        [<span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>],</span><br><span class="line">        [<span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>]])  <span class="comment">##学习Encoding</span></span><br><span class="line">ohe.transform([[<span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>]]).toarray()  <span class="comment">## Encoding</span></span><br><span class="line"><span class="comment">#array([[1., 0., 0., 1., 0., 0., 0., 0., 1.]])</span></span><br></pre></td></tr></table></figure>
<p>观察学习的4×3数据矩阵，共有4个数据，3个特征。</p>
<ul>
<li>第一个特征维度取值仅{0,1}，对应二维One-Hot编码向量{(1,0) , (0,1)}；</li>
<li>第二个特征维度取值为{0,1,2}，对应三维One-Hot编码向量{(1,0,0) , (0,1,0) , (0,0,1)}；</li>
<li>第三个特征维度取值为{0,1,2,3}，对应四维One-Hot编码向量{(1,0,0,0) , (0,1,0,0) , (0,0,1,0) , (0,0,0,1)}。</li>
</ul>
<p>因此，关于(0,1,3)的编码结果应该是{(1,0) , (0,1,0) , (0,0,0,1)}，所以最后输出结果为 [1,0,0,1,0,0,0,0,1]。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> preprocessing</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">oh = preprocessing.OneHotEncoder(sparse=<span class="literal">False</span>)</span><br><span class="line">data = ([<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>],</span><br><span class="line">       [<span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">       [<span class="number">4</span>, <span class="number">2</span>, <span class="number">2</span>])</span><br><span class="line">oh.fit_transform(data)</span><br><span class="line"><span class="comment">#array([[1., 0., 0., 0., 0., 1., 0., 1.],</span></span><br><span class="line"><span class="comment">#       [0., 1., 0., 1., 0., 0., 1., 0.],</span></span><br><span class="line"><span class="comment">#       [0., 0., 1., 0., 1., 0., 0., 1.]])</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU5NzkxODMxOA==&amp;mid=2247484190&amp;idx=1&amp;sn=e7484e733ae84785a8940270cdf289b1&amp;chksm=fe4d541fc93add09a7d2730ec0ec9aeb04bc1d1fe38e9c662087e368b20bb20c087611191956&amp;token=1683818096&amp;lang=zh_CN#rd" target="_blank" rel="noopener">Sklearn学习：线性回归、岭回归、Lasso、Elastic Net</a></li>
</ul>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Machine Learning | K-Means</title>
    <url>/%E7%AE%97%E6%B3%95-K-Means.html</url>
    <content><![CDATA[<p><center>K均值聚类</center><br><a id="more"></a></p>
<h1 id="K-Means"><a href="#K-Means" class="headerlink" title="K-Means"></a>K-Means</h1><ul>
<li>无监督学习</li>
<li>$K$值无法自动获取</li>
<li>初始聚类中心随机选择</li>
</ul>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul>
<li>原理简单</li>
<li>容易实现</li>
<li>对大数据集有较高的学习效率，且具有可伸缩性</li>
</ul>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul>
<li>收敛速度较慢</li>
<li>算法的时间复杂度较高$O(nKt)$<ul>
<li>$n$：样本点个数</li>
<li>$K$：聚类类别数</li>
<li>$t$：迭代次数</li>
</ul>
</li>
<li>不能发现非凸形状的簇</li>
<li>对噪声和离群点敏感</li>
<li>结果不一定是全局最优，只能保证局部最优</li>
</ul>
<h1 id="确定K的方法"><a href="#确定K的方法" class="headerlink" title="确定K的方法"></a>确定K的方法</h1><h2 id="按需选择"><a href="#按需选择" class="headerlink" title="按需选择"></a>按需选择</h2><p>根据建模的需求和目的来选择聚类的个数</p>
<h2 id="观察法"><a href="#观察法" class="headerlink" title="观察法"></a>观察法</h2><p>直接看数据的散点图，看数据点大致聚成几堆</p>
<ul>
<li>原始数据维数要低，一般是两维或三维，否则无法通过散点图观察</li>
<li>对于高维数据，可以先利用PCA（主成分分析法）降维，然后进行观察</li>
</ul>
<h2 id="肘部法"><a href="#肘部法" class="headerlink" title="肘部法"></a>肘部法</h2><p>肘部法（Elbow Method），以聚类的数量为x轴，以WSS为y轴，绘制折线图，拐弯最明显的点对应的值就是比较合适的k值。</p>
<ul>
<li>x轴为聚类的数量</li>
<li>y轴为WSS（within cluster sum of squares），即各个点到cluster（簇）中心的距离的平方和</li>
</ul>
<h2 id="Gap-Statistics方法"><a href="#Gap-Statistics方法" class="headerlink" title="Gap Statistics方法"></a>Gap Statistics方法</h2><h1 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h1><h2 id="K-Means-vs-K-Medoids"><a href="#K-Means-vs-K-Medoids" class="headerlink" title="K-Means vs K-Medoids"></a>K-Means vs K-Medoids</h2><ul>
<li>二者的区别主要在于：质心的选择</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">K-Means</th>
<th style="text-align:center">K-Medoids</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">质心的选择</td>
<td style="text-align:center">样本点均值</td>
<td style="text-align:center">从样本点中选取</td>
</tr>
<tr>
<td style="text-align:center">计算质心的时间复杂度</td>
<td style="text-align:center"></td>
<td style="text-align:center">$O(n^2)$<br>运行速度较慢</td>
</tr>
<tr>
<td style="text-align:center">对噪声</td>
<td style="text-align:center">敏感</td>
<td style="text-align:center">相对较不敏感，比较稳健（robust）</td>
</tr>
</tbody>
</table>
</div>
<h2 id="K-Means-vs-KNN"><a href="#K-Means-vs-KNN" class="headerlink" title="K-Means vs KNN"></a>K-Means vs KNN</h2><div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: center;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: center;">
      <th></th>
      <th>K-Means</th>
      <th>KNN</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>分类</th>
      <td>聚类算法</td>
      <td>分类/回归算法</td>
    </tr>
    <tr>
      <th>监督</th>
      <td>无监督学习</td>
      <td>有监督学习</td>
    </tr>
    <tr>
      <th>训练集</th>
      <td>无标签数据</td>
      <td>有标签数据<br>无序变有序</td>
    </tr>
    <tr>
      <th>相似点</th>
      <td colspan="2">都包含——给定一个点，在数据集中找离它最近的点——的过程；即，二者都使用了NN（Nearest Neighbor）算法，一般用KD树实现NN</td>
    </tr>
    <tr>
  </tr></tbody>
</table>
</div>

<h2 id="K-Means-vs-DBSCAN"><a href="#K-Means-vs-DBSCAN" class="headerlink" title="K-Means vs DBSCAN"></a>K-Means vs DBSCAN</h2><div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: center;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: center;">
      <th></th>
      <th>K-Means</th>
      <th>DBSCAN</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>聚类类型</th>
      <td>基于划分</td>
      <td>基于密度</td>
    </tr>
    <tr>
      <th rowspan="2">对象</th>
      <td colspan="2">都是将每个对象指派到单个簇的划分聚类算法</td>
    </tr>
    <tr>
      <td>一般聚类所有对象</td>
      <td>丢弃被它识别为噪声的对象</td>
    </tr>
    <tr>
      <th>簇</th>
      <td>很难处理非球形的簇和不同大小的簇；<br>可以发现不是明显分离的簇</td>
      <td>可以处理不同大小或形状的簇；<br>会合并有重叠的簇</td>
    </tr>
    <tr>
      <th>噪声/离群点</th>
      <td></td>
      <td>不太受噪声和离群点的影响</td>
    </tr>
    <tr>
      <th>时间复杂度</th>
      <td>$O(n)$</td>
      <td>$O(n^2)$</td>
    </tr>
    <tr>
      <th>结果可重复性</th>
      <td>通常随机初始化质心，不会产生相同结果</td>
      <td>多次运行产生相同的结果</td>
    </tr>
    <tr>
      <th>稀疏数据</th>
      <td>可用于稀疏的高维数据</td>
      <td>在稀疏的高维数据上的表现很差</td>
    </tr>
    <tr>
  </tr></tbody>
</table>
</div>

<p>其中：</p>
<ul>
<li>$n$是样本点个数</li>
<li>聚类可分为<u>基于划分、层次、密度、图形和模型</u>五大类</li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://blog.csdn.net/databatman/article/details/50445561" target="_blank" rel="noopener">机器学习：K-means和K-medoids对比</a></li>
<li><a href="https://www.cnblogs.com/nucdy/p/6349172.html" target="_blank" rel="noopener">KNN与K-Means的区别</a></li>
<li><a href="https://www.cnblogs.com/hugechuanqi/p/10509307.html" target="_blank" rel="noopener">机器学习 之k-means和DBSCAN的区别</a></li>
<li><a href></a></li>
</ul>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>机器学习</tag>
        <tag>聚类</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL | 《SQL进阶教程》</title>
    <url>/sql-SQL%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B.html</url>
    <content><![CDATA[<p><center>《SQL进阶教程》读书笔记</center><br><a id="more"></a></p>
<h1 id="CASE表达式"><a href="#CASE表达式" class="headerlink" title="CASE表达式"></a>CASE表达式</h1><p>CASE表达式：</p>
<ul>
<li>简单CASE表达式（simple case expression）</li>
<li>搜索CASE表达式（searched case expression）</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 简单CASE表达式</span></span><br><span class="line">CASE sex</span><br><span class="line">    WHEN '1' THEN 'male'</span><br><span class="line">    WHEN '2' THEN 'female'</span><br><span class="line">ELSE '其他' <span class="keyword">END</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 搜索CASE表达式</span></span><br><span class="line"><span class="keyword">CASE</span> <span class="keyword">WHEN</span> sex = <span class="string">'1'</span> <span class="keyword">THEN</span> <span class="string">'male'</span></span><br><span class="line">     <span class="keyword">WHEN</span> sex = <span class="string">'2'</span> <span class="keyword">THEN</span> <span class="string">'female'</span></span><br><span class="line"><span class="keyword">ELSE</span> <span class="string">'其他'</span> <span class="keyword">END</span></span><br></pre></td></tr></table></figure>
<ul>
<li>注意：使用WHEN子句时需要注意条件的排他性</li>
<li>一定要注意CASE表达式里每个分支返回的数据类型是否一致<ul>
<li>某个分支返回字符型，而其他分支返回数值型的写法是错误的</li>
</ul>
</li>
<li>CASE表达式末尾不要忘记写END</li>
<li>ELSE子句是可选的<ul>
<li>不写ELSE子句时，CASE表达式的执行结果是NULL</li>
<li>不写ELSE子句可能会造成“语法没有错误，结果却不对”</li>
</ul>
</li>
<li>最好明确地写上ELSE子句</li>
<li>CASE表达式是一种表法式而不是语句</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">+<span class="comment">-----------+------------+</span></span><br><span class="line">| pref_name | population |</span><br><span class="line">+<span class="comment">-----------+------------+</span></span><br><span class="line">| 东京      |        400 |</span><br><span class="line">| 佐贺      |        100 |</span><br><span class="line">| 德岛      |        100 |</span><br><span class="line">| 爱媛      |        150 |</span><br><span class="line">| 福冈      |        300 |</span><br><span class="line">| 群马      |         50 |</span><br><span class="line">| 长崎      |        200 |</span><br><span class="line">| 香川      |        200 |</span><br><span class="line">| 高知      |        200 |</span><br><span class="line">+<span class="comment">-----------+------------+</span></span><br><span class="line">9 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 根据县人口统计表，统计不同地区的人口数量</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">CASE</span> pref_name</span><br><span class="line">                <span class="keyword">WHEN</span> <span class="string">'德岛'</span> <span class="keyword">THEN</span> <span class="string">'四国'</span></span><br><span class="line">                <span class="keyword">WHEN</span> <span class="string">'香川'</span> <span class="keyword">THEN</span> <span class="string">'四国'</span></span><br><span class="line">                <span class="keyword">WHEN</span> <span class="string">'爱媛'</span> <span class="keyword">THEN</span> <span class="string">'四国'</span></span><br><span class="line">                <span class="keyword">WHEN</span> <span class="string">'高知'</span> <span class="keyword">THEN</span> <span class="string">'四国'</span></span><br><span class="line">                <span class="keyword">WHEN</span> <span class="string">'福冈'</span> <span class="keyword">THEN</span> <span class="string">'九州'</span></span><br><span class="line">                <span class="keyword">WHEN</span> <span class="string">'长崎'</span> <span class="keyword">THEN</span> <span class="string">'九州'</span></span><br><span class="line">                <span class="keyword">WHEN</span> <span class="string">'佐贺'</span> <span class="keyword">THEN</span> <span class="string">'九州'</span></span><br><span class="line">        <span class="keyword">ELSE</span> <span class="string">'其他'</span> <span class="keyword">END</span> <span class="keyword">AS</span> district,</span><br><span class="line">        <span class="keyword">SUM</span>(population)</span><br><span class="line"><span class="keyword">FROM</span> PopTbl</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">CASE</span> pref_name</span><br><span class="line">                <span class="keyword">WHEN</span> <span class="string">'德岛'</span> <span class="keyword">THEN</span> <span class="string">'四国'</span></span><br><span class="line">                <span class="keyword">WHEN</span> <span class="string">'香川'</span> <span class="keyword">THEN</span> <span class="string">'四国'</span></span><br><span class="line">                <span class="keyword">WHEN</span> <span class="string">'爱媛'</span> <span class="keyword">THEN</span> <span class="string">'四国'</span></span><br><span class="line">                <span class="keyword">WHEN</span> <span class="string">'高知'</span> <span class="keyword">THEN</span> <span class="string">'四国'</span></span><br><span class="line">                <span class="keyword">WHEN</span> <span class="string">'福冈'</span> <span class="keyword">THEN</span> <span class="string">'九州'</span></span><br><span class="line">                <span class="keyword">WHEN</span> <span class="string">'长崎'</span> <span class="keyword">THEN</span> <span class="string">'九州'</span></span><br><span class="line">                <span class="keyword">WHEN</span> <span class="string">'佐贺'</span> <span class="keyword">THEN</span> <span class="string">'九州'</span></span><br><span class="line">         <span class="keyword">ELSE</span> <span class="string">'其他'</span> <span class="keyword">END</span>;</span><br><span class="line"><span class="comment">-- 注意是对转换后的列 GROUP</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">CASE</span> pref_name</span><br><span class="line">                <span class="keyword">WHEN</span> <span class="string">'德岛'</span> <span class="keyword">THEN</span> <span class="string">'四国'</span></span><br><span class="line">                <span class="keyword">WHEN</span> <span class="string">'香川'</span> <span class="keyword">THEN</span> <span class="string">'四国'</span></span><br><span class="line">                <span class="keyword">WHEN</span> <span class="string">'爱媛'</span> <span class="keyword">THEN</span> <span class="string">'四国'</span></span><br><span class="line">                <span class="keyword">WHEN</span> <span class="string">'高知'</span> <span class="keyword">THEN</span> <span class="string">'四国'</span></span><br><span class="line">                <span class="keyword">WHEN</span> <span class="string">'福冈'</span> <span class="keyword">THEN</span> <span class="string">'九州'</span></span><br><span class="line">                <span class="keyword">WHEN</span> <span class="string">'长崎'</span> <span class="keyword">THEN</span> <span class="string">'九州'</span></span><br><span class="line">                <span class="keyword">WHEN</span> <span class="string">'佐贺'</span> <span class="keyword">THEN</span> <span class="string">'九州'</span></span><br><span class="line">        <span class="keyword">ELSE</span> <span class="string">'其他'</span> <span class="keyword">END</span> <span class="keyword">AS</span> district,</span><br><span class="line">        <span class="keyword">SUM</span>(population)</span><br><span class="line"><span class="keyword">FROM</span> PopTbl</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> district;</span><br><span class="line"><span class="comment">-- 这里引用了SELECT子句中定义的别名来 GROUP</span></span><br><span class="line"><span class="comment">-- 与上面那种方法相比，这里不需要写两段CASE WHEN；</span></span><br><span class="line"><span class="comment">-- 而上面的需要写两段CASE WHEN，当CASE内容需要修改时，需要修改两处，容易出错</span></span><br><span class="line"><span class="comment">-- 但是该写法违反标准SQL的规则，因为GROUP BY子句比SELECT语句先执行</span></span><br></pre></td></tr></table></figure>
<p>CASE WHEN 聚合之后：<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">+<span class="comment">----------+-----------------+</span></span><br><span class="line">| district | SUM(population) |</span><br><span class="line">+<span class="comment">----------+-----------------+</span></span><br><span class="line">| 九州     |             600 |</span><br><span class="line">| 其他     |             450 |</span><br><span class="line">| 四国     |             650 |</span><br><span class="line">+<span class="comment">----------+-----------------+</span></span><br></pre></td></tr></table></figure></p>
<p>进行不同条件的统计：<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">+<span class="comment">-----------+-----+------------+</span></span><br><span class="line">| pref_name | sex | population |</span><br><span class="line">+<span class="comment">-----------+-----+------------+</span></span><br><span class="line">| 东京      | 1   |        250 |</span><br><span class="line">| 东京      | 2   |        150 |</span><br><span class="line">| 佐贺      | 1   |         20 |</span><br><span class="line">| 佐贺      | 2   |         80 |</span><br><span class="line">| 德岛      | 1   |         60 |</span><br><span class="line">| 德岛      | 2   |         40 |</span><br><span class="line">| 爱媛      | 1   |        100 |</span><br><span class="line">| 爱媛      | 2   |         50 |</span><br><span class="line">| 福冈      | 1   |        100 |</span><br><span class="line">| 福冈      | 2   |        200 |</span><br><span class="line">| 长崎      | 1   |        125 |</span><br><span class="line">| 长崎      | 2   |        125 |</span><br><span class="line">| 香川      | 1   |        100 |</span><br><span class="line">| 香川      | 2   |        100 |</span><br><span class="line">| 高知      | 1   |        100 |</span><br><span class="line">| 高知      | 2   |        100 |</span><br><span class="line">+<span class="comment">-----------+-----+------------+</span></span><br><span class="line">16 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"><span class="comment">-- 如果上表有新列“性别”sex，population列为某县的某个性别人口数</span></span><br><span class="line"><span class="keyword">SELECT</span> pref_name,</span><br><span class="line"><span class="comment">-- 男性人口</span></span><br><span class="line">    <span class="keyword">SUM</span>(<span class="keyword">CASE</span> <span class="keyword">WHEN</span> sex=<span class="string">'1'</span> <span class="keyword">THEN</span> population <span class="keyword">ELSE</span> <span class="number">0</span> <span class="keyword">END</span>) <span class="keyword">AS</span> cnt_m,</span><br><span class="line"><span class="comment">-- 女性人口</span></span><br><span class="line">    <span class="keyword">SUM</span>(<span class="keyword">CASE</span> <span class="keyword">WHEN</span> sex=<span class="string">'2'</span> <span class="keyword">THEN</span> population <span class="keyword">ELSE</span> <span class="number">0</span> <span class="keyword">END</span>) <span class="keyword">AS</span> cnt_f</span><br><span class="line"><span class="keyword">FROM</span> PopTbl2</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> pref_name;</span><br><span class="line">+<span class="comment">-----------+-------+-------+</span></span><br><span class="line">| pref_name | cnt_m | cnt_f |</span><br><span class="line">+<span class="comment">-----------+-------+-------+</span></span><br><span class="line">| 东京      |   250 |   150 |</span><br><span class="line">| 佐贺      |    20 |    80 |</span><br><span class="line">| 德岛      |    60 |    40 |</span><br><span class="line">| 爱媛      |   100 |    50 |</span><br><span class="line">| 福冈      |   100 |   200 |</span><br><span class="line">| 长崎      |   125 |   125 |</span><br><span class="line">| 香川      |   100 |   100 |</span><br><span class="line">| 高知      |   100 |   100 |</span><br><span class="line">+<span class="comment">-----------+-------+-------+</span></span><br><span class="line">8 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></p>
<p>使用CHECK约束定义多个列的条件关系：<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">CONSTRAINT check_salary <span class="keyword">CHECK</span></span><br><span class="line">        (<span class="keyword">CASE</span> <span class="keyword">WHEN</span> dept=<span class="string">'IT'</span> </span><br><span class="line">              <span class="keyword">THEN</span> <span class="keyword">CASE</span> <span class="keyword">WHEN</span> salary&gt;=<span class="number">20000</span></span><br><span class="line">                        <span class="keyword">THEN</span> <span class="number">1</span> <span class="keyword">ELSE</span> <span class="number">0</span> <span class="keyword">END</span></span><br><span class="line">              <span class="keyword">ELSE</span> <span class="number">1</span> <span class="keyword">END</span> = <span class="number">1</span>)</span><br><span class="line"><span class="comment">-- 如果是IT部门的员工，则工资应大于等于2万；如果不是IT部门的员工，则工资不受该约束限制</span></span><br><span class="line"><span class="comment">-- 蕴含式（conditional）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 如果用逻辑与（logical product）</span></span><br><span class="line"><span class="keyword">CONSTRAINT</span> check_salary <span class="keyword">CHECK</span> </span><br><span class="line">            (dept=<span class="string">'IT'</span> <span class="keyword">AND</span> salary&gt;=<span class="number">20000</span>)</span><br><span class="line"><span class="comment">-- 表示 salary里的记录只能是'IT'部门的，且工资大于等于2万</span></span><br></pre></td></tr></table></figure></p>
<p>在UPDATE语句里进行条件分支：<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">+<span class="comment">--------+--------+</span></span><br><span class="line">| name   | salary |</span><br><span class="line">+<span class="comment">--------+--------+</span></span><br><span class="line">| 木村   | 220000 |</span><br><span class="line">| 相田   | 300000 |</span><br><span class="line">| 神崎   | 270000 |</span><br><span class="line">| 齐藤   | 290000 |</span><br><span class="line">+<span class="comment">--------+--------+</span></span><br><span class="line">4 rows in <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br><span class="line"></span><br><span class="line"><span class="keyword">UPDATE</span> Salaries </span><br><span class="line">   <span class="keyword">SET</span> salary = <span class="keyword">CASE</span> <span class="keyword">WHEN</span> salary&gt;=<span class="number">300000</span> <span class="keyword">THEN</span> salary*<span class="number">0.9</span></span><br><span class="line">                     <span class="keyword">WHEN</span> salary&gt;=<span class="number">250000</span> <span class="keyword">AND</span> salary&lt;<span class="number">280000</span> <span class="keyword">THEN</span> salary*<span class="number">1.2</span></span><br><span class="line">                     <span class="keyword">ELSE</span> salary <span class="keyword">END</span>;  <span class="comment">-- 最后一句很重要</span></span><br><span class="line"><span class="comment">-- 当前工资为30万元以上的员工，降薪10%；</span></span><br><span class="line"><span class="comment">-- 当前工资为25万元~28万元（不满28万元）的员工，加薪20%</span></span><br><span class="line">+<span class="comment">--------+--------+</span></span><br><span class="line">| name   | salary |</span><br><span class="line">+<span class="comment">--------+--------+</span></span><br><span class="line">| 木村   | 220000 |</span><br><span class="line">| 相田   | 270000 |</span><br><span class="line">| 神崎   | 324000 |</span><br><span class="line">| 齐藤   | 290000 |</span><br><span class="line">+<span class="comment">--------+--------+</span></span><br><span class="line">4 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></p>
<p>调换主键值：<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">+<span class="comment">-------+-------+-------+</span></span><br><span class="line">| p_key | col_1 | col_2 |</span><br><span class="line">+<span class="comment">-------+-------+-------+</span></span><br><span class="line">| a     |     1 | 一    |</span><br><span class="line">| b     |     2 | 二    |</span><br><span class="line">| c     |     3 | 三    |</span><br><span class="line">+<span class="comment">-------+-------+-------+</span></span><br><span class="line">3 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line"><span class="keyword">UPDATE</span> SomeTable</span><br><span class="line">   <span class="keyword">SET</span> p_key = <span class="keyword">CASE</span> <span class="keyword">WHEN</span> p_key=<span class="string">'a'</span> <span class="keyword">THEN</span> <span class="string">'b'</span></span><br><span class="line">                    <span class="keyword">WHEN</span> p_key=<span class="string">'b'</span> <span class="keyword">THEN</span> <span class="string">'a'</span></span><br><span class="line">                    <span class="keyword">ELSE</span> p_key <span class="keyword">END</span>   <span class="comment">-- 该句很重要</span></span><br><span class="line"><span class="keyword">WHERE</span> p_key <span class="keyword">IN</span> (<span class="string">'a'</span>, <span class="string">'b'</span>);</span><br><span class="line"><span class="comment">-- 在PostgreSQL和MySQL中执行该语句，会因为主键重复而报错</span></span><br><span class="line"><span class="comment">-- 如: ERROR 1062 (23000): Duplicate entry 'b' for key 'PRIMARY'</span></span><br></pre></td></tr></table></figure></p>
<p>在CASE表达式中，可以使用<code>BETWEEN</code>、<code>LIKE</code> 和 <code>&lt;</code>、<code>&gt;</code>等谓词组合，以及能嵌套子查询的 <code>IN</code> 和 <code>EXISTS</code> 谓词<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM CourseMaster;</span><br><span class="line">+<span class="comment">-----------+--------------+</span></span><br><span class="line">| course_id | course_name  |</span><br><span class="line">+<span class="comment">-----------+--------------+</span></span><br><span class="line">|         1 | 会计入门     |</span><br><span class="line">|         2 | 财务知识     |</span><br><span class="line">|         3 | 簿记考试     |</span><br><span class="line">|         4 | 税务师       |</span><br><span class="line">+<span class="comment">-----------+--------------+</span></span><br><span class="line">4 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> OpenCourses;</span><br><span class="line">+<span class="comment">--------+-----------+</span></span><br><span class="line">| month  | course_id |</span><br><span class="line">+<span class="comment">--------+-----------+</span></span><br><span class="line">| 200706 |         1 |</span><br><span class="line">| 200706 |         3 |</span><br><span class="line">| 200706 |         4 |</span><br><span class="line">| 200707 |         4 |</span><br><span class="line">| 200708 |         2 |</span><br><span class="line">| 200708 |         4 |</span><br><span class="line">+<span class="comment">--------+-----------+</span></span><br><span class="line">6 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 如果用 IN 谓词</span></span><br><span class="line"><span class="keyword">SELECT</span> course_name,</span><br><span class="line">       <span class="keyword">CASE</span> <span class="keyword">WHEN</span> course_id <span class="keyword">IN</span> </span><br><span class="line">                     (<span class="keyword">SELECT</span> course_id <span class="keyword">FROM</span> OpenCourses </span><br><span class="line">                      <span class="keyword">WHERE</span> <span class="keyword">month</span> = <span class="number">200706</span>) <span class="keyword">THEN</span> <span class="string">'⚪'</span></span><br><span class="line">            <span class="keyword">ELSE</span> <span class="string">'×'</span> <span class="keyword">END</span> <span class="keyword">AS</span> <span class="string">"6月"</span>,</span><br><span class="line">       <span class="keyword">CASE</span> <span class="keyword">WHEN</span> course_id <span class="keyword">IN</span> </span><br><span class="line">                     (<span class="keyword">SELECT</span> course_id <span class="keyword">FROM</span> OpenCourses</span><br><span class="line">                      <span class="keyword">WHERE</span> <span class="keyword">month</span> = <span class="number">200707</span>) <span class="keyword">THEN</span> <span class="string">'⚪'</span></span><br><span class="line">            <span class="keyword">ELSE</span> <span class="string">'×'</span> <span class="keyword">END</span> <span class="keyword">AS</span> <span class="string">"7月"</span>,  </span><br><span class="line">       <span class="keyword">CASE</span> <span class="keyword">WHEN</span> course_id <span class="keyword">IN</span> </span><br><span class="line">                     (<span class="keyword">SELECT</span> course_id <span class="keyword">FROM</span> OpenCourses</span><br><span class="line">                      <span class="keyword">WHERE</span> <span class="keyword">month</span> = <span class="number">200708</span>) <span class="keyword">THEN</span> <span class="string">'⚪'</span></span><br><span class="line">            <span class="keyword">ELSE</span> <span class="string">'×'</span> <span class="keyword">END</span> <span class="keyword">AS</span> <span class="string">"8月"</span></span><br><span class="line"><span class="keyword">FROM</span> CourseMaster;   </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用EXISTS谓词</span></span><br><span class="line"><span class="keyword">SELECT</span> CM.course_name,</span><br><span class="line">       <span class="keyword">CASE</span> <span class="keyword">WHEN</span> <span class="keyword">EXISTS</span></span><br><span class="line">                   (<span class="keyword">SELECT</span> course_id <span class="keyword">FROM</span> OpenCourses OC</span><br><span class="line">                    <span class="keyword">WHERE</span> OC.month=<span class="number">200706</span> </span><br><span class="line">                      <span class="keyword">AND</span> OC.course_id=CM.course_id) <span class="keyword">THEN</span> <span class="string">'O'</span></span><br><span class="line">             <span class="keyword">ELSE</span> <span class="string">'X'</span> <span class="keyword">END</span> <span class="keyword">AS</span> <span class="string">'6月'</span>,</span><br><span class="line">        <span class="keyword">CASE</span> <span class="keyword">WHEN</span> <span class="keyword">EXISTS</span></span><br><span class="line">                    (<span class="keyword">SELECT</span> course_id <span class="keyword">FROM</span> OpenCourses OC</span><br><span class="line">                     <span class="keyword">WHERE</span> OC.month=<span class="number">200707</span></span><br><span class="line">                       <span class="keyword">AND</span> OC.course_id=CM.course_id) <span class="keyword">THEN</span> <span class="string">'O'</span></span><br><span class="line">             <span class="keyword">ELSE</span> <span class="string">'X'</span> <span class="keyword">END</span> <span class="keyword">AS</span> <span class="string">'7月'</span>,</span><br><span class="line">         <span class="keyword">CASE</span> <span class="keyword">WHEN</span> <span class="keyword">EXISTS</span></span><br><span class="line">                     (<span class="keyword">SELECT</span> course_id <span class="keyword">FROM</span> OpenCourses OC</span><br><span class="line">                     <span class="keyword">WHERE</span> OC.month=<span class="number">200708</span></span><br><span class="line">                       <span class="keyword">AND</span> OC.course_id=CM.course_id) <span class="keyword">THEN</span> <span class="string">'O'</span></span><br><span class="line">             <span class="keyword">ELSE</span> <span class="string">'X'</span> <span class="keyword">END</span> <span class="keyword">AS</span> <span class="string">'8月'</span>         </span><br><span class="line"><span class="keyword">FROM</span> CourseMaster CM;</span><br></pre></td></tr></table></figure></p>
<p>CASE表达式用在SELECT子句里时，既可以写在聚合函数内部，也可以写在聚合函数外部。<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">## StudentClub</span></span><br><span class="line">+<span class="comment">--------+---------+-----------+---------------+</span></span><br><span class="line">| std_id | club_id | club_name | main_club_flg |</span><br><span class="line">+<span class="comment">--------+---------+-----------+---------------+</span></span><br><span class="line">|    100 |       1 | 棒球      | Y             |</span><br><span class="line">|    100 |       2 | 管弦乐    | N             |</span><br><span class="line">|    200 |       2 | 管弦乐    | N             |</span><br><span class="line">|    200 |       3 | 羽毛球    | Y             |</span><br><span class="line">|    200 |       4 | 足球      | N             |</span><br><span class="line">|    300 |       4 | 足球      | N             |</span><br><span class="line">|    400 |       5 | 游泳      | N             |</span><br><span class="line">|    500 |       6 | 围棋      | N             |</span><br><span class="line">+<span class="comment">--------+---------+-----------+---------------+</span></span><br><span class="line">8 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"><span class="comment">-- main_club_flg='Y' 表示加入多个社团的学生的主社团</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 找出学生的主社团</span></span><br><span class="line"><span class="keyword">SELECT</span> std_id,</span><br><span class="line">        <span class="keyword">CASE</span> <span class="keyword">WHEN</span> <span class="keyword">COUNT</span>(*) = <span class="number">1</span></span><br><span class="line">              <span class="keyword">THEN</span> <span class="keyword">MAX</span>(club_id)</span><br><span class="line">              <span class="keyword">ELSE</span> <span class="keyword">MAX</span>(<span class="keyword">CASE</span> <span class="keyword">WHEN</span> main_club_flg = <span class="string">'Y'</span></span><br><span class="line">                            <span class="keyword">THEN</span> club_id</span><br><span class="line">                            <span class="keyword">ELSE</span> <span class="literal">NULL</span> <span class="keyword">END</span>)</span><br><span class="line">              <span class="keyword">END</span> <span class="keyword">AS</span> main_club</span><br><span class="line"><span class="keyword">FROM</span> StudentClub</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> std_id;</span><br><span class="line"></span><br><span class="line">+<span class="comment">--------+-----------+</span></span><br><span class="line">| std_id | main_club |</span><br><span class="line">+<span class="comment">--------+-----------+</span></span><br><span class="line">|    100 |         1 |</span><br><span class="line">|    200 |         3 |</span><br><span class="line">|    300 |         4 |</span><br><span class="line">|    400 |         5 |</span><br><span class="line">|    500 |         6 |</span><br><span class="line">+<span class="comment">--------+-----------+</span></span><br><span class="line">5 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></p>
<h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p>找最大值<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- Greatests</span></span><br><span class="line">+<span class="comment">------+---+---+---+</span></span><br><span class="line">| key0 | x | y | z |</span><br><span class="line">+<span class="comment">------+---+---+---+</span></span><br><span class="line">| A    | 1 | 2 | 3 |</span><br><span class="line">| B    | 5 | 5 | 2 |</span><br><span class="line">| C    | 4 | 7 | 1 |</span><br><span class="line">| D    | 3 | 3 | 8 |</span><br><span class="line">+<span class="comment">------+---+---+---+</span></span><br><span class="line">4 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 找出多列数据中的最大值</span></span><br><span class="line"><span class="comment">/* 找出x列和y列中的最大值 */</span></span><br><span class="line"><span class="keyword">SELECT</span> key0,</span><br><span class="line">       <span class="keyword">CASE</span> <span class="keyword">WHEN</span> x &lt; y <span class="keyword">THEN</span> y</span><br><span class="line">            <span class="keyword">ELSE</span> x <span class="keyword">END</span> <span class="keyword">AS</span> <span class="keyword">greatest</span></span><br><span class="line"><span class="keyword">FROM</span> Greatests;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- MySQL自带函数 GREATEST 直接可实现上述过程</span></span><br><span class="line"><span class="keyword">SELECT</span> key0,  <span class="keyword">GREATEST</span>(x,y) <span class="keyword">AS</span> <span class="keyword">greatest</span></span><br><span class="line"><span class="keyword">FROM</span> Greatests;</span><br><span class="line"></span><br><span class="line">+<span class="comment">------+----------+</span></span><br><span class="line">| key0 | greatest |</span><br><span class="line">+<span class="comment">------+----------+</span></span><br><span class="line">| A    |        2 |</span><br><span class="line">| B    |        5 |</span><br><span class="line">| C    |        7 |</span><br><span class="line">| D    |        3 |</span><br><span class="line">+<span class="comment">------+----------+</span></span><br><span class="line">4 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></p>
<p>求和：<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">+<span class="comment">-----------+-----+------------+</span></span><br><span class="line">| pref_name | sex | population |</span><br><span class="line">+<span class="comment">-----------+-----+------------+</span></span><br><span class="line">| 东京      | 1   |        250 |</span><br><span class="line">| 东京      | 2   |        150 |</span><br><span class="line">| 佐贺      | 1   |         20 |</span><br><span class="line">| 佐贺      | 2   |         80 |</span><br><span class="line">| 德岛      | 1   |         60 |</span><br><span class="line">| 德岛      | 2   |         40 |</span><br><span class="line">| 爱媛      | 1   |        100 |</span><br><span class="line">| 爱媛      | 2   |         50 |</span><br><span class="line">| 福冈      | 1   |        100 |</span><br><span class="line">| 福冈      | 2   |        200 |</span><br><span class="line">| 长崎      | 1   |        125 |</span><br><span class="line">| 长崎      | 2   |        125 |</span><br><span class="line">| 香川      | 1   |        100 |</span><br><span class="line">| 香川      | 2   |        100 |</span><br><span class="line">| 高知      | 1   |        100 |</span><br><span class="line">| 高知      | 2   |        100 |</span><br><span class="line">+<span class="comment">-----------+-----+------------+</span></span><br><span class="line">16 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> sex <span class="keyword">AS</span> <span class="string">'性别'</span>,</span><br><span class="line">       <span class="keyword">SUM</span>(population) <span class="keyword">AS</span> <span class="string">'全国'</span>,</span><br><span class="line">       <span class="keyword">SUM</span>(<span class="keyword">CASE</span> <span class="keyword">WHEN</span> pref_name = <span class="string">'德岛'</span> <span class="keyword">THEN</span> population <span class="keyword">ELSE</span> <span class="number">0</span> <span class="keyword">END</span>) <span class="keyword">AS</span> <span class="string">"德岛"</span>,</span><br><span class="line">       <span class="keyword">SUM</span>(<span class="keyword">CASE</span> <span class="keyword">WHEN</span> pref_name = <span class="string">'香川'</span> <span class="keyword">THEN</span> population <span class="keyword">ELSE</span> <span class="number">0</span> <span class="keyword">END</span>) <span class="keyword">AS</span> <span class="string">"香川"</span>,</span><br><span class="line">       <span class="keyword">SUM</span>(<span class="keyword">CASE</span> <span class="keyword">WHEN</span> pref_name = <span class="string">'爱媛'</span> <span class="keyword">THEN</span> population <span class="keyword">ELSE</span> <span class="number">0</span> <span class="keyword">END</span>) <span class="keyword">AS</span> <span class="string">"爱媛"</span>,</span><br><span class="line">       <span class="keyword">SUM</span>(<span class="keyword">CASE</span> <span class="keyword">WHEN</span> pref_name = <span class="string">'高知'</span> <span class="keyword">THEN</span> population <span class="keyword">ELSE</span> <span class="number">0</span> <span class="keyword">END</span>) <span class="keyword">AS</span> <span class="string">"高知"</span>,</span><br><span class="line">       <span class="keyword">SUM</span>(<span class="keyword">CASE</span> <span class="keyword">WHEN</span> pref_name <span class="keyword">IN</span> (<span class="string">'德岛'</span>, <span class="string">'香川'</span>, <span class="string">'爱媛'</span>, <span class="string">'高知'</span>)</span><br><span class="line">                <span class="keyword">THEN</span> population <span class="keyword">ELSE</span> <span class="number">0</span> <span class="keyword">END</span>) <span class="keyword">AS</span> zaijie</span><br><span class="line">  <span class="keyword">FROM</span> PopTbl2</span><br><span class="line"> <span class="keyword">GROUP</span> <span class="keyword">BY</span> sex;</span><br><span class="line"></span><br><span class="line">+<span class="comment">--------+--------+--------+--------+--------+--------+--------+</span></span><br><span class="line">| 性别   | 全国   | 德岛   | 香川   | 爱媛   | 高知   | zaijie |</span><br><span class="line">+<span class="comment">--------+--------+--------+--------+--------+--------+--------+</span></span><br><span class="line">| 1      |    855 |     60 |    100 |    100 |    100 |    360 |</span><br><span class="line">| 2      |    845 |     40 |    100 |     50 |    100 |    290 |</span><br><span class="line">+<span class="comment">--------+--------+--------+--------+--------+--------+--------+</span></span><br><span class="line">2 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></p>
<p>乱序排序：<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">-- 按照 B-A-D-C排序</span></span><br><span class="line"><span class="keyword">SELECT</span> key0,</span><br><span class="line">       <span class="keyword">CASE</span> key0</span><br><span class="line">         <span class="keyword">WHEN</span> <span class="string">'B'</span> <span class="keyword">THEN</span> <span class="number">1</span></span><br><span class="line">         <span class="keyword">WHEN</span> <span class="string">'A'</span> <span class="keyword">THEN</span> <span class="number">2</span></span><br><span class="line">         <span class="keyword">WHEN</span> <span class="string">'D'</span> <span class="keyword">THEN</span> <span class="number">3</span></span><br><span class="line">         <span class="keyword">WHEN</span> <span class="string">'C'</span> <span class="keyword">THEN</span> <span class="number">4</span></span><br><span class="line">         <span class="keyword">ELSE</span> <span class="literal">NULL</span> <span class="keyword">END</span> <span class="keyword">AS</span> sort_col</span><br><span class="line">  <span class="keyword">FROM</span> Greatests</span><br><span class="line"> <span class="keyword">ORDER</span> <span class="keyword">BY</span> sort_col;</span><br><span class="line"></span><br><span class="line">+<span class="comment">------+----------+</span></span><br><span class="line">| key0 | sort_col |</span><br><span class="line">+<span class="comment">------+----------+</span></span><br><span class="line">| B    |        1 |</span><br><span class="line">| A    |        2 |</span><br><span class="line">| D    |        3 |</span><br><span class="line">| C    |        4 |</span><br><span class="line">+<span class="comment">------+----------+</span></span><br><span class="line">4 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></p>
<p>按照给定的三边长度，判断是否能够组成一个三角形；若能组成三角形，判断三角形的类型。<br><a href="https://www.hackerrank.com/challenges/what-type-of-triangle/problem" target="_blank" rel="noopener">题目详情</a></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 注意语句的顺序</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    <span class="keyword">CASE</span> <span class="keyword">WHEN</span> (A+B&lt;=C <span class="keyword">OR</span> A+C&lt;=B <span class="keyword">OR</span> B+C&lt;=A) <span class="keyword">THEN</span> <span class="string">'Not A Triangle'</span></span><br><span class="line">         <span class="keyword">WHEN</span> (A=B <span class="keyword">AND</span> B=C) <span class="keyword">THEN</span> <span class="string">'Equilateral'</span></span><br><span class="line">         <span class="keyword">WHEN</span> (A=B <span class="keyword">OR</span> A=C <span class="keyword">OR</span> B=C) <span class="keyword">THEN</span> <span class="string">'Isosceles'</span></span><br><span class="line">         <span class="keyword">ELSE</span> <span class="string">'Scalene'</span> <span class="keyword">END</span> <span class="keyword">AS</span> triangle</span><br><span class="line"><span class="keyword">FROM</span> TRIANGLES;</span><br></pre></td></tr></table></figure>
<p><a href="https://www.hackerrank.com/challenges/occupations/problem" target="_blank" rel="noopener">HackerRank-Occupations</a><br><code>CASE WHEN</code>和RowNumber的用法：<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> @r1=<span class="number">0</span>, @r2=<span class="number">0</span>, @r3=<span class="number">0</span>, @r4=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">MIN</span>(Doctor), <span class="keyword">MIN</span>(Professor), <span class="keyword">MIN</span>(Singer), <span class="keyword">MIN</span>(Actor)</span><br><span class="line"><span class="keyword">FROM</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="keyword">CASE</span> Occupation</span><br><span class="line">        <span class="keyword">WHEN</span> <span class="string">"Doctor"</span> <span class="keyword">THEN</span> (@r1:=@r1+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">WHEN</span> <span class="string">"Professor"</span> <span class="keyword">THEN</span> (@r2:=@r2+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">WHEN</span> <span class="string">"Singer"</span> <span class="keyword">THEN</span> (@r3:=@r3+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">WHEN</span> <span class="string">"Actor"</span> <span class="keyword">THEN</span> (@r4:=@r4+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">END</span> <span class="keyword">AS</span> rownumber,</span><br><span class="line">        <span class="keyword">CASE</span> <span class="keyword">WHEN</span> Occupation=<span class="string">"Doctor"</span> <span class="keyword">THEN</span> <span class="keyword">Name</span> <span class="keyword">END</span> <span class="keyword">AS</span> Doctor,</span><br><span class="line">        <span class="keyword">CASE</span> <span class="keyword">WHEN</span> Occupation=<span class="string">"Professor"</span> <span class="keyword">THEN</span> <span class="keyword">Name</span> <span class="keyword">END</span> <span class="keyword">AS</span> Professor,</span><br><span class="line">        <span class="keyword">CASE</span> <span class="keyword">WHEN</span> Occupation=<span class="string">"Singer"</span> <span class="keyword">THEN</span> <span class="keyword">Name</span> <span class="keyword">END</span> <span class="keyword">AS</span> Singer,</span><br><span class="line">        <span class="keyword">CASE</span> <span class="keyword">WHEN</span> Occupation=<span class="string">"Actor"</span> <span class="keyword">THEN</span> <span class="keyword">Name</span> <span class="keyword">END</span> <span class="keyword">AS</span> Actor</span><br><span class="line">    <span class="keyword">FROM</span> OCCUPATIONS</span><br><span class="line">    <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">Name</span></span><br><span class="line">) <span class="keyword">AS</span> TEMP</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> rownumber;</span><br><span class="line"><span class="comment">-- min()/max() will return a name for specific index and specific occupation. If there is a name, it will return it, if not, return NULL.</span></span><br></pre></td></tr></table></figure></p>
<h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><p><strong>窗口函数</strong>：也称<strong>OLAP函数</strong>、<strong>分析函数</strong>。</p>
<ul>
<li><code>RANK()</code></li>
<li><code>DENSE_RANK()</code></li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    <span class="keyword">name</span></span><br><span class="line">    , price</span><br><span class="line">    , <span class="keyword">RANK</span>() <span class="keyword">OVER</span>(<span class="keyword">ORDER</span> <span class="keyword">BY</span> price <span class="keyword">DESC</span>) <span class="keyword">AS</span> rank_1</span><br><span class="line">    , <span class="keyword">DENSE_RANK</span>() <span class="keyword">OVER</span>(<span class="keyword">ORDER</span> <span class="keyword">BY</span> price <span class="keyword">DESC</span>) <span class="keyword">AS</span> rank_2</span><br><span class="line"><span class="keyword">FROM</span> Products;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- +------+-------+--------+--------+</span></span><br><span class="line"><span class="comment">-- | name | price | rank_1 | rank_2 |</span></span><br><span class="line"><span class="comment">-- +------+-------+--------+--------+</span></span><br><span class="line"><span class="comment">-- | 橘子 |   100 |      1 |      1 |</span></span><br><span class="line"><span class="comment">-- | 西瓜 |    80 |      2 |      2 |</span></span><br><span class="line"><span class="comment">-- | 苹果 |    50 |      3 |      3 |</span></span><br><span class="line"><span class="comment">-- | 香蕉 |    50 |      3 |      3 |</span></span><br><span class="line"><span class="comment">-- | 葡萄 |    50 |      3 |      3 |</span></span><br><span class="line"><span class="comment">-- | 柠檬 |    30 |      6 |      4 |</span></span><br><span class="line"><span class="comment">-- +------+-------+--------+--------+</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>MySQL不支持<code>RANK()</code>、<code>DENSE_RANK()</code></p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- RANK()等价于</span></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    t1.name</span><br><span class="line">    , t1.price</span><br><span class="line">    , </span><br><span class="line">    (</span><br><span class="line">        <span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(t2.price)</span><br><span class="line">        <span class="keyword">FROM</span> Products t2</span><br><span class="line">        <span class="keyword">WHERE</span> t2.price &gt; t1.price</span><br><span class="line">    ) + <span class="number">1</span> <span class="keyword">AS</span> rank_1</span><br><span class="line"><span class="keyword">FROM</span> Products t2</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> rank_1;</span><br><span class="line"><span class="comment">-- 排序从1开始</span></span><br><span class="line"><span class="comment">-- 如果出现相同的位次，则跳过之后的位次</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 或者</span></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    t1.name,</span><br><span class="line">    <span class="keyword">MAX</span>(t1.price) <span class="keyword">AS</span> price,</span><br><span class="line">    <span class="keyword">COUNT</span>(t2.name) + <span class="number">1</span> <span class="keyword">AS</span> rank_1</span><br><span class="line"><span class="keyword">FROM</span> Products t1 <span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> Products t2</span><br><span class="line"><span class="keyword">ON</span> t1.price &lt; t2.price</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> t1.name</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> rank_1;</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- DENSE_RANK()等价于</span></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    t1.name</span><br><span class="line">    , t1.price</span><br><span class="line">    , </span><br><span class="line">    (</span><br><span class="line">        <span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(<span class="keyword">DISTINCT</span> t2.price)</span><br><span class="line">        <span class="keyword">FROM</span> Products t2</span><br><span class="line">        <span class="keyword">WHERE</span> t2.price &gt; t1.price</span><br><span class="line">    ) + <span class="number">1</span> <span class="keyword">AS</span> rank_2</span><br><span class="line"><span class="keyword">FROM</span> Products t2</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> rank_2;</span><br></pre></td></tr></table></figure>
<h1 id="自连接"><a href="#自连接" class="headerlink" title="自连接"></a>自连接</h1><ul>
<li>自连接经常与非等值连接结合使用</li>
<li>自连接和GROUP BY结合使用可生成递归集合</li>
<li>自连接的性能开销大，应尽量给用于连接的列建立索引</li>
</ul>
<h1 id="三值逻辑和NULL"><a href="#三值逻辑和NULL" class="headerlink" title="三值逻辑和NULL"></a>三值逻辑和NULL</h1><p>大多数编程语言是基于二值逻辑的——逻辑值只有真和假；而SQL语言则是采用三值逻辑（three-valued logic）——逻辑值除了真和假，还有“不确定”（<strong>unknown</strong>）。</p>
<ul>
<li><code>NULL</code>不是值<ul>
<li>因此不能对其使用谓词</li>
</ul>
</li>
<li>对<code>NULL</code>使用谓词后的结果是unknown</li>
</ul>
<h2 id="NULL"><a href="#NULL" class="headerlink" title="NULL"></a>NULL</h2><p>数据库中存在两种<code>NULL</code>，分别指</p>
<ul>
<li>未知（unknown）：虽然现在不知道，但加上某些条件后就可以知道</li>
<li>不适用（not applicable，inapplicable）：无论怎么努力都无法知道</li>
</ul>
<p><meta name="referrer" content="no-referrer"><br><img src="/sql-SQL%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B/NULL_lost.png" class title="丢失的信息的分类"></p>
<div class="note default">
            <p><strong>为什么必须写成<code>IS NULL</code>，而不是<code>=NULL</code>?</strong></p><p>因为对<code>NULL</code>使用比较谓词后得到的结果总是unknown，而SQL查询结果只会包含<code>WHERE</code>子句中判断结果为true的行，不会包含判断结果为false或unknown的行。因此使用<code>xxx = NULL</code>并不能得到正确的查询结果</p>
          </div>
<ul>
<li><code>NULL</code>既不是值（value）也不是变量（variable）</li>
<li><code>NULL</code>只是一个表示“没有值”的标记，而比较谓词只适用于值</li>
<li>应把<code>IS NULL</code>看作是一个谓词</li>
</ul>
<h2 id="unknown"><a href="#unknown" class="headerlink" title="unknown"></a>unknown</h2><ul>
<li>unknown是第三个逻辑真值</li>
<li>真值<strong>unknown</strong>和作为NULL的一种unknown是不同的东西<ul>
<li>真值<strong>unknown</strong>是明确的布尔型（boolean）的真值</li>
<li>作为NULL的未知既不是值也不是变量</li>
</ul>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 以下式子都会被判为unknown</span></span><br><span class="line">1 = NULL</span><br><span class="line">2 &gt; NULL</span><br><span class="line">3 &lt; NULL</span><br><span class="line">4 &lt;&gt; NULL</span><br><span class="line">NULL = NULL</span><br></pre></td></tr></table></figure>
<p>三值逻辑的真值表（NOT）:</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">x</th>
<th style="text-align:center">NOT x</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">true</td>
<td style="text-align:center">false</td>
</tr>
<tr>
<td style="text-align:center">unknown</td>
<td style="text-align:center">unknown</td>
</tr>
<tr>
<td style="text-align:center">false</td>
<td style="text-align:center">true</td>
</tr>
</tbody>
</table>
</div>
<p>三值逻辑的真值表（AND）:</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">AND</th>
<th style="text-align:center">true</th>
<th style="text-align:center">unknown</th>
<th style="text-align:center">false</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">true</td>
<td style="text-align:center">true</td>
<td style="text-align:center">unknown</td>
<td style="text-align:center">false</td>
</tr>
<tr>
<td style="text-align:center">unknown</td>
<td style="text-align:center">unknown</td>
<td style="text-align:center">unknown</td>
<td style="text-align:center">false</td>
</tr>
<tr>
<td style="text-align:center">false</td>
<td style="text-align:center">false</td>
<td style="text-align:center">false</td>
<td style="text-align:center">false</td>
</tr>
</tbody>
</table>
</div>
<p>三值逻辑的真值表（OR）:</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">OR</th>
<th style="text-align:center">true</th>
<th style="text-align:center">unknown</th>
<th style="text-align:center">false</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">true</td>
<td style="text-align:center">true</td>
<td style="text-align:center">true</td>
<td style="text-align:center">true</td>
</tr>
<tr>
<td style="text-align:center">unknown</td>
<td style="text-align:center">true</td>
<td style="text-align:center">unknown</td>
<td style="text-align:center">unknown</td>
</tr>
<tr>
<td style="text-align:center">false</td>
<td style="text-align:center">true</td>
<td style="text-align:center">unknown</td>
<td style="text-align:center">false</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li><code>AND</code>中的优先级：<code>false</code> &gt; <code>unknown</code> &gt; <code>true</code></li>
<li><code>OR</code>中的优先级：<code>true</code> &gt; <code>unknown</code> &gt; <code>false</code></li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- a = 2, b = 4, c = NULL</span></span><br><span class="line">a &lt; b AND b &gt; c </span><br><span class="line"><span class="comment">-- true AND unknown = unknown</span></span><br><span class="line"></span><br><span class="line">a &gt; b OR b &lt; c  </span><br><span class="line"><span class="comment">-- false OR unknown = unknown</span></span><br><span class="line"></span><br><span class="line">a &lt; b OR b &lt; c  </span><br><span class="line"><span class="comment">-- true OR unknown = true</span></span><br><span class="line"></span><br><span class="line">NOT (b &lt;&gt; c)    </span><br><span class="line"><span class="comment">-- NOT(unknown) = unknown</span></span><br></pre></td></tr></table></figure>
<div class="note warning">
            <p><strong>排中律（Law of Excluded Middle）</strong>：<br>命题“把命题和它的否命题通过OR连接而成的命题全都是真命题”在二值逻辑中被称为排中律。</p>
          </div>
<ul>
<li>在SQL中，排中律不成立</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询年龄是25岁或不是25岁的学生</span></span><br><span class="line"><span class="keyword">SELECT</span> * </span><br><span class="line"><span class="keyword">FROM</span> Students</span><br><span class="line"><span class="keyword">WHERE</span> age = <span class="number">25</span> </span><br><span class="line"><span class="keyword">OR</span> age &lt;&gt; <span class="number">25</span>;</span><br><span class="line"><span class="comment">-- 查询结果不包含年龄为空的行</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * </span><br><span class="line"><span class="keyword">FROM</span> Students</span><br><span class="line"><span class="keyword">WHERE</span> age = <span class="literal">NULL</span></span><br><span class="line"><span class="keyword">OR</span> age &lt;&gt; <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">-- 如此才能详尽</span></span><br><span class="line"><span class="comment">-- 或</span></span><br><span class="line"><span class="keyword">SELECT</span> * </span><br><span class="line"><span class="keyword">FROM</span> Students</span><br><span class="line"><span class="keyword">WHERE</span> age = <span class="number">25</span></span><br><span class="line"><span class="keyword">OR</span> age &lt;&gt; <span class="number">25</span></span><br><span class="line"><span class="keyword">OR</span> age <span class="keyword">IS</span> <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>
<h2 id="CASE-表达式与NULL"><a href="#CASE-表达式与NULL" class="headerlink" title="CASE 表达式与NULL"></a>CASE 表达式与NULL</h2><p><code>CASE</code>表达式与<code>NULL</code>：<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">CASE col_1</span><br><span class="line">    WHEN 1      THEN 'O'</span><br><span class="line">    WHEN NULL   THEN 'X'</span><br><span class="line"><span class="keyword">END</span></span><br><span class="line"><span class="comment">-- 这个CASE表达式一定不会返回X</span></span><br><span class="line"><span class="comment">-- 因为第二个WHEN子句表示的是col_1=NULL，这个式子的真值永远是unknown</span></span><br><span class="line"><span class="comment">-- CASE表达式只认可真值为true的条件</span></span><br><span class="line"><span class="comment">-- 正确的写法是</span></span><br><span class="line"><span class="keyword">CASE</span></span><br><span class="line">    <span class="keyword">WHEN</span> col_1 = <span class="number">1</span>      <span class="keyword">THEN</span> <span class="string">'O'</span></span><br><span class="line">    <span class="keyword">WHEN</span> col_2 <span class="keyword">IS</span> <span class="literal">NULL</span>  <span class="keyword">THEN</span> <span class="string">'X'</span></span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure></p>
<h2 id="NOT-IN与NOT-EXISTS"><a href="#NOT-IN与NOT-EXISTS" class="headerlink" title="NOT IN与NOT EXISTS"></a>NOT IN与NOT EXISTS</h2><p>在SQL中，通常会将<code>IN</code>改写成<code>EXISTS</code>进行性能优化。但是将<code>NOT IN</code>改写成<code>NOT EXISTS</code>时，结果未必一样。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 先构建两个表格</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> class_a (</span><br><span class="line">    <span class="keyword">name</span> <span class="built_in">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">    age <span class="built_in">INT</span>(<span class="number">5</span>),</span><br><span class="line">    city <span class="built_in">VARCHAR</span>(<span class="number">40</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> class_a <span class="keyword">VALUES</span> (<span class="string">'布朗'</span>, <span class="number">22</span>, <span class="string">'东京'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> class_a <span class="keyword">VALUES</span> (<span class="string">'拉里'</span>, <span class="number">19</span>, <span class="string">'埼玉'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> class_a <span class="keyword">VALUES</span> (<span class="string">'伯杰'</span>, <span class="number">21</span>, <span class="string">'千叶'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> class_b(</span><br><span class="line">    <span class="keyword">name</span> <span class="built_in">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">    age <span class="built_in">INT</span>(<span class="number">5</span>),</span><br><span class="line">    city <span class="built_in">VARCHAR</span>(<span class="number">40</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> class_b <span class="keyword">VALUES</span> (<span class="string">'齐藤'</span>, <span class="number">22</span>, <span class="string">'东京'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> class_b <span class="keyword">VALUES</span> (<span class="string">'田尻'</span>, <span class="number">23</span>, <span class="string">'东京'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> class_b(<span class="keyword">name</span>, city) <span class="keyword">VALUES</span> (<span class="string">'山田'</span>, <span class="string">'东京'</span>);  <span class="comment">--age为空</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> class_b <span class="keyword">VALUES</span> (<span class="string">'和泉'</span>, <span class="number">18</span>, <span class="string">'千叶'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> class_b <span class="keyword">VALUES</span> (<span class="string">'武田'</span>, <span class="number">20</span>, <span class="string">'千叶'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> class_b <span class="keyword">VALUES</span> (<span class="string">'石川'</span>, <span class="number">19</span>, <span class="string">'神奈川'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> class_a;</span><br><span class="line"><span class="comment">-- +--------+------+--------+</span></span><br><span class="line"><span class="comment">-- | name   | age  | city   |</span></span><br><span class="line"><span class="comment">-- +--------+------+--------+</span></span><br><span class="line"><span class="comment">-- | 布朗   |   22 | 东京   |</span></span><br><span class="line"><span class="comment">-- | 拉里   |   19 | 埼玉   |</span></span><br><span class="line"><span class="comment">-- | 伯杰   |   21 | 千叶   |</span></span><br><span class="line"><span class="comment">-- +--------+------+--------+</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> class_b;</span><br><span class="line"><span class="comment">-- +--------+------+-----------+</span></span><br><span class="line"><span class="comment">-- | name   | age  | city      |</span></span><br><span class="line"><span class="comment">-- +--------+------+-----------+</span></span><br><span class="line"><span class="comment">-- | 齐藤   |   22 | 东京      |</span></span><br><span class="line"><span class="comment">-- | 田尻   |   23 | 东京      |</span></span><br><span class="line"><span class="comment">-- | 山田   | NULL | 东京      |</span></span><br><span class="line"><span class="comment">-- | 和泉   |   18 | 千叶      |</span></span><br><span class="line"><span class="comment">-- | 武田   |   20 | 千叶      |</span></span><br><span class="line"><span class="comment">-- | 石川   |   19 | 神奈川    |</span></span><br><span class="line"><span class="comment">-- +--------+------+-----------+</span></span><br></pre></td></tr></table></figure>
<p><code>NOT IN</code>子查询用到的表里被选择的列中存在<code>NULL</code>，则SQL语句整体的查询结果永远是空。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查找与B班住在东京的学生年龄不同的A班学生</span></span><br><span class="line"><span class="keyword">SELECT</span> * </span><br><span class="line"><span class="keyword">FROM</span> class_a</span><br><span class="line"><span class="keyword">WHERE</span> age <span class="keyword">NOT</span> <span class="keyword">IN</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> age</span><br><span class="line">    <span class="keyword">FROM</span> class_b</span><br><span class="line">    <span class="keyword">WHERE</span> city=<span class="string">'东京'</span></span><br><span class="line">);</span><br><span class="line"><span class="comment">-- Empty set (0.01 sec)</span></span><br><span class="line"><span class="comment">-- 查询结果为空</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 分步骤查找原因：</span></span><br><span class="line"><span class="comment">-- 1. 获取年龄列表</span></span><br><span class="line"><span class="keyword">SELECT</span> * </span><br><span class="line"><span class="keyword">FROM</span> class_a</span><br><span class="line"><span class="keyword">WHERE</span> age <span class="keyword">NOT</span> <span class="keyword">IN</span> (<span class="number">22</span>, <span class="number">23</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">-- Empty set (0.00 sec)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2. 用NOT和IN改写NOT IN</span></span><br><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> class_a</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">NOT</span> age <span class="keyword">IN</span> (<span class="number">22</span>, <span class="number">23</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">-- Empty set (0.00 sec)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 3. 用OR等价改写IN</span></span><br><span class="line"><span class="keyword">SELECT</span> * </span><br><span class="line"><span class="keyword">FROM</span> class_a</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">NOT</span> ( (age = <span class="number">22</span>) <span class="keyword">OR</span> (age = <span class="number">23</span>) <span class="keyword">OR</span> (age = <span class="literal">NULL</span>));</span><br><span class="line"><span class="comment">-- Empty set (0.00 sec)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 4. 使用De Morgan定律等价改写</span></span><br><span class="line"><span class="keyword">SELECT</span> * </span><br><span class="line"><span class="keyword">FROM</span> class_a</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">NOT</span> (age = <span class="number">22</span>) <span class="keyword">AND</span> <span class="keyword">NOT</span> (age = <span class="number">23</span>) <span class="keyword">AND</span> <span class="keyword">NOT</span> (age = <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">-- Empty set (0.00 sec)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 5. 用&lt;&gt;等价改写NOT 和 = </span></span><br><span class="line"><span class="keyword">SELECT</span> * </span><br><span class="line"><span class="keyword">FROM</span> class_a</span><br><span class="line"><span class="keyword">WHERE</span> (age &lt;&gt; <span class="number">22</span>) <span class="keyword">AND</span> (age &lt;&gt; <span class="number">23</span>) <span class="keyword">AND</span> (age &lt;&gt; <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">-- Empty set (0.00 sec)</span></span><br><span class="line"><span class="comment">-- 对NULL使用&lt;&gt;后，结果为unknown</span></span><br><span class="line"><span class="comment">-- unknown AND unknown = unknown</span></span><br></pre></td></tr></table></figure>
<p>应该使用<code>EXISTS</code>谓词：<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * </span><br><span class="line"><span class="keyword">FROM</span> class_a a</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> *</span><br><span class="line">    <span class="keyword">FROM</span> class_b b</span><br><span class="line">    <span class="keyword">WHERE</span> a.age=b.age</span><br><span class="line">    <span class="keyword">AND</span> b.city=<span class="string">'东京'</span></span><br><span class="line">);</span><br><span class="line"><span class="comment">-- +--------+------+--------+</span></span><br><span class="line"><span class="comment">-- | name   | age  | city   |</span></span><br><span class="line"><span class="comment">-- +--------+------+--------+</span></span><br><span class="line"><span class="comment">-- | 拉里   |   19 | 埼玉   |</span></span><br><span class="line"><span class="comment">-- | 伯杰   |   21 | 千叶   |</span></span><br><span class="line"><span class="comment">-- +--------+------+--------+</span></span><br><span class="line"><span class="comment">-- 2 rows in set (0.00 sec)</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>EXISTS</code>谓词只会返回true或false，而不会返回unknown</li>
<li><code>IN</code>和<code>EXISTS</code>可以互相替换使用，而<code>NOT IN</code>和<code>NOT EXISTS</code>却不可以互相替换</li>
</ul>
<h2 id="限定谓词与NULL"><a href="#限定谓词与NULL" class="headerlink" title="限定谓词与NULL"></a>限定谓词与NULL</h2><ul>
<li>SQL中有<code>ALL</code>和<code>ANY</code>两个限定谓词<ul>
<li><code>ANY</code>和<code>IN</code>是等价的</li>
<li><code>ALL</code>可以与比较谓词一起使用</li>
<li><code>ALL</code>谓词其实是多个以<code>AND</code>连接的逻辑表达式的省略写法，如果<code>ALL()</code>的输入中包含NULL，则查询结果为空</li>
</ul>
</li>
<li>当表里存在<code>NULL</code>时，限定谓词与极值谓词不等价</li>
<li>极值谓词（<code>MIN</code>、<code>MAX</code>）在输入为空表（空集）时会返回<code>NULL</code></li>
<li>当需要返回所有行时，需要使用<code>ALL</code>谓词，或者使用<code>COALESCE</code>函数将极值函数返回的<code>NULL</code>处理成合适的值</li>
</ul>
<h1 id="HAVING子句"><a href="#HAVING子句" class="headerlink" title="HAVING子句"></a>HAVING子句</h1><ul>
<li><code>WHERE</code>子句用来调查集合元素的性质，而<code>HAVING</code>子句用来调查集合本身的性质</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询编号是否连续</span></span><br><span class="line"><span class="keyword">SELECT</span>  <span class="string">'存在缺失的编号'</span> <span class="keyword">AS</span> gap </span><br><span class="line"><span class="keyword">FROM</span>    tbl</span><br><span class="line"><span class="keyword">HAVING</span>  <span class="keyword">COUNT</span>(<span class="number">1</span>) &lt;&gt; <span class="keyword">MAX</span>(seq);</span><br><span class="line"><span class="comment">-- 检查自然数集合和tbl集合之间是否存在一一映射</span></span><br><span class="line"><span class="comment">-- 上述语句没有GROUP BY子句，整张表会被聚合为一行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询缺失编号的最小值</span></span><br><span class="line"><span class="keyword">SELECT</span>  <span class="keyword">MIN</span>(seq + <span class="number">1</span>) <span class="keyword">AS</span> gap</span><br><span class="line"><span class="keyword">FROM</span>    tbl</span><br><span class="line"><span class="keyword">WHERE</span>   (seq + <span class="number">1</span>) <span class="keyword">NOT</span> <span class="keyword">IN</span> (<span class="keyword">SELECT</span> seq <span class="keyword">FROM</span> tbl);</span><br><span class="line"><span class="comment">-- 如果tbl里包含NULL，这条SQL语句的查询结果就不正确了</span></span><br></pre></td></tr></table></figure>
<ul>
<li>以前的SQL标准中，<code>HAVING</code>子句必须和<code>GROUP BY</code>子句一起使用；按照现在的SQL标准，<code>HAVING</code>子句可以单独使用，但是不能在<code>SELECT</code>子句里引用原来的表里的列</li>
</ul>
<h2 id="求众数"><a href="#求众数" class="headerlink" title="求众数"></a>求众数</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 求众数</span></span><br><span class="line"><span class="comment">-- 众数：反映群体趋势</span></span><br><span class="line"><span class="keyword">SELECT</span>  income</span><br><span class="line">        , <span class="keyword">COUNT</span>(*)</span><br><span class="line"><span class="keyword">FROM</span>    Graduates</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span>    income</span><br><span class="line"><span class="keyword">HAVING</span>  <span class="keyword">COUNT</span>(*) &gt;= <span class="keyword">ALL</span>(</span><br><span class="line">    <span class="keyword">SELECT</span>  <span class="keyword">COUNT</span>(*)</span><br><span class="line">    <span class="keyword">FROM</span>    Graduates</span><br><span class="line">    <span class="keyword">GROUP</span> <span class="keyword">BY</span>    income</span><br><span class="line">);</span><br><span class="line"><span class="comment">-- ALL用于NULL或空集时会出现问题，可用极值函数来代替</span></span><br><span class="line"><span class="keyword">SELECT</span>  income</span><br><span class="line">        , <span class="keyword">COUNT</span>(*) <span class="keyword">AS</span> cnt</span><br><span class="line"><span class="keyword">FROM</span>    Graduates</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> income</span><br><span class="line"><span class="keyword">HAVING</span> <span class="keyword">COUNT</span>(*) &gt;= (</span><br><span class="line">    <span class="keyword">SELECT</span>  <span class="keyword">MAX</span>(cnt)</span><br><span class="line">    <span class="keyword">FROM</span> (</span><br><span class="line">        <span class="keyword">SELECT</span>  <span class="keyword">COUNT</span>(*) <span class="keyword">AS</span> cnt</span><br><span class="line">        <span class="keyword">FROM</span> Graduates </span><br><span class="line">        <span class="keyword">GROUP</span> <span class="keyword">BY</span> income</span><br><span class="line">    ) tmp</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h2 id="求中位数"><a href="#求中位数" class="headerlink" title="求中位数"></a>求中位数</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 求中位数</span></span><br><span class="line"><span class="comment">-- 在HAVING子句中使用非等值自连接</span></span><br><span class="line"><span class="keyword">SELECT</span>  <span class="keyword">AVG</span>(<span class="keyword">DISTINCT</span> income)</span><br><span class="line"><span class="keyword">FROM</span>    </span><br><span class="line">(</span><br><span class="line">    <span class="keyword">SELECT</span>  T1.income</span><br><span class="line">    <span class="keyword">FROM</span>    Graduates T1, Graduates T2</span><br><span class="line">    <span class="keyword">GROUP</span> <span class="keyword">BY</span> T1.income</span><br><span class="line">    <span class="keyword">HAVING</span>  <span class="keyword">SUM</span>(<span class="keyword">CASE</span> <span class="keyword">WHEN</span> T2.income &gt;= T1.income <span class="keyword">THEN</span> <span class="number">1</span> <span class="keyword">ELSE</span> <span class="number">0</span> <span class="keyword">END</span>) &gt;= <span class="keyword">COUNT</span>(*) / <span class="number">2</span></span><br><span class="line">    <span class="keyword">AND</span>     <span class="keyword">SUM</span>(<span class="keyword">CASE</span> <span class="keyword">WHEN</span> T2.income &lt;= T1.income <span class="keyword">THEN</span> <span class="number">1</span> <span class="keyword">ELSE</span> <span class="number">0</span> <span class="keyword">END</span>) &gt;= <span class="keyword">COUNT</span>(*) / <span class="number">2</span></span><br><span class="line">) TMP;</span><br></pre></td></tr></table></figure>
<h2 id="COUNT-vs-COUNT-列名"><a href="#COUNT-vs-COUNT-列名" class="headerlink" title="COUNT(*) vs COUNT(列名)"></a>COUNT(*) vs COUNT(列名)</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:left">COUNT(*)</th>
<th style="text-align:left">COUNT(列名)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">NULL</td>
<td style="text-align:left">统计NULL</td>
<td style="text-align:left">不统计NULL</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:left">查询的是所有行的数目</td>
<td style="text-align:left">排除掉NULL值</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询“提交日期”列内不包含NULL的学院</span></span><br><span class="line"><span class="keyword">SELECT</span>  dpt</span><br><span class="line"><span class="keyword">FROM</span>    students</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span>    dpt</span><br><span class="line"><span class="keyword">HAVING</span>      <span class="keyword">COUNT</span>(*) = <span class="keyword">COUNT</span>(smbt_date);</span><br><span class="line"><span class="comment">-- 或</span></span><br><span class="line"><span class="keyword">SELECT</span>  dpt <span class="comment">-- 学院名</span></span><br><span class="line"><span class="keyword">FROM</span>    students</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span>    dpt</span><br><span class="line"><span class="keyword">HAVING</span>  <span class="keyword">COUNT</span>(*) = <span class="keyword">SUM</span>(</span><br><span class="line">    <span class="keyword">CASE</span> <span class="keyword">WHEN</span> sbmt_date <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> </span><br><span class="line">    <span class="keyword">THEN</span> <span class="number">1</span> <span class="keyword">ELSE</span> <span class="number">0</span> <span class="keyword">END</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 购物篮分析</span></span><br><span class="line"><span class="comment">-- 找出shopitems表中同时包含items表中物品的商铺</span></span><br><span class="line"><span class="comment">-- 带余除法（division with a remainder）</span></span><br><span class="line"><span class="keyword">SELECT</span>  SI.shop</span><br><span class="line"><span class="keyword">FROM</span>    ShopItems SI, Items I</span><br><span class="line"><span class="keyword">WHERE</span>   SI.item = I.item</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span>    SI.shop</span><br><span class="line"><span class="keyword">HAVING</span>  <span class="keyword">COUNT</span>(SI.item) = (</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(item) <span class="keyword">FROM</span> Items</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 找出ShopItems表中包含Items表中所有物品的商铺（物品完全一致）</span></span><br><span class="line"><span class="comment">-- 精确关系除法（exact relational division）</span></span><br><span class="line"><span class="keyword">SELECT</span>  SI.shop</span><br><span class="line"><span class="keyword">FROM</span>    ShopItems SI </span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> Items I</span><br><span class="line"><span class="keyword">ON</span>      SI.item = I.item</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> SI.shop</span><br><span class="line"><span class="keyword">HAVING</span>  <span class="keyword">COUNT</span>(SI.item) = (<span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(item) <span class="keyword">FROM</span> Items)</span><br><span class="line"><span class="keyword">AND</span>     <span class="keyword">COUNT</span>(I.item) = (<span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(item) <span class="keyword">FROM</span> Items);</span><br></pre></td></tr></table></figure>
<h1 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h1><h2 id="行列转换：行转列"><a href="#行列转换：行转列" class="headerlink" title="行列转换：行转列"></a>行列转换：行转列</h2><p>行列转换求交叉表：<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 水平展开1：使用外连接</span></span><br><span class="line"><span class="keyword">SELECT</span>  c0.name</span><br><span class="line">        , <span class="keyword">CASE</span> <span class="keyword">WHEN</span> c1.name <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">THEN</span> <span class="string">'O'</span></span><br><span class="line">            <span class="keyword">ELSE</span> <span class="literal">NULL</span> <span class="keyword">END</span> <span class="keyword">AS</span> <span class="string">`SQL入门`</span></span><br><span class="line">        , <span class="keyword">CASE</span> <span class="keyword">WHEN</span> c2.name <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">THEN</span> <span class="string">'O'</span></span><br><span class="line">            <span class="keyword">ELSE</span> <span class="literal">NULL</span> <span class="keyword">END</span> <span class="keyword">AS</span> <span class="string">`UNIX基础`</span></span><br><span class="line">        , <span class="keyword">CASE</span> <span class="keyword">WHEN</span> c3.name <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">THEN</span> <span class="string">'O'</span></span><br><span class="line">            <span class="keyword">ELSE</span> <span class="literal">NULL</span> <span class="keyword">END</span> <span class="keyword">AS</span> <span class="string">`Java中级`</span></span><br><span class="line"><span class="keyword">FROM</span> </span><br><span class="line">(</span><br><span class="line">    <span class="keyword">SELECT</span>  <span class="keyword">DISTINCT</span> <span class="keyword">name</span> </span><br><span class="line">    <span class="keyword">FROM</span>    Courses</span><br><span class="line">) c0</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span></span><br><span class="line">(</span><br><span class="line">    <span class="keyword">SELECT</span>  <span class="keyword">name</span></span><br><span class="line">    <span class="keyword">FROM</span>    Courses </span><br><span class="line">    <span class="keyword">WHERE</span>   course = <span class="string">'SQL入门'</span></span><br><span class="line">) c1</span><br><span class="line"><span class="keyword">ON</span>  c0.name = c1.name</span><br><span class="line"></span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span></span><br><span class="line">(</span><br><span class="line">    <span class="keyword">SELECT</span>  <span class="keyword">name</span></span><br><span class="line">    <span class="keyword">FROM</span>    Courses </span><br><span class="line">    <span class="keyword">WHERE</span>   course = <span class="string">'UNIX基础'</span></span><br><span class="line">) c2 </span><br><span class="line"><span class="keyword">ON</span>  c0.name = c2.name</span><br><span class="line"></span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span></span><br><span class="line">(</span><br><span class="line">    <span class="keyword">SELECT</span>  <span class="keyword">name</span></span><br><span class="line">    <span class="keyword">FROM</span>    Courses</span><br><span class="line">    <span class="keyword">WHERE</span>   course = <span class="string">'Java中级'</span></span><br><span class="line">) c3</span><br><span class="line"><span class="keyword">ON</span>  c0.name = c3.name;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>一般情况下，外连接可以用标量子查询替代</li>
<li><p>但是在<code>SELECT</code>子句中使用标量子查询，性能消耗大</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 水平展开2：使用标量子查询</span></span><br><span class="line"><span class="keyword">SELECT</span>  c0.name</span><br><span class="line">        , (</span><br><span class="line">            <span class="keyword">SELECT</span>  <span class="string">'O'</span></span><br><span class="line">            <span class="keyword">FROM</span>    Courses c1</span><br><span class="line">            <span class="keyword">WHERE</span>   course = <span class="string">'SQL入门'</span></span><br><span class="line">            <span class="keyword">AND</span>     c1.name = c0.name</span><br><span class="line">        ) <span class="keyword">AS</span> <span class="string">`SQL入门`</span></span><br><span class="line">        , (</span><br><span class="line">            <span class="keyword">SELECT</span>  <span class="string">'O'</span></span><br><span class="line">            <span class="keyword">FROM</span>    Courses c2</span><br><span class="line">            <span class="keyword">WHERE</span>   course = <span class="string">'UNIX基础'</span></span><br><span class="line">            <span class="keyword">AND</span>     c2.name = c0.name</span><br><span class="line">        ) <span class="keyword">AS</span> <span class="string">`UNIX基础`</span></span><br><span class="line">        , (</span><br><span class="line">            <span class="keyword">SELECT</span>  <span class="string">'O'</span> </span><br><span class="line">            <span class="keyword">FROM</span>    Courses c3</span><br><span class="line">            <span class="keyword">WHERE</span>   course = <span class="string">'Java中级'</span></span><br><span class="line">            <span class="keyword">AND</span>     c3.name = c0.name</span><br><span class="line">        ) <span class="keyword">AS</span> <span class="string">`Java中级`</span></span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">(</span><br><span class="line">    <span class="keyword">SELECT</span>  <span class="keyword">DISTINCT</span> <span class="keyword">name</span></span><br><span class="line">    <span class="keyword">FROM</span>    Courses</span><br><span class="line">) c0;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>CASE</code>表达式可以写在<code>SELECT</code>子句的聚合函数内部或外部</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 水平展开3：嵌套使用CASE表达式</span></span><br><span class="line"><span class="keyword">SELECT</span>  <span class="keyword">name</span></span><br><span class="line">        , <span class="keyword">CASE</span> <span class="keyword">WHEN</span> <span class="keyword">SUM</span>(<span class="keyword">CASE</span> <span class="keyword">WHEN</span> course = <span class="string">'SQL入门'</span> <span class="keyword">THEN</span> <span class="number">1</span> <span class="keyword">ELSE</span> <span class="literal">NULL</span> <span class="keyword">END</span>) = <span class="number">1</span> <span class="keyword">THEN</span> <span class="string">'O'</span></span><br><span class="line">            <span class="keyword">ELSE</span> <span class="literal">NULL</span> <span class="keyword">END</span> <span class="keyword">AS</span> <span class="string">`SQL入门`</span></span><br><span class="line">        , <span class="keyword">CASE</span> <span class="keyword">WHEN</span> <span class="keyword">SUM</span>(<span class="keyword">CASE</span> <span class="keyword">WHEN</span> course = <span class="string">'UNXI基础'</span> <span class="keyword">THEN</span> <span class="number">1</span> <span class="keyword">ELSE</span> <span class="literal">NULL</span> <span class="keyword">END</span>) = <span class="number">1</span> <span class="keyword">THEN</span> <span class="string">'O'</span></span><br><span class="line">            <span class="keyword">ELSE</span> <span class="literal">NULL</span> <span class="keyword">END</span> <span class="keyword">AS</span> <span class="string">`UNIX基础`</span></span><br><span class="line">        , <span class="keyword">CASE</span> <span class="keyword">WHEN</span> <span class="keyword">SUM</span>(<span class="keyword">CASE</span> <span class="keyword">WHEN</span> course = <span class="string">'Java中级'</span> <span class="keyword">THEN</span> <span class="number">1</span> <span class="keyword">ELSE</span> <span class="literal">NULL</span> <span class="keyword">END</span>) = <span class="number">1</span> <span class="keyword">THEN</span> <span class="string">'O'</span></span><br><span class="line">            <span class="keyword">ELSE</span> <span class="literal">NULL</span> <span class="keyword">END</span> <span class="keyword">AS</span> <span class="string">`Java中级`</span></span><br><span class="line"><span class="keyword">FROM</span>    Courses</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span>    <span class="keyword">name</span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="行列转换：列转行"><a href="#行列转换：列转行" class="headerlink" title="行列转换：列转行"></a>行列转换：列转行</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 列转行：使用UNION ALL</span></span><br><span class="line"><span class="keyword">SELECT</span>  employee</span><br><span class="line">        , child_1 <span class="keyword">AS</span> <span class="keyword">child</span></span><br><span class="line"><span class="keyword">FROM</span>    Personnel</span><br><span class="line"><span class="keyword">UNION</span> <span class="keyword">ALL</span></span><br><span class="line"><span class="keyword">SELECT</span>  employee</span><br><span class="line">        , child_2 <span class="keyword">AS</span> <span class="keyword">child</span></span><br><span class="line"><span class="keyword">FROM</span>    Personnel</span><br><span class="line"><span class="keyword">UNION</span> <span class="keyword">ALL</span></span><br><span class="line"><span class="keyword">SELECT</span>  employee</span><br><span class="line">        , child_3 <span class="keyword">AS</span> <span class="keyword">child</span></span><br><span class="line"><span class="keyword">FROM</span>    Personnel;</span><br><span class="line"><span class="comment">-- UNION ALL不会排除掉重复的行，可能会出现child列为NULL的情况</span></span><br></pre></td></tr></table></figure>
<p>外连接：</p>
<ul>
<li>左外连接<code>LEFT OUTER JOIN</code></li>
<li>右外连接<code>RIGHT OUTER JOIN</code></li>
<li>全外连接<code>FULL OUTER JOIN</code>：把两张表都当作主表来使用</li>
</ul>
<blockquote>
<ul>
<li>左外连接和右外连接没有功能上的区别：用作主表的表写在运算符左边时用左外连接，写在运算符右边时写右外连接</li>
<li>如果所用的数据库不支持全外连接，可以分别进行左外连接和右外连接，再把两个结果通过<code>UNION</code>合并起来</li>
<li>MySQL不支持全外连接</li>
<li><code>OUTER</code>可省略</li>
</ul>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- MySQL全外连接</span></span><br><span class="line"><span class="keyword">SELECT</span>  a.id <span class="keyword">AS</span> <span class="keyword">id</span></span><br><span class="line">        , a.name</span><br><span class="line">        , b.name</span><br><span class="line"><span class="keyword">FROM</span>    Class_a a </span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> Class_b b</span><br><span class="line"><span class="keyword">ON</span>  a.id = b.id</span><br><span class="line"></span><br><span class="line"><span class="keyword">UNION</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span>  b.id <span class="keyword">AS</span> <span class="keyword">id</span></span><br><span class="line">        , a.name</span><br><span class="line">        , b.name</span><br><span class="line"><span class="keyword">FROM</span>    Class_a a </span><br><span class="line"><span class="keyword">RIGHT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> Class_b b </span><br><span class="line"><span class="keyword">ON</span>  a.id = b.id;</span><br></pre></td></tr></table></figure>
<ul>
<li>内连接相当于求集合的交集（intersect）/积</li>
<li>全外连接相当于求集合的并集（union）/和</li>
</ul>
<h2 id="差集"><a href="#差集" class="headerlink" title="差集"></a>差集</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 求差集：A-B</span></span><br><span class="line"><span class="keyword">SELECT</span>  a.id <span class="keyword">AS</span> <span class="keyword">id</span></span><br><span class="line">        , a.name <span class="keyword">AS</span> a_name</span><br><span class="line"><span class="keyword">FROM</span>    Class_a a </span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> Class_b b</span><br><span class="line"><span class="keyword">ON</span>      a.id = b.id</span><br><span class="line"><span class="keyword">WHERE</span>   b.name <span class="keyword">IS</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">-- B-A</span></span><br><span class="line"><span class="keyword">SELECT</span>  b.id <span class="keyword">AS</span> <span class="keyword">id</span></span><br><span class="line">        , B.name <span class="keyword">AS</span> b_name</span><br><span class="line"><span class="keyword">FROM</span>    Class_b b</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> Class_a a</span><br><span class="line"><span class="keyword">ON</span>      b.id = a.id</span><br><span class="line"><span class="keyword">WHERE</span>   a.name <span class="keyword">IS</span> <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>
<h2 id="异或集"><a href="#异或集" class="headerlink" title="异或集"></a>异或集</h2><ul>
<li><code>(A UNION B) EXCEPT (A INTERSECT B)</code></li>
<li><code>(A EXCEPT B) UNION (B EXCEPT A)</code></li>
<li>全外连接</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 使用全外连接求异或集</span></span><br><span class="line"><span class="keyword">SELECT</span>  <span class="keyword">COALESCE</span>(a.id, b.id) <span class="keyword">AS</span> <span class="keyword">id</span></span><br><span class="line">        , <span class="keyword">COALESCE</span>(a.name, b.name) <span class="keyword">AS</span> <span class="keyword">name</span></span><br><span class="line"><span class="keyword">FROM</span>    Class_a a </span><br><span class="line"><span class="keyword">FULL</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> Class_b b</span><br><span class="line"><span class="keyword">ON</span>      a.id = b.id</span><br><span class="line"><span class="keyword">WHERE</span>   a.name <span class="keyword">IS</span> <span class="literal">NULL</span> <span class="keyword">OR</span> b.name <span class="keyword">IS</span> <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>
<h1 id="关联子查询"><a href="#关联子查询" class="headerlink" title="关联子查询"></a>关联子查询</h1><ul>
<li>对同一行数据进行列间比较，只需在<code>WHERE</code>子句里写上比较条件</li>
<li>对不同行数据进行列间比较，需要使用关联子查询或窗口函数</li>
</ul>
<h2 id="比较过去"><a href="#比较过去" class="headerlink" title="比较过去"></a>比较过去</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 求与上一年营业额一样的年份：</span></span><br><span class="line"><span class="comment">-- (1)使用关联子查询</span></span><br><span class="line"><span class="keyword">SELECT</span>  <span class="keyword">year</span></span><br><span class="line">        , sale</span><br><span class="line"><span class="keyword">FROM</span>    Sales s1</span><br><span class="line"><span class="keyword">WHERE</span>   sale = (<span class="keyword">SELECT</span> sale <span class="keyword">FROM</span> Sales s2 <span class="keyword">WHERE</span> s2.year = s1.year - <span class="number">1</span>)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span>    <span class="keyword">year</span>;</span><br><span class="line"><span class="comment">-- (2)使用自连接</span></span><br><span class="line"><span class="keyword">SELECT</span>  s1.year</span><br><span class="line">        , s1.sale</span><br><span class="line"><span class="keyword">FROM</span>    Sales s1, Sales s2</span><br><span class="line"><span class="keyword">WHERE</span>   s2.sale = s1.sale</span><br><span class="line"><span class="keyword">AND</span>     s2.year = s1.year - <span class="number">1</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span>    s1.year;</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 比较营业额相较于上一年的变化</span></span><br><span class="line"><span class="comment">-- (1)使用关联子查询</span></span><br><span class="line"><span class="keyword">SELECT</span>  s1.year</span><br><span class="line">        , s1.sale</span><br><span class="line">        , <span class="keyword">CASE</span>  <span class="keyword">WHEN</span> sale = (<span class="keyword">SELECT</span> sale <span class="keyword">FROM</span> Sales s2 <span class="keyword">WHERE</span> s2.year = s1.year - <span class="number">1</span>) <span class="keyword">THEN</span> <span class="string">'→'</span>  <span class="comment">-- 持平</span></span><br><span class="line">                <span class="keyword">WHEN</span> sale &gt; (<span class="keyword">SELECT</span> sale <span class="keyword">FROM</span> Sales s2 <span class="keyword">WHERE</span> s2.year = s1.year - <span class="number">1</span>) <span class="keyword">THEN</span> <span class="string">'↑'</span> <span class="comment">-- 增长</span></span><br><span class="line">                <span class="keyword">WHEN</span> sale &lt; (<span class="keyword">SELECT</span> sale <span class="keyword">FROM</span> Sales s2 <span class="keyword">WHERE</span> s2.year = s1.year - <span class="number">1</span>) <span class="keyword">THEN</span> <span class="string">'↓'</span> <span class="comment">-- 减少</span></span><br><span class="line">        <span class="keyword">ELSE</span> <span class="string">'——'</span> <span class="keyword">END</span> <span class="keyword">AS</span> <span class="keyword">var</span></span><br><span class="line"><span class="keyword">FROM</span>    Sales s1</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span>    <span class="keyword">year</span>;</span><br><span class="line"><span class="comment">-- (2)使用自连接</span></span><br><span class="line"><span class="keyword">SELECT</span>  s1.year</span><br><span class="line">        , s1.sale</span><br><span class="line">        , <span class="keyword">CASE</span>  <span class="keyword">WHEN</span> s1.sale = s2.sale <span class="keyword">THEN</span> <span class="string">'→'</span></span><br><span class="line">                <span class="keyword">WHEN</span> s1.sale &gt; s2.sale <span class="keyword">THEN</span> <span class="string">'↑'</span></span><br><span class="line">                <span class="keyword">WHEN</span> s1.sale &lt; s2.sale <span class="keyword">THEN</span> <span class="string">'↓'</span></span><br><span class="line">        <span class="keyword">ELSE</span> <span class="string">'——'</span> <span class="keyword">END</span> <span class="keyword">AS</span> <span class="keyword">var</span></span><br><span class="line"><span class="keyword">FROM</span>    Sales s1, Sales s2</span><br><span class="line"><span class="keyword">WHERE</span>   s2.year = s1.year - <span class="number">1</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span>    <span class="keyword">year</span>;</span><br><span class="line"><span class="comment">-- 注意：使用自连接，最早的年份不会出现在结果里</span></span><br><span class="line"><span class="comment">-- 以上写法，year需连续才可比较</span></span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 若时间轴有间断</span></span><br><span class="line"><span class="comment">-- 与过去最邻近的年份进行比较</span></span><br><span class="line"><span class="comment">-- (1)使用关联子查询</span></span><br><span class="line"><span class="keyword">SELECT</span>  <span class="keyword">year</span></span><br><span class="line">        , sale</span><br><span class="line"><span class="keyword">FROM</span>    Sales s1</span><br><span class="line"><span class="keyword">WHERE</span>   sale = (</span><br><span class="line">    <span class="keyword">SELECT</span>  sale</span><br><span class="line">    <span class="keyword">FROM</span>    Sales s2</span><br><span class="line">    <span class="keyword">WHERE</span>   s2.year = (</span><br><span class="line">        <span class="keyword">SELECT</span>  <span class="keyword">MAX</span>(<span class="keyword">year</span>)  <span class="comment">-- 过去的年份中，年份最新的那个</span></span><br><span class="line">        <span class="keyword">FROM</span>    Sales s3</span><br><span class="line">        <span class="keyword">WHERE</span>   s1.year &gt; s3.year <span class="comment">-- 与s1.year相比是过去的年份</span></span><br><span class="line">    )</span><br><span class="line">)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span>    <span class="keyword">year</span>;</span><br><span class="line"><span class="comment">-- (2)使用自连接：可减少一层子查询的嵌套</span></span><br><span class="line"><span class="keyword">SELECT</span>  s1.year</span><br><span class="line">        , s1.sale</span><br><span class="line"><span class="keyword">FROM</span>    Sales s1, Sales s2</span><br><span class="line"><span class="keyword">WHERE</span>   s1.sale = s2.sale</span><br><span class="line"><span class="keyword">AND</span>     s2.year = (<span class="keyword">SELECT</span> <span class="keyword">MAX</span>(<span class="keyword">year</span>) <span class="keyword">FROM</span> Sales s3 <span class="keyword">WHERE</span> s1.year &gt; s3.year)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span>    <span class="keyword">year</span>;</span><br><span class="line"><span class="comment">-- 自连接的结果里不包括最早的年份</span></span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 求每一年与过去最邻近的年份之间的营业额之差</span></span><br><span class="line"><span class="comment">-- 使用自外连接，结果里包含最早的年份</span></span><br><span class="line"><span class="keyword">SELECT</span>  s2.year <span class="keyword">AS</span> pre_year</span><br><span class="line">        , s1.year <span class="keyword">AS</span> now_year</span><br><span class="line">        , s2.sale <span class="keyword">AS</span> pre_sale</span><br><span class="line">        , s1.sale <span class="keyword">AS</span> now_sale</span><br><span class="line">        , s1.sale - s2.sale <span class="keyword">AS</span> diff_sale</span><br><span class="line"><span class="keyword">FROM</span>    Sales s1 <span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> Sales s2</span><br><span class="line"><span class="keyword">ON</span>      s2.year = (<span class="keyword">SELECT</span> <span class="keyword">MAX</span>(<span class="keyword">year</span>) <span class="keyword">FROM</span> Sales s3 <span class="keyword">WHERE</span> s1.year &gt; s3.year)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span>    now_year;</span><br></pre></td></tr></table></figure>
<h2 id="累计值"><a href="#累计值" class="headerlink" title="累计值"></a>累计值</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 求截止到某个日期的营业额累计值</span></span><br><span class="line"><span class="comment">-- (1)使用窗口函数</span></span><br><span class="line"><span class="keyword">SELECT</span>  <span class="built_in">date</span></span><br><span class="line">        , amt</span><br><span class="line">        , <span class="keyword">SUM</span>(amt) <span class="keyword">OVER</span>(<span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="built_in">date</span>) <span class="keyword">AS</span> total_amt</span><br><span class="line"><span class="keyword">FROM</span>    Accounts;</span><br><span class="line"><span class="comment">-- (2)使用冯·诺伊曼型递归集合（标准SQL-92下）</span></span><br><span class="line"><span class="keyword">SELECT</span>  <span class="built_in">date</span></span><br><span class="line">        , a1.amt</span><br><span class="line">        , (<span class="keyword">SELECT</span> <span class="keyword">SUM</span>(amt) <span class="keyword">FROM</span> Accounts a2 <span class="keyword">WHERE</span> a1.date &gt;= a2.date) <span class="keyword">AS</span> total_amt</span><br><span class="line"><span class="keyword">FROM</span>    Accounts a1</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span>    <span class="built_in">date</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 求前3行（包括本行）的累计值</span></span><br><span class="line"><span class="keyword">SELECT</span>  <span class="built_in">date</span></span><br><span class="line">        , amt</span><br><span class="line">        , <span class="keyword">SUM</span>(amt) <span class="keyword">OVER</span>(<span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="built_in">date</span> <span class="keyword">ROWS</span> <span class="number">2</span> <span class="keyword">PRECEDING</span>) <span class="keyword">AS</span> total_amt</span><br><span class="line"><span class="keyword">FROM</span>    Accounts ;</span><br><span class="line"><span class="comment">-- 不满3行的时间区间也输出</span></span><br><span class="line"><span class="keyword">SELECT</span>  <span class="built_in">date</span></span><br><span class="line">        , a1.amt</span><br><span class="line">        , (</span><br><span class="line">            <span class="keyword">SELECT</span>  <span class="keyword">SUM</span>(amt) <span class="keyword">FROM</span> Accounts a2 </span><br><span class="line">            <span class="keyword">WHERE</span>   a1.date &gt;= a2.date</span><br><span class="line">            <span class="keyword">AND</span>  </span><br><span class="line">            (</span><br><span class="line">                <span class="keyword">SELECT</span>   <span class="keyword">COUNT</span>(*) <span class="keyword">FROM</span> Accounts a3</span><br><span class="line">                    <span class="keyword">WHERE</span>    a3.date <span class="keyword">BETWEEN</span> a2.date <span class="keyword">AND</span> a1.date</span><br><span class="line">                ) &lt;= <span class="number">3</span></span><br><span class="line">        ) <span class="keyword">AS</span> mvg_sum</span><br><span class="line"><span class="keyword">FROM</span>    Accounts a1</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="built_in">date</span>;</span><br><span class="line"><span class="comment">-- 不满3行的区间按无效处理</span></span><br><span class="line"><span class="keyword">SELECT</span>  <span class="built_in">date</span></span><br><span class="line">        , a1.amt</span><br><span class="line">        , (</span><br><span class="line">            <span class="keyword">SELECT</span>   <span class="keyword">SUM</span>(amt) <span class="keyword">FROM</span> Accounts a2 </span><br><span class="line">            <span class="keyword">WHERE</span>    a1.date &gt;= a2.date</span><br><span class="line">            <span class="keyword">AND</span>      (</span><br><span class="line">                        <span class="keyword">SELECT</span>  <span class="keyword">COUNT</span>(*)</span><br><span class="line">                        <span class="keyword">FROM</span>    Accounts a3</span><br><span class="line">                        <span class="keyword">WHERE</span>   a3.date <span class="keyword">BETWEEN</span> a2.date <span class="keyword">AND</span> a1.date</span><br><span class="line">                    ) &lt;= <span class="number">3</span> </span><br><span class="line">            <span class="keyword">HAVING</span>  <span class="keyword">COUNT</span>(*) = <span class="number">3</span>  <span class="comment">-- 不满3行数据的不显示</span></span><br><span class="line">           ) <span class="keyword">AS</span> mvg_sum</span><br><span class="line"><span class="keyword">FROM</span>    Accounts a1</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span>    <span class="built_in">date</span>;</span><br></pre></td></tr></table></figure>
<h2 id="移动平均值"><a href="#移动平均值" class="headerlink" title="移动平均值"></a>移动平均值</h2><ul>
<li>若要计算移动平均值，只需把上述例子中的<code>SUM</code>改为<code>AVG</code>即可</li>
</ul>
<h2 id="查询重叠的时间区间"><a href="#查询重叠的时间区间" class="headerlink" title="查询重叠的时间区间"></a>查询重叠的时间区间</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 求重叠的住宿期间</span></span><br><span class="line"><span class="keyword">SELECT</span>  reserver</span><br><span class="line">        , start_date</span><br><span class="line">        , end_date</span><br><span class="line"><span class="keyword">FROM</span>    tbl t1</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">EXISTS</span> (</span><br><span class="line">    <span class="keyword">SELECT</span>  * </span><br><span class="line">    <span class="keyword">FROM</span>    tbl t2</span><br><span class="line">    <span class="keyword">WHERE</span>   t1.reserver &lt;&gt; t2.reserver  <span class="comment">-- 与其他客人比较</span></span><br><span class="line">    <span class="keyword">AND</span>     </span><br><span class="line">    (</span><br><span class="line">        t1.start_date <span class="keyword">BETWEEN</span> t2.start_date <span class="keyword">AND</span> t2.end_date <span class="comment">-- 自己的入住日期在他人的住宿期间内</span></span><br><span class="line">        <span class="keyword">OR</span> </span><br><span class="line">        t1.end_date <span class="keyword">BETWEEN</span> t2.start_date <span class="keyword">AND</span> t2.end_date  <span class="comment">-- 自己的离店日期在他人的住宿期间内</span></span><br><span class="line">    )</span><br><span class="line">);</span><br><span class="line"><span class="comment">-- 如果有个人的住宿期间完全包含他人的住宿期间，则上述结果并不会输出这样的区间</span></span><br><span class="line"><span class="comment">-- 如果要把“完全包含他人的住宿期间的情况”也输出</span></span><br><span class="line"><span class="keyword">SELECT</span>  reserver</span><br><span class="line">        , start_date</span><br><span class="line">        , end_date</span><br><span class="line"><span class="keyword">FROM</span>    tbl t1</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">EXISTS</span></span><br><span class="line">    (</span><br><span class="line">        <span class="keyword">SELECT</span>  *</span><br><span class="line">        <span class="keyword">FROM</span>    tbl t2</span><br><span class="line">        <span class="keyword">WHERE</span>   t1.reserver &lt;&gt; t2.reserver</span><br><span class="line">        <span class="keyword">AND</span>     </span><br><span class="line">            (</span><br><span class="line">                (</span><br><span class="line">                    t1.start_date <span class="keyword">BETWEEN</span> t2.start_date <span class="keyword">AND</span> t2.end_date</span><br><span class="line">                    <span class="keyword">OR</span></span><br><span class="line">                    t1.end_date <span class="keyword">BETWEEN</span> t2.start_date <span class="keyword">AND</span> t2.end_date</span><br><span class="line">                )</span><br><span class="line">                <span class="keyword">OR</span> </span><br><span class="line">                (</span><br><span class="line">                    t2.start_date <span class="keyword">BETWEEN</span> t1.start_date <span class="keyword">AND</span> t1.end_date</span><br><span class="line">                    <span class="keyword">AND</span> <span class="comment">-- 注意</span></span><br><span class="line">                    t1.end_date <span class="keyword">BETWEEN</span> t1.start_date <span class="keyword">AND</span> t1.end_date</span><br><span class="line">                )</span><br><span class="line">            )</span><br><span class="line">    );</span><br></pre></td></tr></table></figure>
<h1 id="集合运算"><a href="#集合运算" class="headerlink" title="集合运算"></a>集合运算</h1><ul>
<li>直接使用<code>UNION</code>或<code>INTERSECT</code>，结果里不会出现重复的行；若要在结果里留下重复的行，可以加上<code>ALL</code>，即<code>UNION ALL</code></li>
<li>集合运算符为了排除掉重复行，默认地会发生排序，加上可选项<code>ALL</code>后，就不会再排序，所以性能会有提升</li>
<li>集合运算符有<strong>优先级</strong>：<code>INTERSECT</code>比<code>UNION</code>和<code>EXCEPT</code>优先级更高</li>
<li>集合运算支持：<ul>
<li>SQL Server从2005版开始支持<code>INTERSECT</code>和<code>EXCEPT</code>；而MySQL都不支持</li>
<li>Oracle实现了<code>EXCEPT</code>功能，但命名为<code>MINUS</code></li>
</ul>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>[1] <a href="https://mp.weixin.qq.com/s?__biz=MzU5NzkxODMxOA==&amp;mid=2247486368&amp;idx=1&amp;sn=3ef74be0a7b7345cba471da1370f8986&amp;chksm=fe4d5ca1c93ad5b7481d65a8fa0a8b4e585714af57ad69437d599bbac5830910562a9097a12b&amp;token=1415910284&amp;lang=zh_CN#rd" target="_blank" rel="noopener">Notes | SQL进阶教程 | 001</a></p>
<h1 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h1><ul>
<li><a href="/sql-sql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A.html" title="《SQL必知必会》读书笔记">《SQL必知必会》读书笔记</a></li>
<li><a href="/sql-sql%E8%A7%A3%E6%83%91.html" title="《SQL解惑》读书笔记">《SQL解惑》读书笔记</a>
</li>
</ul>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>天池 | 二手车交易数据</title>
    <url>/%E6%95%B0%E6%8D%AE%E6%B8%85%E6%B4%97-%E5%A4%A9%E6%B1%A0-%E4%BA%8C%E6%89%8B%E8%BD%A6%E4%BA%A4%E6%98%93%E6%95%B0%E6%8D%AE.html</url>
    <content><![CDATA[<p><center></center><br><a id="more"></a></p>
<h1 id="数据说明"><a href="#数据说明" class="headerlink" title="数据说明"></a>数据说明</h1><p>数据来源：<a href="https://tianchi.aliyun.com/notebook-ai/detail?spm=5176.12281978.0.0.68021b43DOhgme&amp;postId=95422" target="_blank" rel="noopener">天池</a></p>
<p><a href="https://tianchi.aliyun.com/competition/entrance/231784/information" target="_blank" rel="noopener">数据详情</a></p>
<blockquote>
<p>本篇笔记的代码使用Jupyter Lab实现</p>
</blockquote>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a><strong>参考资料</strong></h2><p>[1] <a href="https://tianchi.aliyun.com/notebook-ai/detail?spm=5176.12281978.0.0.6802593aEHEy7Y&amp;postId=95422" target="_blank" rel="noopener">Baseline方案</a></p>
<p>[2] <a href="https://tianchi.aliyun.com/notebook-ai/detail?spm=5176.12281978.0.0.6802593aEHEy7Y&amp;postId=95456" target="_blank" rel="noopener">赛题理解</a></p>
<p>[3] <a href="https://tianchi.aliyun.com/notebook-ai/detail?spm=5176.12281978.0.0.6802593aEHEy7Y&amp;postId=95457" target="_blank" rel="noopener">数据分析</a></p>
<p>[4] <a href="https://tianchi.aliyun.com/notebook-ai/detail?spm=5176.12281978.0.0.6802593aEHEy7Y&amp;postId=95501" target="_blank" rel="noopener">特征工程</a></p>
<p>[5] <a href="https://tianchi.aliyun.com/notebook-ai/detail?spm=5176.12281978.0.0.6802593aEHEy7Y&amp;postId=95460" target="_blank" rel="noopener">建模调参</a></p>
<p>[6] <a href="https://tianchi.aliyun.com/notebook-ai/detail?spm=5176.12281978.0.0.6802593aEHEy7Y&amp;postId=95535" target="_blank" rel="noopener">模型融合</a></p>
<h1 id="数据处理-amp-分析"><a href="#数据处理-amp-分析" class="headerlink" title="数据处理&amp;分析"></a>数据处理&amp;分析</h1><h2 id="载入需要的模块"><a href="#载入需要的模块" class="headerlink" title="载入需要的模块"></a>载入需要的模块</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 基础模块</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> warnings</span><br><span class="line"><span class="keyword">import</span> matplotlib</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"><span class="keyword">from</span> scipy.special <span class="keyword">import</span> jn</span><br><span class="line"><span class="keyword">from</span> IPython.display <span class="keyword">import</span> display, clear_output</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">warnings.filterwarnings(<span class="string">'ignore'</span>)</span><br><span class="line">%matplotlib inline</span><br><span class="line"></span><br><span class="line"><span class="comment">## 模型预测</span></span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> linear_model</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> preprocessing</span><br><span class="line"><span class="keyword">from</span> sklearn.svm <span class="keyword">import</span> SVR</span><br><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> RandomForestRegressor, GradientBoostingRegressor</span><br><span class="line"><span class="keyword">import</span> lightgbm <span class="keyword">as</span> lgb</span><br><span class="line"><span class="keyword">import</span> xgboost <span class="keyword">as</span> xgb</span><br><span class="line"></span><br><span class="line"><span class="comment">## 降维</span></span><br><span class="line"><span class="keyword">from</span> sklearn.decomposition <span class="keyword">import</span> PCA, FastICA, FactorAnalysis, SparsePCA</span><br><span class="line"></span><br><span class="line"><span class="comment">## 网格搜索、模型评估</span></span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> GridSearchCV, StratifiedKFold</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> cross_val_score, train_test_split</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> mean_squared_error, mean_absolute_error</span><br></pre></td></tr></table></figure>
<h2 id="载入数据"><a href="#载入数据" class="headerlink" title="载入数据"></a>载入数据</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 读取数据</span></span><br><span class="line">train_data = pd.read_csv(<span class="string">"used_car_train_20200313.csv"</span>, sep=<span class="string">" "</span>)</span><br><span class="line">testB_data = pd.read_csv(<span class="string">"used_car_testB_20200421.csv"</span>, sep=<span class="string">" "</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">## 训练集大小</span></span><br><span class="line">print(<span class="string">"Train data shape:"</span>, train_data.shape)</span><br></pre></td></tr></table></figure>
<pre><code>Train data shape: (150000, 31)
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 测试集大小</span></span><br><span class="line">print(<span class="string">"TestB data shape:"</span>, testB_data.shape)</span><br></pre></td></tr></table></figure>
<pre><code>TestB data shape: (50000, 30)
</code></pre><h2 id="数据预览"><a href="#数据预览" class="headerlink" title="数据预览"></a>数据预览</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">train_data.head()  <span class="comment">## 预览前5行</span></span><br></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>SaleID</th>
      <th>name</th>
      <th>regDate</th>
      <th>model</th>
      <th>brand</th>
      <th>bodyType</th>
      <th>fuelType</th>
      <th>gearbox</th>
      <th>power</th>
      <th>kilometer</th>
      <th>...</th>
      <th>v_5</th>
      <th>v_6</th>
      <th>v_7</th>
      <th>v_8</th>
      <th>v_9</th>
      <th>v_10</th>
      <th>v_11</th>
      <th>v_12</th>
      <th>v_13</th>
      <th>v_14</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>0</td>
      <td>736</td>
      <td>20040402</td>
      <td>30.0</td>
      <td>6</td>
      <td>1.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>60</td>
      <td>12.5</td>
      <td>...</td>
      <td>0.235676</td>
      <td>0.101988</td>
      <td>0.129549</td>
      <td>0.022816</td>
      <td>0.097462</td>
      <td>-2.881803</td>
      <td>2.804097</td>
      <td>-2.420821</td>
      <td>0.795292</td>
      <td>0.914762</td>
    </tr>
    <tr>
      <th>1</th>
      <td>1</td>
      <td>2262</td>
      <td>20030301</td>
      <td>40.0</td>
      <td>1</td>
      <td>2.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0</td>
      <td>15.0</td>
      <td>...</td>
      <td>0.264777</td>
      <td>0.121004</td>
      <td>0.135731</td>
      <td>0.026597</td>
      <td>0.020582</td>
      <td>-4.900482</td>
      <td>2.096338</td>
      <td>-1.030483</td>
      <td>-1.722674</td>
      <td>0.245522</td>
    </tr>
    <tr>
      <th>2</th>
      <td>2</td>
      <td>14874</td>
      <td>20040403</td>
      <td>115.0</td>
      <td>15</td>
      <td>1.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>163</td>
      <td>12.5</td>
      <td>...</td>
      <td>0.251410</td>
      <td>0.114912</td>
      <td>0.165147</td>
      <td>0.062173</td>
      <td>0.027075</td>
      <td>-4.846749</td>
      <td>1.803559</td>
      <td>1.565330</td>
      <td>-0.832687</td>
      <td>-0.229963</td>
    </tr>
    <tr>
      <th>3</th>
      <td>3</td>
      <td>71865</td>
      <td>19960908</td>
      <td>109.0</td>
      <td>10</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>1.0</td>
      <td>193</td>
      <td>15.0</td>
      <td>...</td>
      <td>0.274293</td>
      <td>0.110300</td>
      <td>0.121964</td>
      <td>0.033395</td>
      <td>0.000000</td>
      <td>-4.509599</td>
      <td>1.285940</td>
      <td>-0.501868</td>
      <td>-2.438353</td>
      <td>-0.478699</td>
    </tr>
    <tr>
      <th>4</th>
      <td>4</td>
      <td>111080</td>
      <td>20120103</td>
      <td>110.0</td>
      <td>5</td>
      <td>1.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>68</td>
      <td>5.0</td>
      <td>...</td>
      <td>0.228036</td>
      <td>0.073205</td>
      <td>0.091880</td>
      <td>0.078819</td>
      <td>0.121534</td>
      <td>-1.896240</td>
      <td>0.910783</td>
      <td>0.931110</td>
      <td>2.834518</td>
      <td>1.923482</td>
    </tr>
  </tbody>
</table>
<p>5 rows × 31 columns</p>
</div>




<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">train_data.tail()  <span class="comment">## 预览最后5行</span></span><br></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>SaleID</th>
      <th>name</th>
      <th>regDate</th>
      <th>model</th>
      <th>brand</th>
      <th>bodyType</th>
      <th>fuelType</th>
      <th>gearbox</th>
      <th>power</th>
      <th>kilometer</th>
      <th>...</th>
      <th>v_5</th>
      <th>v_6</th>
      <th>v_7</th>
      <th>v_8</th>
      <th>v_9</th>
      <th>v_10</th>
      <th>v_11</th>
      <th>v_12</th>
      <th>v_13</th>
      <th>v_14</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>149995</th>
      <td>149995</td>
      <td>163978</td>
      <td>20000607</td>
      <td>121.0</td>
      <td>10</td>
      <td>4.0</td>
      <td>0.0</td>
      <td>1.0</td>
      <td>163</td>
      <td>15.0</td>
      <td>...</td>
      <td>0.280264</td>
      <td>0.000310</td>
      <td>0.048441</td>
      <td>0.071158</td>
      <td>0.019174</td>
      <td>1.988114</td>
      <td>-2.983973</td>
      <td>0.589167</td>
      <td>-1.304370</td>
      <td>-0.302592</td>
    </tr>
    <tr>
      <th>149996</th>
      <td>149996</td>
      <td>184535</td>
      <td>20091102</td>
      <td>116.0</td>
      <td>11</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>125</td>
      <td>10.0</td>
      <td>...</td>
      <td>0.253217</td>
      <td>0.000777</td>
      <td>0.084079</td>
      <td>0.099681</td>
      <td>0.079371</td>
      <td>1.839166</td>
      <td>-2.774615</td>
      <td>2.553994</td>
      <td>0.924196</td>
      <td>-0.272160</td>
    </tr>
    <tr>
      <th>149997</th>
      <td>149997</td>
      <td>147587</td>
      <td>20101003</td>
      <td>60.0</td>
      <td>11</td>
      <td>1.0</td>
      <td>1.0</td>
      <td>0.0</td>
      <td>90</td>
      <td>6.0</td>
      <td>...</td>
      <td>0.233353</td>
      <td>0.000705</td>
      <td>0.118872</td>
      <td>0.100118</td>
      <td>0.097914</td>
      <td>2.439812</td>
      <td>-1.630677</td>
      <td>2.290197</td>
      <td>1.891922</td>
      <td>0.414931</td>
    </tr>
    <tr>
      <th>149998</th>
      <td>149998</td>
      <td>45907</td>
      <td>20060312</td>
      <td>34.0</td>
      <td>10</td>
      <td>3.0</td>
      <td>1.0</td>
      <td>0.0</td>
      <td>156</td>
      <td>15.0</td>
      <td>...</td>
      <td>0.256369</td>
      <td>0.000252</td>
      <td>0.081479</td>
      <td>0.083558</td>
      <td>0.081498</td>
      <td>2.075380</td>
      <td>-2.633719</td>
      <td>1.414937</td>
      <td>0.431981</td>
      <td>-1.659014</td>
    </tr>
    <tr>
      <th>149999</th>
      <td>149999</td>
      <td>177672</td>
      <td>19990204</td>
      <td>19.0</td>
      <td>28</td>
      <td>6.0</td>
      <td>0.0</td>
      <td>1.0</td>
      <td>193</td>
      <td>12.5</td>
      <td>...</td>
      <td>0.284475</td>
      <td>0.000000</td>
      <td>0.040072</td>
      <td>0.062543</td>
      <td>0.025819</td>
      <td>1.978453</td>
      <td>-3.179913</td>
      <td>0.031724</td>
      <td>-1.483350</td>
      <td>-0.342674</td>
    </tr>
  </tbody>
</table>
<p>5 rows × 31 columns</p>
</div>




<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## .info()简要查看每列对应的数据类型、非缺失样本量</span></span><br><span class="line">train_data.info()</span><br><span class="line"><span class="comment">## 总共有150000个样本量</span></span><br><span class="line"><span class="comment">## 149999表明'model'列有1个缺失值</span></span><br></pre></td></tr></table></figure>
<pre><code>&lt;class &#39;pandas.core.frame.DataFrame&#39;&gt;
RangeIndex: 150000 entries, 0 to 149999
Data columns (total 31 columns):
SaleID               150000 non-null int64
name                 150000 non-null int64
regDate              150000 non-null int64
model                149999 non-null float64
brand                150000 non-null int64
bodyType             145494 non-null float64
fuelType             141320 non-null float64
gearbox              144019 non-null float64
power                150000 non-null int64
kilometer            150000 non-null float64
notRepairedDamage    150000 non-null object
regionCode           150000 non-null int64
seller               150000 non-null int64
offerType            150000 non-null int64
creatDate            150000 non-null int64
price                150000 non-null int64
v_0                  150000 non-null float64
v_1                  150000 non-null float64
v_2                  150000 non-null float64
v_3                  150000 non-null float64
v_4                  150000 non-null float64
v_5                  150000 non-null float64
v_6                  150000 non-null float64
v_7                  150000 non-null float64
v_8                  150000 non-null float64
v_9                  150000 non-null float64
v_10                 150000 non-null float64
v_11                 150000 non-null float64
v_12                 150000 non-null float64
v_13                 150000 non-null float64
v_14                 150000 non-null float64
dtypes: float64(20), int64(10), object(1)
memory usage: 35.5+ MB
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">train_data.columns  <span class="comment">## 查看所有列名</span></span><br></pre></td></tr></table></figure>
<pre><code>Index([&#39;SaleID&#39;, &#39;name&#39;, &#39;regDate&#39;, &#39;model&#39;, &#39;brand&#39;, &#39;bodyType&#39;, &#39;fuelType&#39;,
       &#39;gearbox&#39;, &#39;power&#39;, &#39;kilometer&#39;, &#39;notRepairedDamage&#39;, &#39;regionCode&#39;,
       &#39;seller&#39;, &#39;offerType&#39;, &#39;creatDate&#39;, &#39;price&#39;, &#39;v_0&#39;, &#39;v_1&#39;, &#39;v_2&#39;, &#39;v_3&#39;,
       &#39;v_4&#39;, &#39;v_5&#39;, &#39;v_6&#39;, &#39;v_7&#39;, &#39;v_8&#39;, &#39;v_9&#39;, &#39;v_10&#39;, &#39;v_11&#39;, &#39;v_12&#39;,
       &#39;v_13&#39;, &#39;v_14&#39;],
      dtype=&#39;object&#39;)
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">testB_data.info()</span><br><span class="line"><span class="comment">## 测试集有50000个样本</span></span><br></pre></td></tr></table></figure>
<pre><code>&lt;class &#39;pandas.core.frame.DataFrame&#39;&gt;
RangeIndex: 50000 entries, 0 to 49999
Data columns (total 30 columns):
SaleID               50000 non-null int64
name                 50000 non-null int64
regDate              50000 non-null int64
model                50000 non-null float64
brand                50000 non-null int64
bodyType             48496 non-null float64
fuelType             47076 non-null float64
gearbox              48032 non-null float64
power                50000 non-null int64
kilometer            50000 non-null float64
notRepairedDamage    50000 non-null object
regionCode           50000 non-null int64
seller               50000 non-null int64
offerType            50000 non-null int64
creatDate            50000 non-null int64
v_0                  50000 non-null float64
v_1                  50000 non-null float64
v_2                  50000 non-null float64
v_3                  50000 non-null float64
v_4                  50000 non-null float64
v_5                  50000 non-null float64
v_6                  50000 non-null float64
v_7                  50000 non-null float64
v_8                  50000 non-null float64
v_9                  50000 non-null float64
v_10                 50000 non-null float64
v_11                 50000 non-null float64
v_12                 50000 non-null float64
v_13                 50000 non-null float64
v_14                 50000 non-null float64
dtypes: float64(20), int64(9), object(1)
memory usage: 11.4+ MB
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 描述性统计</span></span><br><span class="line">train_data.describe()</span><br><span class="line"><span class="comment">## 查看每列的非空样本量、均值mean、标准差std、最小值min、25%分位数、</span></span><br><span class="line"><span class="comment">## 中位数（即50%分位数）、75%分位数、最大值max</span></span><br></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>SaleID</th>
      <th>name</th>
      <th>regDate</th>
      <th>model</th>
      <th>brand</th>
      <th>bodyType</th>
      <th>fuelType</th>
      <th>gearbox</th>
      <th>power</th>
      <th>kilometer</th>
      <th>...</th>
      <th>v_5</th>
      <th>v_6</th>
      <th>v_7</th>
      <th>v_8</th>
      <th>v_9</th>
      <th>v_10</th>
      <th>v_11</th>
      <th>v_12</th>
      <th>v_13</th>
      <th>v_14</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>count</th>
      <td>150000.000000</td>
      <td>150000.000000</td>
      <td>1.500000e+05</td>
      <td>149999.000000</td>
      <td>150000.000000</td>
      <td>145494.000000</td>
      <td>141320.000000</td>
      <td>144019.000000</td>
      <td>150000.000000</td>
      <td>150000.000000</td>
      <td>...</td>
      <td>150000.000000</td>
      <td>150000.000000</td>
      <td>150000.000000</td>
      <td>150000.000000</td>
      <td>150000.000000</td>
      <td>150000.000000</td>
      <td>150000.000000</td>
      <td>150000.000000</td>
      <td>150000.000000</td>
      <td>150000.000000</td>
    </tr>
    <tr>
      <th>mean</th>
      <td>74999.500000</td>
      <td>68349.172873</td>
      <td>2.003417e+07</td>
      <td>47.129021</td>
      <td>8.052733</td>
      <td>1.792369</td>
      <td>0.375842</td>
      <td>0.224943</td>
      <td>119.316547</td>
      <td>12.597160</td>
      <td>...</td>
      <td>0.248204</td>
      <td>0.044923</td>
      <td>0.124692</td>
      <td>0.058144</td>
      <td>0.061996</td>
      <td>-0.001000</td>
      <td>0.009035</td>
      <td>0.004813</td>
      <td>0.000313</td>
      <td>-0.000688</td>
    </tr>
    <tr>
      <th>std</th>
      <td>43301.414527</td>
      <td>61103.875095</td>
      <td>5.364988e+04</td>
      <td>49.536040</td>
      <td>7.864956</td>
      <td>1.760640</td>
      <td>0.548677</td>
      <td>0.417546</td>
      <td>177.168419</td>
      <td>3.919576</td>
      <td>...</td>
      <td>0.045804</td>
      <td>0.051743</td>
      <td>0.201410</td>
      <td>0.029186</td>
      <td>0.035692</td>
      <td>3.772386</td>
      <td>3.286071</td>
      <td>2.517478</td>
      <td>1.288988</td>
      <td>1.038685</td>
    </tr>
    <tr>
      <th>min</th>
      <td>0.000000</td>
      <td>0.000000</td>
      <td>1.991000e+07</td>
      <td>0.000000</td>
      <td>0.000000</td>
      <td>0.000000</td>
      <td>0.000000</td>
      <td>0.000000</td>
      <td>0.000000</td>
      <td>0.500000</td>
      <td>...</td>
      <td>0.000000</td>
      <td>0.000000</td>
      <td>0.000000</td>
      <td>0.000000</td>
      <td>0.000000</td>
      <td>-9.168192</td>
      <td>-5.558207</td>
      <td>-9.639552</td>
      <td>-4.153899</td>
      <td>-6.546556</td>
    </tr>
    <tr>
      <th>25%</th>
      <td>37499.750000</td>
      <td>11156.000000</td>
      <td>1.999091e+07</td>
      <td>10.000000</td>
      <td>1.000000</td>
      <td>0.000000</td>
      <td>0.000000</td>
      <td>0.000000</td>
      <td>75.000000</td>
      <td>12.500000</td>
      <td>...</td>
      <td>0.243615</td>
      <td>0.000038</td>
      <td>0.062474</td>
      <td>0.035334</td>
      <td>0.033930</td>
      <td>-3.722303</td>
      <td>-1.951543</td>
      <td>-1.871846</td>
      <td>-1.057789</td>
      <td>-0.437034</td>
    </tr>
    <tr>
      <th>50%</th>
      <td>74999.500000</td>
      <td>51638.000000</td>
      <td>2.003091e+07</td>
      <td>30.000000</td>
      <td>6.000000</td>
      <td>1.000000</td>
      <td>0.000000</td>
      <td>0.000000</td>
      <td>110.000000</td>
      <td>15.000000</td>
      <td>...</td>
      <td>0.257798</td>
      <td>0.000812</td>
      <td>0.095866</td>
      <td>0.057014</td>
      <td>0.058484</td>
      <td>1.624076</td>
      <td>-0.358053</td>
      <td>-0.130753</td>
      <td>-0.036245</td>
      <td>0.141246</td>
    </tr>
    <tr>
      <th>75%</th>
      <td>112499.250000</td>
      <td>118841.250000</td>
      <td>2.007111e+07</td>
      <td>66.000000</td>
      <td>13.000000</td>
      <td>3.000000</td>
      <td>1.000000</td>
      <td>0.000000</td>
      <td>150.000000</td>
      <td>15.000000</td>
      <td>...</td>
      <td>0.265297</td>
      <td>0.102009</td>
      <td>0.125243</td>
      <td>0.079382</td>
      <td>0.087491</td>
      <td>2.844357</td>
      <td>1.255022</td>
      <td>1.776933</td>
      <td>0.942813</td>
      <td>0.680378</td>
    </tr>
    <tr>
      <th>max</th>
      <td>149999.000000</td>
      <td>196812.000000</td>
      <td>2.015121e+07</td>
      <td>247.000000</td>
      <td>39.000000</td>
      <td>7.000000</td>
      <td>6.000000</td>
      <td>1.000000</td>
      <td>19312.000000</td>
      <td>15.000000</td>
      <td>...</td>
      <td>0.291838</td>
      <td>0.151420</td>
      <td>1.404936</td>
      <td>0.160791</td>
      <td>0.222787</td>
      <td>12.357011</td>
      <td>18.819042</td>
      <td>13.847792</td>
      <td>11.147669</td>
      <td>8.658418</td>
    </tr>
  </tbody>
</table>
<p>8 rows × 30 columns</p>
</div>




<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">testB_data.describe()</span><br></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>SaleID</th>
      <th>name</th>
      <th>regDate</th>
      <th>model</th>
      <th>brand</th>
      <th>bodyType</th>
      <th>fuelType</th>
      <th>gearbox</th>
      <th>power</th>
      <th>kilometer</th>
      <th>...</th>
      <th>v_5</th>
      <th>v_6</th>
      <th>v_7</th>
      <th>v_8</th>
      <th>v_9</th>
      <th>v_10</th>
      <th>v_11</th>
      <th>v_12</th>
      <th>v_13</th>
      <th>v_14</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>count</th>
      <td>50000.000000</td>
      <td>50000.000000</td>
      <td>5.000000e+04</td>
      <td>50000.00000</td>
      <td>50000.000000</td>
      <td>48496.000000</td>
      <td>47076.000000</td>
      <td>48032.000000</td>
      <td>50000.000000</td>
      <td>50000.000000</td>
      <td>...</td>
      <td>50000.000000</td>
      <td>50000.000000</td>
      <td>50000.000000</td>
      <td>50000.000000</td>
      <td>50000.000000</td>
      <td>50000.000000</td>
      <td>50000.000000</td>
      <td>50000.000000</td>
      <td>50000.000000</td>
      <td>50000.000000</td>
    </tr>
    <tr>
      <th>mean</th>
      <td>224999.500000</td>
      <td>68505.606100</td>
      <td>2.003401e+07</td>
      <td>47.64948</td>
      <td>8.087140</td>
      <td>1.793736</td>
      <td>0.376498</td>
      <td>0.226953</td>
      <td>119.766960</td>
      <td>12.598260</td>
      <td>...</td>
      <td>0.248147</td>
      <td>0.044624</td>
      <td>0.124693</td>
      <td>0.058198</td>
      <td>0.062113</td>
      <td>0.019633</td>
      <td>0.002759</td>
      <td>0.004342</td>
      <td>0.004570</td>
      <td>-0.007209</td>
    </tr>
    <tr>
      <th>std</th>
      <td>14433.901067</td>
      <td>61032.124271</td>
      <td>5.351615e+04</td>
      <td>49.90741</td>
      <td>7.899648</td>
      <td>1.764970</td>
      <td>0.549281</td>
      <td>0.418866</td>
      <td>206.313348</td>
      <td>3.912519</td>
      <td>...</td>
      <td>0.045836</td>
      <td>0.051664</td>
      <td>0.201440</td>
      <td>0.029171</td>
      <td>0.035723</td>
      <td>3.764095</td>
      <td>3.289523</td>
      <td>2.515912</td>
      <td>1.287194</td>
      <td>1.044718</td>
    </tr>
    <tr>
      <th>min</th>
      <td>200000.000000</td>
      <td>1.000000</td>
      <td>1.991000e+07</td>
      <td>0.00000</td>
      <td>0.000000</td>
      <td>0.000000</td>
      <td>0.000000</td>
      <td>0.000000</td>
      <td>0.000000</td>
      <td>0.500000</td>
      <td>...</td>
      <td>0.000000</td>
      <td>0.000000</td>
      <td>0.000000</td>
      <td>0.000000</td>
      <td>0.000000</td>
      <td>-9.119719</td>
      <td>-5.662163</td>
      <td>-8.291868</td>
      <td>-4.157649</td>
      <td>-6.098192</td>
    </tr>
    <tr>
      <th>25%</th>
      <td>212499.750000</td>
      <td>11315.000000</td>
      <td>1.999100e+07</td>
      <td>11.00000</td>
      <td>1.000000</td>
      <td>0.000000</td>
      <td>0.000000</td>
      <td>0.000000</td>
      <td>75.000000</td>
      <td>12.500000</td>
      <td>...</td>
      <td>0.243436</td>
      <td>0.000035</td>
      <td>0.062519</td>
      <td>0.035413</td>
      <td>0.033880</td>
      <td>-3.675196</td>
      <td>-1.963928</td>
      <td>-1.865406</td>
      <td>-1.048722</td>
      <td>-0.440706</td>
    </tr>
    <tr>
      <th>50%</th>
      <td>224999.500000</td>
      <td>52215.000000</td>
      <td>2.003091e+07</td>
      <td>30.00000</td>
      <td>6.000000</td>
      <td>1.000000</td>
      <td>0.000000</td>
      <td>0.000000</td>
      <td>110.000000</td>
      <td>15.000000</td>
      <td>...</td>
      <td>0.257818</td>
      <td>0.000801</td>
      <td>0.095880</td>
      <td>0.056804</td>
      <td>0.058749</td>
      <td>1.632134</td>
      <td>-0.375537</td>
      <td>-0.138943</td>
      <td>-0.036352</td>
      <td>0.136849</td>
    </tr>
    <tr>
      <th>75%</th>
      <td>237499.250000</td>
      <td>118710.750000</td>
      <td>2.007110e+07</td>
      <td>66.00000</td>
      <td>13.000000</td>
      <td>3.000000</td>
      <td>1.000000</td>
      <td>0.000000</td>
      <td>150.000000</td>
      <td>15.000000</td>
      <td>...</td>
      <td>0.265263</td>
      <td>0.101654</td>
      <td>0.125470</td>
      <td>0.079387</td>
      <td>0.087624</td>
      <td>2.846205</td>
      <td>1.263451</td>
      <td>1.775632</td>
      <td>0.945239</td>
      <td>0.685555</td>
    </tr>
    <tr>
      <th>max</th>
      <td>249999.000000</td>
      <td>196808.000000</td>
      <td>2.015121e+07</td>
      <td>246.00000</td>
      <td>39.000000</td>
      <td>7.000000</td>
      <td>6.000000</td>
      <td>1.000000</td>
      <td>19211.000000</td>
      <td>15.000000</td>
      <td>...</td>
      <td>0.291176</td>
      <td>0.153403</td>
      <td>1.411559</td>
      <td>0.157458</td>
      <td>0.211304</td>
      <td>12.177864</td>
      <td>18.789496</td>
      <td>13.384828</td>
      <td>5.635374</td>
      <td>2.649768</td>
    </tr>
  </tbody>
</table>
<p>8 rows × 29 columns</p>
</div>



<h2 id="数据特征"><a href="#数据特征" class="headerlink" title="数据特征"></a>数据特征</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 提取数值型特征列名</span></span><br><span class="line">numerical_cols = train_data.select_dtypes(exclude=<span class="string">'object'</span>).columns</span><br><span class="line">print(numerical_cols)</span><br></pre></td></tr></table></figure>
<pre><code>Index([&#39;SaleID&#39;, &#39;name&#39;, &#39;regDate&#39;, &#39;model&#39;, &#39;brand&#39;, &#39;bodyType&#39;, &#39;fuelType&#39;,
       &#39;gearbox&#39;, &#39;power&#39;, &#39;kilometer&#39;, &#39;regionCode&#39;, &#39;seller&#39;, &#39;offerType&#39;,
       &#39;creatDate&#39;, &#39;price&#39;, &#39;v_0&#39;, &#39;v_1&#39;, &#39;v_2&#39;, &#39;v_3&#39;, &#39;v_4&#39;, &#39;v_5&#39;, &#39;v_6&#39;,
       &#39;v_7&#39;, &#39;v_8&#39;, &#39;v_9&#39;, &#39;v_10&#39;, &#39;v_11&#39;, &#39;v_12&#39;, &#39;v_13&#39;, &#39;v_14&#39;],
      dtype=&#39;object&#39;)
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 提取非数值型特征列名</span></span><br><span class="line">categorical_cols = train_data.select_dtypes(include=<span class="string">'object'</span>).columns</span><br><span class="line">print(categorical_cols)</span><br></pre></td></tr></table></figure>
<pre><code>Index([&#39;notRepairedDamage&#39;], dtype=&#39;object&#39;)
</code></pre><h2 id="训练集和测试集"><a href="#训练集和测试集" class="headerlink" title="训练集和测试集"></a>训练集和测试集</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 选择特征列</span></span><br><span class="line">feature_cols = [col <span class="keyword">for</span> col <span class="keyword">in</span> numerical_cols <span class="keyword">if</span> col <span class="keyword">not</span> <span class="keyword">in</span> [<span class="string">'SaleID'</span>, <span class="string">'name'</span>, <span class="string">'regDate'</span>,<span class="string">'creatDate'</span>,<span class="string">'price'</span>,<span class="string">'model'</span>,<span class="string">'brand'</span>,<span class="string">'regionCode'</span>,<span class="string">'seller'</span>]]</span><br><span class="line">feature_cols = [col <span class="keyword">for</span> col <span class="keyword">in</span> feature_cols <span class="keyword">if</span> <span class="string">'Type'</span> <span class="keyword">not</span> <span class="keyword">in</span> col]</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 提取特征列、标签列构造训练集和测试集</span></span><br><span class="line">X_train = train_data[feature_cols]  <span class="comment">## 训练集特征</span></span><br><span class="line">y_train = train_data[<span class="string">'price'</span>]  <span class="comment">## 训练集标签</span></span><br><span class="line"></span><br><span class="line">X_test = testB_data[feature_cols]  <span class="comment">## 测试集标签</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">'X train shape is :'</span>, X_train.shape)</span><br><span class="line">print(<span class="string">'X test shape is :'</span>, X_test.shape)</span><br></pre></td></tr></table></figure>
<pre><code>X train shape is : (150000, 18)
X test shape is : (50000, 18)
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 统计标签的基本分布信息</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">stat_info</span><span class="params">(data)</span>:</span></span><br><span class="line">    print(<span class="string">'_min'</span>, np.min(data))</span><br><span class="line">    print(<span class="string">'_max'</span>, np.max(data))</span><br><span class="line">    print(<span class="string">'_mean'</span>, np.mean(data))</span><br><span class="line">    print(<span class="string">'_ptp'</span>, np.ptp(data))  <span class="comment">## 最大值与最小值的差</span></span><br><span class="line">    print(<span class="string">'_std'</span>, np.std(data))</span><br><span class="line">    print(<span class="string">'_var'</span>, np.var(data))</span><br><span class="line"></span><br><span class="line">print(<span class="string">'Stat of label:'</span>)</span><br><span class="line">stat_info(y_train)</span><br></pre></td></tr></table></figure>
<pre><code>Stat of label:
_min 11
_max 99999
_mean 5923.327333333334
_ptp 99988
_std 7501.973469876438
_var 56279605.94272992
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## label中可能存在异常大值</span></span><br><span class="line"><span class="comment">## 绘制标签的直方图，查看标签分布</span></span><br><span class="line">plt.hist(y_train)</span><br><span class="line">plt.show()</span><br><span class="line">plt.close()</span><br></pre></td></tr></table></figure>
<p><meta name="referrer" content="no-referrer"><br><img src="/%E6%95%B0%E6%8D%AE%E6%B8%85%E6%B4%97-%E5%A4%A9%E6%B1%A0-%E4%BA%8C%E6%89%8B%E8%BD%A6%E4%BA%A4%E6%98%93%E6%95%B0%E6%8D%AE/output_23_0.png" class title="直方图"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 填补缺失值</span></span><br><span class="line">X_train = X_train.fillna(<span class="number">-1</span>)  <span class="comment">## 用-1填补</span></span><br><span class="line">X_test = X_test.fillna(<span class="number">-1</span>)</span><br></pre></td></tr></table></figure>
<h1 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 利用XGBoost进行5折交叉验证</span></span><br><span class="line">xgb_reg = xgb.XGBRegressor(</span><br><span class="line">    n_estimators=<span class="number">120</span>, </span><br><span class="line">    learning_rate=<span class="number">0.1</span>, </span><br><span class="line">    gamma=<span class="number">0</span>,</span><br><span class="line">    subsample=<span class="number">0.8</span>,</span><br><span class="line">    colsample_bytree=<span class="number">0.9</span>,</span><br><span class="line">    max_depth=<span class="number">7</span>,</span><br><span class="line">    objective=<span class="string">'reg:squarederror'</span></span><br><span class="line">)</span><br><span class="line">scores_train = []</span><br><span class="line">scores = []</span><br><span class="line"></span><br><span class="line"><span class="comment">## 5折交叉验证</span></span><br><span class="line">folds = StratifiedKFold(n_splits=<span class="number">5</span>, shuffle=<span class="literal">True</span>, random_state=<span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> train_idx, val_idx <span class="keyword">in</span> folds.split(X_train, y_train):</span><br><span class="line">    train_X = X_train.iloc[train_idx].values</span><br><span class="line">    train_y = y_train.iloc[train_idx]</span><br><span class="line">    val_X = X_train.iloc[val_idx].values</span><br><span class="line">    val_y = y_train.iloc[val_idx]</span><br><span class="line">    </span><br><span class="line">    xgb_reg.fit(train_X, train_y)</span><br><span class="line">    pred_train_y_xgb = xgb_reg.predict(train_X)</span><br><span class="line">    pred_val_y_xgb = xgb_reg.predict(val_X)</span><br><span class="line">    </span><br><span class="line">    score_train = mean_absolute_error(train_y, pred_train_y_xgb)</span><br><span class="line">    scores_train.append(score_train)</span><br><span class="line">    score = mean_absolute_error(val_y, pred_val_y_xgb)</span><br><span class="line">    scores.append(score)</span><br><span class="line">    </span><br><span class="line">print(<span class="string">'Train MAE:'</span>, np.mean(score_train))</span><br><span class="line">print(<span class="string">'Validation MAE:'</span>, np.mean(scores))</span><br></pre></td></tr></table></figure>
<pre><code>Train MAE: 622.8334142499367
Validation MAE: 713.7602744693083
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 定义xgb和lgb模型函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">XGB_model</span><span class="params">(x_train, y_train)</span>:</span></span><br><span class="line">    model = xgb.XGBRegressor(</span><br><span class="line">        n_estimators=<span class="number">150</span>,</span><br><span class="line">        learning_rate=<span class="number">0.1</span>,</span><br><span class="line">        gamma=<span class="number">0</span>,</span><br><span class="line">        subsample=<span class="number">0.8</span>,</span><br><span class="line">        colsample_bytree=<span class="number">0.9</span>,</span><br><span class="line">        max_depth=<span class="number">7</span>,</span><br><span class="line">        objective=<span class="string">'reg:squarederror'</span></span><br><span class="line">    )</span><br><span class="line">    model.fit(x_train, y_train)</span><br><span class="line">    <span class="keyword">return</span> model</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">LGB_model</span><span class="params">(x_train, y_train)</span>:</span></span><br><span class="line">    estimator = lgb.LGBMRegressor(</span><br><span class="line">        num_leaves=<span class="number">127</span>,</span><br><span class="line">        n_estimators=<span class="number">150</span></span><br><span class="line">    )</span><br><span class="line">    param_grid = &#123;</span><br><span class="line">        <span class="string">'learning_rate'</span>: [<span class="number">0.01</span>, <span class="number">0.05</span>, <span class="number">0.1</span>, <span class="number">0.2</span>],</span><br><span class="line">    &#125;</span><br><span class="line">    gbm = GridSearchCV(estimator, param_grid)</span><br><span class="line">    gbm.fit(x_train, y_train)</span><br><span class="line">    <span class="keyword">return</span> gbm</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 切分训练集和验证集</span></span><br><span class="line">x_train, x_val, yy_train, y_val = train_test_split(X_train, y_train, test_size=<span class="number">0.3</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="string">"Training LGB ..."</span>)</span><br><span class="line">model_lgb = LGB_model(x_train, yy_train)</span><br><span class="line">val_lgb = model_lgb.predict(x_val)</span><br><span class="line">MAE_lgb = mean_absolute_error(y_val, val_lgb)</span><br><span class="line">print(<span class="string">"MAE of val with LGB:"</span>, MAE_lgb)</span><br><span class="line"></span><br><span class="line">print(<span class="string">"Predict LGB ..."</span>)</span><br><span class="line">model_lgb_pred = LGB_model(X_train, y_train)</span><br><span class="line">subB_lgb = model_lgb_pred.predict(X_test)</span><br><span class="line">print(<span class="string">"stat of Predict LGB:"</span>)</span><br><span class="line">stat_info(subB_lgb)</span><br></pre></td></tr></table></figure>
<pre><code>Training LGB ...
MAE of val with LGB: 687.1736052804791
Predict LGB ...
stat of Predict LGB:
_min -589.8793550785414
_max 90760.26063584947
_mean 5906.935218383807
_ptp 91350.13999092802
_std 7344.644970956768
_var 53943809.749400534
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="string">"Training XGB ..."</span>)</span><br><span class="line">model_xgb = XGB_model(x_train, yy_train)</span><br><span class="line">val_xgb = model_xgb.predict(x_val)</span><br><span class="line">MAE_xgb = mean_absolute_error(y_val, val_xgb)</span><br><span class="line">print(<span class="string">"MAE of val with xgb:"</span>, MAE_xgb)</span><br><span class="line"></span><br><span class="line">print(<span class="string">"Predict xgb ..."</span>)</span><br><span class="line">model_xgb_pred = XGB_model(X_train, y_train)</span><br><span class="line">subB_xgb = model_xgb_pred.predict(X_test)</span><br><span class="line">print(<span class="string">"Stat of Predict XGB:"</span>)</span><br><span class="line">stat_info(subB_xgb)</span><br></pre></td></tr></table></figure>
<pre><code>Training XGB ...
MAE of val with xgb: 713.8987584188461
Predict xgb ...
Stat of Predict XGB:
_min -318.2115
_max 90140.625
_mean 5910.76
_ptp 90458.836
_std 7345.9653
_var 53963204.0
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 加权融合两模型的结果</span></span><br><span class="line">val_weighted = (<span class="number">1</span> - MAE_lgb / (MAE_xgb + MAE_lgb)) * val_lgb + (<span class="number">1</span> - MAE_xgb / (MAE_xgb + MAE_lgb) * val_xgb)</span><br><span class="line">val_weighted[val_weighted &lt; <span class="number">0</span>] = <span class="number">10</span>  <span class="comment">## 修正预测值为负的样本</span></span><br><span class="line">print(<span class="string">"MAE of val with weighted ensemble:"</span>, mean_absolute_error(y_val, val_weighted))</span><br></pre></td></tr></table></figure>
<pre><code>MAE of val with weighted ensemble: 5888.071354671169
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sub_weighted = (<span class="number">1</span> - MAE_lgb / (MAE_xgb + MAE_lgb)) * subB_lgb + (<span class="number">1</span> - MAE_xgb / (MAE_xgb + MAE_lgb)) * subB_xgb</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 查看预测值的直方图</span></span><br><span class="line">plt.hist(sub_weighted)</span><br><span class="line">plt.show()</span><br><span class="line">plt.close()</span><br></pre></td></tr></table></figure>
<p><meta name="referrer" content="no-referrer"><br><img src="/%E6%95%B0%E6%8D%AE%E6%B8%85%E6%B4%97-%E5%A4%A9%E6%B1%A0-%E4%BA%8C%E6%89%8B%E8%BD%A6%E4%BA%A4%E6%98%93%E6%95%B0%E6%8D%AE/output_33_0.png" class title="直方图"></p>
<h1 id="输出结果"><a href="#输出结果" class="headerlink" title="输出结果"></a>输出结果</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sub = pd.DataFrame()</span><br><span class="line">sub[<span class="string">'SaleID'</span>] = testB_data.SaleID</span><br><span class="line">sub[<span class="string">'price'</span>] = sub_weighted</span><br><span class="line">sub.to_csv(<span class="string">"./sub_weighted.csv"</span>, index=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sub.head()  <span class="comment">## 预览结果</span></span><br></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>SaleID</th>
      <th>price</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>200000</td>
      <td>1177.409043</td>
    </tr>
    <tr>
      <th>1</th>
      <td>200001</td>
      <td>1806.548102</td>
    </tr>
    <tr>
      <th>2</th>
      <td>200002</td>
      <td>8560.376569</td>
    </tr>
    <tr>
      <th>3</th>
      <td>200003</td>
      <td>1346.403363</td>
    </tr>
    <tr>
      <th>4</th>
      <td>200004</td>
      <td>2074.413901</td>
    </tr>
  </tbody>
</table>
</div>

]]></content>
      <tags>
        <tag>Data</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL | 《sql必知必会》</title>
    <url>/sql-sql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A.html</url>
    <content><![CDATA[<p><center>《SQL必知必会》读书笔记</center><br><a id="more"></a></p>
<h1 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h1><ul>
<li><strong>数据库</strong>（database）：保存有组织的数据的容器<ul>
<li>通常是一个文件或一组文件</li>
</ul>
</li>
<li><strong>数据库管理系统</strong>（DBMS，Database Management System）：数据库软件<ul>
<li>数据库是通过DBMS创建和操作的容器</li>
</ul>
</li>
<li><strong>表</strong>（table）：某种特定类型数据的结构化清单<ul>
<li>存储在表中的数据是同一种类型的数据或清单</li>
<li>在相同数据库中不能两次使用相同的表名，在不同的数据库中可以使用相同的表名</li>
<li>表由列组成</li>
</ul>
</li>
<li><strong>模式</strong>（schema）：关于数据库和表的布局及特性的信息</li>
<li><strong>列</strong>（column）：表中的一个字段。所有表都是由一个或多个列组成的<ul>
<li>数据库中的每个列都有相应的数据类型</li>
</ul>
</li>
<li><strong>行</strong>（row）：表中的一个记录<ul>
<li>表中的数据按行存储</li>
</ul>
</li>
<li><strong>数据类型</strong>（datatype）：所允许的数据的类型<ul>
<li>每个表列都有相应的数据类型，限制或允许该列中存储的数据</li>
<li>数据类型还帮助正确地分类数据，并在优化磁盘使用方面起重要作用</li>
</ul>
</li>
<li><strong>主键</strong>（primary key）：一列（或一组列），其值能够唯一标识表中每一行<ul>
<li>主键用来表示一个特定的行</li>
<li>主键应满足：<ul>
<li>任意两行都不具有相同的主键值</li>
<li>每一行都必须具有一个主键值（主键列不允许为NULL）</li>
<li>主键列中的值不允许修改或更新</li>
<li>主键值不能重复使用（如果某行从表中删除，它的主键不能赋给新行）</li>
</ul>
</li>
</ul>
</li>
<li><strong>子句</strong>（clause）：SQL语句由子句构成；一个子句通常由一个关键字加上所提供的数据组成 </li>
</ul>
<p><strong>SQL</strong>（发音为S-Q-L或sequel）：结构化查询语言（Structural Query Language），专门用来与数据库沟通的语言</p>
<ul>
<li>SQL语句不区分大小写<ul>
<li>多数SQL开发人员喜欢对SQL关键字使用大写，而对列名和表名使用小写，使代码更易于阅读和调试</li>
</ul>
</li>
<li>多条SQL语句必须以分号分隔<ul>
<li>多数DBMS不需要在单条SQL语句后面加分号</li>
</ul>
</li>
<li>在处理SQL语句时，其中所有空格都被忽略<ul>
<li>多数SQL开发人员认为，将SQL语句分成多行更容易阅读和调试</li>
</ul>
</li>
</ul>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><ul>
<li>行内注释：使用两个连字符（<code>--</code>）或井字符（<code>#</code>）</li>
<li>多行注释：<code>/*      */</code></li>
</ul>
<h1 id="SELECT语句"><a href="#SELECT语句" class="headerlink" title="SELECT语句"></a>SELECT语句</h1><p>使用SELECT检索表数据，必须至少给出两条信息：</p>
<ol>
<li>想选择什么</li>
<li>从什么地方选择</li>
</ol>
<p>从一个表中检索多列时，列名之间必须以逗号分隔</p>
<p><u>表：SELECT的子句顺序</u></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"><strong>子句</strong></th>
<th style="text-align:center"><strong>说明</strong></th>
<th style="text-align:center"><strong>是否必须使用</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">SELECT</td>
<td style="text-align:center">要选择的列/表达式</td>
<td style="text-align:center">是</td>
</tr>
<tr>
<td style="text-align:center">FROM</td>
<td style="text-align:center">从中检索数据的表</td>
<td style="text-align:center">仅在从表中选择数据时使用</td>
</tr>
<tr>
<td style="text-align:center">WHERE</td>
<td style="text-align:center">行级过滤</td>
<td style="text-align:center">否</td>
</tr>
<tr>
<td style="text-align:center">GROUP BY</td>
<td style="text-align:center">分组说明</td>
<td style="text-align:center">仅在按组计算聚合时使用</td>
</tr>
<tr>
<td style="text-align:center">HAVING</td>
<td style="text-align:center">组级过滤</td>
<td style="text-align:center">否</td>
</tr>
<tr>
<td style="text-align:center">ORDER BY</td>
<td style="text-align:center">输出排序顺序</td>
<td style="text-align:center">否</td>
</tr>
</tbody>
</table>
</div>
<h2 id="AS"><a href="#AS" class="headerlink" title="AS"></a>AS</h2><p>AS：使用别名</p>
<ul>
<li>可选</li>
<li>别名可以是一个单词或一个字符串；是字符串的话，需要放在引号中</li>
<li>别名有时也称为导出列（derived column）</li>
<li>Oracle不支持AS关键字；直接指定列名的别名即可</li>
</ul>
<h2 id="DISTINCT关键字"><a href="#DISTINCT关键字" class="headerlink" title="DISTINCT关键字"></a>DISTINCT关键字</h2><p>DISTINCT关键字：指示数据库只返回不同的值</p>
<ul>
<li>作用于所有的列，而不仅仅是跟在它之后的那一列</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT vend_id FROM Products;</span><br><span class="line">+<span class="comment">---------+</span></span><br><span class="line">| vend_id |</span><br><span class="line">+<span class="comment">---------+</span></span><br><span class="line">|    1001 |</span><br><span class="line">|    1001 |</span><br><span class="line">|    1001 |</span><br><span class="line">|    1002 |</span><br><span class="line">|    1002 |</span><br><span class="line">|    1003 |</span><br><span class="line">|    1003 |</span><br><span class="line">|    1003 |</span><br><span class="line">|    1003 |</span><br><span class="line">|    1003 |</span><br><span class="line">|    1003 |</span><br><span class="line">|    1003 |</span><br><span class="line">|    1005 |</span><br><span class="line">|    1005 |</span><br><span class="line">+<span class="comment">---------+</span></span><br><span class="line">14 rows in <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br><span class="line">mysql&gt; <span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> vend_id <span class="keyword">FROM</span> Products;</span><br><span class="line">+<span class="comment">---------+</span></span><br><span class="line">| vend_id |</span><br><span class="line">+<span class="comment">---------+</span></span><br><span class="line">|    1001 |</span><br><span class="line">|    1002 |</span><br><span class="line">|    1003 |</span><br><span class="line">|    1005 |</span><br><span class="line">+<span class="comment">---------+</span></span><br><span class="line">4 rows in <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure>
<h2 id="限制返回的行数"><a href="#限制返回的行数" class="headerlink" title="限制返回的行数"></a>限制返回的行数</h2><ul>
<li>SQL Server或Acess：<code>TOP</code><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 返回前5行数据</span></span><br><span class="line"><span class="keyword">SELECT</span> TOP <span class="number">5</span> prod_name <span class="keyword">FROM</span> Products;</span><br></pre></td></tr></table></figure></li>
<li>DB2：<code>FETCH FIRST ... ROWS ONLY</code><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> TOP <span class="number">5</span> prod_name <span class="keyword">FROM</span> Products;</span><br><span class="line"><span class="keyword">SELECT</span> prod_name <span class="keyword">FROM</span> Products </span><br><span class="line"><span class="keyword">FETCH</span> <span class="keyword">FIRST</span> <span class="number">5</span> <span class="keyword">ROWS</span> <span class="keyword">ONLY</span>;</span><br></pre></td></tr></table></figure></li>
<li>Oracle：行计数器 <code>ROWNUM</code><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name <span class="keyword">FROM</span> Products</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">ROWNUM</span>&lt;=<span class="number">5</span>;</span><br></pre></td></tr></table></figure></li>
<li>MySQL、MariaDB、PostgreSQL、SQLite：<code>LIMIT</code><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT prod_name FROM Products LIMIT 5;</span><br><span class="line">+<span class="comment">--------------+</span></span><br><span class="line">| prod_name    |</span><br><span class="line">+<span class="comment">--------------+</span></span><br><span class="line">| .5 ton anvil |</span><br><span class="line">| 1 ton anvil  |</span><br><span class="line">| 2 ton anvil  |</span><br><span class="line">| Detonator    |</span><br><span class="line">| Bird seed    |</span><br><span class="line">+<span class="comment">--------------+</span></span><br><span class="line">5 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="限制检索的起始位置"><a href="#限制检索的起始位置" class="headerlink" title="限制检索的起始位置"></a>限制检索的起始位置</h2><p>限制检索的起始位置：<code>OFFSET</code><br> <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 从第3行起（不包括第3行）返回前5行数据</span></span><br><span class="line">mysql&gt; SELECT prod_name FROM Products LIMIT 5 OFFSET 3;</span><br><span class="line">+<span class="comment">--------------+</span></span><br><span class="line">| prod_name    |</span><br><span class="line">+<span class="comment">--------------+</span></span><br><span class="line">| Detonator    |</span><br><span class="line">| Bird seed    |</span><br><span class="line">| Carrots      |</span><br><span class="line">| Fuses        |</span><br><span class="line">| JetPack 1000 |</span><br><span class="line">+<span class="comment">--------------+</span></span><br><span class="line">5 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></p>
<ul>
<li><p>第一个被检索的行是第0行，而不是第一行</p>
<blockquote>
<p><code>LIMIT 3 OFFSET 1</code> 会检索第2行，而不是第1行</p>
</blockquote>
</li>
<li><p>MySQL和MariaDB会支持简化版的LIMIT OFFSET 语句，但是两个数字的顺序改变了</p>
<blockquote>
<p><code>LIMIT 5 OFFSET 3</code> 等价于 <code>LIMIT 3, 5</code></p>
</blockquote>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT prod_name FROM Products LIMIT 3, 5;</span><br><span class="line">+<span class="comment">--------------+</span></span><br><span class="line">| prod_name    |</span><br><span class="line">+<span class="comment">--------------+</span></span><br><span class="line">| Detonator    |</span><br><span class="line">| Bird seed    |</span><br><span class="line">| Carrots      |</span><br><span class="line">| Fuses        |</span><br><span class="line">| JetPack 1000 |</span><br><span class="line">+<span class="comment">--------------+</span></span><br><span class="line">5 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
<h1 id="ORDER-BY子句"><a href="#ORDER-BY子句" class="headerlink" title="ORDER BY子句"></a>ORDER BY子句</h1><p>排序：ORDER BY 子句</p>
<ul>
<li>必须是SELECT语句中的最后一个子句</li>
<li>默认升序排列（ASC）；如果要降序排列，需指定DESC</li>
<li>DESC关键字只应用到直接位于其前面的列名</li>
<li>如果对多个列进行降序排列，则必须对每一列指定DESC关键字</li>
<li>大多数DBMS认为A与a相同；数据管理员可以改变这种行为</li>
<li>按多个列排序的话，列名之间用逗号分开；先排序的在前面，后排序的在后面</li>
<li>Microsoft Access不允许按别名排序<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT prod_id, prod_price, prod_name</span><br><span class="line">    -&gt; FROM Products;</span><br><span class="line">+<span class="comment">---------+------------+----------------+</span></span><br><span class="line">| prod_id | prod_price | prod_name      |</span><br><span class="line">+<span class="comment">---------+------------+----------------+</span></span><br><span class="line">| ANV01   |       5.99 | .5 ton anvil   |</span><br><span class="line">| ANV02   |       9.99 | 1 ton anvil    |</span><br><span class="line">| ANV03   |      14.99 | 2 ton anvil    |</span><br><span class="line">| DTNTR   |      13.00 | Detonator      |</span><br><span class="line">| FB      |      10.00 | Bird seed      |</span><br><span class="line">| FC      |       2.50 | Carrots        |</span><br><span class="line">| FU1     |       3.42 | Fuses          |</span><br><span class="line">| JP1000  |      35.00 | JetPack 1000   |</span><br><span class="line">| JP2000  |      55.00 | JetPack 2000   |</span><br><span class="line">| OL1     |       8.99 | Oil can        |</span><br><span class="line">| SAFE    |      50.00 | Safe           |</span><br><span class="line">| SLING   |       4.49 | Sling          |</span><br><span class="line">| TNT1    |       2.50 | TNT (1 stick)  |</span><br><span class="line">| TNT2    |      10.00 | TNT (5 sticks) |</span><br><span class="line">+<span class="comment">---------+------------+----------------+</span></span><br><span class="line">14 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line">mysql&gt; <span class="keyword">SELECT</span> prod_id, prod_price, prod_name</span><br><span class="line">    -&gt; <span class="keyword">FROM</span> Products</span><br><span class="line">    -&gt; <span class="keyword">ORDER</span> <span class="keyword">BY</span> prod_price, prod_name;</span><br><span class="line">+<span class="comment">---------+------------+----------------+</span></span><br><span class="line">| prod_id | prod_price | prod_name      |</span><br><span class="line">+<span class="comment">---------+------------+----------------+</span></span><br><span class="line">| FC      |       2.50 | Carrots        |</span><br><span class="line">| TNT1    |       2.50 | TNT (1 stick)  |</span><br><span class="line">| FU1     |       3.42 | Fuses          |</span><br><span class="line">| SLING   |       4.49 | Sling          |</span><br><span class="line">| ANV01   |       5.99 | .5 ton anvil   |</span><br><span class="line">| OL1     |       8.99 | Oil can        |</span><br><span class="line">| ANV02   |       9.99 | 1 ton anvil    |</span><br><span class="line">| FB      |      10.00 | Bird seed      |</span><br><span class="line">| TNT2    |      10.00 | TNT (5 sticks) |</span><br><span class="line">| DTNTR   |      13.00 | Detonator      |</span><br><span class="line">| ANV03   |      14.99 | 2 ton anvil    |</span><br><span class="line">| JP1000  |      35.00 | JetPack 1000   |</span><br><span class="line">| SAFE    |      50.00 | Safe           |</span><br><span class="line">| JP2000  |      55.00 | JetPack 2000   |</span><br><span class="line">+<span class="comment">---------+------------+----------------+</span></span><br><span class="line">14 rows in <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure></li>
<li>还支持按照SELECT清单中的列的相对位置进行排序<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT prod_id, prod_price, prod_name</span><br><span class="line">    -&gt; FROM Products</span><br><span class="line">    -&gt; ORDER BY 2, 3;</span><br><span class="line">+<span class="comment">---------+------------+----------------+</span></span><br><span class="line">| prod_id | prod_price | prod_name      |</span><br><span class="line">+<span class="comment">---------+------------+----------------+</span></span><br><span class="line">| FC      |       2.50 | Carrots        |</span><br><span class="line">| TNT1    |       2.50 | TNT (1 stick)  |</span><br><span class="line">| FU1     |       3.42 | Fuses          |</span><br><span class="line">| SLING   |       4.49 | Sling          |</span><br><span class="line">| ANV01   |       5.99 | .5 ton anvil   |</span><br><span class="line">| OL1     |       8.99 | Oil can        |</span><br><span class="line">| ANV02   |       9.99 | 1 ton anvil    |</span><br><span class="line">| FB      |      10.00 | Bird seed      |</span><br><span class="line">| TNT2    |      10.00 | TNT (5 sticks) |</span><br><span class="line">| DTNTR   |      13.00 | Detonator      |</span><br><span class="line">| ANV03   |      14.99 | 2 ton anvil    |</span><br><span class="line">| JP1000  |      35.00 | JetPack 1000   |</span><br><span class="line">| SAFE    |      50.00 | Safe           |</span><br><span class="line">| JP2000  |      55.00 | JetPack 2000   |</span><br><span class="line">+<span class="comment">---------+------------+----------------+</span></span><br><span class="line">14 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="WHERE子句"><a href="#WHERE子句" class="headerlink" title="WHERE子句"></a>WHERE子句</h1><p><strong>过滤数据</strong>：指定搜索条件（search criteria）/过滤条件（filter condition），只检索所需数据</p>
<ul>
<li>在SELECT语句中，数据根据WHERE子句中指定的搜索条件进行过滤</li>
<li>WHERE子句在表名（FROM子句）之后给出<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT prod_name, prod_price</span><br><span class="line">    -&gt; FROM Products</span><br><span class="line">    -&gt; WHERE prod_price=2.5;</span><br><span class="line">+<span class="comment">---------------+------------+</span></span><br><span class="line">| prod_name     | prod_price |</span><br><span class="line">+<span class="comment">---------------+------------+</span></span><br><span class="line">| Carrots       |       2.50 |</span><br><span class="line">| TNT (1 stick) |       2.50 |</span><br><span class="line">+<span class="comment">---------------+------------+</span></span><br><span class="line">2 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></li>
<li>同时使用ORDER BY子句和WHERE子句时，ORDER BY 应位于WHERE子句后面</li>
</ul>
<p><u>表：WHERE子句操作符</u></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"><strong>操作符</strong></th>
<th style="text-align:center"><strong>说明</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">=</td>
<td style="text-align:center">等于</td>
</tr>
<tr>
<td style="text-align:center">&lt;&gt;  或  !=</td>
<td style="text-align:center">不等于</td>
</tr>
<tr>
<td style="text-align:center">&lt;</td>
<td style="text-align:center">小于</td>
</tr>
<tr>
<td style="text-align:center">&lt;=  或  !&gt;</td>
<td style="text-align:center">小于等于 或 不大于</td>
</tr>
<tr>
<td style="text-align:center">&gt;</td>
<td style="text-align:center">大于</td>
</tr>
<tr>
<td style="text-align:center">&gt;= 或 !&lt;</td>
<td style="text-align:center">大于等于 或 不小于</td>
</tr>
<tr>
<td style="text-align:center">BETWEEN</td>
<td style="text-align:center">在指定的两个值之间</td>
</tr>
<tr>
<td style="text-align:center">IS NULL</td>
<td style="text-align:center">为NULL值</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li><code>!=</code> 和 <code>&lt;&gt;</code> 通常是可以互换的。但并非所有DBMS都支持这两种操作<blockquote>
<p>eg：Microsoft Access支持 <code>&lt;&gt;</code>而不支持 <code>!=</code></p>
</blockquote>
</li>
</ul>
<h2 id="BETWEEN"><a href="#BETWEEN" class="headerlink" title="BETWEEN"></a>BETWEEN</h2><p><code>BETWEEN</code>匹配范围中的所有值，包括指定的开始值和结束值<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; ##查找价格在5到10之间的产品</span><br><span class="line">mysql&gt; SELECT prod_name, prod_price</span><br><span class="line">    -&gt; FROM Products</span><br><span class="line">    -&gt; WHERE prod_price BETWEEN 5 AND 10;</span><br><span class="line">+<span class="comment">----------------+------------+</span></span><br><span class="line">| prod_name      | prod_price |</span><br><span class="line">+<span class="comment">----------------+------------+</span></span><br><span class="line">| .5 ton anvil   |       5.99 |</span><br><span class="line">| 1 ton anvil    |       9.99 |</span><br><span class="line">| Bird seed      |      10.00 |</span><br><span class="line">| Oil can        |       8.99 |</span><br><span class="line">| TNT (5 sticks) |      10.00 |</span><br><span class="line">+<span class="comment">----------------+------------+</span></span><br><span class="line">5 rows in <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure></p>
<h2 id="NULL"><a href="#NULL" class="headerlink" title="NULL"></a>NULL</h2><p><strong>NULL</strong>：无值/空值（no value），与字段包含0、空字符串、空格不同</p>
<ul>
<li>用<code>IS NULL</code>来检查某个值是否为NULL<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT cust_name</span><br><span class="line">    -&gt; FROM CUSTOMERS</span><br><span class="line">    -&gt; WHERE cust_email IS NULL;</span><br><span class="line">+<span class="comment">-------------+</span></span><br><span class="line">| cust_name   |</span><br><span class="line">+<span class="comment">-------------+</span></span><br><span class="line">| Mouse House |</span><br><span class="line">| E Fudd      |</span><br><span class="line">+<span class="comment">-------------+</span></span><br><span class="line">2 rows in <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h2><p>操作符（operator）：用来联结或改变WHERE子句中的子句的关键字，也称逻辑操作符（logical operator）</p>
<ul>
<li><code>AND</code>、<code>OR</code>、<code>IN</code>、<code>NOT</code></li>
<li>SQL允许给出多个WHERE子句，使用AND或OR联结</li>
</ul>
<h3 id="AND"><a href="#AND" class="headerlink" title="AND"></a>AND</h3><p>AND：用在WHERE子句中的关键字，用来指示检索满足所有给定条件的行<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT prod_id, prod_price, prod_name</span><br><span class="line">    -&gt; FROM Products</span><br><span class="line">    -&gt; WHERE vend_id=1003 AND prod_price &lt;= 4;</span><br><span class="line">+<span class="comment">---------+------------+---------------+</span></span><br><span class="line">| prod_id | prod_price | prod_name     |</span><br><span class="line">+<span class="comment">---------+------------+---------------+</span></span><br><span class="line">| FC      |       2.50 | Carrots       |</span><br><span class="line">| TNT1    |       2.50 | TNT (1 stick) |</span><br><span class="line">+<span class="comment">---------+------------+---------------+</span></span><br><span class="line">2 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></p>
<h3 id="OR"><a href="#OR" class="headerlink" title="OR"></a>OR</h3><p>OR：用在WHERE子句中的关键字，用来表示检索匹配任一给定条件的行</p>
<ul>
<li>AND的优先级高于OR</li>
<li>同时使用AND和OR时，注意使用圆括号对操作符进行明确分组<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT prod_id, prod_price, prod_name</span><br><span class="line">    -&gt; FROM Products</span><br><span class="line">    -&gt; WHERE vend_id=1003 OR vend_id=1002;</span><br><span class="line">+<span class="comment">---------+------------+----------------+</span></span><br><span class="line">| prod_id | prod_price | prod_name      |</span><br><span class="line">+<span class="comment">---------+------------+----------------+</span></span><br><span class="line">| DTNTR   |      13.00 | Detonator      |</span><br><span class="line">| FB      |      10.00 | Bird seed      |</span><br><span class="line">| FC      |       2.50 | Carrots        |</span><br><span class="line">| FU1     |       3.42 | Fuses          |</span><br><span class="line">| OL1     |       8.99 | Oil can        |</span><br><span class="line">| SAFE    |      50.00 | Safe           |</span><br><span class="line">| SLING   |       4.49 | Sling          |</span><br><span class="line">| TNT1    |       2.50 | TNT (1 stick)  |</span><br><span class="line">| TNT2    |      10.00 | TNT (5 sticks) |</span><br><span class="line">+<span class="comment">---------+------------+----------------+</span></span><br><span class="line">9 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="IN"><a href="#IN" class="headerlink" title="IN"></a>IN</h3><p>IN：WHERE子句中用来指定要匹配值的清单的关键字，功能与OR相当</p>
<ul>
<li>IN操作符一般比一组OR操作符执行得更快<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT prod_id, prod_price, prod_name</span><br><span class="line">    -&gt; FROM Products</span><br><span class="line">    -&gt; WHERE vend_id IN (1002, 1003);</span><br><span class="line">+<span class="comment">---------+------------+----------------+</span></span><br><span class="line">| prod_id | prod_price | prod_name      |</span><br><span class="line">+<span class="comment">---------+------------+----------------+</span></span><br><span class="line">| DTNTR   |      13.00 | Detonator      |</span><br><span class="line">| FB      |      10.00 | Bird seed      |</span><br><span class="line">| FC      |       2.50 | Carrots        |</span><br><span class="line">| FU1     |       3.42 | Fuses          |</span><br><span class="line">| OL1     |       8.99 | Oil can        |</span><br><span class="line">| SAFE    |      50.00 | Safe           |</span><br><span class="line">| SLING   |       4.49 | Sling          |</span><br><span class="line">| TNT1    |       2.50 | TNT (1 stick)  |</span><br><span class="line">| TNT2    |      10.00 | TNT (5 sticks) |</span><br><span class="line">+<span class="comment">---------+------------+----------------+</span></span><br><span class="line">9 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="NOT"><a href="#NOT" class="headerlink" title="NOT"></a>NOT</h3><p>NOT：WHERE子句中用来否定其后条件的关键字</p>
<ul>
<li>常与IN联合使用</li>
<li>大多数DBMS允许使用<code>NOT</code>否定任何条件</li>
<li>MariaDB支持使用<code>NOT</code>否定IN、BETWEEN、EXISTS子句<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT prod_id, prod_price, prod_name</span><br><span class="line">    -&gt; FROM Products</span><br><span class="line">    -&gt; WHERE NOT vend_id=1003</span><br><span class="line">    -&gt; ORDER BY prod_name;</span><br><span class="line">+<span class="comment">---------+------------+--------------+</span></span><br><span class="line">| prod_id | prod_price | prod_name    |</span><br><span class="line">+<span class="comment">---------+------------+--------------+</span></span><br><span class="line">| ANV01   |       5.99 | .5 ton anvil |</span><br><span class="line">| ANV02   |       9.99 | 1 ton anvil  |</span><br><span class="line">| ANV03   |      14.99 | 2 ton anvil  |</span><br><span class="line">| FU1     |       3.42 | Fuses        |</span><br><span class="line">| JP1000  |      35.00 | JetPack 1000 |</span><br><span class="line">| JP2000  |      55.00 | JetPack 2000 |</span><br><span class="line">| OL1     |       8.99 | Oil can      |</span><br><span class="line">+<span class="comment">---------+------------+--------------+</span></span><br><span class="line">7 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="pattern"><a href="#pattern" class="headerlink" title="pattern"></a>pattern</h1><p>搜索模式（search pattern）：由字面值、通配符或两者组合构成的搜索条件</p>
<p>谓词（predicate）：操作符作为谓词时不是操作符</p>
<ul>
<li>从技术上来说，LIKE是谓词而不是操作符</li>
</ul>
<h2 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h2><p>通配符（wildcard）：用来匹配值得一部分的特殊字符</p>
<ul>
<li>通配符实质上是WHERE子句中有特殊意义的字符</li>
<li>要在WHERE子句中使用通配符，必须使用LIKE操作符</li>
<li>通配符搜索只能用于文本字段（字符串），非文本数据类型的字段不能使用通配符搜索</li>
<li>不要过度使用通配符</li>
<li>注意通配符的位置</li>
</ul>
<h3 id><a href="#" class="headerlink" title="%"></a>%</h3><p><code>%</code> ：百分号通配符，表示任何字符出现任意次数</p>
<ul>
<li>Microsoft Access使用的通配符是 <code>*</code> 而不是 <code>%</code></li>
<li>根据DBMS的不同及其配置，搜索可以是区分大小写的</li>
<li>通配符可在搜索模式的任意位置使用，并且可以使用多个通配符</li>
<li><code>%</code> 代表搜索模式中给定位置的0个、1个或多个字符</li>
<li><code>%</code> 不会匹配NULL<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; ##找出prod_name以Jet开头的产品</span><br><span class="line">mysql&gt; SELECT prod_id, prod_name</span><br><span class="line">    -&gt; FROM Products</span><br><span class="line">    -&gt; WHERE prod_name LIKE 'Jet%';</span><br><span class="line">+<span class="comment">---------+--------------+</span></span><br><span class="line">| prod_id | prod_name    |</span><br><span class="line">+<span class="comment">---------+--------------+</span></span><br><span class="line">| JP1000  | JetPack 1000 |</span><br><span class="line">| JP2000  | JetPack 2000 |</span><br><span class="line">+<span class="comment">---------+--------------+</span></span><br><span class="line">2 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="-1"><a href="#-1" class="headerlink" title="_"></a>_</h3><p><code>_</code> ：下划线通配符；用途与 <code>%</code> 一样，但是仅匹配单个字符</p>
<ul>
<li>DB2不支持下划线通配符</li>
<li>Microsoft Access中对应的是 <code>？</code>而不是 <code>_</code></li>
</ul>
<h3 id="-2"><a href="#-2" class="headerlink" title="[]"></a>[]</h3><p><code>[ ]</code> ：方括号通配符，用来指定一个字符集；必须匹配指定位置的一个字符</p>
<ul>
<li>只有Microsoft Access和SQL Server支持集合</li>
<li>使用 <code>^</code> 来表示否定；Microsoft Access是用 <code>！</code>表示否定而不是 <code>^</code><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 找出姓名首字母为V或T的学生信息</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">ID</span>, <span class="keyword">name</span>, dept_name</span><br><span class="line"><span class="keyword">FROM</span> student</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">name</span> <span class="keyword">LIKE</span> <span class="string">'[VT]%'</span>;</span><br><span class="line"><span class="comment">## 找出姓名首字母不为V且不为T的学生信息</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">ID</span>, <span class="keyword">name</span>, dept_name</span><br><span class="line"><span class="keyword">FROM</span> student</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">name</span> <span class="keyword">LIKE</span> <span class="string">'[^VT]%'</span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="计算字段"><a href="#计算字段" class="headerlink" title="计算字段"></a>计算字段</h1><p>字段（field）：基本上与列（column）的意思相同，经常互换使用；数据库列一般称为列，而字段通常与计算字段一起使用</p>
<h2 id="拼接"><a href="#拼接" class="headerlink" title="拼接"></a>拼接</h2><p><strong>拼接</strong>（concatenate）：将值联结到一起（将一个值附加到另一个值）构成单个值</p>
<ul>
<li>Access、SQL Server使用 <code>+</code> 拼接</li>
<li>DB2、Oracle、PostgreSQL、SQLite、Open Office Base使用 <code>||</code> 拼接</li>
<li>MySQL、MariaDB使用特殊函数 <code>CONCAT()</code></li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM Vendors;</span><br><span class="line">+<span class="comment">---------+----------------+-----------------+-------------+------------+----------+--------------+</span></span><br><span class="line">| vend_id | vend_name      | vend_address    | vend_city   | vend_state | vend_zip | vend_country |</span><br><span class="line">+<span class="comment">---------+----------------+-----------------+-------------+------------+----------+--------------+</span></span><br><span class="line">|    1001 | Anvils R Us    | 123 Main Street | Southfield  | MI         | 48075    | USA          |</span><br><span class="line">|    1002 | LT Supplies    | 500 Park Street | Anytown     | OH         | 44333    | USA          |</span><br><span class="line">|    1003 | ACME           | 555 High Street | Los Angeles | CA         | 90046    | USA          |</span><br><span class="line">|    1004 | Furball Inc.   | 1000 5th Avenue | New York    | NY         | 11111    | USA          |</span><br><span class="line">|    1005 | Jet <span class="keyword">Set</span>        | <span class="number">42</span> Galaxy Road  | London      | <span class="literal">NULL</span>       | N16 <span class="number">6</span>PS  | England      |</span><br><span class="line">|    <span class="number">1006</span> | Jouets Et Ours | <span class="number">1</span> Rue Amusement | Paris       | <span class="literal">NULL</span>       | <span class="number">45678</span>    | France       |</span><br><span class="line">+<span class="comment">---------+----------------+-----------------+-------------+------------+----------+--------------+</span></span><br><span class="line"><span class="number">6</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">SELECT</span> <span class="keyword">CONCAT</span>(vend_name, <span class="string">'('</span>, vend_country, <span class="string">')'</span>)</span><br><span class="line">    -&gt; <span class="keyword">FROM</span> Vendors</span><br><span class="line">    -&gt; <span class="keyword">ORDER</span> <span class="keyword">BY</span> vend_name;</span><br><span class="line">+<span class="comment">-------------------------------------------+</span></span><br><span class="line">| CONCAT(vend_name, '(', vend_country, ')') |</span><br><span class="line">+<span class="comment">-------------------------------------------+</span></span><br><span class="line">| ACME(USA)                                 |</span><br><span class="line">| Anvils R Us(USA)                          |</span><br><span class="line">| Furball Inc.(USA)                         |</span><br><span class="line">| Jet <span class="keyword">Set</span>(England)                          |</span><br><span class="line">| Jouets Et Ours(France)                    |</span><br><span class="line">| LT Supplies(USA)                          |</span><br><span class="line">+<span class="comment">-------------------------------------------+</span></span><br><span class="line"><span class="number">6</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure>
<p>SQL Server：<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">ID</span> + <span class="string">'('</span> + dept_name + <span class="string">')'</span></span><br><span class="line"><span class="keyword">FROM</span> student</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">ID</span>;</span><br></pre></td></tr></table></figure></p>
<p><u>表 ：SQL算术操作符</u></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">操作符</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">+</td>
<td style="text-align:center">加</td>
</tr>
<tr>
<td style="text-align:center">-</td>
<td style="text-align:center">减</td>
</tr>
<tr>
<td style="text-align:center">*</td>
<td style="text-align:center">乘</td>
</tr>
<tr>
<td style="text-align:center">/</td>
<td style="text-align:center">除</td>
</tr>
</tbody>
</table>
</div>
<h1 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h1><p>可移植（portable）：所编写的代码可以在多个系统上运行</p>
<ul>
<li>SQL函数不可移植</li>
</ul>
<h2 id="SUBSTR"><a href="#SUBSTR" class="headerlink" title="SUBSTR()"></a>SUBSTR()</h2><p>提取字符串的组成部分：</p>
<ul>
<li>Access：使用 <code>MID()</code></li>
<li>DB2、Oracle、PostgreSQL、SQLite：使用 <code>SUBSTR()</code></li>
<li>MySQL、SQL Server：使用 <code>SUBSTRING()</code></li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM Vendors;</span><br><span class="line">+<span class="comment">---------+----------------+-----------------+-------------+------------+----------+--------------+</span></span><br><span class="line">| vend_id | vend_name      | vend_address    | vend_city   | vend_state | vend_zip | vend_country |</span><br><span class="line">+<span class="comment">---------+----------------+-----------------+-------------+------------+----------+--------------+</span></span><br><span class="line">|    1001 | Anvils R Us    | 123 Main Street | Southfield  | MI         | 48075    | USA          |</span><br><span class="line">|    1002 | LT Supplies    | 500 Park Street | Anytown     | OH         | 44333    | USA          |</span><br><span class="line">|    1003 | ACME           | 555 High Street | Los Angeles | CA         | 90046    | USA          |</span><br><span class="line">|    1004 | Furball Inc.   | 1000 5th Avenue | New York    | NY         | 11111    | USA          |</span><br><span class="line">|    1005 | Jet <span class="keyword">Set</span>        | <span class="number">42</span> Galaxy Road  | London      | <span class="literal">NULL</span>       | N16 <span class="number">6</span>PS  | England      |</span><br><span class="line">|    <span class="number">1006</span> | Jouets Et Ours | <span class="number">1</span> Rue Amusement | Paris       | <span class="literal">NULL</span>       | <span class="number">45678</span>    | France       |</span><br><span class="line">+<span class="comment">---------+----------------+-----------------+-------------+------------+----------+--------------+</span></span><br><span class="line"><span class="number">6</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line">mysql&gt; <span class="comment">## 截取vend_address的第4个字符（包括空格）开始(包括第4个字符)的所有字符</span></span><br><span class="line">mysql&gt; <span class="keyword">SELECT</span> <span class="keyword">SUBSTRING</span>(vend_address, <span class="number">4</span>)</span><br><span class="line">    -&gt; <span class="keyword">FROM</span> Vendors;</span><br><span class="line">+<span class="comment">----------------------------+</span></span><br><span class="line">| SUBSTRING(vend_address, 4) |</span><br><span class="line">+<span class="comment">----------------------------+</span></span><br><span class="line">|  Main Street               |</span><br><span class="line">|  Park Street               |</span><br><span class="line">|  High Street               |</span><br><span class="line">| 0 5th Avenue               |</span><br><span class="line">| Galaxy Road                |</span><br><span class="line">| ue Amusement               |</span><br><span class="line">+<span class="comment">----------------------------+</span></span><br><span class="line">6 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="comment">## 截取vend_address的倒数第4个字符开始的所有字符</span></span><br><span class="line">mysql&gt; <span class="keyword">SELECT</span> <span class="keyword">SUBSTRING</span>(vend_address, <span class="number">-4</span>)</span><br><span class="line">    -&gt; <span class="keyword">FROM</span> Vendors;</span><br><span class="line">+<span class="comment">-----------------------------+</span></span><br><span class="line">| SUBSTRING(vend_address, -4) |</span><br><span class="line">+<span class="comment">-----------------------------+</span></span><br><span class="line">| reet                        |</span><br><span class="line">| reet                        |</span><br><span class="line">| reet                        |</span><br><span class="line">| enue                        |</span><br><span class="line">| Road                        |</span><br><span class="line">| ment                        |</span><br><span class="line">+<span class="comment">-----------------------------+</span></span><br><span class="line">6 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line">mysql&gt; <span class="comment">## 截取vend_address的第4-6个字符</span></span><br><span class="line">mysql&gt; <span class="keyword">SELECT</span> <span class="keyword">SUBSTRING</span>(vend_address, <span class="number">4</span>, <span class="number">3</span>)</span><br><span class="line">    -&gt; <span class="keyword">FROM</span> Vendors;</span><br><span class="line">+<span class="comment">-------------------------------+</span></span><br><span class="line">| SUBSTRING(vend_address, 4, 3) |</span><br><span class="line">+<span class="comment">-------------------------------+</span></span><br><span class="line">|  Ma                           |</span><br><span class="line">|  Pa                           |</span><br><span class="line">|  Hi                           |</span><br><span class="line">| 0 5                           |</span><br><span class="line">| Gal                           |</span><br><span class="line">| ue                            |</span><br><span class="line">+<span class="comment">-------------------------------+</span></span><br><span class="line">6 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"><span class="comment">-- 第4~6个字符，共有3个字符</span></span><br><span class="line">mysql&gt; <span class="comment">## 截取vend_address的倒数第4个~倒数第2个字符</span></span><br><span class="line">mysql&gt; <span class="keyword">SELECT</span> <span class="keyword">SUBSTRING</span>(vend_address, <span class="number">-4</span>, <span class="number">3</span>)</span><br><span class="line">    -&gt; <span class="keyword">FROM</span> Vendors;</span><br><span class="line">+<span class="comment">--------------------------------+</span></span><br><span class="line">| SUBSTRING(vend_address, -4, 3) |</span><br><span class="line">+<span class="comment">--------------------------------+</span></span><br><span class="line">| ree                            |</span><br><span class="line">| ree                            |</span><br><span class="line">| ree                            |</span><br><span class="line">| enu                            |</span><br><span class="line">| Roa                            |</span><br><span class="line">| men                            |</span><br><span class="line">+<span class="comment">--------------------------------+</span></span><br><span class="line">6 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
<h2 id="TRIM"><a href="#TRIM" class="headerlink" title="TRIM()"></a>TRIM()</h2><p>TRIM() ：去掉字符串左右两边的空格</p>
<h2 id="RTRIM"><a href="#RTRIM" class="headerlink" title="RTRIM()"></a>RTRIM()</h2><p>RTRIM() ：去掉字符串右边的所有空格</p>
<h2 id="LTRIM"><a href="#LTRIM" class="headerlink" title="LTRIM()"></a>LTRIM()</h2><p>LTRIM() ：去掉字符串左边的所有空格</p>
<h2 id="LEFT"><a href="#LEFT" class="headerlink" title="LEFT()"></a>LEFT()</h2><p>LEFT() ：返回字符串左边的字符</p>
<h2 id="RIGHT"><a href="#RIGHT" class="headerlink" title="RIGHT()"></a>RIGHT()</h2><p>RIGHT() ：返回字符串右边的字符</p>
<h2 id="LENGTH"><a href="#LENGTH" class="headerlink" title="LENGTH()"></a>LENGTH()</h2><p>LENGTH() ：返回字符串的长度；或<code>DATALENGTH()</code> 、<code>LEN()</code></p>
<h2 id="SOUNDEX"><a href="#SOUNDEX" class="headerlink" title="SOUNDEX()"></a>SOUNDEX()</h2><p>SOUNDEX() ：返回字符串的SOUNDEX值</p>
<ul>
<li>SOUNDEX是一个将任何文本字符串转换为描述其语音表示的字母数字模式的算法</li>
<li>Microsoft Access、PostgreSQL不支持SOUNDEX()</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">mysql&gt; ## 找出cust_contact中发音与Michael Green类似的记录</span><br><span class="line">mysql&gt; SELECT cust_name, cust_contact</span><br><span class="line">    -&gt; FROM Customers</span><br><span class="line">    -&gt; WHERE SOUNDEX(cust_contact)=SOUNDEX('Michael Green');</span><br></pre></td></tr></table></figure>
<h1 id="日期处理函数"><a href="#日期处理函数" class="headerlink" title="日期处理函数"></a>日期处理函数</h1><p>DATEPART() ：返回日期的一部分</p>
<ul>
<li>Oracle没有<code>DATEPART()</code>函数，可借助 <code>TO_CHAR()</code> 和 <code>TO_NUMBER()</code><ul>
<li><code>TO_CHAR()</code>用来提取日期的成分</li>
<li><code>TO_NUMBER()</code>用来将提取出来的成分转换为数值；或用 <code>BETWEEN()</code></li>
</ul>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 检索2012年的所有订单</span></span><br><span class="line"><span class="comment">## SQL Server</span></span><br><span class="line"><span class="keyword">SELECT</span> order_num <span class="keyword">FROM</span> Orders</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">DATEPART</span>(yy, order_date) = <span class="number">2012</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">## Access</span></span><br><span class="line"><span class="keyword">SELECT</span> order_num <span class="keyword">FROM</span> Orders</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">DATEPART</span>(<span class="string">'yyyy'</span>, order_date) = <span class="number">2012</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">## PostgreSQL</span></span><br><span class="line"><span class="keyword">SELECT</span> order_num <span class="keyword">FROM</span> Orders</span><br><span class="line"><span class="keyword">WHERE</span> DATE_PART(<span class="string">'year'</span>, order_date) = <span class="number">2012</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">## Oracle</span></span><br><span class="line"><span class="keyword">SELECT</span> order_num <span class="keyword">FROM</span> Orders</span><br><span class="line"><span class="keyword">WHERE</span> TO_NUMBER(TO_CHAR(order_date, <span class="string">'YYYY'</span>)) = <span class="number">2012</span>;</span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line"><span class="keyword">SELECT</span> order_num <span class="keyword">FROM</span> Orders</span><br><span class="line"><span class="keyword">WHERE</span> order_date <span class="keyword">BETWEEN</span> <span class="keyword">TO_DATE</span>(<span class="string">'01-01-2012'</span>)</span><br><span class="line"><span class="keyword">AND</span> <span class="keyword">TO_DATE</span>(<span class="string">'12-31-2012'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">## MySQL 或 MariaDB</span></span><br><span class="line"><span class="keyword">SELECT</span> order_num <span class="keyword">FROM</span> Orders</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">YEAR</span>(order_date) = <span class="number">2012</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">## SQLite</span></span><br><span class="line"><span class="keyword">SELECT</span> order_num <span class="keyword">FROM</span> Orders</span><br><span class="line"><span class="keyword">WHERE</span> STRFTIME(<span class="string">'%Y'</span>, order_date) = <span class="string">'2012'</span>;</span><br></pre></td></tr></table></figure>
<h1 id="数值处理函数"><a href="#数值处理函数" class="headerlink" title="数值处理函数"></a>数值处理函数</h1><p><u>表 ：常用数值处理函数</u></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">操作符</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">ABS()</td>
<td style="text-align:center">绝对值</td>
</tr>
<tr>
<td style="text-align:center">COS()</td>
<td style="text-align:center">余弦值</td>
</tr>
<tr>
<td style="text-align:center">EXP()</td>
<td style="text-align:center">指数值</td>
</tr>
<tr>
<td style="text-align:center">PI()</td>
<td style="text-align:center">圆周率Π</td>
</tr>
<tr>
<td style="text-align:center">SIN()</td>
<td style="text-align:center">正弦值</td>
</tr>
<tr>
<td style="text-align:center">SQRT()</td>
<td style="text-align:center">平方根</td>
</tr>
<tr>
<td style="text-align:center">TAN()</td>
<td style="text-align:center">正切</td>
</tr>
</tbody>
</table>
</div>
<h1 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h1><p>聚合函数（aggregate function）：对某些行运行的函数，计算并返回一个值</p>
<p><u>表 ：SQL聚合函数</u></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">操作符</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">AVG()</td>
<td style="text-align:center">平均值</td>
</tr>
<tr>
<td style="text-align:center">COUNT()</td>
<td style="text-align:center">行数</td>
</tr>
<tr>
<td style="text-align:center">MAX()</td>
<td style="text-align:center">最大值</td>
</tr>
<tr>
<td style="text-align:center">MIN()</td>
<td style="text-align:center">最小值</td>
</tr>
<tr>
<td style="text-align:center">SUM()</td>
<td style="text-align:center">求和</td>
</tr>
</tbody>
</table>
</div>
<h2 id="AVG"><a href="#AVG" class="headerlink" title="AVG()"></a>AVG()</h2><p>AVG() ：平均值</p>
<ul>
<li>AVG() 只能用来确定特定数值列的平均值，列名必须作为函数参数给出</li>
<li>AVG() 函数忽略列值为NULL的行</li>
</ul>
<h2 id="COUNT"><a href="#COUNT" class="headerlink" title="COUNT()"></a>COUNT()</h2><p>COUNT() ：计数</p>
<ul>
<li>COUNT(*) 对表中行的数目进行计数，不管表列中包含的是空值还是非空值</li>
<li>COUNT(column) 对特定列中的具有值的行进行计数，忽略NULL值</li>
</ul>
<h2 id="MAX"><a href="#MAX" class="headerlink" title="MAX()"></a>MAX()</h2><p>MAX() ：最大值</p>
<ul>
<li>一般用来找出最大的数值或日期值</li>
<li>大多数DBMS允许它用来返回任意列中的最大值，包括返回文本列中的最大值</li>
<li>在用于文本数据时，返回按该列排序后的最后一行</li>
<li>忽略列值为NULL的行</li>
</ul>
<h2 id="MIN"><a href="#MIN" class="headerlink" title="MIN()"></a>MIN()</h2><p>MIN() ：最小值</p>
<ul>
<li>一般用来找出最小的数值或日期值</li>
<li>大多数DBMS允许它用来返回任意列中的最小值，包括返回文本列中的最小值</li>
<li>在用于文本数据时，返回按该列排序后的最前面的一行</li>
<li>略列值为NULL的行</li>
</ul>
<h2 id="SUM"><a href="#SUM" class="headerlink" title="SUM()"></a>SUM()</h2><p>SUM() ：求和</p>
<ul>
<li>忽略值为NULL的行</li>
</ul>
<h2 id="DISTINCT"><a href="#DISTINCT" class="headerlink" title="DISTINCT"></a>DISTINCT</h2><p>DISTINCT：</p>
<ul>
<li>以上5个聚合函数，默认对所有的行执行计算，指定ALL参数或补指定（ALL是默认行为）</li>
<li>若只考虑对不同的值的行执行计算，则应指定参数 DISTINCT</li>
<li>Microsoft Access在聚合函数中不支持DISTINCT</li>
<li>DISTINCT不能用于 COUNT(*)</li>
<li>DISTINCT必须使用列名，不能用于计算或表达式</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT AVG(DISTINCT prod_price) AS avg_price</span><br><span class="line">    -&gt; FROM Products</span><br><span class="line">    -&gt; WHERE vend_id=1003;</span><br><span class="line">+<span class="comment">-----------+</span></span><br><span class="line">| avg_price |</span><br><span class="line">+<span class="comment">-----------+</span></span><br><span class="line">| 15.998000 |</span><br><span class="line">+<span class="comment">-----------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>[1] <a href="https://book.douban.com/subject/24250054/" target="_blank" rel="noopener">SQL必知必会</a><br>[2] <a href="https://forta.com/wp-content/uploads/books/0672327120/mysql_scripts.zip" target="_blank" rel="noopener">本文sql脚本参照</a><br>[3] <a href="https://mp.weixin.qq.com/s?__biz=MzU5NzkxODMxOA==&amp;mid=2247486117&amp;idx=1&amp;sn=47aa300d46873749282b368db799afd7&amp;chksm=fe4d5da4c93ad4b2a125503826e381610b79c3905feb0b194907d46bf771dc66b784325ddb30&amp;token=1415910284&amp;lang=zh_CN#rd" target="_blank" rel="noopener">Notes | SQL必知必会 | 01</a></p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Python | Pandas</title>
    <url>/python-pandas%E6%A8%A1%E5%9D%97.html</url>
    <content><![CDATA[<p><center></center><br><a id="more"></a></p>
<blockquote>
<ul>
<li><a href="https://pandas.pydata.org/docs/user_guide/index.html" target="_blank" rel="noopener">Pandas用户手册（英文版）</a></li>
<li><a href="https://pandas.pydata.org/docs/pandas.pdf" target="_blank" rel="noopener">Pandas: Powerful Python Data Analysis Toolkit（PDF版）</a></li>
</ul>
</blockquote>
<h1 id="Pandas"><a href="#Pandas" class="headerlink" title="Pandas"></a>Pandas</h1><p>Pandas是Python中基于提供高性能易用数据类型和分析工具的第三方库。</p>
<ul>
<li>其基于Numpy实现</li>
<li>名称来源于面板数据（Panel Data）和数据分析（Data Analysis）</li>
<li>提供2种最基本的数据类型：Series（一维数组）和DataFrame（二维数组）</li>
</ul>
<p>安装pandas库：（在Anaconda Prompt中实现）<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip install pandas</span><br></pre></td></tr></table></figure></p>
<p>查看Pandas的版本：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd </span><br><span class="line">pd.__version__ <span class="comment">## 注意version前后各有2个下划线</span></span><br></pre></td></tr></table></figure></p>
<h1 id="Series"><a href="#Series" class="headerlink" title="Series()"></a>Series()</h1><p>Series是一维数组（即向量）。</p>
<ul>
<li>由一组数组（Numpy数据类型）和一组与之相关的数据标签（索引）组成</li>
<li>表现形式：索引在左边，值在右边</li>
<li>索引可以不用指定，会自动创建一个从0开始、到n-1结束的整数型索引。（这里n是数据的长度）</li>
<li>可以通过Series的values属性和index属性获取其表现形式和索引对象</li>
<li>Series对象本身及其索引（index）都有一个name属性</li>
<li>索引可以通过赋值进行修改。</li>
</ul>
<p><code>Series()</code>：创建一维数组。<br><code>Series(data=None, index=None, dtype=None, name=None, copy=False, fastpath=False)</code></p>
<ul>
<li><code>data</code>：指定数据</li>
<li><code>index</code>：指定索引（可以缺省）</li>
<li><code>name</code>：指定数组名称</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 创建Series</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> pandas <span class="keyword">import</span> Series, DataFrame</span><br><span class="line"></span><br><span class="line"><span class="comment">#s = Series([1, 3, 4, np.nan, 6.5, 8.9])</span></span><br><span class="line"><span class="comment">#print(s)</span></span><br><span class="line"><span class="comment">#0    1.0</span></span><br><span class="line"><span class="comment">#1    3.0</span></span><br><span class="line"><span class="comment">#2    4.0</span></span><br><span class="line"><span class="comment">#3    NaN</span></span><br><span class="line"><span class="comment">#4    6.5</span></span><br><span class="line"><span class="comment">#5    8.9</span></span><br><span class="line"><span class="comment">#dtype: float64</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 创建Series的时候指定特殊的index：</span></span><br><span class="line">s2 = Series([<span class="number">2</span>, <span class="number">3.5</span>, <span class="number">6.3</span>, <span class="number">6</span>, <span class="number">7</span>, np.nan], </span><br><span class="line">           index=[<span class="string">'td'</span>, <span class="string">'ad'</span>, <span class="string">'rm'</span>, <span class="string">'ed'</span>,<span class="string">'way'</span>, <span class="string">'moon'</span>])</span><br><span class="line">print(s2)</span><br><span class="line"><span class="comment">#td      2.0</span></span><br><span class="line"><span class="comment">#ad      3.5</span></span><br><span class="line"><span class="comment">#rm      6.3</span></span><br><span class="line"><span class="comment">#ed      6.0</span></span><br><span class="line"><span class="comment">#way     7.0</span></span><br><span class="line"><span class="comment">#moon    NaN</span></span><br><span class="line"><span class="comment">#dtype: float64</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 结合字典创建Series：</span></span><br><span class="line">dict1 = &#123;<span class="string">'new'</span>:<span class="number">2.3</span>, <span class="string">'old'</span>:<span class="number">3.5</span>, <span class="string">'then'</span>:<span class="number">6.5</span>, <span class="string">'obj'</span>:<span class="number">8.4</span>&#125;</span><br><span class="line">s3 = Series(dict1)</span><br><span class="line">s3</span><br><span class="line"><span class="comment">#new     2.3</span></span><br><span class="line"><span class="comment">#old     3.5</span></span><br><span class="line"><span class="comment">#then    6.5</span></span><br><span class="line"><span class="comment">#obj     8.4</span></span><br><span class="line"><span class="comment">#dtype: float64</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 将字典dict1按照索引ind1创建Series：</span></span><br><span class="line"><span class="comment">## 若ind1的索引比字典dict1的索引多，则与dict1相匹配的值会找到，并放置到相应的位置中；ind1多出的索引，则填充NaN。</span></span><br><span class="line">ind1 = [<span class="string">'new'</span>, <span class="string">'after'</span>, <span class="string">'old'</span>, <span class="string">'then'</span>, <span class="string">'obj'</span>, <span class="string">'six'</span>]</span><br><span class="line">s4 = Series(dict1, index=ind1)</span><br><span class="line">s4</span><br><span class="line"><span class="comment">#new      2.3</span></span><br><span class="line"><span class="comment">#after    NaN</span></span><br><span class="line"><span class="comment">#old      3.5</span></span><br><span class="line"><span class="comment">#then     6.5</span></span><br><span class="line"><span class="comment">#obj      8.4</span></span><br><span class="line"><span class="comment">#six      NaN</span></span><br><span class="line"><span class="comment">#dtype: float64</span></span><br></pre></td></tr></table></figure>
<h2 id="index"><a href="#index" class="headerlink" title=".index"></a>.index</h2><p>查看Series的索引<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s.index</span><br><span class="line"><span class="comment"># RangeIndex(start=0, stop=6, step=1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 可以根据索引查看索引对应的值：</span></span><br><span class="line">s2[<span class="string">'rm'</span>]</span><br><span class="line"><span class="comment">#6.3</span></span><br><span class="line">s2[[<span class="string">'ed'</span>, <span class="string">'way'</span>, <span class="string">'moon'</span>]]</span><br><span class="line"><span class="comment">#ed      6.0</span></span><br><span class="line"><span class="comment">#way     7.0</span></span><br><span class="line"><span class="comment">#moon    NaN</span></span><br><span class="line"><span class="comment">#dtype: float64</span></span><br><span class="line">s2[s2 &gt; <span class="number">4.3</span>]  <span class="comment">## 查看s2中大于4.3的值</span></span><br><span class="line"><span class="comment">#rm     6.3</span></span><br><span class="line"><span class="comment">#ed     6.0</span></span><br><span class="line"><span class="comment">#way    7.0</span></span><br><span class="line"><span class="comment">#dtype: float64</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 判断是否存在某个索引：</span></span><br><span class="line"><span class="string">'way'</span> <span class="keyword">in</span> s2</span><br><span class="line"></span><br><span class="line"><span class="comment">## 修改索引：</span></span><br><span class="line">s4.index = [<span class="string">'one'</span>, <span class="string">'two'</span>, <span class="string">'three'</span>, <span class="string">'four'</span>, <span class="string">'five'</span>, <span class="string">'six'</span>]</span><br><span class="line">s4</span><br><span class="line"><span class="comment">#one      2.3</span></span><br><span class="line"><span class="comment">#two      NaN</span></span><br><span class="line"><span class="comment">#three    3.5</span></span><br><span class="line"><span class="comment">#four     6.5</span></span><br><span class="line"><span class="comment">#five     8.4</span></span><br><span class="line"><span class="comment">#six      NaN</span></span><br><span class="line"><span class="comment">#Name: New_name, dtype: float64</span></span><br></pre></td></tr></table></figure></p>
<h2 id="name"><a href="#name" class="headerlink" title=".name"></a>.name</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## name属性：</span></span><br><span class="line">s4</span><br><span class="line"><span class="comment">#new      2.3</span></span><br><span class="line"><span class="comment">#after    NaN</span></span><br><span class="line"><span class="comment">#old      3.5</span></span><br><span class="line"><span class="comment">#then     6.5</span></span><br><span class="line"><span class="comment">#obj      8.4</span></span><br><span class="line"><span class="comment">#six      NaN</span></span><br><span class="line"><span class="comment">#dtype: float64</span></span><br><span class="line">s4.name = <span class="string">'New_name'</span></span><br><span class="line">s4.index.name = <span class="string">'Index_name'</span></span><br><span class="line">s4</span><br><span class="line"><span class="comment">#Index_name</span></span><br><span class="line"><span class="comment">#new      2.3</span></span><br><span class="line"><span class="comment">#after    NaN</span></span><br><span class="line"><span class="comment">#old      3.5</span></span><br><span class="line"><span class="comment">#then     6.5</span></span><br><span class="line"><span class="comment">#obj      8.4</span></span><br><span class="line"><span class="comment">#six      NaN</span></span><br><span class="line"><span class="comment">#Name: New_name, dtype: float64</span></span><br></pre></td></tr></table></figure>
<h2 id="values"><a href="#values" class="headerlink" title=".values"></a>.values</h2><p>查看Series的值<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s.values</span><br><span class="line"><span class="comment"># array([1. , 3. , 4. , nan, 6.5, 8.9])</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 判断是否存在某个值：</span></span><br><span class="line"><span class="number">6.3</span> <span class="keyword">in</span> s2.values</span><br></pre></td></tr></table></figure></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="concat"><a href="#concat" class="headerlink" title="concat()"></a>concat()</h1><p>拼接DataFrame；将数据根据不同的轴作简单的融合<br><code>pd.concat(objs, axis=0, join=&#39;outer&#39;, join_axes=None, ignore_index=False,
       keys=None, levels=None, names=None, verify_integrity=False)</code></p>
<ul>
<li><code>axis</code>：需要合并的轴<ul>
<li><code>=0</code>是行（列对齐，合并行）</li>
<li><code>=1</code>是列（行对齐，合并列）</li>
</ul>
</li>
<li><code>join</code>：连接的方式<ul>
<li><code>inner</code>：得到多表的交集</li>
<li><code>outer</code>：得到多表的并集</li>
</ul>
</li>
<li><code>ignore_index</code>：无视表的索引，会自动根据列字段对齐，然后进行合并</li>
<li><code>keys</code>：说明数据源（分组键）</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df1 = pd.DataFrame(&#123;<span class="string">'A'</span>: [<span class="string">'A0'</span>, <span class="string">'A1'</span>, <span class="string">'A2'</span>, <span class="string">'A3'</span>],</span><br><span class="line">                    <span class="string">'B'</span>: [<span class="string">'B0'</span>, <span class="string">'B1'</span>, <span class="string">'B2'</span>, <span class="string">'B3'</span>],</span><br><span class="line">                    <span class="string">'C'</span>: [<span class="string">'C0'</span>, <span class="string">'C1'</span>, <span class="string">'C2'</span>, <span class="string">'C3'</span>],</span><br><span class="line">                    <span class="string">'D'</span>: [<span class="string">'D0'</span>, <span class="string">'D1'</span>, <span class="string">'D2'</span>, <span class="string">'D3'</span>]&#125;)</span><br><span class="line">df2 = pd.DataFrame(&#123;<span class="string">'A'</span>: [<span class="string">'A4'</span>, <span class="string">'A5'</span>, <span class="string">'A6'</span>, <span class="string">'A7'</span>],</span><br><span class="line">                    <span class="string">'B'</span>: [<span class="string">'B4'</span>, <span class="string">'B5'</span>, <span class="string">'B6'</span>, <span class="string">'B7'</span>],</span><br><span class="line">                    <span class="string">'C'</span>: [<span class="string">'C4'</span>, <span class="string">'C5'</span>, <span class="string">'C6'</span>, <span class="string">'C7'</span>],</span><br><span class="line">                    <span class="string">'D'</span>: [<span class="string">'D4'</span>, <span class="string">'D5'</span>, <span class="string">'D6'</span>, <span class="string">'D7'</span>]&#125;)</span><br><span class="line">df3 = pd.DataFrame(&#123;<span class="string">'A'</span>: [<span class="string">'A8'</span>, <span class="string">'A9'</span>, <span class="string">'A10'</span>, <span class="string">'A11'</span>],</span><br><span class="line">                    <span class="string">'B'</span>: [<span class="string">'B8'</span>, <span class="string">'B9'</span>, <span class="string">'B10'</span>, <span class="string">'B11'</span>],</span><br><span class="line">                    <span class="string">'C'</span>: [<span class="string">'C8'</span>, <span class="string">'C9'</span>, <span class="string">'C10'</span>, <span class="string">'C11'</span>],</span><br><span class="line">                    <span class="string">'D'</span>: [<span class="string">'D8'</span>, <span class="string">'D9'</span>, <span class="string">'D10'</span>, <span class="string">'D11'</span>]&#125;)</span><br><span class="line">frames = [df1, df2, df3]</span><br><span class="line">result = pd.concat(frames)  <span class="comment">## 默认按列对齐，拼接行</span></span><br><span class="line">result</span><br><span class="line"><span class="comment">#     A    B    C    D</span></span><br><span class="line"><span class="comment">#0   A0   B0   C0   D0</span></span><br><span class="line"><span class="comment">#1   A1   B1   C1   D1</span></span><br><span class="line"><span class="comment">#2   A2   B2   C2   D2</span></span><br><span class="line"><span class="comment">#3   A3   B3   C3   D3</span></span><br><span class="line"><span class="comment">#0   A4   B4   C4   D4</span></span><br><span class="line"><span class="comment">#1   A5   B5   C5   D5</span></span><br><span class="line"><span class="comment">#2   A6   B6   C6   D6</span></span><br><span class="line"><span class="comment">#3   A7   B7   C7   D7</span></span><br><span class="line"><span class="comment">#0   A8   B8   C8   D8</span></span><br><span class="line"><span class="comment">#1   A9   B9   C9   D9</span></span><br><span class="line"><span class="comment">#2  A10  B10  C10  D10</span></span><br><span class="line"><span class="comment">#3  A11  B11  C11  D11</span></span><br></pre></td></tr></table></figure>
<p>添加参数<code>keys</code>，说明数据源（分组键）<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">result = pd.concat(frames, keys=[<span class="string">'x'</span>, <span class="string">'y'</span>, <span class="string">'z'</span>])</span><br><span class="line">result</span><br><span class="line"><span class="comment">#       A    B    C    D</span></span><br><span class="line"><span class="comment">#x 0   A0   B0   C0   D0</span></span><br><span class="line"><span class="comment">#  1   A1   B1   C1   D1</span></span><br><span class="line"><span class="comment">#  2   A2   B2   C2   D2</span></span><br><span class="line"><span class="comment">#  3   A3   B3   C3   D3</span></span><br><span class="line"><span class="comment">#y 0   A4   B4   C4   D4</span></span><br><span class="line"><span class="comment">#  1   A5   B5   C5   D5</span></span><br><span class="line"><span class="comment">#  2   A6   B6   C6   D6</span></span><br><span class="line"><span class="comment">#  3   A7   B7   C7   D7</span></span><br><span class="line"><span class="comment">#z 0   A8   B8   C8   D8</span></span><br><span class="line"><span class="comment">#  1   A9   B9   C9   D9</span></span><br><span class="line"><span class="comment">#  2  A10  B10  C10  D10</span></span><br><span class="line"><span class="comment">#  3  A11  B11  C11  D11</span></span><br></pre></td></tr></table></figure></p>
<p>也可通过字典来传入分组键<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pieces = &#123;<span class="string">'x'</span>: df1, <span class="string">'y'</span>: df2, <span class="string">'z'</span>: df3&#125;</span><br><span class="line">pd.concat(pieces)</span><br><span class="line"><span class="comment">#       A    B    C    D</span></span><br><span class="line"><span class="comment">#x 0   A0   B0   C0   D0</span></span><br><span class="line"><span class="comment">#  1   A1   B1   C1   D1</span></span><br><span class="line"><span class="comment">#  2   A2   B2   C2   D2</span></span><br><span class="line"><span class="comment">#  3   A3   B3   C3   D3</span></span><br><span class="line"><span class="comment">#y 0   A4   B4   C4   D4</span></span><br><span class="line"><span class="comment">#  1   A5   B5   C5   D5</span></span><br><span class="line"><span class="comment">#  2   A6   B6   C6   D6</span></span><br><span class="line"><span class="comment">#  3   A7   B7   C7   D7</span></span><br><span class="line"><span class="comment">#z 0   A8   B8   C8   D8</span></span><br><span class="line"><span class="comment">#  1   A9   B9   C9   D9</span></span><br><span class="line"><span class="comment">#  2  A10  B10  C10  D10</span></span><br><span class="line"><span class="comment">#  3  A11  B11  C11  D11</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df1 = pd.DataFrame(&#123;<span class="string">'A'</span>: [<span class="string">'A0'</span>, <span class="string">'A1'</span>, <span class="string">'A2'</span>, <span class="string">'A3'</span>],</span><br><span class="line">                    <span class="string">'B'</span>: [<span class="string">'B0'</span>, <span class="string">'B1'</span>, <span class="string">'B2'</span>, <span class="string">'B3'</span>],</span><br><span class="line">                    <span class="string">'C'</span>: [<span class="string">'C0'</span>, <span class="string">'C1'</span>, <span class="string">'C2'</span>, <span class="string">'C3'</span>],</span><br><span class="line">                    <span class="string">'D'</span>: [<span class="string">'D0'</span>, <span class="string">'D1'</span>, <span class="string">'D2'</span>, <span class="string">'D3'</span>]&#125;)</span><br><span class="line">df4 = pd.DataFrame(&#123;<span class="string">'B'</span>: [<span class="string">'B2'</span>, <span class="string">'B3'</span>, <span class="string">'B6'</span>, <span class="string">'B7'</span>],</span><br><span class="line">                    <span class="string">'D'</span>: [<span class="string">'D2'</span>, <span class="string">'D3'</span>, <span class="string">'D6'</span>, <span class="string">'D7'</span>],</span><br><span class="line">                    <span class="string">'F'</span>: [<span class="string">'F2'</span>, <span class="string">'F3'</span>, <span class="string">'F6'</span>, <span class="string">'F7'</span>]&#125;)</span><br><span class="line">pd.concat([df1, df4], axis=<span class="number">1</span>)  <span class="comment">## 行对齐，合并列</span></span><br><span class="line"><span class="comment">#    A   B   C   D   B   D   F</span></span><br><span class="line"><span class="comment">#0  A0  B0  C0  D0  B2  D2  F2</span></span><br><span class="line"><span class="comment">#1  A1  B1  C1  D1  B3  D3  F3</span></span><br><span class="line"><span class="comment">#2  A2  B2  C2  D2  B6  D6  F6</span></span><br><span class="line"><span class="comment">#3  A3  B3  C3  D3  B7  D7  F7</span></span><br></pre></td></tr></table></figure>
<p><code>join=inner</code>：返回index的交集<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df4 = pd.DataFrame(&#123;<span class="string">'B'</span>: [<span class="string">'B2'</span>, <span class="string">'B3'</span>, <span class="string">'B6'</span>, <span class="string">'B7'</span>],</span><br><span class="line">                    <span class="string">'D'</span>: [<span class="string">'D2'</span>, <span class="string">'D3'</span>, <span class="string">'D6'</span>, <span class="string">'D7'</span>],</span><br><span class="line">                    <span class="string">'F'</span>: [<span class="string">'F2'</span>, <span class="string">'F3'</span>, <span class="string">'F6'</span>, <span class="string">'F7'</span>]&#125;)</span><br><span class="line">df4.index = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">7</span>]</span><br><span class="line">df1</span><br><span class="line"><span class="comment">#    A   B   C   D</span></span><br><span class="line"><span class="comment">#0  A0  B0  C0  D0</span></span><br><span class="line"><span class="comment">#1  A1  B1  C1  D1</span></span><br><span class="line"><span class="comment">#2  A2  B2  C2  D2</span></span><br><span class="line"><span class="comment">#3  A3  B3  C3  D3</span></span><br><span class="line">df4</span><br><span class="line"><span class="comment">#    B   D   F</span></span><br><span class="line"><span class="comment">#2  B2  D2  F2</span></span><br><span class="line"><span class="comment">#3  B3  D3  F3</span></span><br><span class="line"><span class="comment">#6  B6  D6  F6</span></span><br><span class="line"><span class="comment">#7  B7  D7  F7</span></span><br><span class="line">pd.concat([df1, df4], axis=<span class="number">1</span>, join=<span class="string">'inner'</span>)</span><br><span class="line"><span class="comment">#    A   B   C   D   B   D   F</span></span><br><span class="line"><span class="comment">#2  A2  B2  C2  D2  B2  D2  F2</span></span><br><span class="line"><span class="comment">#3  A3  B3  C3  D3  B3  D3  F3</span></span><br></pre></td></tr></table></figure></p>
<p><code>join_axes</code>指定用于对齐的轴<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df1</span><br><span class="line"><span class="comment">#    A   B   C   D</span></span><br><span class="line"><span class="comment">#0  A0  B0  C0  D0</span></span><br><span class="line"><span class="comment">#1  A1  B1  C1  D1</span></span><br><span class="line"><span class="comment">#2  A2  B2  C2  D2</span></span><br><span class="line"><span class="comment">#3  A3  B3  C3  D3</span></span><br><span class="line">df4</span><br><span class="line"><span class="comment">#    B   D   F</span></span><br><span class="line"><span class="comment">#2  B2  D2  F2</span></span><br><span class="line"><span class="comment">#3  B3  D3  F3</span></span><br><span class="line"><span class="comment">#6  B6  D6  F6</span></span><br><span class="line"><span class="comment">#7  B7  D7  F7</span></span><br><span class="line">pd.concat([df1, df4], axis=<span class="number">1</span>, join_axes=[df1.index])</span><br><span class="line"><span class="comment">#    A   B   C   D    B    D    F</span></span><br><span class="line"><span class="comment">#0  A0  B0  C0  D0  NaN  NaN  NaN</span></span><br><span class="line"><span class="comment">#1  A1  B1  C1  D1  NaN  NaN  NaN</span></span><br><span class="line"><span class="comment">#2  A2  B2  C2  D2   B2   D2   F2</span></span><br><span class="line"><span class="comment">#3  A3  B3  C3  D3   B3   D3   F3</span></span><br><span class="line"></span><br><span class="line">pd.concat([df1, df4], axis=<span class="number">1</span>, join_axes=[df4.index])</span><br><span class="line"><span class="comment">#     A    B    C    D   B   D   F</span></span><br><span class="line"><span class="comment">#2   A2   B2   C2   D2  B2  D2  F2</span></span><br><span class="line"><span class="comment">#3   A3   B3   C3   D3  B3  D3  F3</span></span><br><span class="line"><span class="comment">#6  NaN  NaN  NaN  NaN  B6  D6  F6</span></span><br><span class="line"><span class="comment">#7  NaN  NaN  NaN  NaN  B7  D7  F7</span></span><br></pre></td></tr></table></figure></p>
<p><code>ignore_index</code>：无视表的索引，会自动根据列字段对齐，然后进行合并<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df1</span><br><span class="line"><span class="comment">#    A   B   C   D</span></span><br><span class="line"><span class="comment">#0  A0  B0  C0  D0</span></span><br><span class="line"><span class="comment">#1  A1  B1  C1  D1</span></span><br><span class="line"><span class="comment">#2  A2  B2  C2  D2</span></span><br><span class="line"><span class="comment">#3  A3  B3  C3  D3</span></span><br><span class="line">df4</span><br><span class="line"><span class="comment">#    B   D   F</span></span><br><span class="line"><span class="comment">#2  B2  D2  F2</span></span><br><span class="line"><span class="comment">#3  B3  D3  F3</span></span><br><span class="line"><span class="comment">#6  B6  D6  F6</span></span><br><span class="line"><span class="comment">#7  B7  D7  F7</span></span><br><span class="line">pd.concat([df1, df4], axis=<span class="number">1</span>, ignore_index=<span class="literal">True</span>)</span><br><span class="line"><span class="comment">#     0    1    2    3    4    5    6</span></span><br><span class="line"><span class="comment">#0   A0   B0   C0   D0  NaN  NaN  NaN</span></span><br><span class="line"><span class="comment">#1   A1   B1   C1   D1  NaN  NaN  NaN</span></span><br><span class="line"><span class="comment">#2   A2   B2   C2   D2   B2   D2   F2</span></span><br><span class="line"><span class="comment">#3   A3   B3   C3   D3   B3   D3   F3</span></span><br><span class="line"><span class="comment">#6  NaN  NaN  NaN  NaN   B6   D6   F6</span></span><br><span class="line"><span class="comment">#7  NaN  NaN  NaN  NaN   B7   D7   F7</span></span><br></pre></td></tr></table></figure></p>
<h1 id="cut"><a href="#cut" class="headerlink" title="cut()"></a>cut()</h1><p>将数组按区间划分</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cut(数据数组, 面元数组)  <span class="comment"># 将数据数组按区间划分</span></span><br><span class="line">cut(数据数组, 面元个数, precision=<span class="number">2</span>)  <span class="comment"># 将数据数组均分；每个面元的间距一致</span></span><br><span class="line"><span class="comment"># precision=2表示保留2位小数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">ages = [<span class="number">23</span>, <span class="number">45</span>, <span class="number">21</span>, <span class="number">15</span>, <span class="number">24</span>, <span class="number">54</span>, <span class="number">36</span>, <span class="number">48</span>, <span class="number">57</span>, <span class="number">86</span>, <span class="number">61</span>, <span class="number">45</span>]  <span class="comment"># 数据数组</span></span><br><span class="line">cat2 = pd.cut(ages, <span class="number">5</span>)  <span class="comment"># 不指定面元划分，只指定面元个数</span></span><br><span class="line">cat2</span><br><span class="line"><span class="comment"># [(14.929, 29.2], (43.4, 57.6], (14.929, 29.2], (14.929, 29.2], (14.929, 29.2], ..., (43.4, 57.6], (43.4, 57.6], (71.8, 86.0], (57.6, 71.8], (43.4, 57.6]]</span></span><br><span class="line"><span class="comment"># Length: 12</span></span><br><span class="line"><span class="comment"># Categories (5, interval[float64]): [(14.929, 29.2] &lt; (29.2, 43.4] &lt; (43.4, 57.6] &lt; (57.6, 71.8] &lt; (71.8, 86.0]]</span></span><br></pre></td></tr></table></figure>
<p>指定面元标签：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">ages = np.random.randint(<span class="number">18</span>, <span class="number">89</span>, size = <span class="number">30</span>)</span><br><span class="line">ages</span><br><span class="line"><span class="comment"># array([75, 66,  1, 25, 38, 53, 29, 50, 88, 54, 87, 93, 53, 16, 51, 34, 69,</span></span><br><span class="line"><span class="comment">#        60, 70, 58, 95, 76, 52,  8, 20, 48, 61,  1, 11, 18])</span></span><br><span class="line">df = pd.DataFrame()</span><br><span class="line">df[<span class="string">'age'</span>] = ages</span><br><span class="line"><span class="comment"># 一般来说：0（初生）-6岁为婴幼儿；7-12岁为少儿；</span></span><br><span class="line"><span class="comment"># 13-17岁为青少年；18-45岁为青年；46-69岁为中年；&gt;69岁为老年。</span></span><br><span class="line">bins = [<span class="number">0</span>, <span class="number">6</span>, <span class="number">12</span>, <span class="number">18</span>, <span class="number">45</span>, <span class="number">69</span>, <span class="number">100</span>]</span><br><span class="line"></span><br><span class="line">df[<span class="string">'age_bin'</span>] = pd.cut(df[<span class="string">'age'</span>], bins)</span><br><span class="line">df.head()</span><br><span class="line"><span class="comment">#    age    age_bin</span></span><br><span class="line"><span class="comment"># 0   75  (69, 100]</span></span><br><span class="line"><span class="comment"># 1   66   (45, 69]</span></span><br><span class="line"><span class="comment"># 2    1     (0, 6]</span></span><br><span class="line"><span class="comment"># 3   25   (18, 45]</span></span><br><span class="line"><span class="comment"># 4   38   (18, 45]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 给区间添加标签</span></span><br><span class="line">df[<span class="string">'age_category'</span>] = pd.cut(df[<span class="string">'age'</span>], bins, </span><br><span class="line">  labels=[<span class="string">'婴幼儿'</span>, <span class="string">'少儿'</span>, <span class="string">'青少年'</span>, <span class="string">'青年'</span>, <span class="string">'中年'</span>, <span class="string">'老年'</span>])</span><br><span class="line"></span><br><span class="line">df.head().append(df.tail())  <span class="comment"># 查看前5行和最后5行</span></span><br><span class="line"><span class="comment">#     age    age_bin age_category</span></span><br><span class="line"><span class="comment"># 0    75  (69, 100]           老年</span></span><br><span class="line"><span class="comment"># 1    66   (45, 69]           中年</span></span><br><span class="line"><span class="comment"># 2     1     (0, 6]          婴幼儿</span></span><br><span class="line"><span class="comment"># 3    25   (18, 45]           青年</span></span><br><span class="line"><span class="comment"># 4    38   (18, 45]           青年</span></span><br><span class="line"><span class="comment"># 25   48   (45, 69]           中年</span></span><br><span class="line"><span class="comment"># 26   61   (45, 69]           中年</span></span><br><span class="line"><span class="comment"># 27    1     (0, 6]          婴幼儿</span></span><br><span class="line"><span class="comment"># 28   11    (6, 12]           少儿</span></span><br><span class="line"><span class="comment"># 29   18   (12, 18]          青少年</span></span><br></pre></td></tr></table></figure></p>
<h2 id="codes"><a href="#codes" class="headerlink" title=".codes"></a>.codes</h2><p>查看数据对应的面元编号<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">ages = [<span class="number">23</span>, <span class="number">45</span>, <span class="number">21</span>, <span class="number">15</span>, <span class="number">24</span>, <span class="number">54</span>, <span class="number">36</span>, <span class="number">48</span>, <span class="number">57</span>, <span class="number">86</span>, <span class="number">61</span>, <span class="number">45</span>]  <span class="comment"># 数据数组</span></span><br><span class="line">bins = [<span class="number">0</span>,<span class="number">18</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>, <span class="number">65</span>,<span class="number">100</span>]  <span class="comment"># 面元数组</span></span><br><span class="line"></span><br><span class="line">cat = pd.cut(ages, bins)</span><br><span class="line">cat  <span class="comment"># 返回每个数据对应的面元</span></span><br><span class="line"><span class="comment"># [(18, 30], (40, 50], (18, 30], (0, 18], (18, 30], ..., (40, 50], (50, 65], (65, 100], (50, 65], (40, 50]]</span></span><br><span class="line"><span class="comment"># Length: 12</span></span><br><span class="line"><span class="comment"># Categories (6, interval[int64]): [(0, 18] &lt; (18, 30] &lt; (30, 40] &lt; (40, 50] &lt; (50, 65] &lt; (65, 100]]</span></span><br></pre></td></tr></table></figure></p>
<h2 id="value-counts"><a href="#value-counts" class="headerlink" title=".value_counts()"></a>.value_counts()</h2><p>不同面元里含有的数据个数<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cat.value_counts()  <span class="comment"># 不同面元里含有的数据个数</span></span><br><span class="line"><span class="comment"># (0, 18]      1</span></span><br><span class="line"><span class="comment"># (18, 30]     3</span></span><br><span class="line"><span class="comment"># (30, 40]     1</span></span><br><span class="line"><span class="comment"># (40, 50]     3</span></span><br><span class="line"><span class="comment"># (50, 65]     3</span></span><br><span class="line"><span class="comment"># (65, 100]    1</span></span><br><span class="line"><span class="comment"># dtype: int64</span></span><br></pre></td></tr></table></figure></p>
<h1 id="DataFrame"><a href="#DataFrame" class="headerlink" title="DataFrame()"></a>DataFrame()</h1><p>DataFrame是二维数组（即数据框），是表格型数据结构</p>
<ul>
<li>包含一组有序的列，每列可以是不同的值类型</li>
<li>DataFrame有行索引和列索引</li>
<li>可以看作是由多个Series组成的字典</li>
<li>若没有指定索引，会自动加上索引（从0开始）</li>
</ul>
<p><code>DataFrame()</code>：创建二维数组（数据框）。<br><code>DataFrame(data=None, index=None, columns=None, dtype=None, copy=False)</code></p>
<ul>
<li><code>index</code> ：指定行索引（可以缺省）</li>
<li><code>columns</code>：指定列名</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 结合字典创建一个DataFrame：</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> pandas <span class="keyword">import</span> DataFrame</span><br><span class="line"></span><br><span class="line">data1 = &#123;<span class="string">'Name'</span>:[<span class="string">'Jane'</span>, <span class="string">'John'</span>, <span class="string">'Mike'</span>, <span class="string">'Jack'</span>],</span><br><span class="line">        <span class="string">'Gender'</span>:[<span class="string">'F'</span>, <span class="string">'M'</span>, <span class="string">'M'</span>, <span class="string">'M'</span>],</span><br><span class="line">        <span class="string">'Age'</span>:[<span class="number">18</span>, <span class="number">19</span>, <span class="number">21</span>, <span class="number">17</span>],</span><br><span class="line">        <span class="string">'Grade'</span>:[<span class="number">89</span>, <span class="number">90</span>, <span class="number">87</span>, <span class="number">76</span>]&#125;</span><br><span class="line">df1 = DataFrame(data1)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 使用嵌套字典创建DataFrame：</span></span><br><span class="line"><span class="comment">## 嵌套字典：外层字典的键作为列名（columns）；内层字典的键作为行索引（index）</span></span><br><span class="line">dict2 = &#123;<span class="string">'Neth'</span>:&#123;<span class="number">2010</span>:<span class="number">3.4</span>, <span class="number">2013</span>:<span class="number">5.2</span>&#125;,</span><br><span class="line">        <span class="string">'Norway'</span>:&#123;<span class="number">2010</span>:<span class="number">2.5</span>, <span class="number">2011</span>:<span class="number">3.4</span>, <span class="number">2012</span>:<span class="number">2.8</span>, <span class="number">2013</span>:<span class="number">4.3</span>&#125;</span><br><span class="line">        &#125;</span><br><span class="line">df4 = DataFrame(dict2)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 若指定参数columns，则按columns有序排列：</span></span><br><span class="line">df2 = DataFrame(data1, columns=[<span class="string">'Name'</span>, <span class="string">'Grade'</span>, <span class="string">'Gender'</span>, <span class="string">'Age'</span>])</span><br></pre></td></tr></table></figure>
<p>访问某一列：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 访问DataFrame的某一列（2种方法）：（访问df1的“Age”列）</span></span><br><span class="line">df1[<span class="string">'Age'</span>]</span><br><span class="line"><span class="comment">#0    18</span></span><br><span class="line"><span class="comment">#1    19</span></span><br><span class="line"><span class="comment">#2    21</span></span><br><span class="line"><span class="comment">#3    17</span></span><br><span class="line"><span class="comment">#Name: Age, dtype: int64</span></span><br><span class="line"></span><br><span class="line">df1.Age <span class="comment">## 结果同上</span></span><br></pre></td></tr></table></figure></p>
<p>访问某几列：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 访问DataFrame的某几列：</span></span><br><span class="line">df1[[<span class="string">'Name'</span>, <span class="string">'Age'</span>, <span class="string">'Gender'</span>]]</span><br></pre></td></tr></table></figure></p>
<h2 id="at"><a href="#at" class="headerlink" title="at[]"></a>at[]</h2><p>通过<strong>行标签</strong>和<strong>列标签</strong>，选取DataFrame中的某个元素<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dict1 = &#123;<span class="string">'Name'</span>:[<span class="string">'Mike'</span>, <span class="string">'John'</span>, <span class="string">'Maria'</span>, <span class="string">'Jack'</span>],</span><br><span class="line">        <span class="string">'Gender'</span>:[<span class="string">'M'</span>, <span class="string">'M'</span>, <span class="string">'F'</span>, <span class="string">'M'</span>],</span><br><span class="line">        <span class="string">'Age'</span>:[<span class="number">21</span>, <span class="number">19</span>, <span class="number">24</span>, <span class="number">18</span>]&#125;</span><br><span class="line">df1 = DataFrame(data=dict1)</span><br><span class="line">df1.at[<span class="number">2</span>, <span class="string">'Name'</span>]</span><br><span class="line"><span class="comment">#'Maria'</span></span><br></pre></td></tr></table></figure></p>
<h2 id="columns"><a href="#columns" class="headerlink" title=".columns"></a>.columns</h2><p>查看DataFrame的列名<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df1.columns</span><br><span class="line"><span class="comment">#Index(['Name', 'Gender', 'Age'], dtype='object')</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="del"><a href="#del" class="headerlink" title="del"></a>del</h2><p>删除列数据<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">del</span> df3[<span class="string">'Female'</span>]</span><br></pre></td></tr></table></figure></p>
<h2 id="describe"><a href="#describe" class="headerlink" title=".describe"></a>.describe</h2><p>查看数据概况<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df3.describe</span><br><span class="line"><span class="comment">#&lt;bound method NDFrame.describe of        Name Gender   Age  Grade  Class  Female</span></span><br><span class="line"><span class="comment">#one    Jane      F  16.0     91      2    True</span></span><br><span class="line"><span class="comment">#two    John      M   NaN     93      3   False</span></span><br><span class="line"><span class="comment">#three  Mike      M  25.0     89      1   False</span></span><br><span class="line"><span class="comment">#four   Jack      M   NaN     79      2   False&gt;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="describe-1"><a href="#describe-1" class="headerlink" title="describe()"></a>describe()</h2><p>数据DataFrame的描述性统计</p>
<ul>
<li><code>count</code>：计数</li>
<li><code>mean</code>：均值</li>
<li><code>std</code>：标准差</li>
<li><code>min</code>：最小值</li>
<li><code>25%</code>：25\%分位数</li>
<li><code>50%</code>：中位数</li>
<li><code>75%</code>：75\%分位数</li>
<li><code>max</code>：最大值</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.describe()</span><br></pre></td></tr></table></figure>
<h2 id="drop"><a href="#drop" class="headerlink" title=".drop()"></a>.drop()</h2><p>删除行或列</p>
<ul>
<li>默认按行删除（即axis=0）</li>
<li>axis=1 或 axis=”columns” 表示按列删除</li>
<li>若要直接修改DataFrame，不保持原样，则令参数 inplace=True。</li>
</ul>
<p>按行删除：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df1.drop([<span class="number">2</span>])  <span class="comment">## 删除行索引为2的行，返回被删除行后的DataFrame</span></span><br><span class="line"><span class="comment">## df1并未改变</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 删除多行：</span></span><br><span class="line">df1.drop([<span class="number">1</span>,<span class="number">3</span>])</span><br></pre></td></tr></table></figure></p>
<p>按列删除：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df1.drop([<span class="string">'Gender'</span>, <span class="string">'Age'</span>], axis=<span class="number">1</span>)</span><br><span class="line"><span class="comment">#或</span></span><br><span class="line">df1.drop([<span class="string">'Gender'</span>, <span class="string">'Age'</span>], axis=<span class="string">'columns'</span>)</span><br><span class="line"><span class="comment">## df1并未改变</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 直接对DataFrame操作</span></span><br><span class="line">df1.drop([<span class="string">'Gender'</span>], axis=<span class="number">1</span>, inplace=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<h2 id="dropna"><a href="#dropna" class="headerlink" title="dropna()"></a>dropna()</h2><p>删除含缺失值的行</p>
<h2 id="head"><a href="#head" class="headerlink" title="head()"></a>head()</h2><p>预览前5行</p>
<ul>
<li>可以通过赋值<code>df.head(n)</code>中n来调整预览的行数</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.head()</span><br></pre></td></tr></table></figure>
<h2 id="iloc"><a href="#iloc" class="headerlink" title=".iloc[]"></a>.iloc[]</h2><p>通过<strong>行号</strong>索引行数据<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 在创建DataFrame时指定行标签：</span></span><br><span class="line">data1 = &#123;<span class="string">'Name'</span>:[<span class="string">'Jane'</span>, <span class="string">'John'</span>, <span class="string">'Mike'</span>, <span class="string">'Jack'</span>],</span><br><span class="line">        <span class="string">'Gender'</span>:[<span class="string">'F'</span>, <span class="string">'M'</span>, <span class="string">'M'</span>, <span class="string">'M'</span>],</span><br><span class="line">        <span class="string">'Age'</span>:[<span class="number">18</span>, <span class="number">19</span>, <span class="number">21</span>, <span class="number">17</span>],</span><br><span class="line">        <span class="string">'Grade'</span>:[<span class="number">89</span>, <span class="number">90</span>, <span class="number">87</span>, <span class="number">76</span>]&#125;</span><br><span class="line">df3 = DataFrame(data=data1, index=[<span class="string">'one'</span>, <span class="string">'two'</span>, <span class="string">'three'</span>, <span class="string">'four'</span>]</span><br><span class="line">df3.iloc[<span class="number">2</span>]</span><br><span class="line"><span class="comment">#Name      Mike</span></span><br><span class="line"><span class="comment">#Gender       M</span></span><br><span class="line"><span class="comment">#Age         21</span></span><br><span class="line"><span class="comment">#Grade       87</span></span><br><span class="line"><span class="comment">#Name: three, dtype: object</span></span><br><span class="line"></span><br><span class="line">df3.iloc[[<span class="number">0</span>,<span class="number">2</span>]]</span><br></pre></td></tr></table></figure></p>
<p>获取多行数据：</p>
<ul>
<li>使用行号索引时，左闭右开<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 下例中仅获取0、1、2行</span></span><br><span class="line">df3.iloc[<span class="number">0</span>:<span class="number">3</span>]</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>获取单列数据：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df3.iloc[:, <span class="number">3</span>]</span><br><span class="line"><span class="comment">#one      89</span></span><br><span class="line"><span class="comment">#two      90</span></span><br><span class="line"><span class="comment">#three    87</span></span><br><span class="line"><span class="comment">#four     76</span></span><br><span class="line"><span class="comment">#Name: Grade, dtype: int64</span></span><br></pre></td></tr></table></figure></p>
<p>获取多列数据：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df3.iloc[:, <span class="number">1</span>:<span class="number">3</span>]</span><br></pre></td></tr></table></figure></p>
<h2 id="index-1"><a href="#index-1" class="headerlink" title=".index"></a>.index</h2><p>查看DataFrame的行索引/标签<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df3.index</span><br><span class="line"><span class="comment">#Index(['one', 'two', 'three', 'four'], dtype='object')</span></span><br></pre></td></tr></table></figure></p>
<h2 id="isin"><a href="#isin" class="headerlink" title="isin()"></a>isin()</h2><p>用于选择DataFrame中符合条件的行</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">dates = pd.date_range(<span class="string">"20130101"</span>, periods=<span class="number">6</span>)</span><br><span class="line">dates</span><br><span class="line"><span class="comment"># DatetimeIndex(['2013-01-01', '2013-01-02', '2013-01-03', '2013-01-04',</span></span><br><span class="line"><span class="comment">#                '2013-01-05', '2013-01-06'],</span></span><br><span class="line"><span class="comment">#               dtype='datetime64[ns]', freq='D')</span></span><br><span class="line">df = pd.DataFrame(np.random.randn(<span class="number">6</span>, <span class="number">4</span>), index=dates, columns=list(<span class="string">"ABCD"</span>))</span><br><span class="line">df[<span class="string">"E"</span>] = [<span class="string">"one"</span>, <span class="string">"one"</span>, <span class="string">"two"</span>, <span class="string">"three"</span>, <span class="string">"four"</span>, <span class="string">"three"</span>]</span><br><span class="line">df.head()</span><br><span class="line"><span class="comment">#     A   B   C   D   E</span></span><br><span class="line"><span class="comment"># 2013-01-01 0.522782 -0.908932 0.503061 -1.133839 one</span></span><br><span class="line"><span class="comment"># 2013-01-02 -0.137954 -0.801103 0.416220 1.085829 one</span></span><br><span class="line"><span class="comment"># 2013-01-03 0.782363 0.044841 0.106608 1.169290 two</span></span><br><span class="line"><span class="comment"># 2013-01-04 1.143327 -2.648602 -1.410805 -0.639302 three</span></span><br><span class="line"><span class="comment"># 2013-01-05 -0.174496 0.810790 0.566061 -0.230608 four</span></span><br><span class="line">df[df[<span class="string">"E"</span>].isin([<span class="string">"two"</span>, <span class="string">"four"</span>])]</span><br><span class="line"><span class="comment">#     A   B   C   D   E</span></span><br><span class="line"><span class="comment"># 2013-01-03 0.782363 0.044841 0.106608 1.169290 two</span></span><br><span class="line"><span class="comment"># 2013-01-05 -0.174496 0.810790 0.566061 -0.230608 four</span></span><br></pre></td></tr></table></figure>
<h2 id="isna"><a href="#isna" class="headerlink" title="isna()"></a>isna()</h2><p>判断数据是否缺失</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pd.isna(df2[<span class="string">"one"</span>])</span><br><span class="line">df.isna()</span><br></pre></td></tr></table></figure>
<p>注意：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="literal">None</span> == <span class="literal">None</span></span><br><span class="line"><span class="comment"># True</span></span><br><span class="line"></span><br><span class="line">np.nan == np.nan</span><br><span class="line"><span class="comment"># False</span></span><br><span class="line"><span class="comment"># 因此，不能使用 == np.nan来判断数据是否缺失</span></span><br></pre></td></tr></table></figure></p>
<p>对于<code>datetime64</code>类型数据，<code>NaT</code>表示缺失值。</p>
<h2 id="ix"><a href="#ix" class="headerlink" title=".ix[]"></a>.ix[]</h2><p>通过<strong>行号</strong> / <strong>行标签</strong> 索引行数据。是<code>.loc[]</code>和<code>.iloc[]</code>的结合。</p>
<ul>
<li>已弃用</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df3.ix[<span class="number">3</span>]</span><br><span class="line"><span class="comment">#Name      Jack</span></span><br><span class="line"><span class="comment">#Gender       M</span></span><br><span class="line"><span class="comment">#Age         17</span></span><br><span class="line"><span class="comment">#Grade       76</span></span><br><span class="line"><span class="comment">#Name: four, dtype: object</span></span><br><span class="line"></span><br><span class="line">df3.ix[<span class="string">'four'</span>]</span><br><span class="line"><span class="comment">#Name      Jack</span></span><br><span class="line"><span class="comment">#Gender       M</span></span><br><span class="line"><span class="comment">#Age         17</span></span><br><span class="line"><span class="comment">#Grade       76</span></span><br><span class="line"><span class="comment">#Name: four, dtype: object</span></span><br></pre></td></tr></table></figure>
<h2 id="loc"><a href="#loc" class="headerlink" title=".loc[]"></a>.loc[]</h2><p>通过<strong>行标签</strong>索引行数据。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df3.loc[<span class="string">'three'</span>]  <span class="comment">## 获取行标签为“three”的行数据</span></span><br><span class="line"><span class="comment">#Name      Mike</span></span><br><span class="line"><span class="comment">#Gender       M</span></span><br><span class="line"><span class="comment">#Age         21</span></span><br><span class="line"><span class="comment">#Grade       87</span></span><br><span class="line"><span class="comment">#Name: three, dtype: object</span></span><br><span class="line"></span><br><span class="line">df3.loc[[<span class="string">'two'</span>, <span class="string">'four'</span>]]  <span class="comment">## 获取行标签为“two”和“four”的行数据</span></span><br></pre></td></tr></table></figure></p>
<p>获取多行数据：</p>
<ul>
<li>使用行标签索引时，两边都是闭的<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 获取多行数据：</span></span><br><span class="line">df3.loc[<span class="string">'one'</span>:<span class="string">'three'</span>]</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>获取单列数据：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df3.loc[:, <span class="string">'Age'</span>]  <span class="comment">##不显示列名</span></span><br><span class="line">df3.loc[:, [<span class="string">'Age'</span>]]  <span class="comment">##显示列名</span></span><br></pre></td></tr></table></figure></p>
<p>获取多列数据：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df3.loc[:, <span class="string">'Age'</span>:]</span><br></pre></td></tr></table></figure></p>
<h2 id="merge"><a href="#merge" class="headerlink" title="merge()"></a>merge()</h2><p>合并DataFrame</p>
<ul>
<li>交集、并集</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 取交集</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">df1 = pd.DataFrame([[<span class="string">'a'</span>, <span class="number">10</span>, <span class="string">'男'</span>], [<span class="string">'b'</span>, <span class="number">11</span>, <span class="string">'女'</span>], [<span class="string">'a'</span>, <span class="number">10</span>, <span class="string">'女'</span>]], </span><br><span class="line">                   columns=[<span class="string">'name'</span>, <span class="string">'age'</span>, <span class="string">'gender'</span>])</span><br><span class="line">df1</span><br><span class="line"><span class="comment"># name age gender</span></span><br><span class="line"><span class="comment"># 0 a 10 男</span></span><br><span class="line"><span class="comment"># 1 b 11 女</span></span><br><span class="line"><span class="comment"># 2 a 10 女</span></span><br><span class="line"></span><br><span class="line">df2 = pd.DataFrame([[<span class="string">'a'</span>, <span class="number">10</span>, <span class="string">'男'</span>]],</span><br><span class="line">                   columns=[<span class="string">'name'</span>, <span class="string">'age'</span>, <span class="string">'gender'</span>])</span><br><span class="line">df2</span><br><span class="line"><span class="comment"># name age gender</span></span><br><span class="line"><span class="comment"># 0 a 10 男</span></span><br><span class="line"></span><br><span class="line">df = pd.merge(df1, df2, on=[<span class="string">'name'</span>, <span class="string">'age'</span>])</span><br><span class="line">df</span><br><span class="line"><span class="comment">#  name age gender_x gender_y</span></span><br><span class="line"><span class="comment"># 0 a 10 男 男</span></span><br><span class="line"><span class="comment"># 1 a 10 女 男</span></span><br><span class="line"></span><br><span class="line">df = pd.merge(df1, df2, on=[<span class="string">'name'</span>, <span class="string">'age'</span>, <span class="string">'gender'</span>])</span><br><span class="line">df</span><br><span class="line"><span class="comment">#  name age gender</span></span><br><span class="line"><span class="comment"># 0 a 10 男</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 取并集</span></span><br><span class="line">df = pd.merge(df1, df2, on=[<span class="string">'name'</span>, <span class="string">'age'</span>, <span class="string">'gender'</span>], how=<span class="string">'outer'</span>)</span><br><span class="line">df</span><br><span class="line"><span class="comment">#  name age gender</span></span><br><span class="line"><span class="comment"># 0 a 10 男</span></span><br><span class="line"><span class="comment"># 1 b 11 女</span></span><br><span class="line"><span class="comment"># 2 a 10 女</span></span><br></pre></td></tr></table></figure>
<h2 id="notna"><a href="#notna" class="headerlink" title="notna()"></a>notna()</h2><p>判断数据是否非缺失</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df1[<span class="string">'B'</span>].notna()</span><br></pre></td></tr></table></figure>
<h2 id="sort-index"><a href="#sort-index" class="headerlink" title="sort_index()"></a>sort_index()</h2><p>按照轴排序</p>
<ul>
<li>默认升序</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.sort_index(axis=<span class="number">1</span>, ascending=<span class="literal">False</span>) <span class="comment">## 按列名降序排序</span></span><br><span class="line"></span><br><span class="line">df.sort_index(by=<span class="string">'B'</span>) <span class="comment">## 按照B列的值升序排序</span></span><br></pre></td></tr></table></figure>
<h2 id="T"><a href="#T" class="headerlink" title=".T"></a>.T</h2><p>转置</p>
<h2 id="tail"><a href="#tail" class="headerlink" title="tail()"></a>tail()</h2><p>预览最后5行</p>
<ul>
<li>可以通过赋值<code>df.tail(n)</code>中n来调整预览的行数</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.tail()</span><br></pre></td></tr></table></figure>
<h2 id="to-numpy"><a href="#to-numpy" class="headerlink" title="to_numpy()"></a>to_numpy()</h2><p>将DataFrame转换为数组Array</p>
<ul>
<li>输出不包括DataFrame的列名、索引</li>
</ul>
<h2 id="values-1"><a href="#values-1" class="headerlink" title=".values"></a>.values</h2><p>查看DataFrame的数据<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df3.values</span><br><span class="line"><span class="comment">#array([['Jane', 'F', 16.0, 91, 2, True],</span></span><br><span class="line"><span class="comment">#       ['John', 'M', nan, 93, 3, False],</span></span><br><span class="line"><span class="comment">#       ['Mike', 'M', 25.0, 89, 1, False],</span></span><br><span class="line"><span class="comment">#       ['Jack', 'M', nan, 79, 2, False]], dtype=object)</span></span><br></pre></td></tr></table></figure></p>
<h2 id="修改列值"><a href="#修改列值" class="headerlink" title="修改列值"></a>修改列值</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df3[<span class="string">'Grade'</span>] = (<span class="number">91</span>, <span class="number">93</span>, <span class="number">89</span>, <span class="number">79</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">## 结合Series精准插补数据/修改列值：</span></span><br><span class="line">df3[<span class="string">'Age'</span>] = pd.Series([<span class="number">16</span>, <span class="number">25</span>], index=[<span class="string">'one'</span>, <span class="string">'three'</span>])</span><br></pre></td></tr></table></figure>
<h2 id="添加新列"><a href="#添加新列" class="headerlink" title="添加新列"></a>添加新列</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 直接为不存在的列赋值：</span></span><br><span class="line">df3[<span class="string">'Class'</span>] = (<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">df3[<span class="string">'Female'</span>] = df3.Gender==<span class="string">'F'</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="factorize"><a href="#factorize" class="headerlink" title="factorize()"></a>factorize()</h1><p>将类别变量/特征数字化。</p>
<p>Pandas中的<code>factorize()</code>可以将类别型变量转换为一组数字，相同的类别对应相同的数字。<br><code>factorize()</code>函数的返回值是一个元组（tuple），元组中含有两个元素:</p>
<ul>
<li>第一个元素是array，其中的元素是类别型变量对应的数字；</li>
<li>第二个元素是Index，是所有没有重复的类别元素。</li>
</ul>
<p>以iris鸢尾花数据为例：</p>
<ul>
<li>iris数据下载网址：<a href="https://archive.ics.uci.edu/ml/datasets/Iris" target="_blank" rel="noopener">https://archive.ics.uci.edu/ml/datasets/Iris</a></li>
<li>鸢尾花数据共有3个品种</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> urllib.request <span class="keyword">import</span> urlretrieve</span><br><span class="line"></span><br><span class="line">urlretrieve(url=<span class="string">"https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data"</span>,</span><br><span class="line">           filename=<span class="string">"iris.data"</span>)</span><br><span class="line">iris = pd.read_csv(<span class="string">"iris.data"</span>, header=<span class="literal">None</span>)</span><br><span class="line">iris.columns = [<span class="string">'Sepal_length'</span>, <span class="string">'Sepal_width'</span>, <span class="string">'Petal_length'</span>, <span class="string">'Petal_width'</span>, <span class="string">'class'</span>]</span><br><span class="line">iris.head()</span><br><span class="line"><span class="comment">#   Sepal_length  Sepal_width  Petal_length  Petal_width        class</span></span><br><span class="line"><span class="comment">#0           5.1          3.5           1.4          0.2  Iris-setosa</span></span><br><span class="line"><span class="comment">#1           4.9          3.0           1.4          0.2  Iris-setosa</span></span><br><span class="line"><span class="comment">#2           4.7          3.2           1.3          0.2  Iris-setosa</span></span><br><span class="line"><span class="comment">#3           4.6          3.1           1.5          0.2  Iris-setosa</span></span><br><span class="line"><span class="comment">#4           5.0          3.6           1.4          0.2  Iris-setosa</span></span><br><span class="line"></span><br><span class="line">iris[<span class="string">'class'</span>] = pd.factorize(iris[<span class="string">'class'</span>])[<span class="number">0</span>]</span><br><span class="line">iris.head()</span><br><span class="line"><span class="comment">#   Sepal_length  Sepal_width  Petal_length  Petal_width  class</span></span><br><span class="line"><span class="comment">#0           5.1          3.5           1.4          0.2      0</span></span><br><span class="line"><span class="comment">#1           4.9          3.0           1.4          0.2      0</span></span><br><span class="line"><span class="comment">#2           4.7          3.2           1.3          0.2      0</span></span><br><span class="line"><span class="comment">#3           4.6          3.1           1.5          0.2      0</span></span><br><span class="line"><span class="comment">#4           5.0          3.6           1.4          0.2      0</span></span><br><span class="line"></span><br><span class="line">iris.tail()</span><br><span class="line"><span class="comment">#     Sepal_length  Sepal_width  Petal_length  Petal_width  class</span></span><br><span class="line"><span class="comment">#145           6.7          3.0           5.2          2.3      2</span></span><br><span class="line"><span class="comment">#146           6.3          2.5           5.0          1.9      2</span></span><br><span class="line"><span class="comment">#147           6.5          3.0           5.2          2.0      2</span></span><br><span class="line"><span class="comment">#148           6.2          3.4           5.4          2.3      2</span></span><br><span class="line"><span class="comment">#149           5.9          3.0           5.1          1.8      2</span></span><br></pre></td></tr></table></figure>
<h1 id="get-dummies"><a href="#get-dummies" class="headerlink" title="get_dummies()"></a>get_dummies()</h1><p>将类别变量one-hot encoding</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">df = pd.DataFrame(&#123;<span class="string">'A'</span>: [<span class="string">'F'</span>, <span class="string">'F'</span>, <span class="string">'M'</span>, <span class="string">'F'</span>, <span class="string">'M'</span>],</span><br><span class="line">                   <span class="string">'B'</span>: [<span class="string">'one'</span>, <span class="string">'three'</span>, <span class="string">'two'</span>, np.nan, <span class="string">'one'</span>],</span><br><span class="line">                   <span class="string">'C'</span>: [<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'1'</span>, <span class="string">'3'</span>, <span class="string">'2'</span>]&#125;)</span><br><span class="line">print(df)</span><br><span class="line"><span class="comment">#   A      B  C</span></span><br><span class="line"><span class="comment">#0  F    one  1</span></span><br><span class="line"><span class="comment">#1  F  three  2</span></span><br><span class="line"><span class="comment">#2  M    two  1</span></span><br><span class="line"><span class="comment">#3  F    NaN  3</span></span><br><span class="line"><span class="comment">#4  M    one  2</span></span><br><span class="line"></span><br><span class="line">print(pd.get_dummies(df))  <span class="comment">## 默认na值不作为一类</span></span><br><span class="line"><span class="comment">#   A_F  A_M  B_one  B_three  B_two  C_1  C_2  C_3</span></span><br><span class="line"><span class="comment">#0    1    0      1        0      0    1    0    0</span></span><br><span class="line"><span class="comment">#1    1    0      0        1      0    0    1    0</span></span><br><span class="line"><span class="comment">#2    0    1      0        0      1    1    0    0</span></span><br><span class="line"><span class="comment">#3    1    0      0        0      0    0    0    1</span></span><br><span class="line"><span class="comment">#4    0    1      1        0      0    0    1    0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 参数prefix指定新列名的前缀</span></span><br><span class="line">print(pd.get_dummies(df, prefix=[<span class="string">'col1'</span>, <span class="string">'col2'</span>, <span class="string">'col3'</span>]))</span><br><span class="line"><span class="comment">#   col1_F  col1_M  col2_one  col2_three  col2_two  col3_1  col3_2  col3_3</span></span><br><span class="line"><span class="comment">#0       1       0         1           0         0       1       0       0</span></span><br><span class="line"><span class="comment">#1       1       0         0           1         0       0       1       0</span></span><br><span class="line"><span class="comment">#2       0       1         0           0         1       1       0       0</span></span><br><span class="line"><span class="comment">#3       1       0         0           0         0       0       0       1</span></span><br><span class="line"><span class="comment">#4       0       1         1           0         0       0       1       0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 参数dummy_na表示是否将na作为单独的一类</span></span><br><span class="line">print(pd.get_dummies(df[<span class="string">'B'</span>], dummy_na=<span class="literal">True</span>))</span><br><span class="line"><span class="comment">#   one  three  two  NaN</span></span><br><span class="line"><span class="comment">#0    1      0    0    0</span></span><br><span class="line"><span class="comment">#1    0      1    0    0</span></span><br><span class="line"><span class="comment">#2    0      0    1    0</span></span><br><span class="line"><span class="comment">#3    0      0    0    1</span></span><br><span class="line"><span class="comment">#4    1      0    0    0</span></span><br></pre></td></tr></table></figure>
<h1 id="isnull"><a href="#isnull" class="headerlink" title="isnull()"></a>isnull()</h1><p>判断目标中是否是缺失值/缺失数据</p>
<ul>
<li>若为缺失数据，则返回True；否则返回False。<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 检查Series中是否存在缺失值/缺失数据（即NaN/NA）</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">dict1 = &#123;<span class="string">'new'</span>:<span class="number">2.3</span>, <span class="string">'old'</span>:<span class="number">3.5</span>, <span class="string">'then'</span>:<span class="number">6.5</span>, <span class="string">'obj'</span>:<span class="number">8.4</span>&#125;</span><br><span class="line">ind1 = [<span class="string">'new'</span>, <span class="string">'after'</span>, <span class="string">'old'</span>, <span class="string">'then'</span>, <span class="string">'obj'</span>, <span class="string">'six'</span>]</span><br><span class="line">s4 = Series(dict1, index=ind1)</span><br><span class="line">pd.isnull(s4)</span><br><span class="line"><span class="comment">#new      False</span></span><br><span class="line"><span class="comment">#after     True</span></span><br><span class="line"><span class="comment">#old      False</span></span><br><span class="line"><span class="comment">#then     False</span></span><br><span class="line"><span class="comment">#obj      False</span></span><br><span class="line"><span class="comment">#six       True</span></span><br><span class="line"><span class="comment">#dtype: bool</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="notnull"><a href="#notnull" class="headerlink" title="notnull()"></a>notnull()</h1><p>判断是否不是缺失数据</p>
<ul>
<li>若为缺失数据，则返回False；否则返回True。</li>
<li>与<code>isnull()</code>结果完全相反。<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">dict1 = &#123;<span class="string">'new'</span>:<span class="number">2.3</span>, <span class="string">'old'</span>:<span class="number">3.5</span>, <span class="string">'then'</span>:<span class="number">6.5</span>, <span class="string">'obj'</span>:<span class="number">8.4</span>&#125;</span><br><span class="line">ind1 = [<span class="string">'new'</span>, <span class="string">'after'</span>, <span class="string">'old'</span>, <span class="string">'then'</span>, <span class="string">'obj'</span>, <span class="string">'six'</span>]</span><br><span class="line">s4 = Series(dict1, index=ind1)</span><br><span class="line">pd.notnull(s4)</span><br><span class="line"><span class="comment">#new       True</span></span><br><span class="line"><span class="comment">#after    False</span></span><br><span class="line"><span class="comment">#old       True</span></span><br><span class="line"><span class="comment">#then      True</span></span><br><span class="line"><span class="comment">#obj       True</span></span><br><span class="line"><span class="comment">#six      False</span></span><br><span class="line"><span class="comment">#dtype: bool</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="qcut"><a href="#qcut" class="headerlink" title="qcut()"></a>qcut()</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">qcut(数据数组, 面元个数)  <span class="comment"># 将数据数组均分；每个面元的数据个数相等</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cat3 = pd.qcut(ages, <span class="number">5</span>)</span><br><span class="line">cat3</span><br><span class="line"><span class="comment"># [(14.999, 23.2], (39.6, 46.8], (14.999, 23.2], (14.999, 23.2], (23.2, 39.6], ..., (46.8, 56.4], (56.4, 86.0], (56.4, 86.0], (56.4, 86.0], (39.6, 46.8]]</span></span><br><span class="line"><span class="comment"># Length: 12</span></span><br><span class="line"><span class="comment"># Categories (5, interval[float64]): [(14.999, 23.2] &lt; (23.2, 39.6] &lt; (39.6, 46.8] &lt; (46.8, 56.4] &lt; (56.4, 86.0]]</span></span><br><span class="line">cat3.value_counts()  <span class="comment"># qcut()会尽可能保证每个面元包含的数据个数相等</span></span><br><span class="line"><span class="comment"># (14.999, 23.2]    3</span></span><br><span class="line"><span class="comment"># (23.2, 39.6]      2</span></span><br><span class="line"><span class="comment"># (39.6, 46.8]      2</span></span><br><span class="line"><span class="comment"># (46.8, 56.4]      2</span></span><br><span class="line"><span class="comment"># (56.4, 86.0]      3</span></span><br><span class="line"><span class="comment"># dtype: int64</span></span><br><span class="line"></span><br><span class="line">cat4 = pd.qcut(ages, <span class="number">3</span>)  <span class="comment"># 将ages均分成3份，每个面元有4个数据</span></span><br><span class="line">cat4</span><br><span class="line"><span class="comment"># [(14.999, 32.0], (32.0, 50.0], (14.999, 32.0], (14.999, 32.0], (14.999, 32.0], ..., (32.0, 50.0], (50.0, 86.0], (50.0, 86.0], (50.0, 86.0], (32.0, 50.0]]</span></span><br><span class="line"><span class="comment"># Length: 12</span></span><br><span class="line"><span class="comment"># Categories (3, interval[float64]): [(14.999, 32.0] &lt; (32.0, 50.0] &lt; (50.0, 86.0]]</span></span><br><span class="line">cat4.value_counts()</span><br><span class="line"><span class="comment"># (14.999, 32.0]    4</span></span><br><span class="line"><span class="comment"># (32.0, 50.0]      4</span></span><br><span class="line"><span class="comment"># (50.0, 86.0]      4</span></span><br><span class="line"><span class="comment"># dtype: int64</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://www.cnblogs.com/RB26DETT/p/11555099.html" target="_blank" rel="noopener">python数据拼接: pd.concat</a></li>
<li><a href="https://github.com/zhouyanasd/or-pandas">【运筹OR帷幄｜数据科学】Pandas实战教程系列电子书</a></li>
</ul>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python | Python 2和Python 3的主要区别</title>
    <url>/python-23%E5%8C%BA%E5%88%AB.html</url>
    <content><![CDATA[<p><center>Python 2 vs Python 3</center><br><a id="more"></a></p>
<h1 id="Python2-vs-Python-3"><a href="#Python2-vs-Python-3" class="headerlink" title="Python2 vs Python 3"></a>Python2 vs Python 3</h1><h2 id="默认编码"><a href="#默认编码" class="headerlink" title="默认编码"></a>默认编码</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">Python 2</th>
<th style="text-align:center">Python 3</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">默认编码</td>
<td style="text-align:center">ASCII</td>
<td style="text-align:center">utf-8</td>
</tr>
</tbody>
</table>
</div>
<h2 id="用户交互"><a href="#用户交互" class="headerlink" title="用户交互"></a>用户交互</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">Python 2</th>
<th style="text-align:center">Python 3</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">用户输入函数</td>
<td style="text-align:center"><code>raw_input()</code></td>
<td style="text-align:center"><code>input()</code></td>
</tr>
</tbody>
</table>
</div>
<h2 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">Python 2</th>
<th style="text-align:center">Python 3</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Unicode默认</td>
<td style="text-align:center">2个字节表示一个字符</td>
<td style="text-align:center">4个字节表示一个字符</td>
</tr>
</tbody>
</table>
</div>
<h2 id="init文件"><a href="#init文件" class="headerlink" title="init文件"></a>init文件</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">Python 2</th>
<th style="text-align:center">Python 3</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">init文件</td>
<td style="text-align:center">新建的包如果没有init文件，不能被调用</td>
<td style="text-align:center">新建的包里面的init文件如果被删除，包照样可以被调用</td>
</tr>
</tbody>
</table>
</div>
<h2 id="range"><a href="#range" class="headerlink" title="range"></a>range</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">Python 2</th>
<th style="text-align:center">Python 3</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>xrange</code></td>
<td style="text-align:center">有<br>返回一个迭代器<br>在每次循环中生成序列的下一个数字</td>
<td style="text-align:center">无</td>
</tr>
<tr>
<td style="text-align:center"><code>range</code></td>
<td style="text-align:center">有<br>返回一个list</td>
<td style="text-align:center">有<br>相当于Python2中的<code>xrange</code></td>
</tr>
</tbody>
</table>
</div>
<h2 id="print函数"><a href="#print函数" class="headerlink" title="print函数"></a>print函数</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">Python 2</th>
<th style="text-align:center">Python 3</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>print</code></td>
<td style="text-align:center">是statement，不需要加括号</td>
<td style="text-align:center">是函数，需要加括号</td>
</tr>
</tbody>
</table>
</div>
<h2 id="整数相除"><a href="#整数相除" class="headerlink" title="整数相除"></a>整数相除</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">Python 2</th>
<th style="text-align:center">Python 3</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>/</code></td>
<td style="text-align:center"><code>3/2</code>是<code>int</code></td>
<td style="text-align:center"><code>3/2</code>是<code>float</code></td>
</tr>
</tbody>
</table>
</div>
<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">Python 2</th>
<th style="text-align:center">Python 3</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>as</code>关键字</td>
<td style="text-align:center">不用使用</td>
<td style="text-align:center">必须使用</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## Python 2</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="number">1</span>/<span class="number">0</span></span><br><span class="line"><span class="keyword">except</span> ZeroDivisionError, e:</span><br><span class="line">    <span class="keyword">print</span> str(e)</span><br><span class="line"></span><br><span class="line"><span class="comment">## Python 3</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="number">1</span>/<span class="number">0</span></span><br><span class="line"><span class="keyword">except</span> ZeroDivisionError <span class="keyword">as</span> e:</span><br><span class="line">    print(str(e))</span><br></pre></td></tr></table></figure>
<h2 id="map函数"><a href="#map函数" class="headerlink" title="map函数"></a>map函数</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">Python 2</th>
<th style="text-align:center">Python 3</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>map()</code></td>
<td style="text-align:center">返回list</td>
<td style="text-align:center">返回迭代器（iterator）</td>
</tr>
</tbody>
</table>
</div>
<h2 id="不等运算符"><a href="#不等运算符" class="headerlink" title="不等运算符"></a>不等运算符</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">Python 2</th>
<th style="text-align:center">Python 3</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">不等运算符</td>
<td style="text-align:center"><code>&lt;&gt;</code> 或 <code>!=</code></td>
<td style="text-align:center">只有<code>!=</code></td>
</tr>
</tbody>
</table>
</div>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">Python 2</th>
<th style="text-align:center">Python 3</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">数据类型</td>
<td style="text-align:center">有 <code>long</code>类型</td>
<td style="text-align:center">没有<code>long</code>类型，只有<code>int</code></td>
</tr>
</tbody>
</table>
</div>
<h2 id="has-key方法"><a href="#has-key方法" class="headerlink" title="has_key方法"></a>has_key方法</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">Python 2</th>
<th style="text-align:center">Python 3</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">字典</td>
<td style="text-align:center">字典支持has_key方法</td>
<td style="text-align:center">字典不支持has_key方法</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">person = &#123;<span class="string">"age"</span>: <span class="number">35</span>, <span class="string">"name"</span>: <span class="string">"Wang Wu"</span>&#125;</span><br><span class="line"><span class="comment">## Python 2</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">"person has key \"age\":"</span>, person.has_key(<span class="string">"age"</span>)</span><br><span class="line"><span class="comment"># person has key "age": True</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">"person has key \"age\":"</span>, <span class="string">"age"</span> <span class="keyword">in</span> person</span><br><span class="line"><span class="comment"># person has key "age": True</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## Python 3</span></span><br><span class="line">print(<span class="string">"person has key \"age\":"</span>, <span class="string">"age"</span> <span class="keyword">in</span> person)</span><br><span class="line"><span class="comment"># person has key "age": True</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Machine Learning | 分类模型评估</title>
    <url>/Machine-Learning-%E5%88%86%E7%B1%BB%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0.html</url>
    <content><![CDATA[<p><center>Classification</center><br><a id="more"></a></p>
<h1 id="分类方法"><a href="#分类方法" class="headerlink" title="分类方法"></a>分类方法</h1><p>从使用的技术上来分，可以把分类方法归结为四种类型：</p>
<ol>
<li>基于距离的分类方法<ul>
<li>最邻近方法</li>
</ul>
</li>
<li>决策树分类方法<ul>
<li>ID3</li>
<li>C4.5</li>
<li>VFDT</li>
</ul>
</li>
<li>贝叶斯方法<ul>
<li>朴素贝叶斯方法</li>
<li>EM算法</li>
</ul>
</li>
<li>规则归纳方法<ul>
<li>AQ算法</li>
<li>CN2算法</li>
<li>FOIL算法</li>
</ul>
</li>
</ol>
<h1 id="分类评估"><a href="#分类评估" class="headerlink" title="分类评估"></a>分类评估</h1><p>针对一个二分类问题，将实例分为正例（Positive）和负例（Negative）两种。</p>
<ul>
<li><strong>TP</strong>（True Positive）：真正例；是正类且被预测为正类的实例</li>
<li><strong>FP</strong>（False Positive）：假正例；是负类但被预测为正类的实例</li>
<li><strong>TN</strong>（True Negative）：真负例；是负类且被预测为负类的实例</li>
<li><strong>FN</strong>（False Negative）：假负例；是正类但被预测为负类的实例</li>
</ul>
<h2 id="精确率-Precision"><a href="#精确率-Precision" class="headerlink" title="精确率 Precision"></a>精确率 Precision</h2><p><strong>精确率</strong>（Precision）or <strong>查准率</strong>：</p>
<script type="math/tex; mode=display">Precision=\frac{TP}{TP+FP}</script><blockquote>
<p>如：警察抓小偷，描述警察抓的人中有多少个是小偷的标准即Precision</p>
</blockquote>
<p>计算Precision的加权均值（<strong>AP</strong>，average precision）：</p>
<script type="math/tex; mode=display">AP=\sum_i(R_i-R_{i-1})P_i</script><p>其中，$R_i$、$P_i$分别是第$i$个阈值对应的Recall和Precision。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sklearn.metrics.average_precision_score</span><br></pre></td></tr></table></figure>
<h2 id="召回率-Recall"><a href="#召回率-Recall" class="headerlink" title="召回率 Recall"></a>召回率 Recall</h2><p><strong>召回率</strong>（Recall）or <strong>查全率</strong>：</p>
<script type="math/tex; mode=display">Recall=\frac{TP}{TP+FN}</script><script type="math/tex; mode=display">召回率=\frac{提取出的正确信息条数}{样本中相关的信息条数}</script><blockquote>
<p>如：警察抓小偷，描述有多少比例的小偷被警察抓了的标准即Recall</p>
</blockquote>
<p><meta name="referrer" content="no-referrer"><br><img src="/Machine-Learning-%E5%88%86%E7%B1%BB%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0/pic5.png" class title="维基百科-Precision and Recall"></p>
<h2 id="灵敏度-Sensitivity"><a href="#灵敏度-Sensitivity" class="headerlink" title="灵敏度 Sensitivity"></a>灵敏度 Sensitivity</h2><p><strong>灵敏度</strong>（Sensitivity）or <strong>真正例率</strong>（TPR，True Positive Rate）</p>
<script type="math/tex; mode=display">Sensitivity=TPR=Recall=\frac{TP}{TP+FN}</script><ul>
<li>召回率的同义词</li>
</ul>
<p><strong>1-灵敏度</strong> or <strong>假负例率</strong>（FNR，False Negative Rate）or <strong>漏诊率</strong></p>
<script type="math/tex; mode=display">FNR=1-Sensitivity=\frac{FN}{TP+FN}</script><h2 id="特异度-Specificity"><a href="#特异度-Specificity" class="headerlink" title="特异度 Specificity"></a>特异度 Specificity</h2><p><strong>特异度</strong>（Specificity）or <strong>真负例率</strong>（TNR，True Negative Rate）</p>
<script type="math/tex; mode=display">Specificity=TNR=\frac{TN}{TN+FP}</script><p><strong>1-特异度</strong> or <strong>假正例率</strong>（FPR，False Positive Rate）or <strong>误诊率</strong></p>
<script type="math/tex; mode=display">FPR=1-Specificity=\frac{FP}{TN+FP}</script><h2 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h2><script type="math/tex; mode=display">Error=\frac{FP+FN}{TP+FP+TN+FN}</script><h2 id="准确率-Accuracy"><a href="#准确率-Accuracy" class="headerlink" title="准确率 Accuracy"></a>准确率 Accuracy</h2><p><strong>准确率</strong>（Accuracy，ACC）：分类正确的样本占总样本个数的比例，即</p>
<script type="math/tex; mode=display">ACC=\frac{TP+TN}{TP+FP+TN+FN}</script><p>准确率存在局限性<br><div class="note default">
            <p>例子：Hulu的奢侈品广告主们希望把广告定向投放给奢侈品用户。Hulu通过第三方的数据管理平台（Data Management Platform，DMP）拿到了一部分奢侈品用户的数据，并以此为训练集和测试集，训练和测试奢侈品用户的分类模型。该模型的分类准确率超过了95%，但在实际广告投放过程中，该模型还是把大部分广告投给了非奢侈品用户。</p><p>这是因为：当负样本在训练集中占99%时，分类器把所有样本都预测为负样本也可以获得99%的准确率。所以，当不同类别的样本比例非常不均衡时，占比大的类别往往成为影响准确率的最主要因素。</p><p>奢侈品用户只占Hulu全体用户的一小部分，虽然模型的整体分类准确率高，但是不代表对奢侈品用户的分类准确率也高。在线上投放时，仅对模型判定的“奢侈品用户”进行投放，因此，对“奢侈品用户”判定的准确率不够高的问题就很明显了。</p><p>可使用更为有效的<strong>平均准确率</strong>（每个类别下的样本准确率的算数平均）作为模型评估的指标。</p><script type="math/tex; mode=display">平均准确率=\frac{1}{2}\left(\frac{TP}{TP+FN}+\frac{TN}{TN+FP}\right)</script><p>但是，有时候，即使分类评估指标选择正确，仍可能会存在模型过拟合或欠拟合、训练集和测试集划分不合理、线下评估与线上测试的样本分布存在差异等问题。</p>
          </div></p>
<h2 id="LR"><a href="#LR" class="headerlink" title="LR+"></a>LR+</h2><p>正例似然比（Positive Likelihood Ratio，LR+）=真正例率 / 假正例率=灵敏度 / （1-特异度）</p>
<script type="math/tex; mode=display">LR+=\frac{TPR}{FPR}</script><h2 id="LR-1"><a href="#LR-1" class="headerlink" title="LR-"></a>LR-</h2><p>负例似然比（Negative Likelihood Ratio，LR-）=假负例率 / 真负例率=（1-灵敏度）/ 特异度</p>
<script type="math/tex; mode=display">LR-=\frac{FNR}{TNR}</script><h2 id="DOR"><a href="#DOR" class="headerlink" title="DOR"></a>DOR</h2><p>DOR（Diagnostic Odds Ratio，诊断优势比）：</p>
<script type="math/tex; mode=display">DOR=\frac{LR+}{LR-}</script><h2 id="Youden-Index"><a href="#Youden-Index" class="headerlink" title="Youden Index"></a>Youden Index</h2><script type="math/tex; mode=display">Youden指数=灵敏度+特异度-1=真正例率-假正例率</script><h2 id="F1-score"><a href="#F1-score" class="headerlink" title="F1-score"></a>F1-score</h2><p><strong>F1 值</strong>（F1-score）：综合考虑Precision和Recall的度量（metric）</p>
<script type="math/tex; mode=display">F1-score=\frac{2\times Precision\times Recall}{Precision+Recall}</script><ul>
<li><strong>宏平均F1</strong>（macro-averaging）：先对每个类别单独计算F1值，再取这些F1值的算数平均值作为全局指标；宏平均平等对待每一个类别；值受到稀有类别的影响较大</li>
<li><strong>微平均F1</strong>（micro-averaging）：先累加计算各个类别的TP、TN、FP、FN，再由这些值计算F1值；平等考虑样例集中的每一个样例；值受到常见类别的影响较大</li>
<li>在multi-class classification（多分类）的情况下，macro-averaging会比micro-averaging好一些，更能体现在small class（稀有类别）上的表现（performance）</li>
</ul>
<h2 id="ROC"><a href="#ROC" class="headerlink" title="ROC"></a>ROC</h2><p><strong>ROC曲线</strong>（Receiver Operating Characteristic Curve，接收者操作特征曲线）：是反映灵敏性和特异性连续变量的综合指标。</p>
<ul>
<li>横坐标：FPR（预测为正但实际为负的样本占所有负例样本的比例）；即 1-Specificity</li>
<li>纵坐标：TPR（预测为正且实际为正的样本占所有正例样本的比例）；即Sensitivity</li>
<li>ROC曲线用于绘制采用不同分类阈值时的TPR与FPR</li>
<li>阈值最大时，对应坐标点为(0,0)；阈值最小时，对应坐标点为(1,1)</li>
<li>降低分类阈值会导致将更多样本归为正例，从而增加假正例和真正例的个数，TPR和FPR会同时增大</li>
<li>理想目标：TPR=1，FPR=0，即ROC图中的(0,1)点</li>
<li>ROC越靠拢(0,1)点、越偏离45°对角线越好；Sensitivity、Specificity越大，效果越好</li>
<li>为什么使用ROC曲线？<blockquote>
<p>当测试集中的正负样本的分布变化的时候，ROC曲线能够基本保持原貌</p>
</blockquote>
</li>
</ul>
<p><meta name="referrer" content="no-referrer"><br><img src="/Machine-Learning-%E5%88%86%E7%B1%BB%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0/pic3.png" class title="ROC曲线"></p>
<p><meta name="referrer" content="no-referrer"><br><img src="/Machine-Learning-%E5%88%86%E7%B1%BB%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0/pic2.png" class title="ROC曲线上点的解读"></p>
<blockquote>
<p><strong>ROC vs F1-score</strong><br>When you have a data imbalance between positive and negative samples, you should always use F1-score because of ROC averages over all possible thresholds.</p>
</blockquote>
<p><meta name="referrer" content="no-referrer"><br><img src="/Machine-Learning-%E5%88%86%E7%B1%BB%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0/pic1.png" class title="ROC曲线&amp;TP,TN,FP,FN的关系"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 计算ROC</span></span><br><span class="line">sklearn.metrics.roc_curve(y_true, y_score)</span><br></pre></td></tr></table></figure>
<h2 id="AUC"><a href="#AUC" class="headerlink" title="AUC"></a>AUC</h2><p><strong>AUC</strong>（Area Under Curve）：ROC曲线下的面积</p>
<ul>
<li>对所有可能的分类阈值的效果进行综合衡量</li>
<li>一种解读方式：可把AUC看作模型将某个随机正例样本排列在某个随机负例样本之上的概率（AUC值是一个概率值）<blockquote>
<p>AUC代表：随机抽出一个正例、一个负例，用训练得到的分类器对这两个样本进行预测，预测结果为正的概率大于为负的概率的概率</p>
<script type="math/tex; mode=display">AUC=P\left\{P(Positive)>P(Negative)\right\}</script></blockquote>
</li>
</ul>
<blockquote>
<p>The <strong>AUC value</strong> is equivalent to the probability that a randomly chosen positive example is ranked higher than a randomly chosen negative example.<br>—— Fawcett, 2006</p>
</blockquote>
<ul>
<li>AUC的取值范围为[0,1]；但AUC一般都处于直线y=x的上方，所以AUC的取值范围一般在0.5和1之间<ul>
<li>预测结果100%错误的模型的AUC=0</li>
<li>预测结果100%正确的模型的AUC=1</li>
<li>对应AUC更大的分类器，分类效果更好</li>
</ul>
</li>
<li>AUC的尺度不变：测量预测的排名情况，而不是测量其绝对值</li>
<li>AUC的分类阈值不变：测量模型预测的质量，而不考虑所选的分类阈值</li>
<li>在假负例与假正例的代价存在较大差异的情况下，尽量减少一种类型的分类错误可能至关重要<blockquote>
<p>如：进行垃圾邮件检测时，可能希望优先考虑尽量减少假正例</p>
</blockquote>
</li>
<li>AUC=1，是完美分类器；采用这个预测模型时，存在至少一个阈值能得到完美预测；绝大多数预测的场合，不存在完美分类器</li>
<li>0.5 &lt; AUC &lt;1 ，优于随机猜测；该模型妥善设定阈值的话，能有预测价值</li>
<li>AUC = 0.5，等同于随机猜测；该模型没有预测价值</li>
<li>AUC  &lt; 0.5，比随机猜测还差</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 计算AUC</span></span><br><span class="line">sklearn.metrics.roc_auc_score(y_true, y_score)</span><br></pre></td></tr></table></figure>
<h2 id="PR"><a href="#PR" class="headerlink" title="PR"></a>PR</h2><p><strong>PR</strong>（Precision-Recall）曲线</p>
<ul>
<li>横轴：Recall</li>
<li>纵轴：Precision</li>
<li>不同阈值下的Precision、Recall值</li>
<li>精确率越高，召回率越高，模型和算法就越高效；即，PR曲线越靠近右上越好</li>
</ul>
<p><meta name="referrer" content="no-referrer"><br><img src="/Machine-Learning-%E5%88%86%E7%B1%BB%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0/pic4.png" class title="An Introduction to ROC Analysis"></p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://www.cnblogs.com/pinard/p/5993450.html" target="_blank" rel="noopener">精确率与召回率，RoC曲线与PR曲线</a></li>
<li><a href="https://blog.csdn.net/qq_22238533/article/details/78666436" target="_blank" rel="noopener">AUC的计算方法</a></li>
<li><a href="https://www.lagou.com/lgeduarticle/109119.html" target="_blank" rel="noopener">机器学习之模型评估详解</a></li>
<li><a href="https://blog.csdn.net/weixin_41791402/article/details/102557277" target="_blank" rel="noopener">分类方法归结</a></li>
<li><a href="https://blog.csdn.net/xiaoyu714543065/article/details/8559741" target="_blank" rel="noopener">分类效果评价</a></li>
<li><a href="https://intellipaat.com/community/14889/f1-score-vs-roc-auc" target="_blank" rel="noopener">F1 Score vs ROC AUC</a></li>
<li><a href="https://en.wikipedia.org/wiki/Precision_and_recall" target="_blank" rel="noopener">维基百科-Precision and recall</a></li>
<li><a href="https://wenku.baidu.com/view/a5fa7ae7cd22bcd126fff705cc17552707225e29.html?from=search" target="_blank" rel="noopener">数据挖掘习题</a></li>
<li><a href="https://developers.google.com/machine-learning/crash-course/classification/roc-and-auc" target="_blank" rel="noopener">分类（Classification）：ROC和曲线下面积</a></li>
<li><a href="https://www.zhihu.com/question/30643044" target="_blank" rel="noopener">精确率、召回率、F1 值、ROC、AUC 各自的优缺点是什么？</a></li>
<li><a href="https://www.jianshu.com/p/c61ae11cc5f6" target="_blank" rel="noopener">机器学习之分类性能度量指标 : ROC曲线、AUC值、正确率、召回率</a></li>
<li><a href="https://ccrma.stanford.edu/workshops/mir2009/references/ROCintro.pdf" target="_blank" rel="noopener">An Introduction to ROC Analysis</a></li>
<li><a href="https://scikit-learn.org/stable/modules/generated/sklearn.metrics.roc_auc_score.html" target="_blank" rel="noopener">sklearn.metrics.roc_auc_score</a></li>
<li><a href="https://scikit-learn.org/stable/modules/generated/sklearn.metrics.average_precision_score.html#sklearn.metrics.average_precision_score" target="_blank" rel="noopener">sklearn.metrics.average_precision_score</a></li>
<li><a href="https://scikit-learn.org/stable/modules/generated/sklearn.metrics.roc_curve.html#sklearn.metrics.roc_curve" target="_blank" rel="noopener">sklearn.metrics.roc_curve</a></li>
<li><a href="https://book.douban.com/subject/30285146/" target="_blank" rel="noopener">《百面机器学习》</a></li>
</ul>
<h1 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h1><ul>
<li><a href="/Machine-Learning-%E8%81%9A%E7%B1%BB%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0.html" title="Machine Learning | 聚类模型评估">Machine Learning | 聚类模型评估</a></li>
<li><a href="/Machine-Learning-%E6%B1%87%E6%80%BB.html" title="Machine Learning | 汇总">Machine Learning | 汇总</a></li>
</ul>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>机器学习</tag>
        <tag>分类</tag>
      </tags>
  </entry>
  <entry>
    <title>大数据</title>
    <url>/%E6%95%B0%E6%8D%AE-%E5%A4%A7%E6%95%B0%E6%8D%AE.html</url>
    <content><![CDATA[<p><center>Big Data</center><br><a id="more"></a></p>
<h1 id="Big-Data"><a href="#Big-Data" class="headerlink" title="Big Data"></a>Big Data</h1><ul>
<li>What is Big Data?</li>
<li><p>你对大数据的理解是什么？</p>
</li>
<li><p>A Definition given by <a href="https://www.oracle.com/big-data/what-is-big-data.html" target="_blank" rel="noopener">Oracle</a>:</p>
<blockquote>
<p>Put simply, big data is larger, more complex data sets, especially from new data sources. These data sets are so voluminous that traditional data processing software just can’t manage them. But these massive <strong>volumes</strong> of data can be used to address business problems you wouldn’t have been able to tackle before.</p>
</blockquote>
</li>
<li><p>A Definition given by <a href="https://baike.baidu.com/item/%E5%A4%A7%E6%95%B0%E6%8D%AE/1356941?forcehttps=1%3Ffr%3Dkg_hanyu" target="_blank" rel="noopener">Baidu</a></p>
<blockquote>
<p>无法在一定时间范围内用常规软件工具进行捕捉、管理和处理的数据集合，是需要新处理模式才能具有更强的决策力、洞察发现力和流程优化能力的海量、高增长率和多样化的信息资产</p>
</blockquote>
</li>
<li><p>A Definition given by <a href="https://searchdatamanagement.techtarget.com/definition/big-data" target="_blank" rel="noopener">SearchDataManagement</a></p>
<blockquote>
<p>Big data is a combination of structured, semistructured and unstructured data collected by organizations that can be mined for information and used in machine learing projects, predictive modeling and other advanced analytics applications.</p>
</blockquote>
</li>
</ul>
<h2 id="5V特征"><a href="#5V特征" class="headerlink" title="5V特征"></a>5V特征</h2><ul>
<li>Volume 大量</li>
<li>Velocity 高速</li>
<li>Variety 多样</li>
<li>Value低价值密度</li>
<li>Veracity 真实性</li>
</ul>
<blockquote>
<p>Oracle / SAS - 3Vs:</p>
<ul>
<li>Volume</li>
<li>Velocity</li>
<li>Variety</li>
</ul>
</blockquote>
<h3 id="Volume"><a href="#Volume" class="headerlink" title="Volume"></a>Volume</h3><p>数据量大，包括采集、存储和计算的量都非常大</p>
<h3 id="Velocity"><a href="#Velocity" class="headerlink" title="Velocity"></a>Velocity</h3><p>数据增长速度快，处理速度也快，时效性要求高</p>
<h3 id="Variety"><a href="#Variety" class="headerlink" title="Variety"></a>Variety</h3><p>数据的种类和来源多样化</p>
<ul>
<li>包括结构化、半结构化和非结构化数据</li>
<li>如网络日志、音频、视频、图片、地理位置信息等</li>
<li>多类型的数据对数据的处理能力提出了更高的要求</li>
</ul>
<h3 id="Value"><a href="#Value" class="headerlink" title="Value"></a>Value</h3><p>数据的价值密度相对较低</p>
<ul>
<li>如何结合业务逻辑并通过强大的机器学习算法来挖掘数据价值——大数据时代最需要解决的问题</li>
</ul>
<blockquote>
<p>big data must have value. </p>
</blockquote>
<h3 id="Veracity"><a href="#Veracity" class="headerlink" title="Veracity"></a>Veracity</h3><p>数据的准确性和可信赖度——即数据的质量</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://baike.baidu.com/item/%E5%A4%A7%E6%95%B0%E6%8D%AE/1356941?forcehttps=1%3Ffr%3Dkg_hanyu" target="_blank" rel="noopener">百度汉语：大数据</a></li>
<li><a href="https://blog.csdn.net/qq_40402685/article/details/86750861" target="_blank" rel="noopener">浅谈对大数据的理解</a></li>
<li><a href="https://blog.csdn.net/arsaycode/article/details/70847184" target="_blank" rel="noopener">大数据5V特点 —- 5Vs of Big Data</a></li>
<li><a href="https://www.ibm.com/blogs/watson-health/the-5-vs-of-big-data/" target="_blank" rel="noopener">IBM-The 5 V’s of big data</a></li>
</ul>
]]></content>
      <categories>
        <category>Data Scientist</category>
      </categories>
  </entry>
  <entry>
    <title>Machine Learning | 集成方法</title>
    <url>/%E7%AE%97%E6%B3%95-%E9%9B%86%E6%88%90%E6%96%B9%E6%B3%95.html</url>
    <content><![CDATA[<p><center>Ensemble Method</center><br><a id="more"></a></p>
<h1 id="集成方法"><a href="#集成方法" class="headerlink" title="集成方法"></a>集成方法</h1><ul>
<li>Bagging</li>
<li>Boosting</li>
<li>Stacking</li>
</ul>
<p>集成学习（Ensemble Learning），基于多个学习算法的集成，提升预测结果。</p>
<ul>
<li>多个弱学习器通过一定的策略结合成一个强学习器。</li>
<li>集成学习不是一个算法，是算法的门类。</li>
</ul>
<blockquote>
<p>The process by which multiple models are <u>strategically generated</u> and <u>combined</u> in order to <u>better</u> solve a particular Machine Learning problem.<br>清华大学-数据挖掘：集成学习</p>
</blockquote>
<p>如何创建多个、不同的基础分类器/基础学习器/基分类器：</p>
<ul>
<li>使用不同的学习算法：DT，SVM，NN，KNN，…</li>
<li>使用不同的训练过程：<ul>
<li>不同的参数</li>
<li>不同的训练集：bootstrap samples（有放回采样）</li>
<li>不同的特征集</li>
</ul>
</li>
</ul>
<h2 id="基学习器"><a href="#基学习器" class="headerlink" title="基学习器"></a>基学习器</h2><p>基分类器：</p>
<ul>
<li>基分类器不需要很强；强分类器可能会有很多问题</li>
<li>基分类器需要有较大的差异，差异性过小的分类器被集成没有意义</li>
<li>基分类器的精度最好略高于0.5（正确分类率）<br>随着集成规模的增加，低于0.5的弱分类器会导致集成分类准确率不断下降，而高于0.5则会提升模型的准确率（趋于1）</li>
</ul>
<h2 id="结合策略"><a href="#结合策略" class="headerlink" title="结合策略"></a>结合策略</h2><p>怎么将基分类器的结果结合起来？</p>
<ol>
<li>平均法</li>
<li>投票法</li>
<li>学习法</li>
</ol>
<h3 id="平均法"><a href="#平均法" class="headerlink" title="平均法"></a>平均法</h3><p>平均法（Averaging）：取所有基础学习器（基分类器）的输出结果的平均作为最终决策</p>
<script type="math/tex; mode=display">H(x)=\sum_{i=1}^T\omega_ih_i(x)</script><p>其中</p>
<ul>
<li>共$T$个基础学习器（弱学习器）$\{h_1,\cdots,h_T\}$</li>
<li>对任意一个样本$x$，$h_i(x)$为第$i$个学习器的分类结果</li>
<li>$\omega_i$为基础学习器$h_i$的权重，$\omega_i\geq0,\ \sum_{i=1}^T\omega_i=1$</li>
<li>预测类别为$\{c_1,c_2,\cdots,c_K\}$</li>
</ul>
<p>最简单的平均是\textbf{算数平均}：</p>
<script type="math/tex; mode=display">\omega_i=\frac{1}{T}</script><script type="math/tex; mode=display">H(x)=\frac{1}{T}\sum_{i=1}^Th_i(x)</script><h3 id="投票法"><a href="#投票法" class="headerlink" title="投票法"></a>投票法</h3><p>投票法（Voting）：使用所有基础学习器（基分类器）结果的凸组合作为最终决策</p>
<ul>
<li><strong>相对多数投票法</strong>（Plurality Voting）：少数服从多数；分类问题中，对样本的预测结果中票数最多的那个类别作为最终的分类类别；若获得最高票的类别不止一个，则随机选择其中一个作为最终类别</li>
<li><strong>绝对多数投票法</strong>（Majority Voting）：票过半数；多个基分类器对某一类别的预测结果大于总投票结果的一半，则预测结果为该类别，否则拒绝预测<blockquote>
<p>如：</p>
</blockquote>
</li>
<li><strong>加权投票法</strong>（Weighted Majority Voting）：类似加权平均法；给予每个基分类器的预测结果权重，计算各类别的加权票数和，票数最高的那个类别作为最终预测类别<blockquote>
<p>如：AdaBoost</p>
</blockquote>
</li>
</ul>
<h3 id="学习法"><a href="#学习法" class="headerlink" title="学习法"></a>学习法</h3><ul>
<li>General Combiner：Stacking</li>
<li>Piecewise Combiner：RegionBoost</li>
</ul>
<h2 id="类别"><a href="#类别" class="headerlink" title="类别"></a>类别</h2><p>集成学习的集成方法按基分类器连接方式分为两种：</p>
<ol>
<li><strong>序列集成</strong>（sequential ensemble）：基分类器按照顺序生成；基分类器之间存在依赖关系；通过对前面训练中错误——Boosting</li>
<li><strong>并行集成</strong>（parallel ensemble）：基学习器可以并行生成；利用基学习器之间的独立性，通过平均可以显著降低分类错误——Bagging</li>
</ol>
<h3 id="Bagging"><a href="#Bagging" class="headerlink" title="Bagging"></a>Bagging</h3><ul>
<li>
</li>
</ul>
<p>Bagging（Bootstrap Aggregating）：对样本进行Bootstrap随机采样（Bootstrap sampling），得到k个训练集，对每个训练集训练一个弱学习器（弱分类器），得到k个分类器，通过一定的结合策略，得到一个强学习器。</p>
<h3 id="Boosting"><a href="#Boosting" class="headerlink" title="Boosting"></a>Boosting</h3><ul>
<li>AdaBoost</li>
<li>XGBoost</li>
<li>LightGBM</li>
<li>CatBoost</li>
<li>Boosting Tree（提升树）</li>
</ul>
<p>Boosting算法（提升方法），是一类可以用来减小监督式学习中偏差的机器学习算法；将弱分类器提升为强分类器。</p>
<ul>
<li>Boosting会减小在上一轮训练正确的样本的权重，增大错误样本的权重</li>
</ul>
<h4 id="AdaBoost"><a href="#AdaBoost" class="headerlink" title="AdaBoost"></a>AdaBoost</h4><ul>
<li>每次使用的是全部样本</li>
<li>每轮训练改变样本的权重</li>
<li>下一轮训练的目标是找到一个函数来拟合上一轮训练后的残差</li>
<li>当残差足够小或达到设置的最大迭代次数时停止训练</li>
</ul>
<h3 id="Stacking"><a href="#Stacking" class="headerlink" title="Stacking"></a>Stacking</h3><ul>
<li>是Bagging的升级版</li>
<li>改进预测</li>
<li>结合策略是“学习法”</li>
<li>将训练集弱学习器（基学习器）的学习结果作为输入，将训练集的输出作为输出，重新训练一个学习器来得到最终决策</li>
<li>这里称弱学习器为初级学习器，最后用于结合的学习器称为次级学习器</li>
<li>对于测试集，先用初级学习器预测一次，得到次级学习器的输入（Input），再用次级学习器预测一次，得到最终的预测结果</li>
</ul>
<h2 id="Bagging-vs-Boosting"><a href="#Bagging-vs-Boosting" class="headerlink" title="Bagging vs Boosting"></a>Bagging vs Boosting</h2><h3 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h3><ul>
<li>都是模型融合的方法</li>
<li>可以将弱分类器融合形成一个强分类器，融合之后的分类效果比最好的弱分类器效果更好</li>
</ul>
<h3 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h3><div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: center;">
      <th></th>
      <th>Bagging</th>
      <th>Boosting</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="2">样本选择</th>
      <td>训练集是在原始数据集中有放回抽取的</td>
      <td>每一轮的训练集不变</td>
    </tr>
    <tr>
      <td>从原始数据集中选出的各轮训练集之间相互独立</td>
      <td>每轮的训练集中每个样例在分类器中的权重发生变化;权值根据上一轮的分类结果进行调整</td>
    </tr>
    <tr>
      <th>样例权重</th>
      <td>每个样例的权重相等</td>
      <td>根据错误率不断调整样例的权重;<br>错误率越大则权重越大</td>
    </tr>
    <tr>
      <th>基分类器</th>
      <td>所有基分类器权重相等</td>
      <td>分类误差小的基分类器权重更大</td>
    </tr>
    <tr>
      <th>并行计算</th>
      <td>基分类器可以并行生成</td>
      <td>基分类器只能序列生成</td>
    </tr>
    <tr>
      <th>bias-variance</th>
      <td>减少variance</td>
      <td>减少bias</td>
    </tr>
  </tbody>
</table>
</div>

<div class="note success">
            <p>为什么“Bagging是减少Variance，而Boosting是减少Bias”？</p>
          </div>
<div class="note default">
            <ol><li><strong>Bagging</strong>对样本重采样（bootstrap），对每一轮采样得到的子样本集训练一个模型，最后对模型的结果取均值。<ul><li>由于子样本集的相似性及基分类器都是同种模型，所以各模型有近似相等的Bias和Variance</li><li>因为$E\left[\frac{\sum_iX_i}{n}\right]=E(X_i)$，所以bagging后的Bias和单个基分类器接近，所以不能“显著降低Bias”</li><li>若各基分类器独立，则有<script type="math/tex; mode=display">Var\large(\frac{\sum_iX_i}{n}\large)=\frac{Var(X_i)}{n}</script>因此可以“显著降低Variance”</li><li>若各基分类器完全相同，则<script type="math/tex; mode=display">Var\left(\frac{\sum_iX_i}{n}\right)=Var(X_i)</script>此时不会“降低Variance”</li><li>Bagging得到的各基分类器具有一定的相关性，但又不完全相同，所以可以“一定程度地降低Variance”</li></ul></li><li><strong>Boosting</strong>使用forward-stagewise（贪心法）最小化损失函数$L(y,\sum_ia_if_i(x))$<ul><li>在第$n$步，求解新的子模型$f(x)$及步长$a$来最小化$L(y, f_{n-1}(x)+af(x))$($f_{n-1}(x)$是前$n-1$步得到的子模型的和)</li><li>Boosting是在“Sequential”地最小化损失函数，其Bias逐步下降</li><li>Boosting的基分类器之间是强相关的，所以并不能“显著降低Variance”</li></ul></li></ol>
          </div>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://blog.csdn.net/u013709270/article/details/72553282" target="_blank" rel="noopener">机器学习中Bagging和Boosting的区别</a></li>
<li><a href="https://www.zhihu.com/question/26760839/answer/40337791" target="_blank" rel="noopener">为什么说bagging是减少variance，而boosting是减少bias?</a></li>
</ul>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Machine Learning | 生成式模型 &amp; 判别式模型</title>
    <url>/%E7%94%9F%E6%88%90%E5%BC%8F%E6%A8%A1%E5%9E%8B-%E5%88%A4%E5%88%AB%E5%BC%8F%E6%A8%A1%E5%9E%8B.html</url>
    <content><![CDATA[<p><center>Generative Model & Discriminative Model</center><br><a id="more"></a></p>
<h1 id="生成式模型"><a href="#生成式模型" class="headerlink" title="生成式模型"></a>生成式模型</h1><p>生成式模型（Generative Model）：生成数据的分布的模型（有多个模型，将测试用例分别放进各个模型，最后比较其结果，选择最优的作为label）</p>
<ul>
<li>会对$x$和$y$的联合分布$p(x,y)$进行建模，然后通过来求得$p(y|x)$，最后选取使得$p(y|x)$最大的$y_i$，即<br>\begin{equation}<br>\begin{aligned}<br>y^*&amp;=\arg{\max_{y_i}p(y_i|x)}\\<br>&amp;=\arg{\max_{y_i}\frac{p(x|y_i)p(y_i)}{p(x)}}\\<br>&amp;=\arg{\max_{y_i}p(x|y_i)p(y_i)}\\<br>&amp;=\arg{\max_{y_i}p(x,y_i)}<br>\end{aligned}<br>\end{equation}</li>
</ul>
<p>生成式模型有：</p>
<ul>
<li><a href="/%E7%AE%97%E6%B3%95-%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF.html" title="朴素贝叶斯(Naive Bayes)">朴素贝叶斯(Naive Bayes)</a></li>
<li><a href="/%E7%AE%97%E6%B3%95-KNN.html" title="k邻近（KNN）">k邻近（KNN）</a></li>
<li>高斯混合模型（GMM）</li>
<li><a href="/%E7%AE%97%E6%B3%95-HMM.html" title="隐马尔可夫模型（HMM）">隐马尔可夫模型（HMM）</a></li>
<li>贝叶斯网络</li>
<li>Sigmoid Belief Networks</li>
<li>马尔可夫随机场（Markov Random Fields）</li>
<li>深度信念网络（DBN）</li>
<li>迪利克雷分布模型（LDA，Latent Dirichlet Allocation）</li>
</ul>
<h1 id="判别式模型"><a href="#判别式模型" class="headerlink" title="判别式模型"></a>判别式模型</h1><p>判别式模型（Discriminative Model）：判别数据输出量的模型（只有一个模型，将模型应用到测试用例中，生成label）</p>
<ul>
<li>会直接对$p(y|x)$进行建模</li>
</ul>
<p>判别式模型有：</p>
<ul>
<li><a href="/%E7%AE%97%E6%B3%95-%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92.html" title="线性回归（Linear Regression）">线性回归（Linear Regression）</a></li>
<li>线性判别分析</li>
<li><a href="/%E7%AE%97%E6%B3%95-LogisticRegression.html" title="逻辑回归（Logistic Regression）">逻辑回归（Logistic Regression）</a></li>
<li><a href="/%E7%AE%97%E6%B3%95-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C.html" title="神经网络（NN）">神经网络（NN）</a></li>
<li><a href="/%E7%AE%97%E6%B3%95-SVM.html" title="支持向量机（SVM）">支持向量机（SVM）</a></li>
<li>高斯过程（Gaussian Process）</li>
<li>条件随机场（CRF）</li>
<li>CART（Classification and Regression Tree）</li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://blog.csdn.net/u013630349/article/details/47146425" target="_blank" rel="noopener">机器学习 之 生成式模型 VS 判别式模型</a></li>
<li><a href="https://www.cnblogs.com/kemaswill/p/3427422.html" target="_blank" rel="noopener">判别式模型 vs. 生成式模型</a></li>
</ul>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>机器学习</tag>
        <tag>分类</tag>
        <tag>有监督学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Machine Learning | Naive Bayes</title>
    <url>/%E7%AE%97%E6%B3%95-%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF.html</url>
    <content><![CDATA[<p><center>朴素贝叶斯</center><br><a id="more"></a></p>
<p>Naive Bayes</p>
<h1 id="朴素贝叶斯"><a href="#朴素贝叶斯" class="headerlink" title="朴素贝叶斯"></a>朴素贝叶斯</h1><ul>
<li>分类方法</li>
<li><a href="/%E7%94%9F%E6%88%90%E5%BC%8F%E6%A8%A1%E5%9E%8B-%E5%88%A4%E5%88%AB%E5%BC%8F%E6%A8%A1%E5%9E%8B.html" title="生成式模型">生成式模型</a>
</li>
</ul>
<blockquote>
<p>贝叶斯学派的思想可概括为：</p>
<script type="math/tex; mode=display">先验概率+数据=后验概率</script><p>——刘建平Pinard</p>
</blockquote>
<h2 id="贝叶斯公式"><a href="#贝叶斯公式" class="headerlink" title="贝叶斯公式"></a>贝叶斯公式</h2><ul>
<li><strong>条件概率</strong>公式<script type="math/tex; mode=display">P(X|Y)=\frac{P(X,Y)}{P(Y)}=\frac{P(Y|X)P(X)}{P(Y)}</script><script type="math/tex; mode=display">P(Y|X)=\frac{P(X,Y)}{P(X)}=\frac{P(X|Y)P(Y)}{P(X)}</script></li>
<li><strong>全概率</strong>公式<script type="math/tex; mode=display">P(X)=\sum_{k}P(X|Y=Y_k)P(Y_k)</script>其中$\sum_{k}P(Y_k)=1$。</li>
<li><strong>贝叶斯公式</strong><script type="math/tex; mode=display">P(Y_k|X)=\frac{P(X|Y_k)P(Y_k)}{\sum_{k}P(X|Y=Y_k)P(Y_k)}</script></li>
</ul>
<h2 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h2><p>考虑</p>
<ul>
<li>$n$个样本，每个样本有$p$个特征<script type="math/tex; mode=display">x_i=(x_{i1},\cdots, x_{ip})^T</script>$i=1,\cdots,n$</li>
<li>有$K$个类别$C=\{C_1,\cdots,C_K\}$</li>
<li>每个样本的类别标签为$y_i \in \{C_1,\cdots,C_K\}$</li>
</ul>
<p>从样本数据可以学习到朴素贝叶斯的先验分布$(k=1,\cdots,K)$</p>
<script type="math/tex; mode=display">P(Y=C_k)</script><p>从而学习到条件概率分布</p>
<script type="math/tex; mode=display">P(X=x|Y=C_k)=P(X_1=x_1,\cdots,X_p=x_p|Y=C_k)</script><p>接着用贝叶斯公式可以得到$X$和$Y$的联合分布$P(X,Y)$<br>\begin{equation}<br>  \begin{aligned}<br>P(X,Y=C_k)&amp;=P(Y=C_k)P(X=x|Y=C_k)\\<br>&amp;= P(Y=C_k)P(X_1=x_1,\cdots,X_p=x_p|Y=C_k)<br>  \end{aligned}<br>\end{equation}</p>
<p>由极大似然法可得$P(Y=C_k)$为类别$C_k$在训练集样本中出现的频数，即</p>
<script type="math/tex; mode=display">P(Y=C_k)=\sum_{i=1}^n\frac{1}{n}I\left\{y_i=C_k\right\}</script><p>其中</p>
<script type="math/tex; mode=display">I\left\{y_i=C_k\right\}=\left\{
\begin{array}{ll}
  1 & \mbox{如果}y_i=C_k\\
  0 & \mbox{如果}y_i\neq C_k
\end{array}
\right.</script><p>为了降低$P(X_1=x_1,\cdots,X_p=x_p|Y=C_k)$的求解难度，朴素贝叶斯方法<u>假设$X$的$p$个维度之间相互独立</u>，则有<br>\begin{equation}<br>  \begin{aligned}<br>&amp;P(X_1=x_1,\cdots,X_p=x_p|Y=C_k)\\<br>=&amp;P(X_1=x_1|Y=C_k)P(X_2=x_2|Y=C_k)\cdots P(X_p=x_p|Y=C_k)<br>  \end{aligned}<br>\end{equation}</p>
<h3 id="基本假设"><a href="#基本假设" class="headerlink" title="基本假设"></a>基本假设</h3><ul>
<li>所有的$x_i$对于给定条件$y$是相互独立的<br>$i=1,\cdots,p.$<ul>
<li>不是所有$x_i$相互独立，是$x_i|y$相互独立</li>
</ul>
</li>
</ul>
<p>相关问题</p>
<ul>
<li><a href="https://www.nowcoder.com/test/question/done?tid=33437220&amp;qid=304794#summary" target="_blank" rel="noopener">如果在模型训练过程中，由于失误操作导致训练数据中两个维度重复表示</a>，则模型效果精度降低</li>
</ul>
<h3 id="连续型特征"><a href="#连续型特征" class="headerlink" title="连续型特征"></a>连续型特征</h3><p>当特征属性是<u>连续型</u>时，通常假设其服从<u>高斯分布</u>（即正态分布）</p>
<script type="math/tex; mode=display">g(x;\mu,\sigma)=\frac{1}{\sqrt{2\pi\sigma}}exp\{-\frac{(x-\mu)^2}{2\sigma^2}\}</script><p>则有</p>
<script type="math/tex; mode=display">P(X_j=x_j|y_i)=g(x_j;\mu_{y_i},\sigma_{y_i})</script><h3 id="Laplace校准"><a href="#Laplace校准" class="headerlink" title="Laplace校准"></a>Laplace校准</h3><p>Laplace校准 / 拉普拉斯平滑（Laplace Smoothing）：<br>可能会存在某个特征项划分没有出现的情况，即$P(x_j|y_i)=0$，这会导致分类器的质量降低——可使用<strong>Laplace校准</strong>改善</p>
<p>假设随机特征$z$的可能取值有$\{1,\cdots,k\}$，使用$\Phi_i=P(z=i)$参数化其分布。对于$n$个独立样本（观测集合）$\{z^{(1)},\cdots,z^{(n)}\}$，参数$\Phi_j$的极大似然估计为</p>
<script type="math/tex; mode=display">\phi_j=\frac{\sum_{i=1}^n\mathbb{1}\{z^{(i)}=j\}}{n}</script><p>使用Laplace平滑进行修正：</p>
<script type="math/tex; mode=display">\phi_j=\frac{\sum_{i=1}^n\mathbb{1}\{z^{(i)}=j\}+1}{n+k}</script><ul>
<li>分子加1<ul>
<li>保证了$\Phi_j\neq0$对所有的$\Phi_j$都成立</li>
</ul>
</li>
<li>分母加$k$（随机变量$z$能取到的最大值）<ul>
<li>保证了$\sum_{j=1}^k\Phi_j=1$仍然成立</li>
</ul>
</li>
</ul>
<h3 id="预测"><a href="#预测" class="headerlink" title="预测"></a>预测</h3><p>对于新的样本$x{0}=(x_1^0,\cdots,x_p^0)^T$，如何预测其所属的类别？</p>
<blockquote>
<p>根据<strong>最大后验概率</strong>来判断分类</p>
</blockquote>
<ul>
<li>计算所有$K$个条件概率$P(Y=C_k|X=x^0)$</li>
<li>$x^0$属于条件概率最大的那个类别</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>发源于古典数学理论，有稳定的分类效率</li>
<li>对小规模数据的表现很好</li>
<li>能够处理过分类问题</li>
<li>对缺失数据不太敏感</li>
<li>算法简单</li>
<li>常用于文本分类</li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>朴素贝叶斯模型在给定输出类别的情况下假设各特征之间相互独立，但实际应用中该假设往往不成立<ul>
<li>特征数量较多或特征之间的相关性较大时，分类效果较差</li>
<li>特征的相关性较小时，分两类效果较为良好</li>
</ul>
</li>
<li>需要知道先验概率——先验概率一般基于假设<ul>
<li>可能会因为先验模型假设不当，导致预测效果不佳</li>
</ul>
</li>
<li>对输入数据的表达形式很敏感（？）</li>
</ul>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><ul>
<li><a href="https://www.ruanyifeng.com/blog/2013/12/naive_bayes_classifier.html" target="_blank" rel="noopener">朴素贝叶斯分类器的应用</a><ul>
<li>病人分类</li>
<li>性别分类</li>
</ul>
</li>
<li><a href="https://www.cnblogs.com/leoo2sk/archive/2010/09/17/1829190.html" target="_blank" rel="noopener">算法杂货铺——分类算法之朴素贝叶斯分类(Naive Bayesian classification)</a><ul>
<li>检测SNS社区中不真实账号</li>
</ul>
</li>
<li><a href="https://zyzypeter.github.io/2017/07/22/machine-learning-ch5-Naive-Bayes/" target="_blank" rel="noopener">机器学习 第五章 朴素贝叶斯算法(Naive Bayes) 拉普拉斯平滑(Laplace smoothing) 文本分类的事件模型</a><ul>
<li>文本分类问题</li>
</ul>
</li>
<li><a href="https://wizardforcel.gitbooks.io/dm-algo-top10/content/naive-bayes.html" target="_blank" rel="noopener">朴素贝叶斯分类器</a><ul>
<li>按照某人是否要打网球来划分天气</li>
</ul>
</li>
</ul>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><ul>
<li>对朴素贝叶斯的理解：<br>朴素贝叶斯是在已知一些先验概率的情况下，由果索因的一种方法</li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://www.cnblogs.com/pinard/p/6069267.html" target="_blank" rel="noopener">朴素贝叶斯算法原理小结</a></li>
<li><a href="https://www.cnblogs.com/leoo2sk/archive/2010/09/17/1829190.html" target="_blank" rel="noopener">算法杂货铺——分类算法之朴素贝叶斯分类(Naive Bayesian classification)</a></li>
<li><a href="https://zyzypeter.github.io/2017/07/22/machine-learning-ch5-Naive-Bayes/" target="_blank" rel="noopener">机器学习 第五章 朴素贝叶斯算法(Naive Bayes) 拉普拉斯平滑(Laplace smoothing) 文本分类的事件模型</a></li>
</ul>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>机器学习</tag>
        <tag>分类</tag>
        <tag>有监督学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Machine Learning | 聚类模型评估</title>
    <url>/Machine-Learning-%E8%81%9A%E7%B1%BB%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0.html</url>
    <content><![CDATA[<p><center>Clustering</center><br><a id="more"></a></p>
<p><strong>模型评估/评价</strong>：对于已经建立的一个或多个模型，根据模型的类别，选择不同的指标评价其性能优劣的过程。</p>
<h1 id="聚类评估"><a href="#聚类评估" class="headerlink" title="聚类评估"></a>聚类评估</h1><p>关于聚类分析，往往是希望聚类结果中，组内（同类别）的相似性（稠密程度）越大、组间（不同类别）的相似性（离散程度）越小。</p>
<p>聚类模型的评估指标/方法：</p>
<ul>
<li>ARI评价法（兰德系数）</li>
<li>AMI评价法（互信息）</li>
<li>V-measure评分</li>
<li>FMI评价法</li>
<li>轮廓系数</li>
<li>Calinski-Harabasz分数</li>
<li>……</li>
</ul>
<h2 id="ARI评价法"><a href="#ARI评价法" class="headerlink" title="ARI评价法"></a>ARI评价法</h2><h3 id="兰德系数RI"><a href="#兰德系数RI" class="headerlink" title="兰德系数RI"></a>兰德系数RI</h3><p><strong>兰德系数/兰德指数</strong>（RI，Rand Index）：用于聚类模型的性能评估。</p>
<ul>
<li>需要真实的类别</li>
<li>最佳值为1</li>
<li>RI的取值范围为 [0,1]；值越大意味着聚类结果与真实情况越吻合</li>
</ul>
<blockquote>
<ul>
<li>样本个数$n$</li>
<li>$n$个样本集合$S=\{x_1,\cdots,x_n\}$</li>
<li>样本集合的真实划分$U=\{u_1,\cdots,u_R\}$</li>
<li>样本集合的聚类结果$V=\{v_1,\cdots,v_C\}$</li>
<li>$a$：在$U$中为同一类且在$V$中也为同一类别的数据点对数（即TP）</li>
<li>$b$：在$U$中为同一类但在$V$中却是不同类别的数据点对数（即FN）</li>
<li>$c$：在$U$中不是同一类但在$V$中却是同一类的数据点对数（即FP）</li>
<li>$d$：在$U$中不是同一类且在$V$中也是不同类别的数据点对数（即TN）</li>
</ul>
</blockquote>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">Class\Cluster</th>
<th style="text-align:center">Same Cluster</th>
<th style="text-align:center">Different Cluster</th>
<th style="text-align:center">Sum(U)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Same Class</td>
<td style="text-align:center">a</td>
<td style="text-align:center">b</td>
<td style="text-align:center">a+b</td>
</tr>
<tr>
<td style="text-align:center">Different Class</td>
<td style="text-align:center">c</td>
<td style="text-align:center">d</td>
<td style="text-align:center">c+d</td>
</tr>
<tr>
<td style="text-align:center">Sum(V)</td>
<td style="text-align:center">a+c</td>
<td style="text-align:center">b+d</td>
<td style="text-align:center">a+b+c+d</td>
</tr>
</tbody>
</table>
</div>
<p>则兰德指数为</p>
<script type="math/tex; mode=display">\mathrm{RI}=\frac{a+d}{C_n^2}=\frac{TP+TN}{TP+FP+TN+FN}</script><p>其中，</p>
<script type="math/tex; mode=display">C_n^2=
\left(\begin{array}{c}
n\\
2
\end{array}\right)=\frac{n(n-1)}{2}</script><p>是样本集中能够组成的元素对数。</p>
<h3 id="调整兰德系数ARI"><a href="#调整兰德系数ARI" class="headerlink" title="调整兰德系数ARI"></a>调整兰德系数ARI</h3><p>对于随机聚类结果，RI并不能保证接近零。为了实现“在聚类结果随机产生的情况下，指标应该接近零”，有人提出了<strong>调整兰德系数</strong>（ARI，Adjusted Rand Index），具有更高的区分度</p>
<ul>
<li>ARI的取值范围为 [-1,1] ；值越大意味着聚类结果与真实情况越吻合</li>
<li>ARI实际是RI去均值归一化</li>
<li>从广义的角度来看，ARI衡量的是两个数据分布的吻合程度（相似度）</li>
</ul>
<script type="math/tex; mode=display">\mathrm{ARI}=\frac{\mathrm{RI}-E(\mathrm{RI})}{\max{(\mathrm{RI})}-E(\mathrm{RI})}</script><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">Class\Cluster</th>
<th style="text-align:center">$v_1$</th>
<th style="text-align:center">$v_2$</th>
<th style="text-align:center">$\cdots$</th>
<th style="text-align:center">$v_C$</th>
<th style="text-align:center">SUM</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">$u_1$</td>
<td style="text-align:center">$n_{11}$</td>
<td style="text-align:center">$n_{12}$</td>
<td style="text-align:center">$\cdots$</td>
<td style="text-align:center">$n_{1C}$</td>
<td style="text-align:center">$n_{1.}$</td>
</tr>
<tr>
<td style="text-align:center">$u_2$</td>
<td style="text-align:center">$n_{21}$</td>
<td style="text-align:center">$n_{22}$</td>
<td style="text-align:center">$\cdots$</td>
<td style="text-align:center">$n_{2C}$</td>
<td style="text-align:center">$n_{2.}$</td>
</tr>
<tr>
<td style="text-align:center">$\cdots$</td>
<td style="text-align:center">$\cdots$</td>
<td style="text-align:center">$\cdots$</td>
<td style="text-align:center">$\cdots$</td>
<td style="text-align:center">$\cdots$</td>
<td style="text-align:center">$\cdots$</td>
</tr>
<tr>
<td style="text-align:center">$u_R$</td>
<td style="text-align:center">$n_{R1}$</td>
<td style="text-align:center">$n_{R2}$</td>
<td style="text-align:center">$\cdots$</td>
<td style="text-align:center">$n_{RC}$</td>
<td style="text-align:center">$n_{R.}$</td>
</tr>
<tr>
<td style="text-align:center">SUM</td>
<td style="text-align:center">$n_{.1}$</td>
<td style="text-align:center">$n_{.2}$</td>
<td style="text-align:center">$\cdots$</td>
<td style="text-align:center">$n_{. C}$</td>
<td style="text-align:center">$n_{..}=n$</td>
</tr>
</tbody>
</table>
</div>
<p>RI中的$a+d$可表示为</p>
<script type="math/tex; mode=display">\sum_{i,j}\left(\begin{array}{c}
n_{ij}\\
2
\end{array}\right)</script><p>且</p>
<script type="math/tex; mode=display">E(\mathrm{RI})=E(\sum_{i,j}\left(\begin{array}{c}
n_{ij}\\
2
\end{array}\right))=\frac{\sum_i\left(\begin{array}{c}
n_{i.}\\
2
\end{array}\right)\sum_j\left(\begin{array}{c}
n_{.j}\\
2
\end{array}\right)
}{
\left(\begin{array}{c}
n\\2
\end{array}\right)
}</script><p>\begin{equation}<br>\max{(\mathrm{RI})}=\frac{1}{2}[\sum_i\left(\begin{array}{c}<br>n_{i.}\\<br>2<br>\end{array}\right)+\sum_j\left(\begin{array}{c}<br>n_{.j}\\<br>2<br>\end{array}\right)]<br>\end{equation}</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Python实现</span></span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> adjust_rand_score</span><br><span class="line"></span><br><span class="line">ari = adjusted_rand_score(labels_true, labels_pred)</span><br><span class="line"><span class="comment"># labels_true：真实的分类标签</span></span><br><span class="line"><span class="comment"># label_pred：模型聚类的结果</span></span><br><span class="line"><span class="comment"># ARI = (RI - Expected_RI) / (max(RI) - Expected_RI)</span></span><br><span class="line"><span class="comment"># adjusted_rand_score(a, b) == adjusted_rand_score(b, a)</span></span><br></pre></td></tr></table></figure>
<h2 id="AMI评价法"><a href="#AMI评价法" class="headerlink" title="AMI评价法"></a>AMI评价法</h2><p><strong>互信息</strong>（MI，Mutual Information）：衡量两个数据分布的吻合程度。</p>
<ul>
<li>需要真实类别</li>
<li>最佳值为1</li>
<li>MI和NMI的取值范围为 [0,1]；AMI的取值范围为 [-1,1]；都是值越大，意味着聚类结果与真实情况越吻合</li>
</ul>
<h3 id="互信息MI"><a href="#互信息MI" class="headerlink" title="互信息MI"></a>互信息MI</h3><p>两个离散随机变量$X$和$Y$的互信息定义为</p>
<script type="math/tex; mode=display">I(X,Y)=\sum_{y\in Y}\sum_{x\in X}p(x,y)\log{\frac{p(x,y)}{p(x)p(y)}}</script><p>其中，$p(x,y)$是$X$和$Y$的联合概率分布函数，$p(x)$、$p(y)$分别是$X$和$Y$的边缘概率分布函数。<br>两个连续随机变量的互信息定义为</p>
<script type="math/tex; mode=display">I(X,Y)=\int_Y\int_Xp(x,y)\log{\frac{p(x,y)}{p(x)p(y)}}\mathrm{d}x\mathrm{d}y</script><p>其中，$p(x,y)$是$X$和$Y$的联合概率密度函数，$p(x)$、$p(y)$分别是$X$和$Y$的边缘概率密度函数。</p>
<ul>
<li>互信息是互信息量$I(x_i,y_j)$在联合概率空间中的统计平均值</li>
<li>（平均）互信息克服了互信息量$I(x_i,y_j)$的随机性，是一个确定的量</li>
<li>互信息是$X$和$Y$的联合分布相对于假定$X$和$Y$独立情况下的联合分布之间的内在依赖性</li>
<li>$I(X,Y)=0$当且仅当$X$和$Y$独立时成立</li>
<li>当$X$和$Y$独立时，$p(x,y)=p(x)p(y)$。因此<script type="math/tex; mode=display">\log{\frac{p(x,y)}{p(x)p(y)}}=\log1=0</script></li>
</ul>
<p>用互信息来评估聚类效果：</p>
<blockquote>
<ul>
<li>样本个数$n$</li>
<li>$n$个样本集合$S=\{x_1,\cdots,x_n\}$</li>
<li>样本集合的真实划分$U=\{u_1,\cdots,u_R\}$</li>
<li>样本集合的聚类结果$V=\{v_1,\cdots,v_C\}$</li>
<li>$P(i)$为$u_i$在$U$中的概率（比率）<script type="math/tex; mode=display">P(i)=\frac{||u_i||}{n}=\frac{n_{i.}}{n}</script></li>
<li>$P^\prime(j)$为$v_j$在$V$中的概率（比率）<script type="math/tex; mode=display">P^\prime(j)=\frac{||v_j||}{n}=\frac{n_{.j}}{n}</script></li>
<li>$U$的熵为<script type="math/tex; mode=display">H(U)=\sum_{i=1}^RP(i)\log{\left(P(i)\right)}</script></li>
<li>$V$的熵为<script type="math/tex; mode=display">H(V)=\sum_{j=1}^CP^\prime(j)\log{\left(P^\prime(j)\right)}</script></li>
</ul>
</blockquote>
<p>$U$和$V$之间的<strong>互信息</strong>（MI）为</p>
<script type="math/tex; mode=display">\mathrm{MI}(U,V)=\sum_{i=1}^R\sum_{j=1}^CP(i,j)\log{\left(\frac{P(i,j)}{P(i)P^\prime(j)}\right)}</script><p>其中$P(i,j)=n_{ij}/n$。</p>
<h3 id="标准化的互信息NMI"><a href="#标准化的互信息NMI" class="headerlink" title="标准化的互信息NMI"></a>标准化的互信息NMI</h3><p><strong>标准化后的互信息</strong>（NMI，Normalized Mutual Information）为</p>
<script type="math/tex; mode=display">\mathrm{NMI}(U,V)=\frac{\mathrm{MI}(U,V)}{\sqrt{H(U)H(V)}}</script><h3 id="调整互信息AMI"><a href="#调整互信息AMI" class="headerlink" title="调整互信息AMI"></a>调整互信息AMI</h3><p><strong>调整互信息</strong>（AMI，Adjusted Mutual Information）为</p>
<script type="math/tex; mode=display">\mathrm{AMI}=\frac{\mathrm{MI}-E[\mathrm{MI}]}{\max{\left(H(U),H(V)\right)}-E[\mathrm{MI}]}</script><p>\begin{equation}<br>  \begin{aligned}<br>E[\mathrm{MI}(U,V)]=&amp;\sum_{i=1}^R\sum_{j=1}^C\sum_{n_{ij}=(n_{i.}+n_{.j}-n)^+}^{\min{(n_{i.},n_{.j})}}\frac{n_{ij}}{n}<br>\log{\left(\frac{n\cdot n_{ij}}{n_{i.}n_{.j}}\right)}\times\\<br>&amp;\frac{n_{i.}!n_{.j}(n-n_{i.})!(n-n_{.j})!}{n!n_{ij}!(n_{i.}-n_{ij})!(n_{.j-n_{ij}})!(n-n_{i.}-n_{.j}+n_{ij})!}<br>  \end{aligned}<br>\end{equation}</p>
<ul>
<li>$(n_{i.}+n_{.j}-n)^+=\max{\{1, n_{i.}+n_{.j}-n\}}$</li>
<li>$n_{i.}=\sum_{j=1}^Cn_{ij}$</li>
<li>$n_{.j}=\sum_{i=1}^Rn_{ij}$</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Python实现</span></span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> adjusted_mutual_info_score</span><br><span class="line"></span><br><span class="line"><span class="comment">## AMI</span></span><br><span class="line">ami = adjusted_mutual_info_score(labels_true, labels_pred)</span><br><span class="line"><span class="comment"># labels_true：真实的分类标签</span></span><br><span class="line"><span class="comment"># label_pred：模型聚类的结果</span></span><br><span class="line"><span class="comment"># Python的sklearn中的AMI的公式为</span></span><br><span class="line"><span class="comment"># AMI(U,V)=[MI(U,V) - E(MI(U,V))] / [avg(H(U),H(V)) - E(MI(U,V))]</span></span><br><span class="line"><span class="comment"># 其中用的是avg而不是max</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## NMI</span></span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> normalized_mutual_info_score</span><br><span class="line"></span><br><span class="line">nmi = normalized_mutual_info_score(labels_true, labels_pred)</span><br></pre></td></tr></table></figure>
<h2 id="V-measure评价法"><a href="#V-measure评价法" class="headerlink" title="V-measure评价法"></a>V-measure评价法</h2><p>V-measure评价法：同质性（Homogeneity）和完整性（Completeness）的调和平均值。</p>
<ul>
<li>需要真实值</li>
<li>最佳值为1</li>
<li>对簇结构不作假设，可以比较两种聚类算法的结果（比如k均值算法和谱聚类算法）</li>
<li>随机聚类的V-measure不会为零</li>
<li>当样本数较大（&gt;1000） 或 聚类数较小（&lt;10）时，可以忽略“V-measure不为零”的问题；当样本数较小或聚类数较大时，使用AMI或ARI会更可靠</li>
</ul>
<h3 id="同质性"><a href="#同质性" class="headerlink" title="同质性"></a>同质性</h3><p>同质性（Homogeneity）：每个簇(cluster)只包含单个类成员</p>
<ul>
<li>在一个簇内包含的类别越少，则聚类效果越好</li>
<li>取值范围为 [0,1]<script type="math/tex; mode=display">h=1-\frac{H(U|V)}{H(U)}</script>其中<script type="math/tex; mode=display">H(U|V)=-\sum_{i=1}^R\sum_{j=1}^C\frac{n_{ij}}{n}\log{\left(\frac{n_{ij}}{n_{.j}}\right)}</script><script type="math/tex; mode=display">H(U)=-\sum_{i=1}^R\frac{n_{i.}}{n}\log{\left(\frac{n_{i.}}{n}\right)}</script></li>
</ul>
<h3 id="完整性"><a href="#完整性" class="headerlink" title="完整性"></a>完整性</h3><p>完整性（Completeness）：给定类的所有成员分配给同一簇类</p>
<script type="math/tex; mode=display">c=1-\frac{H(V|U)}{H(V)}</script><p>其中</p>
<script type="math/tex; mode=display">H(V|U)=-\sum_{i=1}^R\sum_{j=1}^C\frac{n_{ij}}{n}\log{\left(\frac{n_{ij}}{n_{i.}}\right)}</script><script type="math/tex; mode=display">H(V)=-\sum_{j=1}^C\frac{n_{.j}}{n}\log{\left(\frac{n_{.j}}{n}\right)}</script><h3 id="V-measure"><a href="#V-measure" class="headerlink" title="V-measure"></a>V-measure</h3><p>V-measure是同质性和完整性的调和平均数，公式为</p>
<script type="math/tex; mode=display">V=\frac{2\cdot h\cdot c}{h+c}</script><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Python实现 V-measure</span></span><br><span class="line"><span class="keyword">from</span> sklearn.metrics.cluster <span class="keyword">import</span> v_measure_score</span><br><span class="line"></span><br><span class="line">vs = v_measure_score(labels_true, labels_pred, beta=<span class="number">1.0</span>)</span><br><span class="line"><span class="comment"># labels_true：真实的分类标签</span></span><br><span class="line"><span class="comment"># label_pred：模型聚类的结果</span></span><br><span class="line"><span class="comment"># v = (1 + beta) * homogeneity * completenes</span></span><br><span class="line"><span class="comment">#     / (beta * homogeneity + completeness)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># homogeneity</span></span><br><span class="line"><span class="keyword">from</span> sklearn.metrics.cluster <span class="keyword">import</span> homogeneity_score</span><br><span class="line"></span><br><span class="line">h = homogeneity_score(labels_true, labels_pred)</span><br><span class="line"></span><br><span class="line"><span class="comment"># completeness</span></span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> completeness_score</span><br><span class="line"></span><br><span class="line">c = completeness_score(labels_true, labels_pred)</span><br></pre></td></tr></table></figure>
<h2 id="FMI评价法"><a href="#FMI评价法" class="headerlink" title="FMI评价法"></a>FMI评价法</h2><p><strong>FMI评价法</strong>（Fowlkes-Mallows score FMI）：精确率（Precision）和召回率（Recall）的几何平均值</p>
<ul>
<li>需要真实值</li>
<li>最佳值为1<script type="math/tex; mode=display">\mathrm{FMI}=\sqrt{\mathrm{Precision\cdot Recall}}=\frac{TP}{\sqrt{(TP+FP)(TP+FN)}}</script></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Python实现</span></span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> fowlkes_mallows_score</span><br><span class="line"></span><br><span class="line">fmi = fowlkes_mallows_score(labels_true, labels_pred)</span><br></pre></td></tr></table></figure>
<h2 id="轮廓系数"><a href="#轮廓系数" class="headerlink" title="轮廓系数"></a>轮廓系数</h2><p><strong>轮廓系数</strong>（Silhouette Coefficient）：适用于实际类别信息未知的情况。</p>
<ul>
<li>轮廓系数的取值范围为 [-1,1]</li>
<li>同类别样本距离越相近且不同类别样本距离越远，值越高，表明聚类效果越好</li>
</ul>
<p>计算单个样本的轮廓系数：</p>
<ol>
<li>计算样本$x_i$到同簇其他样本的平均距离$a_i$（$a_i$ 称为样本$x_i$的<strong>簇内不相似度</strong>）。 $a_i$ 越小，说明样本$x_i$ 越应该被聚类到该簇。</li>
<li>计算样本$x_i$到其他簇$C_j$的所有样本的平均距离$b_{ij}$，称为样本$x_i$与簇$C_j$的不相似度。定义样本$x_i$的<strong>簇间不相似度</strong>为$b_i=\min\{b_{ij},j\neq i\}$。$b_i$越大，说明样本$x_i$越不属于其他簇。</li>
<li>根据样本$x_i$的簇内不相似度$a_i$和簇间不相似度$b_i$，定义样本$x_i$的<strong>轮廓系数</strong><script type="math/tex; mode=display">s_i=\frac{b_i-a_i}{\max\{a_i,b_i\}}=\left\{
\begin{array}{ll}
1-\frac{a_i}{b_i} & a_i<b_i\\
0 & a_i=b_i\\
\frac{b_i}{a_i}-1 & a_i>b_i
\end{array}
\right.</script></li>
<li>判断：<ul>
<li>$s_i$接近1，说明样本$x_i$聚类合理</li>
<li>$s_i$接近-1，说明样本$x_i$更应该分类到另外的簇</li>
<li>若$s_i$约等于0，则说明样本$x_i$在两个簇的边界上</li>
</ul>
</li>
</ol>
<p>样本集合的轮廓系数是其所有样本轮廓系数的平均值。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Python</span></span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> silhouette_score</span><br><span class="line"></span><br><span class="line">ss = silhouette_scor(X, labels, metric=<span class="string">'euclidean'</span>)</span><br></pre></td></tr></table></figure>
<h2 id="Calinski-Harabasz指数"><a href="#Calinski-Harabasz指数" class="headerlink" title="Calinski-Harabasz指数"></a>Calinski-Harabasz指数</h2><p><strong>Calinski-Harabasz Index</strong>（Variance Ratio Criterion）：用簇内的稠密程度和簇间的离散程度来评估聚类的效果。</p>
<ul>
<li>主要用于k-均值聚类</li>
<li>类别内部数据的协方差越小越好，类别之间的协方差越大越好，则Calinski-Harabasz分数会越高，表明聚类效果越好</li>
</ul>
<p>\begin{equation}<br>  \begin{aligned}<br>s(k) &amp;= \frac{\mathrm{tr}(B_k)/(k-1)}{\mathrm{tr}(W_k)/(n-k)}= \frac{\mathrm{tr}(B_k)}{\mathrm{tr}(W_k)}\times\frac{n-k}{k-1}\\<br>&amp;= \frac{SS_B/(k-1)}{SS_W/(n-k)}=\frac{SS_B}{SS_W}\times\frac{n-k}{k-1}<br>  \end{aligned}<br>\end{equation}<br>其中</p>
<ul>
<li>$B_k$是类别之间的协方差矩阵（$SS_B$ is the overall between-cluster variance）<script type="math/tex; mode=display">SS_B=TSS-SS_W</script>total sum of squares TSS<script type="math/tex; mode=display">TSS=\sum_{i=1}^n(x_i-\bar{x})^2</script></li>
<li>$W_k$是类别内部数据的协方差矩阵（$SS_W$ is the overall within-cluster variance）</li>
<li>$\mathrm{tr}$ 是矩阵的迹</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Python实现</span></span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> calinski-harabasz_score</span><br><span class="line"></span><br><span class="line">ch = calinski_harabasz_score(X, labels)</span><br></pre></td></tr></table></figure>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU5NzkxODMxOA==&amp;mid=2247486297&amp;idx=1&amp;sn=0a2c549de4e1cfe54694e8364acfceb9&amp;chksm=fe4d5c58c93ad54e7b45b5f644870f011f5e7ffc1d6cb0698f53d15d38e1419bc8cc7c0e1cd7&amp;token=1168016353&amp;lang=zh_CN#rd" target="_blank" rel="noopener">聚类模型评估</a></li>
<li><a href="https://www.lagou.com/lgeduarticle/109119.html" target="_blank" rel="noopener">机器学习之模型评估详解</a></li>
<li><a href="https://zhaokv.com/machine_learning/2016/03/ml-metric.html" target="_blank" rel="noopener">机器学习评价指标大汇总</a></li>
<li><a href="https://en.wikipedia.org/wiki/Rand_index#Adjusted_Rand_index" target="_blank" rel="noopener"> 维基百科-Rand Index</a></li>
<li><a href="https://en.wikipedia.org/wiki/Adjusted_mutual_information" target="_blank" rel="noopener">维基百科-调整互信息</a></li>
<li><a href="https://blog.csdn.net/sinat_30203515/article/details/82634778" target="_blank" rel="noopener">兰德系数、调整兰德系数</a></li>
<li><a href="https://www.wandouip.com/t5i267906/" target="_blank" rel="noopener">方法名称最优值sklearn函数</a></li>
<li><a href="https://www.jianshu.com/p/b9528df2f57a" target="_blank" rel="noopener">聚类模型评估</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1010857" target="_blank" rel="noopener">聚类︱python实现六大分群质量评估指标（兰德系数、互信息、轮廓系数）</a></li>
<li><a href="https://www.cnblogs.com/pinard/p/6169370.html" target="_blank" rel="noopener">用scikit-learn学习K-Means聚类</a></li>
<li><a href="https://ethen8181.github.io/machine-learning/clustering_old/clustering/clustering.html" target="_blank" rel="noopener">Calinski-Harabasz Index and Bootstrap Evaluation with Clustering Methods</a></li>
<li><a href="https://scikit-learn.org/stable/modules/generated/sklearn.metrics.adjusted_mutual_info_score.html" target="_blank" rel="noopener">sklearn.metrics.adjusted_mutual_info_score</a></li>
<li><a href="https://scikit-learn.org/stable/modules/generated/sklearn.metrics.adjusted_rand_score.html" target="_blank" rel="noopener">sklearn.metrics.adjusted_rand_score</a></li>
<li><a href="https://scikit-learn.org/stable/modules/generated/sklearn.metrics.v_measure_score.html" target="_blank" rel="noopener">sklearn.metrics.v_measure_score</a></li>
<li><a href="https://scikit-learn.org/stable/modules/generated/sklearn.metrics.homogeneity_score.html#sklearn.metrics.homogeneity_score" target="_blank" rel="noopener">sklearn.metrics.homogeneity_score</a></li>
<li><a href="https://scikit-learn.org/stable/modules/generated/sklearn.metrics.completeness_score.html" target="_blank" rel="noopener">sklearn.metrics.completeness_score</a></li>
<li><a href="https://scikit-learn.org/stable/modules/generated/sklearn.metrics.silhouette_score.html" target="_blank" rel="noopener">sklearn.metrics.silhouette_score</a></li>
<li><a href="https://scikit-learn.org/stable/modules/generated/sklearn.metrics.calinski_harabasz_score.html" target="_blank" rel="noopener">sklearn.metrics.calinski_harabasz_score</a></li>
</ul>
<h1 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h1><ul>
<li><a href="/Machine-Learning-%E5%88%86%E7%B1%BB%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0.html" title="分类模型评估">分类模型评估</a></li>
</ul>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>机器学习</tag>
        <tag>聚类</tag>
      </tags>
  </entry>
  <entry>
    <title>Python | 命名方式</title>
    <url>/python-%E5%91%BD%E5%90%8D%E6%96%B9%E5%BC%8F.html</url>
    <content><![CDATA[<p><center></center><br><a id="more"></a></p>
<h1 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h1><h2 id="xxx"><a href="#xxx" class="headerlink" title="xxx"></a>xxx</h2><p>公用的命名方法</p>
<ul>
<li>标识符由字母-数字-下划线组成</li>
<li>不能以数字开头</li>
<li>区分大小写</li>
</ul>
<h2 id="xxx-1"><a href="#xxx-1" class="headerlink" title="_xxx"></a>_xxx</h2><ul>
<li>半保护命名（protect）</li>
<li>代表不能直接访问的类属性</li>
<li>只有类对象和子类对象能访问</li>
<li>在模块或类外不可以使用</li>
<li>不能用<code>from module import *</code>导入</li>
<li>为了避免与子类的方法名称冲突</li>
</ul>
<h2 id="xxx-2"><a href="#xxx-2" class="headerlink" title="__xxx"></a>__xxx</h2><ul>
<li>全私有、全保护（private）</li>
<li>类的私有成员</li>
<li>只有类对象自己能访问，而子类对象不能访问</li>
<li>不能用<code>from module import *</code>导入</li>
<li>实际上是 <code>_classname__xxx</code></li>
</ul>
<h2 id="xxx-3"><a href="#xxx-3" class="headerlink" title="xxx"></a><strong>xxx</strong></h2><ul>
<li>内建方法</li>
<li>用户避免使用该定义方法</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://www.runoob.com/python/python-basic-syntax.html" target="_blank" rel="noopener">Python标识符</a></li>
</ul>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python | NumPy</title>
    <url>/python-numpy%E6%A8%A1%E5%9D%97.html</url>
    <content><![CDATA[<p><center></center><br><a id="more"></a></p>
<h1 id="NumPy"><a href="#NumPy" class="headerlink" title="NumPy"></a>NumPy</h1><h2 id="argmax"><a href="#argmax" class="headerlink" title="argmax()"></a>argmax()</h2><p>返回矩阵/数组的最大值的索引</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.arange(<span class="number">12</span>).reshape(<span class="number">3</span>,<span class="number">4</span>)  <span class="comment">## 3行4列</span></span><br><span class="line">a</span><br><span class="line"><span class="comment">#array([[ 0,  1,  2,  3],</span></span><br><span class="line"><span class="comment">#       [ 4,  5,  6,  7],</span></span><br><span class="line"><span class="comment">#       [ 8,  9, 10, 11]])</span></span><br><span class="line"></span><br><span class="line">np.argmax(a)  <span class="comment">## 返回展平的a的最大值的索引</span></span><br><span class="line"><span class="comment"># 11</span></span><br><span class="line"></span><br><span class="line">np.argmax(a, axis=<span class="number">0</span>)  <span class="comment">## 返回每列的最大值的索引</span></span><br><span class="line"><span class="comment"># array([2, 2, 2, 2], dtype=int64)</span></span><br><span class="line"></span><br><span class="line">np.argmax(a, axis=<span class="number">1</span>)  <span class="comment">## 返回每行的最大值的索引</span></span><br><span class="line"><span class="comment"># array([3, 3, 3], dtype=int64)</span></span><br></pre></td></tr></table></figure>
<h2 id="argmin"><a href="#argmin" class="headerlink" title="argmin()"></a>argmin()</h2><p>返回矩阵/数组的最小值的索引<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.arange(<span class="number">12</span>).reshape(<span class="number">3</span>,<span class="number">4</span>)  <span class="comment">## 3行4列</span></span><br><span class="line">a</span><br><span class="line"><span class="comment">#array([[ 0,  1,  2,  3],</span></span><br><span class="line"><span class="comment">#       [ 4,  5,  6,  7],</span></span><br><span class="line"><span class="comment">#       [ 8,  9, 10, 11]])</span></span><br><span class="line"></span><br><span class="line">np.argmin(a, axis=<span class="number">0</span>)  <span class="comment">## 返回每列的最小值的索引</span></span><br><span class="line"><span class="comment"># array([0, 0, 0, 0], dtype=int64)</span></span><br><span class="line"></span><br><span class="line">np.argmin(a, axis=<span class="number">1</span>)  <span class="comment">## 返回每行的最小值的索引</span></span><br><span class="line"><span class="comment"># array([0, 0, 0], dtype=int64)</span></span><br><span class="line"></span><br><span class="line">a[<span class="number">2</span>, <span class="number">2</span>] = <span class="number">2</span></span><br><span class="line">a</span><br><span class="line"><span class="comment">#array([[ 0,  1,  2,  3],</span></span><br><span class="line"><span class="comment">#       [ 4,  5,  6,  7],</span></span><br><span class="line"><span class="comment">#       [ 8,  9,  2, 11]])</span></span><br><span class="line">np.argmin(a, axis=<span class="number">0</span>)  <span class="comment">## 多个最小值，只返回第一个最小值的索引</span></span><br><span class="line"><span class="comment"># array([0, 0, 0, 0], dtype=int64)</span></span><br></pre></td></tr></table></figure></p>
<h2 id="mean"><a href="#mean" class="headerlink" title="mean()"></a>mean()</h2><p>求均值<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">lst = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">np.mean(lst)</span><br><span class="line"><span class="comment"># 4.0</span></span><br></pre></td></tr></table></figure></p>
<h2 id="median"><a href="#median" class="headerlink" title="median()"></a>median()</h2><p>求中位数<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">lst = [<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">8</span>]</span><br><span class="line">np.median(lst)</span><br><span class="line"><span class="comment"># 4.5</span></span><br></pre></td></tr></table></figure></p>
<h2 id="newaxis"><a href="#newaxis" class="headerlink" title="newaxis"></a>newaxis</h2><p>用于扩展数组的维度<br><a href="https://stackoverflow.com/questions/29241056/how-does-numpy-newaxis-work-and-when-to-use-it" target="_blank" rel="noopener">https://stackoverflow.com/questions/29241056/how-does-numpy-newaxis-work-and-when-to-use-it</a><br>中的图片简单易懂</p>
<h2 id="ptp"><a href="#ptp" class="headerlink" title="ptp()"></a>ptp()</h2><p>最大值与最小值的差</p>
<h2 id="reshape"><a href="#reshape" class="headerlink" title="reshape()"></a>reshape()</h2><p>改变矩阵/数组的维数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.arange(<span class="number">12</span>).reshape(<span class="number">3</span>, <span class="number">4</span>)  <span class="comment">## 3行4列</span></span><br><span class="line">a</span><br><span class="line"><span class="comment">#array([[ 0,  1,  2,  3],</span></span><br><span class="line"><span class="comment">#       [ 4,  5,  6,  7],</span></span><br><span class="line"><span class="comment">#       [ 8,  9, 10, 11]])</span></span><br></pre></td></tr></table></figure>
<h3 id="reshape-m-1"><a href="#reshape-m-1" class="headerlink" title="reshape(m,-1)"></a>reshape(m,-1)</h3><p>将数组形状变为m行（列数相应确定）；元素个数必须是m的整数倍</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = np.arange(<span class="number">12</span>).reshape(<span class="number">1</span>, <span class="number">-1</span>)  <span class="comment">## 1行（不指定列数）</span></span><br><span class="line">a</span><br><span class="line"><span class="comment"># array([[ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11]])</span></span><br><span class="line"></span><br><span class="line">a = np.arange(<span class="number">12</span>).reshape(<span class="number">3</span>, <span class="number">-1</span>)  <span class="comment">## 3行</span></span><br><span class="line">a</span><br><span class="line"><span class="comment"># array([[ 0,  1,  2,  3],</span></span><br><span class="line"><span class="comment">#       [ 4,  5,  6,  7],</span></span><br><span class="line"><span class="comment">#       [ 8,  9, 10, 11]])</span></span><br></pre></td></tr></table></figure>
<h3 id="reshape-1-n"><a href="#reshape-1-n" class="headerlink" title="reshape(-1,n)"></a>reshape(-1,n)</h3><p>将数组形状变为n列（行数相应确定）；元素个数必须是n的整数倍<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = np.arange(<span class="number">12</span>).reshape(<span class="number">-1</span>, <span class="number">4</span>)  <span class="comment">## 4列</span></span><br><span class="line">a</span><br><span class="line"><span class="comment"># array([[ 0,  1,  2,  3],</span></span><br><span class="line"><span class="comment">#       [ 4,  5,  6,  7],</span></span><br><span class="line"><span class="comment">#       [ 8,  9, 10, 11]])</span></span><br></pre></td></tr></table></figure></p>
<h2 id="tile"><a href="#tile" class="headerlink" title="tile()"></a>tile()</h2><p><code>tile(A, B)</code>：重复A B次</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">np.tile([<span class="number">1</span>, <span class="number">2</span>],<span class="number">5</span>)<span class="comment">#在列方向上重复[1, 2]5次，默认行1次</span></span><br><span class="line"><span class="comment"># array([1, 2, 1, 2, 1, 2, 1, 2, 1, 2])</span></span><br><span class="line"></span><br><span class="line">np.tile([<span class="number">3</span>, <span class="number">4</span>],(<span class="number">2</span>,<span class="number">1</span>))<span class="comment">#在列方向上重复[3, 4]1次，行2次</span></span><br><span class="line"><span class="comment"># array([[3, 4],</span></span><br><span class="line"><span class="comment">#        [3, 4]])</span></span><br><span class="line"></span><br><span class="line">np.tile([<span class="number">1</span>, <span class="number">2</span>], (<span class="number">3</span>, <span class="number">4</span>)) <span class="comment"># 在行方向上重复[1, 2] 3次、列4次</span></span><br><span class="line"><span class="comment"># array([[1, 2, 1, 2, 1, 2, 1, 2],</span></span><br><span class="line"><span class="comment">#        [1, 2, 1, 2, 1, 2, 1, 2],</span></span><br><span class="line"><span class="comment">#        [1, 2, 1, 2, 1, 2, 1, 2]])</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://blog.csdn.net/weixin_41770169/article/details/80714461" target="_blank" rel="noopener">Numpy.argmin的使用</a></li>
<li><a href="https://blog.csdn.net/ksearch/article/details/21388985" target="_blank" rel="noopener">numpy中的tile函数</a></li>
</ul>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python | Keras</title>
    <url>/python-keras.html</url>
    <content><![CDATA[<p><center></center><br><a id="more"></a></p>
<h1 id="keras"><a href="#keras" class="headerlink" title="keras"></a>keras</h1><p>Keras 是一个用 Python 编写的高级神经网络 API，它能够以 TensorFlow, CNTK, 或者 Theano 作为后端运行。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ul>
<li>使用PyPI安装<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># Anaconda Prompt</span></span></span><br><span class="line">pip install keras</span><br></pre></td></tr></table></figure></li>
<li>使用GitHub源码安装<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/keras-team/keras.git</span><br><span class="line">cd keras</span><br><span class="line">python setup.py install</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h2><ul>
<li>Keras不处理如张量乘积、卷积等低级操作</li>
<li>依赖于一个专门的、优化的张量操作库来完成这个操作，它可以作为 Keras 的「后端引擎」</li>
<li>Keras 有三个后端实现可用: <ul>
<li>TensorFlow 后端</li>
<li>Theano 后端</li>
<li>CNTK 后端</li>
</ul>
</li>
</ul>
<p>配置见：<a href="https://keras.io/zh/backend/" target="_blank" rel="noopener">Keras后端配置</a></p>
<h2 id="Sequential顺序模型"><a href="#Sequential顺序模型" class="headerlink" title="Sequential顺序模型"></a>Sequential顺序模型</h2><ul>
<li>由多个网络层线性堆叠</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> keras.models <span class="keyword">import</span> Sequential</span><br><span class="line"></span><br><span class="line">model = Sequential()</span><br></pre></td></tr></table></figure>
<h3 id="堆叠"><a href="#堆叠" class="headerlink" title="堆叠"></a>堆叠</h3><p>可以使用<code>.add()</code>来堆叠模型：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> keras.models <span class="keyword">import</span> Sequential</span><br><span class="line"><span class="keyword">from</span> keras.layers <span class="keyword">import</span> Dense</span><br><span class="line"></span><br><span class="line">model.add(Dense(units=<span class="number">64</span>, activation=<span class="string">'relu'</span>, input_dim=<span class="number">100</span>))</span><br><span class="line">model.add(Dense(units=<span class="number">10</span>, activation=<span class="string">'softmax'</span>))</span><br></pre></td></tr></table></figure></p>
<p>模型需要知道它所期望的输入的尺寸——因此，模型的第一层<sup><a href="#fn_1" id="reffn_1">1</a></sup>需要接收关于其输入尺寸的信息。</p>
<blockquote id="fn_1">
<sup>1</sup>. 且只有第一层需要，下面的层可以自动地推断尺寸<a href="#reffn_1" title="Jump back to footnote [1] in the text."> &#8617;</a>
</blockquote>
<p>输入尺寸的方法：</p>
<ul>
<li>传递<code>input_shape</code>参数给第一层<ul>
<li><code>input_shape</code>是一个表示尺寸的元组<sup><a href="#fn_2" id="reffn_2">2</a></sup></li>
<li><code>input_shape</code>中不包含数据的batch大小</li>
</ul>
</li>
<li>某些2D层（如<code>Dense</code>）支持通过参数<code>input_dim</code>指定输入尺寸；某些3D时序层支持<code>input_dim</code>和<code>input_length</code>参数</li>
<li><p>如果需要为输入指定一个固定的<code>batch</code>大小，可以传递参数<code>batch_size</code>给一个层</p>
<blockquote>
<p>如：同时将<code>batch_size=32</code>和<code>input_shape=(6,8)</code>传递给一个层，则每一批输入的尺寸为<code>(32, 6, 8)</code></p>
</blockquote>
</li>
</ul>
<blockquote id="fn_2">
<sup>2</sup>. 一个由整数或<code>None</code>组成的元组，其中<code>None</code>表示可能为任何正整数。<a href="#reffn_2" title="Jump back to footnote [2] in the text."> &#8617;</a>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">model = Sequential()</span><br><span class="line">model.add(Dense(<span class="number">32</span>, input_shape=(<span class="number">784</span>,)))</span><br><span class="line"><span class="comment">## 等价于</span></span><br><span class="line">model = Sequential()</span><br><span class="line">model.add(Dense(<span class="number">32</span>, input_dim=<span class="number">784</span>))</span><br></pre></td></tr></table></figure>
<h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>构建模型之后，可以使用<code>.compile()</code>来配置学习过程。</p>
<ul>
<li>优化器<code>optimizer</code>：可以是现有优化器的字符串标识符，也可以是Optimizer类的实例。<ul>
<li>现有优化器的字符串标识符：<code>rmsprop</code>、<code>adagrad</code></li>
<li>Optimizer类的实例：<a href="https://keras.io/api/optimizers/sgd" target="_blank" rel="noopener">SGD</a>、<a href="https://keras.io/api/optimizers/rmsprop" target="_blank" rel="noopener">RMSprop</a>、<a href="https://keras.io/api/optimizers/adam" target="_blank" rel="noopener">Adam</a>、<a href="https://keras.io/api/optimizers/adadelta" target="_blank" rel="noopener">Adadelta</a>、<a href="https://keras.io/api/optimizers/adagrad" target="_blank" rel="noopener">Adagrad</a>、<a href="https://keras.io/api/optimizers/adamax" target="_blank" rel="noopener">Adamax</a>、<a href="https://keras.io/api/optimizers/Nadam" target="_blank" rel="noopener">Nadam</a>、<a href="https://keras.io/api/optimizers/ftrl" target="_blank" rel="noopener">Ftrl</a></li>
</ul>
</li>
<li>损失函数<code>loss</code>：模型试图最小化的目标函数；可以是现有损失函数的字符串标识符，也可以是一个目标函数。<ul>
<li>现有损失函数的字符串标识符：<code>categorical_crossentropy</code>、<code>mse</code></li>
<li>目标函数：见<a href="https://keras.io/api/losses/" target="_blank" rel="noopener">losses</a></li>
</ul>
</li>
<li>评估标准<code>metrics</code>：可以是现有的标准的字符串标识符，也可以是自定义的评估标准函数。<ul>
<li><code>metrics=[&#39;accuracy&#39;]</code></li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">model.compile(loss=<span class="string">'categorical_crossentropy'</span>,</span><br><span class="line">              optimizer=<span class="string">'sgd'</span>,</span><br><span class="line">              metrics=[<span class="string">'accuracy'</span>])</span><br><span class="line"><span class="comment">## 自定义评估标准函数</span></span><br><span class="line"><span class="keyword">import</span> keras.backend <span class="keyword">as</span> K  <span class="comment">## 加载后端</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mean_pred</span><span class="params">(y_true, y_pred)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> K.mean(y_pred)</span><br><span class="line"></span><br><span class="line">model.compile(optimizer=<span class="string">'rmsprop'</span>,</span><br><span class="line">              loss=<span class="string">'binary_crossentropy'</span>,</span><br><span class="line">              metrics=[<span class="string">'accuracy'</span>, mean_pred])</span><br></pre></td></tr></table></figure>
<ul>
<li>多分类问题<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">model.compile(optimizer=<span class="string">'rmsprop'</span>,</span><br><span class="line">             loss=<span class="string">'categorical_crossentropy'</span>,</span><br><span class="line">             metrics=[<span class="string">'accuracy'</span>])</span><br></pre></td></tr></table></figure></li>
<li>二分类问题<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">model.compile(optimizer=<span class="string">'rmsprop'</span>,</span><br><span class="line">             loss=<span class="string">'binary_crossentropy'</span>,</span><br><span class="line">             metrics=[<span class="string">'accuracy'</span>])</span><br></pre></td></tr></table></figure></li>
<li>回归问题<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">model.compile(optimizer=<span class="string">'rmsprop'</span>,</span><br><span class="line">             loss=<span class="string">'mse'</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h3><p>然后在训练集数据上进行迭代(<strong>训练</strong>)：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">model.fit(x_train, y_train, epochs=<span class="number">5</span>, batch_size=<span class="number">32</span>)</span><br></pre></td></tr></table></figure></p>
<p><strong>评估</strong>模型性能:<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">loss_and_metrics = model.evaluate(x_test, y_test, batch_size=<span class="number">128</span>)</span><br></pre></td></tr></table></figure></p>
<p>进行<strong>预测</strong>：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pred_classes = model.predict(x_test, batch_size=<span class="number">128</span>)</span><br></pre></td></tr></table></figure></p>
<h2 id="utils"><a href="#utils" class="headerlink" title="utils"></a>utils</h2><h3 id="to-categorical"><a href="#to-categorical" class="headerlink" title="to_categorical()"></a>to_categorical()</h3><p>进行One-Hot Encoding</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> keras.utils <span class="keyword">import</span> to_categorical</span><br><span class="line">data = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line">tc = to_categorical(data)</span><br><span class="line">tc</span><br><span class="line"><span class="comment">#array([[0., 1., 0., 0.],</span></span><br><span class="line"><span class="comment">#       [0., 0., 0., 1.],</span></span><br><span class="line"><span class="comment">#       [0., 0., 1., 0.],</span></span><br><span class="line"><span class="comment">#       [1., 0., 0., 0.],</span></span><br><span class="line"><span class="comment">#       [0., 0., 0., 1.],</span></span><br><span class="line"><span class="comment">#       [0., 0., 1., 0.],</span></span><br><span class="line"><span class="comment">#       [0., 0., 1., 0.],</span></span><br><span class="line"><span class="comment">#       [0., 1., 0., 0.],</span></span><br><span class="line"><span class="comment">#       [1., 0., 0., 0.],</span></span><br><span class="line"><span class="comment">#       [0., 1., 0., 0.]], dtype=float32)</span></span><br></pre></td></tr></table></figure>
<p>共有{0,1,2,3}四个类别，所以是四维变量。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://keras.io/zh/" target="_blank" rel="noopener">Keras中文文档</a></li>
</ul>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>概率论基础</title>
    <url>/%E6%A6%82%E7%8E%87%E8%AE%BA%E5%9F%BA%E7%A1%80.html</url>
    <content><![CDATA[<center>Probability Theory</center>

<a id="more"></a>
<h1 id="概率论基础"><a href="#概率论基础" class="headerlink" title="概率论基础"></a>概率论基础</h1><h2 id="随机事件与概率"><a href="#随机事件与概率" class="headerlink" title="随机事件与概率"></a>随机事件与概率</h2><ul>
<li><strong>随机现象</strong>：在一定条件下，并不总是出现相同结果的现象<ul>
<li>结果不止一个</li>
<li>人们事先并不知道哪一个结果出现</li>
</ul>
</li>
<li><strong>确定性现象</strong>：只有一个结果的现象</li>
<li><strong>随机事件</strong>（简称<strong>事件</strong>）：随机现象的某些样本点组成的集合<ul>
<li>任一事件$A$是相应样本空间的一个子集</li>
<li>样本空间$\Omega$</li>
<li><strong>基本事件</strong>：由样本空间$\Omega$中的单个元素组成的子集</li>
<li><strong>必然事件</strong>：样本空间$\Omega$的最大子集（$\Omega$本身）</li>
<li><strong>不可能事件</strong>：样本空间$\Omega$的最小子集（即空集$\emptyset$）</li>
</ul>
</li>
</ul>
<h3 id="事件间关系"><a href="#事件间关系" class="headerlink" title="事件间关系"></a>事件间关系</h3><ul>
<li><strong>包含</strong>：如果属于$A$的样本点必属于$B$，则称$A$被包含在$B$中 或 $B$包含$A$<script type="math/tex; mode=display">A\subset B 或 B \supset A</script><ul>
<li>对任一事件$A$，必有$\emptyset \subset A\subset \Omega$</li>
</ul>
</li>
<li><strong>相等</strong>：如果事件$A$和事件$B$满足——属于$A$的样本点必属于$B$，且属于$B$的样本点——则称事件$A$与事件$B$相等（$A=B$） <script type="math/tex; mode=display">A\subset B 且 B\subset A</script></li>
<li><strong>互不相容</strong>：事件$A$和事件$B$没有相同的样本点（事件$A$与事件$B$不可能同时发生）</li>
</ul>
<h3 id="事件间运算"><a href="#事件间运算" class="headerlink" title="事件间运算"></a>事件间运算</h3><ul>
<li><strong>并</strong>：由事件$A$与$B$中所有的样本点组成的新事件<ul>
<li>事件$A$与$B$中至少有一个发生<script type="math/tex; mode=display">A\cup B</script></li>
</ul>
</li>
<li><strong>交</strong>：由事件$A$与$B$中公共的样本点组成的新事件<ul>
<li>事件$A$与$B$同时发生<script type="math/tex; mode=display">A\cap B或 AB</script></li>
</ul>
</li>
<li><strong>差</strong>：由在事件$A$中而不在事件$B$中的样本点组成的新事件<ul>
<li>事件$A$发生而事件$B$不发生<script type="math/tex; mode=display">A-B 或 A\cap B^c</script></li>
</ul>
</li>
<li><strong>对立事件</strong> 或 <strong>补</strong>：事件$A$的对立事件$\bar{A}$——由在$\Omega$中而不在$A$中的样本点组成的新事件<ul>
<li>$A$不发生<script type="math/tex; mode=display">\bar{A}=A^c=\Omega-A</script></li>
<li>对立事件是相互的<script type="math/tex; mode=display">\overline{\overline{A}}=A</script></li>
<li>$\overline{\Omega}=\emptyset$</li>
<li>$\overline{\emptyset}=\Omega$</li>
</ul>
</li>
</ul>
<h3 id="事件的运算性质"><a href="#事件的运算性质" class="headerlink" title="事件的运算性质"></a>事件的运算性质</h3><ul>
<li><strong>交换律</strong><script type="math/tex; mode=display">A\cup B=B\cup A</script><script type="math/tex; mode=display">AB=BA</script></li>
<li><strong>结合律</strong><script type="math/tex; mode=display">(A\cup B)\cup C=A\cup (B\cup C)</script><script type="math/tex; mode=display">(AB)C=A(BC)</script></li>
<li><strong>分配律</strong><script type="math/tex; mode=display">(A\cup B)\cap C=(A\cap C)\cup(B\cap C)</script><script type="math/tex; mode=display">(A\cap B)\cup C=(A\cup C)\cap(B\cup C)</script></li>
<li><strong>De Morgan</strong>(对偶律)<ul>
<li>事件并的对立等于对立的交 <script type="math/tex; mode=display">\overline{A\cup B}=\overline{A}\cap \overline{B}</script></li>
<li>事件交的对立等于对立的并<script type="math/tex; mode=display">\overline{A\cap B}=\overline{A}\cup\overline{B}</script><script type="math/tex; mode=display">\overline{\bigcup_{i=1}^nA_i}=\bigcap_{i=1}^n\overline{A_i},\quad \overline{\bigcup_{i=1}^\infty A_i}=\bigcap_{i=1}^\infty \overline{A_i}</script><script type="math/tex; mode=display">\overline{\bigcap_{i=1}^nA_i}=\bigcup_{i=1}^n\overline{A_i},\quad \overline{\bigcap_{i=1}^\infty A_i}=\bigcup_{i=1}^\infty \overline{A_i}</script></li>
</ul>
</li>
</ul>
<h3 id="分割"><a href="#分割" class="headerlink" title="分割"></a>分割</h3><p>partition<br>将样本空间$\Omega$划分为$n$个<u>互不相容</u>的事件$D_1,\cdots,D_n$——$\{D_1,\cdots,D_n\}$称为$\Omega$的一个分割</p>
<script type="math/tex; mode=display">\mathscr{F}=\{D_1,\cdots,D_n\}</script><ul>
<li>对所有的$i,j=1,\cdots,n$且$i\neq j$，有$D_i\cap D_j=\emptyset$</li>
<li>$\bigcup_{i=1}^n=\Omega$</li>
</ul>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="Beta函数"><a href="#Beta函数" class="headerlink" title="Beta函数"></a>Beta函数</h3><script type="math/tex; mode=display">B(\alpha, \beta)=\int_0^1 x^{\alpha-1}(1-x)^{\beta-1}\mathrm{d}x ,\quad \alpha,\beta>0</script><ul>
<li>$B(\alpha,\beta)=\frac{\Gamma(\alpha)\Gamma(\beta)}{\Gamma(\alpha+\beta)}$<br>证明：</li>
</ul>
<h3 id="Gamma函数"><a href="#Gamma函数" class="headerlink" title="Gamma函数"></a>Gamma函数</h3><script type="math/tex; mode=display">\Gamma(\alpha)=\int_0^{+\infty}x^{\alpha-1}e^{-x}\mathrm{d}x ,\quad \alpha>0</script><ul>
<li>$\Gamma(\alpha+1)=\alpha\Gamma(\alpha)$</li>
<li>$\Gamma(n+1)=n!,\quad n\in \mathbb{N}$.</li>
</ul>
<h1 id="随机变量"><a href="#随机变量" class="headerlink" title="随机变量"></a>随机变量</h1><p>用来表示随机现象结果的变量</p>
<h2 id="概率"><a href="#概率" class="headerlink" title="概率"></a>概率</h2><h3 id="条件概率"><a href="#条件概率" class="headerlink" title="条件概率"></a>条件概率</h3><p>$X$ condition on $Y$</p>
<script type="math/tex; mode=display">P(X|Y)=\frac{P(X,Y)}{P(Y)}=\frac{P(Y|X)P(X)}{P(Y)}</script><h3 id="贝叶斯公式"><a href="#贝叶斯公式" class="headerlink" title="贝叶斯公式"></a>贝叶斯公式</h3><ul>
<li>如果$\{A_i:i=1,\cdots,k\}$是一个分割(partition)，则有<script type="math/tex; mode=display">P(A_j|B)=\frac{P(B|A_j)P(A_j)}{\sum_{i=1}^kP(B|A_i)P(A_i)}</script></li>
</ul>
<h2 id="期望"><a href="#期望" class="headerlink" title="期望"></a>期望</h2><p>Expectation</p>
<script type="math/tex; mode=display">E(X)=\int xf_X(x)\mathrm{d}x</script><h3 id="条件期望"><a href="#条件期望" class="headerlink" title="条件期望"></a>条件期望</h3><p>条件期望/条件均值（Conditional Mean）：</p>
<script type="math/tex; mode=display">E\left(X|Y=y\right)=\int xf_{X|Y}(x|y)\mathrm{d}x</script><h3 id="重期望"><a href="#重期望" class="headerlink" title="重期望"></a>重期望</h3><p>LIE(Law of Iterated Expectation)<br><div class="note success">
            <script type="math/tex; mode=display">E(X)=E\left[E\left(X|Y\right) \right]</script><script type="math/tex; mode=display">E\left[Z|X \right]=E\left[E\left(Z|Y,X\right)|X \right]</script><script type="math/tex; mode=display">Var(X)=E\left[Var(X|Y) \right]+Var\left[E\left(X|Y \right)\right]</script>
          </div></p>
<div class="note default">
            <p>证明：</p>
          </div>
<h2 id="方差"><a href="#方差" class="headerlink" title="方差"></a>方差</h2><h3 id="条件方差"><a href="#条件方差" class="headerlink" title="条件方差"></a>条件方差</h3><script type="math/tex; mode=display">Var\left(X|Y=y\right)=\int \left[x-E\left(X|Y=y \right)\right]^2f_{X|Y}(x|y)\mathrm{d}x</script><h2 id="协方差"><a href="#协方差" class="headerlink" title="协方差"></a>协方差</h2><p>Covariance</p>
<h3 id="条件协方差"><a href="#条件协方差" class="headerlink" title="条件协方差"></a>条件协方差</h3><p>Law of Total Conditional Variance：</p>
<script type="math/tex; mode=display">Cov(Z|X)=Cov\left[E\left(Z|Y,X\right)|X \right]+E\left[Cov\left(Z|Y,X\right)|X \right]</script><h1 id="分布"><a href="#分布" class="headerlink" title="分布"></a>分布</h1><ul>
<li><strong>概率密度函数</strong>（pdf，probability density function）</li>
</ul>
<h2 id="常见离散分布"><a href="#常见离散分布" class="headerlink" title="常见离散分布"></a>常见离散分布</h2><h3 id="伯努利分布"><a href="#伯努利分布" class="headerlink" title="伯努利分布"></a>伯努利分布</h3><p>Bernoulli Distribution<br>$X\sim Bernoulli(p)$, $X$的可能取值只有0和1，且相应的概率为</p>
<script type="math/tex; mode=display">P(X=1)=p,\quad P(X=0)=1-p\quad 0 < p <1</script><p>即</p>
<script type="math/tex; mode=display">f(x|p)=\left\{
    \begin{array}{ll}
    p^x(1-p)^{1-x}, & x=0,1\\
    0, & x\neq0,1
    \end{array}
    \right.</script><ul>
<li>$E(X)=p$<script type="math/tex; mode=display">E(X)=1\cdot p+0\cdot (1-p)=p</script></li>
<li>$Var(X)=p(1-p)$<script type="math/tex; mode=display">E(X^2)=1^2\cdot p+0^2\cdot (1-p)=p</script><script type="math/tex; mode=display">Var(X)=E(X^2)-[E(X)]^2=p-p^2=p(1-p)</script></li>
</ul>
<h3 id="泊松分布"><a href="#泊松分布" class="headerlink" title="泊松分布"></a>泊松分布</h3><ul>
<li><a href="/%E5%88%86%E5%B8%83-%E6%B3%8A%E6%9D%BE%E5%88%86%E5%B8%83.html" title="泊松分布">泊松分布</a>
</li>
</ul>
<p>Poisson Distribution<br>参数为$\lambda$的泊松分布的概率密度函数为</p>
<script type="math/tex; mode=display">P(X=k)=\frac{\lambda^k}{k!}e^{-\lambda},\quad k=0,1,\cdots.</script><ul>
<li>$E(X)=\lambda$</li>
<li>$Var(X)=\lambda$</li>
</ul>
<h2 id="常见连续分布"><a href="#常见连续分布" class="headerlink" title="常见连续分布"></a>常见连续分布</h2><h3 id="贝塔分布"><a href="#贝塔分布" class="headerlink" title="贝塔分布"></a>贝塔分布</h3><p>Beta Distribution<br>$X\sim B(\alpha, \beta)$, 则$X$的概率密度函数为</p>
<script type="math/tex; mode=display">f_X(x)=\frac{1}{B(\alpha,\beta)}x^{\alpha-1}(1-x)^{\beta-1},\quad 0< x < 1</script><ul>
<li><p>$E(X)=\frac{\alpha}{\alpha+\beta}$</p>
<font face="仿宋">
\begin{equation}
\begin{aligned}
E(X)&=\int_0^1 x\frac{1}{B(\alpha,\beta)}x^{\alpha-1}(1-x)^{\beta-1}\mathrm{d}x\\
&=
\end{aligned}
\end{equation}
</font>
</li>
<li><p>$Var(X)=\frac{\alpha\beta}{(\alpha+\beta)^2(\alpha+\beta+1)}$</p>
</li>
</ul>
<h3 id="伽马分布"><a href="#伽马分布" class="headerlink" title="伽马分布"></a>伽马分布</h3><p>Gamma Distribution<br>$X\sim \Gamma(\alpha, \beta)$, 则$X$的概率密度函数为</p>
<script type="math/tex; mode=display">f_X(x)=\frac{\beta^{\alpha}}{\Gamma(\alpha)}x^{\alpha-1}e^{-\beta x},\quad x>0</script><ul>
<li>$E(X)=\frac{\alpha}{\beta}$</li>
<li>$Var(X)=\frac{\alpha}{\beta^2}$</li>
</ul>
<h3 id="逆伽马分布"><a href="#逆伽马分布" class="headerlink" title="逆伽马分布"></a>逆伽马分布</h3><p>Inverted Gamma Distribution<br>$X\sim \Gamma(\alpha, \beta)$，定义$Y=\frac{1}{X}$，则$Y$服从逆伽马分布，概率密度函数为</p>
<script type="math/tex; mode=display">f_Y(y)=\frac{\beta^{\alpha}}{\Gamma(\alpha)}y^{-(\alpha+1)}e^{-\frac{\beta}{y}},\quad y>0</script><h3 id="正态分布"><a href="#正态分布" class="headerlink" title="正态分布"></a>正态分布</h3><h3 id="t-分布"><a href="#t-分布" class="headerlink" title="$t$分布"></a>$t$分布</h3><p>Student’s t-distribution<sup><a href="#fn_1" id="reffn_1">1</a></sup></p>
<p>从均值为$\mu$、方差为$\sigma^2$的正态总体种抽取容量为$n$的随机样本，随机样本的</p>
<ul>
<li>均值：$\bar{x}$</li>
<li>方差：$s^2=\frac{1}{n-1}\sum_{i=1}^n(x_i-\bar{x})^2$</li>
</ul>
<p>则随机变量T</p>
<script type="math/tex; mode=display">T=\frac{\bar{x}-\mu}{s/\sqrt{n}}</script><p>服从自由度为$n-1$的$t$分布，即$T\sim t(n-1)$。</p>
<ul>
<li>$t$分布是一种典型的长尾分布</li>
</ul>
<blockquote id="fn_1">
<sup>1</sup>. ‘Student’是William Sealy Gosset的笔名<a href="#reffn_1" title="Jump back to footnote [1] in the text."> &#8617;</a>
</blockquote>
<h3 id="卡方分布"><a href="#卡方分布" class="headerlink" title="卡方分布"></a>卡方分布</h3><p>若$k$个随机变量$Z_1, Z_2, \cdots, Z_k$是相互独立、服从标准<a href="#正态分布">正态分布</a>的随机变量，则随机变量Z的平方和</p>
<script type="math/tex; mode=display">X = \sum_{i=1}^kZ_i^2</script><p>服从自由度为$k$的卡方分布。</p>
<ul>
<li>$E(X)=$</li>
</ul>
<h2 id="分布的特征"><a href="#分布的特征" class="headerlink" title="分布的特征"></a>分布的特征</h2><h3 id="偏态"><a href="#偏态" class="headerlink" title="偏态"></a>偏态</h3><p>||左偏|正态|右偏|<br>|均值、中位数、众数|均值$&lt;$中位数$&lt;$众数|均值=中位数=众数|众数$&lt;$中位数$&lt;$均值|</p>
<h3 id="峰度"><a href="#峰度" class="headerlink" title="峰度"></a>峰度</h3><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://book.douban.com/subject/5998092/" target="_blank" rel="noopener">概率论与数理统计教程</a></li>
</ul>
]]></content>
      <categories>
        <category>Statistics</category>
      </categories>
      <tags>
        <tag>概率统计基础</tag>
        <tag>概率分布</tag>
      </tags>
  </entry>
  <entry>
    <title>Python | pip</title>
    <url>/python-pip.html</url>
    <content><![CDATA[<p><center></center><br><a id="more"></a></p>
<h1 id="pip"><a href="#pip" class="headerlink" title="pip"></a>pip</h1><p>一般在Anaconda Prompt中输入pip命令</p>
<h2 id="版本更新"><a href="#版本更新" class="headerlink" title="版本更新"></a>版本更新</h2><p>参考：<a href="https://mp.weixin.qq.com/s?__biz=MzAwNDc0MTUxMw==&amp;mid=2649643692&amp;idx=1&amp;sn=70dbc41763a8c644a4d6c77ae5f7dd7e&amp;chksm=833dba4ab44a335cc7e177dc657f1967ebbd38214c692153cb9a82fdfb542d9a132c2325a227&amp;mpshare=1&amp;scene=1&amp;srcid=&amp;sharer_sharetime=1589007082512&amp;sharer_shareid=b539221659d6ecf12200314308b58dd3&amp;key=cbc079077f0681e386b6535f2cb4ef718f051657f8a1901edd559d983b9035139ec5357fc73a707c01d8308cb77ec658498db2c158f5ec06b4af30c7b17076247a4aee34eb0c3830103a133ab46a209f&amp;ascene=1&amp;uin=MjAwNDUzMjgxNw%3D%3D&amp;devicetype=Windows+10+x64&amp;version=62090070&amp;lang=zh_CN&amp;exportkey=ARqsCMWgte4FkZi5FL4hNrc%3D&amp;pass_ticket=CmNRIqxaQvL5KoUpjMG2wm1sm1tONovrasNNAw%2F3Gmy%2FS79A7RAXf525qAh80qgw" target="_blank" rel="noopener">pip 发布新版本了！</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python -m pip install --upgrade pip</span><br></pre></td></tr></table></figure>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1>]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>C++学习</title>
    <url>/C-%E5%AD%A6%E4%B9%A0.html</url>
    <content><![CDATA[<p><center>C plus plus</center><br><a id="more"></a></p>
<h1 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h1><h2 id="getchar"><a href="#getchar" class="headerlink" title="getchar()"></a>getchar()</h2><p>用于暂停程序，以便查看程序输出的内容</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">11</span>],i,j,t;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;=<span class="number">10</span>;i++)</span><br><span class="line">        a[i]=<span class="number">0</span>;  <span class="comment">//初始化为0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">        a[t]++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;=<span class="number">10</span>;i++)</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=a[i];j++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d"</span>,i);</span><br><span class="line">    </span><br><span class="line">    getchar();getchar();  <span class="comment">//用来暂停程序</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA</title>
    <url>/JAVA%E5%AD%A6%E4%B9%A0.html</url>
    <content><![CDATA[<p><center>JAVA小白的学习之路</center><br><a id="more"></a></p>
<h1 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h1><ul>
<li><a href="https://www.runoob.com/java/java-environment-setup.html" target="_blank" rel="noopener">Java 开发环境配置</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU5NzkxODMxOA==&amp;mid=2247484931&amp;idx=1&amp;sn=711689c6734cf40856639baae8fb375c&amp;chksm=fe4d5102c93ad8146c09e3a9d001db254899668f77b0f4cedd8537758d4089b4aab0e9e1a24d&amp;token=1150466167&amp;lang=zh_CN#rd" target="_blank" rel="noopener">JAVA JDK 安装配置</a></li>
</ul>
<h2 id="安装IDE"><a href="#安装IDE" class="headerlink" title="安装IDE"></a>安装IDE</h2><ul>
<li><a href="https://www.jetbrains.com/idea/download/download-thanks.html?platform=windows&amp;code=IIC" target="_blank" rel="noopener">IntelliJ IDEA下载</a></li>
</ul>
<h1 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h1><h2 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h2><ul>
<li><strong>对象</strong>：是类的一个实例，有状态和行为。</li>
<li><strong>类</strong>：类是一个模板，描述一类对象的行为和状态。</li>
<li><strong>方法</strong>：就是行为，一个类可以有很多方法。<ul>
<li>逻辑运算</li>
<li>数据修改</li>
<li>……</li>
</ul>
</li>
<li><strong>实例变量</strong>：每个对象都有独特的实例变量，对象的状态由这些实例变量的值决定。</li>
</ul>
<h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><ul>
<li>大小写敏感</li>
<li>类名<ul>
<li>类名的首字母应该大写</li>
<li>若类名由多个单词组成，则每个单词的首字母应该大写</li>
</ul>
</li>
<li>方法名<ul>
<li>所有方法名都应该以小写字母开头</li>
<li>若方法名由多个单词组成，则后面的每个单词首字母大写</li>
</ul>
</li>
<li>源文件名<ul>
<li>源文件名必须与类名相同</li>
<li>后缀为<code>.java</code></li>
</ul>
</li>
<li>主方法入口<ul>
<li>所有的JAVA程序由 public static void main(String []args) 方法开始执行</li>
</ul>
</li>
</ul>
<h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><ul>
<li>Java的所有组成部分都需要名字</li>
<li>类名、变量名及方法名都被称为<strong>标识符</strong></li>
</ul>
<p>注意事项：</p>
<ul>
<li>标识符应以字母、美元符或下划线开始</li>
<li>首字符后可以是字母、美元符、下划线或数字的任何字符组合</li>
<li>关键字不能用作标识符</li>
<li>标识符是大小写敏感的</li>
</ul>
<h2 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h2><p>用于修饰类中方法和属性。</p>
<p>主要有两类：</p>
<ol>
<li>访问控制修饰符<ul>
<li><code>default</code></li>
<li><code>public</code></li>
<li><code>protected</code></li>
<li><code>private</code></li>
</ul>
</li>
<li>非访问控制修饰符<ul>
<li><code>final</code></li>
<li><code>abstract</code></li>
<li><code>static</code></li>
<li><code>synchronized</code></li>
</ul>
</li>
</ol>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>主要有三类：</p>
<ol>
<li>局部变量</li>
<li>类变量/静态变量</li>
<li>成员变量/非静态变量</li>
</ol>
<h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><h3 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">关键字</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>private</code></td>
<td style="text-align:left">私有的</td>
</tr>
<tr>
<td style="text-align:left"><code>protected</code></td>
<td style="text-align:left">受保护的</td>
</tr>
<tr>
<td style="text-align:left"><code>public</code></td>
<td style="text-align:left">公共的</td>
</tr>
<tr>
<td style="text-align:left"><code>default</code></td>
<td style="text-align:left">默认</td>
</tr>
</tbody>
</table>
</div>
<h3 id="类、方法和变量修饰符"><a href="#类、方法和变量修饰符" class="headerlink" title="类、方法和变量修饰符"></a>类、方法和变量修饰符</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">关键字</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>abstract</code></td>
<td style="text-align:left">声明抽象</td>
</tr>
<tr>
<td style="text-align:left"><code>class</code></td>
<td style="text-align:left">类</td>
</tr>
<tr>
<td style="text-align:left"><code>extends</code></td>
<td style="text-align:left">扩充，继承</td>
</tr>
<tr>
<td style="text-align:left"><code>final</code></td>
<td style="text-align:left">最终值，不可改变的</td>
</tr>
<tr>
<td style="text-align:left"><code>implements</code></td>
<td style="text-align:left">实现（接口）</td>
</tr>
<tr>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
</div>
<p>未完待续</p>
<h3 id="程序控制句"><a href="#程序控制句" class="headerlink" title="程序控制句"></a>程序控制句</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">关键字</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
</div>
<h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">关键字</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
</div>
<h3 id="包相关"><a href="#包相关" class="headerlink" title="包相关"></a>包相关</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">关键字</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
</div>
<h3 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">关键字</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
</div>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://cn.bing.com/images/search?view=detailV2&amp;ccid=zThJuq%2bC&amp;id=474DFD30EC584147A5C8FC0F10952D615CF2795A&amp;thid=OIP.zThJuq-CIVq3uElNx7mDVQHaEK&amp;mediaurl=https%3a%2f%2fwww.vizteams.com%2fwp-content%2fuploads%2f2015%2f07%2fjava-logo.png&amp;exph=576&amp;expw=1024&amp;q=java&amp;simid=608020279042638133&amp;selectedIndex=2" target="_blank" rel="noopener">首页缩略图</a></li>
<li><a href="https://www.runoob.com/java/java-basic-syntax.html" target="_blank" rel="noopener">Java 基础语法</a></li>
</ul>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Python | pyecharts</title>
    <url>/python-pyecharts%E6%A8%A1%E5%9D%97.html</url>
    <content><![CDATA[<p><center></center><br><a id="more"></a></p>
<h1 id="pyecharts"><a href="#pyecharts" class="headerlink" title="pyecharts"></a>pyecharts</h1><ul>
<li><a href="https://pyecharts.org/" target="_blank" rel="noopener">pyecharts官网</a></li>
</ul>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>在Anaconda Prompt中输入：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install pyecharts</span><br></pre></td></tr></table></figure></p>
<p>安装过程可能会出现多种问题：</p>
<ol>
<li>缺少相关的库</li>
<li>安装MarkupSafe出错</li>
<li>提示找不到相应版本</li>
</ol>
<p><a href="https://blog.csdn.net/qq_37954088/article/details/88876791" target="_blank" rel="noopener">解决方法</a></p>
<h2 id="渲染图片"><a href="#渲染图片" class="headerlink" title="渲染图片"></a>渲染图片</h2><p>仅运行demo，并不能直接获得图片，要想获得图片输出（即使用pyecharts将输出渲染成图片），需要进行一点操作，根据官网的说明，共有3种方式：</p>
<ul>
<li><a href="https://pyecharts.org/#/zh-cn/render_images" target="_blank" rel="noopener">渲染图片</a></li>
</ul>
<ol>
<li>selenium</li>
<li>phantomjs</li>
<li>pyppeteer</li>
</ol>
<h3 id="selenium"><a href="#selenium" class="headerlink" title="selenium"></a>selenium</h3><p>安装snapshot-selenium（在Anaconda Prompt中运行）：<br><figure class="highlight md"><table><tr><td class="code"><pre><span class="line">pip install snapshot-selenium</span><br></pre></td></tr></table></figure></p>
<p>使用selenium<sup><a href="#fn_2" id="reffn_2">2</a></sup>，需要配置browser driver（浏览器驱动程序），详情可参见:<br><a href="https://selenium-python.readthedocs.io/installation.html#drivers" target="_blank" rel="noopener">https://selenium-python.readthedocs.io/installation.html#drivers</a></p>
<p>选择浏览器对应的driver，下面以Edge浏览器<sup><a href="#fn_1" id="reffn_1">1</a></sup>为例：<br><a href="https://developer.microsoft.com/en-us/microsoft-edge/tools/webdriver/" target="_blank" rel="noopener">Edge的WebDriver下载地址</a></p>
<ol>
<li>首先查看Edge的版本信息（version）：点击Edge浏览器右上角的“…”，选择“设置”，“常规”的最下方有Edge版本信息<br><meta name="referrer" content="no-referrer"><img src="/python-pyecharts%E6%A8%A1%E5%9D%97/oldedge.png" class title="旧Edge版本信息">
<ul>
<li>查看全新Edge的版本信息：点击右上角的“…”，选择“帮助与反馈”中的“关于Microsoft Edge”，即可查看相应的版本信息<br><meta name="referrer" content="no-referrer"><img src="/python-pyecharts%E6%A8%A1%E5%9D%97/newedgev.png" class title="新Edge版本信息"></li>
</ul>
</li>
<li>接着下载<a href="https://msedgewebdriverstorage.z22.web.core.windows.net/?prefix=79.0.309.68/" target="_blank" rel="noopener">版本79.0.309.68的Edge对应的WebDriver</a>，从<a href="https://msedgewebdriverstorage.z22.web.core.windows.net/" target="_blank" rel="noopener">各版本WebDriver</a>中找到相应版本</li>
<li>下载后解压，将driver的路径添加到系统路径中：<ul>
<li>右键单击“此电脑/我的电脑”</li>
<li>选择“属性”</li>
<li>选择“高级系统设置”—“环境变量”</li>
<li>在”系统变量“中的”Path“添加driver的路径</li>
</ul>
</li>
</ol>
<blockquote id="fn_1">
<sup>1</sup>. 2020年01月16日，基于Chromium内核的全新Microsoft Edge正式上线微软官网，可自行下载进行更新。<a href="https://www.microsoft.com/en-us/edge" target="_blank" rel="noopener">全新Microsoft Edge</a><a href="#reffn_1" title="Jump back to footnote [1] in the text."> &#8617;</a>
</blockquote>
<p><meta name="referrer" content="no-referrer"><br><img src="/python-pyecharts%E6%A8%A1%E5%9D%97/newedge.png" class title="全新Edge"></p>
<blockquote id="fn_2">
<sup>2</sup>. selenium目前支持Chrome和Safari<a href="#reffn_2" title="Jump back to footnote [2] in the text."> &#8617;</a>
</blockquote>
<p>Chrome的Driver下载可见：<br><a href="https://sites.google.com/a/chromium.org/chromedriver/home" target="_blank" rel="noopener">https://sites.google.com/a/chromium.org/chromedriver/home</a></p>
<p>使用selenium渲染图片，需要在运行python代码时添加以下代码（举例）：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pyecharts.render <span class="keyword">import</span> make_snapshot</span><br><span class="line"><span class="keyword">from</span> snapshot_selenium <span class="keyword">import</span> snapshot</span><br><span class="line"></span><br><span class="line">make_snapshot(snapshot, calendar_base().render(), <span class="string">"calendar0.png"</span>)</span><br></pre></td></tr></table></figure><br>总是报错(ノへ￣、)</p>
<p>将Chrome Driver应用程序直接放在项目文件所在的文件夹中即可正常运行（惊了</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pyecharts <span class="keyword">import</span> options <span class="keyword">as</span> opts</span><br><span class="line"><span class="keyword">from</span> pyecharts.charts <span class="keyword">import</span> Calendar</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pyecharts.render <span class="keyword">import</span> make_snapshot</span><br><span class="line"><span class="keyword">from</span> snapshot_selenium <span class="keyword">import</span> snapshot</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calendar_base</span><span class="params">()</span> -&gt; Calendar:</span></span><br><span class="line">    begin = datetime.date(<span class="number">2019</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">    end = datetime.date(<span class="number">2019</span>, <span class="number">12</span>, <span class="number">31</span>)</span><br><span class="line">    data = [</span><br><span class="line">        [str(begin + datetime.timedelta(days=i)), </span><br><span class="line">        random.randint(<span class="number">1000</span>, <span class="number">25000</span>)] </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range((end - begin).days + <span class="number">1</span>)</span><br><span class="line">    ]</span><br><span class="line">    c = (</span><br><span class="line">        Calendar()</span><br><span class="line">        .add(<span class="string">""</span>, data, calendar_opts=opts.CalendarOpts(range_=<span class="string">"2019"</span>))</span><br><span class="line">        .set_global_opts(</span><br><span class="line">            title_opts=opts.TitleOpts(title=<span class="string">"Calendar-2019年每日步数情况"</span>),</span><br><span class="line">            visualmap_opts=opts.VisualMapOpts(</span><br><span class="line">                max_ = <span class="number">20000</span>,</span><br><span class="line">                min_ = <span class="number">500</span>,</span><br><span class="line">                orient = <span class="string">"horizontal"</span>,</span><br><span class="line">                is_piecewise = <span class="literal">True</span>,</span><br><span class="line">                pos_top = <span class="string">"230px"</span>,</span><br><span class="line">                pos_left = <span class="string">"100px"</span>,</span><br><span class="line">            ),</span><br><span class="line">        )</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line"></span><br><span class="line">make_snapshot(snapshot, calendar_base().render(), <span class="string">"calendar0.png"</span>)</span><br></pre></td></tr></table></figure>
<h3 id="phantomjs"><a href="#phantomjs" class="headerlink" title="phantomjs"></a>phantomjs</h3><p>安装snapshot-phantomjs（在Anaconda Prompt中运行）：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install snapshot-phantomjs</span><br></pre></td></tr></table></figure></p>
<p>使用snapshot-phantomjs需要安装phantom.exe，<a href="https://phantomjs.org/download.html" target="_blank" rel="noopener">下载地址</a></p>
<p>下载后解压即可（需要将phantomjs所在路径添加到系统变量的PATH中）</p>
<p>仍是报错(ノへ￣、)</p>
<p>将Phantom.exe直接放在项目文件所在的文件夹内即可正常运行</p>
<blockquote>
<p><a href="https://phantomjs.org/quick-start.html" target="_blank" rel="noopener">简单认识PhantomJS</a></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pyecharts <span class="keyword">import</span> options <span class="keyword">as</span> opts</span><br><span class="line"><span class="keyword">from</span> pyecharts.charts <span class="keyword">import</span> Bar</span><br><span class="line"><span class="keyword">from</span> pyecharts.render <span class="keyword">import</span> make_snapshot</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> snapshot_phantomjs <span class="keyword">import</span> snapshot</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bar_chart</span><span class="params">()</span> -&gt; Bar:</span></span><br><span class="line">    c = (</span><br><span class="line">        Bar()</span><br><span class="line">        .add_xaxis([<span class="string">"衬衫"</span>, <span class="string">"毛衣"</span>, <span class="string">"领带"</span>, <span class="string">"裤子"</span>, <span class="string">"风衣"</span>, <span class="string">"高跟鞋"</span>, <span class="string">"袜子"</span>])</span><br><span class="line">        .add_yaxis(<span class="string">"商家A"</span>, [<span class="number">114</span>, <span class="number">55</span>, <span class="number">27</span>, <span class="number">101</span>, <span class="number">125</span>, <span class="number">27</span>, <span class="number">105</span>])</span><br><span class="line">        .add_yaxis(<span class="string">"商家B"</span>, [<span class="number">57</span>, <span class="number">134</span>, <span class="number">137</span>, <span class="number">129</span>, <span class="number">145</span>, <span class="number">60</span>, <span class="number">49</span>])</span><br><span class="line">        .reversal_axis()</span><br><span class="line">        .set_series_opts(label_opts=opts.LabelOpts(position=<span class="string">"right"</span>))</span><br><span class="line">        .set_global_opts(title_opts=opts.TitleOpts(title=<span class="string">"Bar-测试渲染图片"</span>))</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line"></span><br><span class="line">make_snapshot(snapshot, bar_chart().render(), <span class="string">"bar0.png"</span>)</span><br></pre></td></tr></table></figure>
<h3 id="pyppeteer"><a href="#pyppeteer" class="headerlink" title="pyppeteer"></a>pyppeteer</h3><p>安装snapshot-pyppeteer（在Anaconda Prompt中运行）：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install snapshot-pyppeteer</span><br></pre></td></tr></table></figure></p>
<p>并执行chromium安装命令（在Anaconda Prompt中运行）：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pyppeteer-install</span><br></pre></td></tr></table></figure></p>
<h3 id="最直接的渲染方式"><a href="#最直接的渲染方式" class="headerlink" title="最直接的渲染方式"></a>最直接的渲染方式</h3><p>最简单直接的方式：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">xxx().render()</span><br></pre></td></tr></table></figure><br>其中<code>xxx()</code>是相应的pyecharts对象的执行命令</p>
<p>输出的对象为html文件，打开html文件，单击右键可保存图片</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pyecharts <span class="keyword">import</span> options <span class="keyword">as</span> opts</span><br><span class="line"><span class="keyword">from</span> pyecharts.charts <span class="keyword">import</span> Graph, Page</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">graph_base</span><span class="params">()</span> -&gt; Graph:</span></span><br><span class="line">    nodes = [</span><br><span class="line">        &#123;<span class="string">"name"</span>: <span class="string">"结点1"</span>, <span class="string">"symbolSize"</span>: <span class="number">10</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"name"</span>: <span class="string">"结点2"</span>, <span class="string">"symbolSize"</span>: <span class="number">20</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"name"</span>: <span class="string">"结点3"</span>, <span class="string">"symbolSize"</span>: <span class="number">30</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"name"</span>: <span class="string">"结点4"</span>, <span class="string">"symbolSize"</span>: <span class="number">40</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"name"</span>: <span class="string">"结点5"</span>, <span class="string">"symbolSize"</span>: <span class="number">50</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"name"</span>: <span class="string">"结点6"</span>, <span class="string">"symbolSize"</span>: <span class="number">40</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"name"</span>: <span class="string">"结点7"</span>, <span class="string">"symbolSize"</span>: <span class="number">30</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"name"</span>: <span class="string">"结点8"</span>, <span class="string">"symbolSize"</span>: <span class="number">20</span>&#125;,</span><br><span class="line">    ]</span><br><span class="line">    links = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> nodes:</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> nodes:</span><br><span class="line">            links.append(&#123;<span class="string">"source"</span>: i.get(<span class="string">"name"</span>), <span class="string">"target"</span>: j.get(<span class="string">"name"</span>)&#125;)</span><br><span class="line">    c = (</span><br><span class="line">        Graph()</span><br><span class="line">        .add(<span class="string">""</span>, nodes, links, repulsion=<span class="number">8000</span>)</span><br><span class="line">        .set_global_opts(title_opts=opts.TitleOpts(title=<span class="string">"Graph-基本示例"</span>))</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line"></span><br><span class="line">graph_base().render()</span><br></pre></td></tr></table></figure>
<h1 id="图表类型"><a href="#图表类型" class="headerlink" title="图表类型"></a>图表类型</h1><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="将echart插入到PPT"><a href="#将echart插入到PPT" class="headerlink" title="将echart插入到PPT"></a>将echart插入到PPT</h2><ol>
<li>使用pyecharts画图并生成html文件</li>
<li>查看html的源代码</li>
<li>把相关的源代码复制到PPT插件中，点击运行即可</li>
</ol>
<blockquote>
<p>需要安装PPT插件<code>Office Apps Fiddle for PowerPoint</code></p>
</blockquote>
<p>参考<a href="http://gallery.pyecharts.org/#/Sankey/sankey_base" target="_blank" rel="noopener">官方源码</a>生成html文件：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pyecharts <span class="keyword">import</span> options <span class="keyword">as</span> opts</span><br><span class="line"><span class="keyword">from</span> pyecharts.charts <span class="keyword">import</span> Sankey</span><br><span class="line"></span><br><span class="line">nodes = [</span><br><span class="line">    &#123;<span class="string">"name"</span>: <span class="string">"category1"</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"name"</span>: <span class="string">"category2"</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"name"</span>: <span class="string">"category3"</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"name"</span>: <span class="string">"category4"</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"name"</span>: <span class="string">"category5"</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"name"</span>: <span class="string">"category6"</span>&#125;,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">links = [</span><br><span class="line">    &#123;<span class="string">"source"</span>: <span class="string">"category1"</span>, <span class="string">"target"</span>: <span class="string">"category2"</span>, <span class="string">"value"</span>: <span class="number">10</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"source"</span>: <span class="string">"category2"</span>, <span class="string">"target"</span>: <span class="string">"category3"</span>, <span class="string">"value"</span>: <span class="number">15</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"source"</span>: <span class="string">"category3"</span>, <span class="string">"target"</span>: <span class="string">"category4"</span>, <span class="string">"value"</span>: <span class="number">20</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"source"</span>: <span class="string">"category5"</span>, <span class="string">"target"</span>: <span class="string">"category6"</span>, <span class="string">"value"</span>: <span class="number">25</span>&#125;,</span><br><span class="line">]</span><br><span class="line">c = (</span><br><span class="line">    Sankey()</span><br><span class="line">    .add(</span><br><span class="line">        <span class="string">"sankey"</span>,</span><br><span class="line">        nodes,</span><br><span class="line">        links,</span><br><span class="line">        linestyle_opt=opts.LineStyleOpts(opacity=<span class="number">0.2</span>, curve=<span class="number">0.5</span>, color=<span class="string">"source"</span>),</span><br><span class="line">        label_opts=opts.LabelOpts(position=<span class="string">"right"</span>),</span><br><span class="line">    )</span><br><span class="line">    .set_global_opts(title_opts=opts.TitleOpts(title=<span class="string">"Sankey-基本示例"</span>))</span><br><span class="line">    .render(<span class="string">"sankey_base.html"</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><br><strong>查看html源代码</strong>：<br>二选一</p>
<ol>
<li>用浏览器打开<code>sankey_base.html</code>，右键选择“查看源代码”或<code>Ctrl+U</code></li>
<li>用Visual Sudio Code打开<code>sankey_base.html</code><br>查看源代码<br><meta name="referrer" content="no-referrer"><img src="/python-pyecharts%E6%A8%A1%E5%9D%97/code1.png" class title="html源代码">
</li>
</ol>
<p><strong>安装PPT插件</strong>：<br>打开PowerPoint，选择“插入”——“获取加载项”——搜索“html”，添加“Office Apps Fiddle for PowerPoint”。</p>
<p><meta name="referrer" content="no-referrer"><br><img src="/python-pyecharts%E6%A8%A1%E5%9D%97/pic2.png" class title="安装PPT插件"></p>
<p>将html的源代码粘贴到该插件的“HTML”中</p>
<p><meta name="referrer" content="no-referrer"><br><img src="/python-pyecharts%E6%A8%A1%E5%9D%97/pic.png" class title="粘贴html源代码"></p>
<p>点击“Run Fiddle!”按钮，会报错</p>
<p><meta name="referrer" content="no-referrer"><br><img src="/python-pyecharts%E6%A8%A1%E5%9D%97/pic3.png" class title="报错"></p>
<p>点击“×”，并点击齿轮“Setting”；再次点击“Run Fiddle!”按钮，即可成功生成交互式echarts。</p>
<p><meta name="referrer" content="no-referrer"><br><img src="/python-pyecharts%E6%A8%A1%E5%9D%97/pic4.png" class title="成功的交互式桑基图"></p>
<p>非第一次使用该插件，可从“插入”——“我的加载项”中找到该插件。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://pyecharts.org/#/" target="_blank" rel="noopener">pyecharts官方文档</a></li>
<li><a href="http://gallery.pyecharts.org/#/" target="_blank" rel="noopener">Pyecharts-Gallary</a></li>
<li><a href="https://campus.alibaba.com/traineePositions.htm?spm=a1z3e1.11874847.0.0.5d8d4928Tx32T7&amp;refno=12394" target="_blank" rel="noopener">如何把pyecharts的炫酷延续到PPT里？</a></li>
<li><a href="https://echarts.apache.org/examples/zh/" target="_blank" rel="noopener">百度官方Echarts</a></li>
</ul>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>数据分析 | AARRR模型</title>
    <url>/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90-AARRR%E6%A8%A1%E5%9E%8B.html</url>
    <content><![CDATA[<p><center></center><br><a id="more"></a></p>
<h1 id="AARRR模型"><a href="#AARRR模型" class="headerlink" title="AARRR模型"></a>AARRR模型</h1><p><strong>AARRR模型</strong>是经典的用户分析模型，是一个典型的漏斗结构。</p>
<p>AARRR也称“海盗指标”，由风险投资人Dave McClure创造。Dave McClure将创业公司最需要关注的指标分为五大类：</p>
<ul>
<li><strong>Acquisition</strong> 获取用户</li>
<li><strong>Activation</strong> 提高活跃度（激发活跃）</li>
<li><strong>Retention</strong> 提高留存率</li>
<li><strong>Revenue</strong> 获取营收</li>
<li><strong>Referral</strong> 自传播（传播推荐）</li>
</ul>
<blockquote>
<p>这五个指标并不一定遵守严格的先后顺序<br>eg：用户可能先推荐某一个产品后（Referral）再购买（Revenue），或者在光顾很多次（Revenue）后再注册（Acquisition）</p>
</blockquote>
<p>该模型描述了用户/客户/访客须经历的五个环节，以便企业获取价值。</p>
<p>价值不仅直接源于客户购买行为（Revenue），还来自客户作为推销者（Referral）和内容产生者（Retention）所带来的营收。</p>
<pre class="mermaid">graph TD;
    id0(获取用户) --用户从何得知你的存在--> id1(提高活跃度);</pre>

<p><meta name="referrer" content="no-referrer"><br><img src="/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90-AARRR%E6%A8%A1%E5%9E%8B/AARRR1.png" class title="百度百科-AARRR模型"></p>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: center;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: center;">
      <th>要素</th>
      <th>功用</th>
      <th>相关指标</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>获取用户<br>Acquisition</th>
      <td>通过各种各样的手段博取眼球，无论是免费还是付费的方式</td>
      <td>流量<br>提及量<br>CPC<br>搜索结果<br>用户获取成本<br>点开率</td>
    </tr>
    <tr>
      <th>提高活跃度<br>Activation</th>
      <td>将获取的“过客”式访客转化为产品的真正参与者</td>
      <td>注册人数<br>注册量<br>订阅量<br>新手教程完成量<br>至少用过一次产品的人数</td>
    </tr>
    <tr>
      <th>提高留存率<br>Retention</th>
      <td>说服用户再次光临，反复使用，表现出黏性行为</td>
      <td>用户参与度<br>距上次登录的时间<br>日/月活跃使用量<br>流失率</td>
    </tr>
    <tr>
      <th>获取营收<br>Revenue</th>
      <td>商业活动的产出<br>
      不同商业模式看重不同的产出
      <br>如购买量、广告点击率、内容产生量、订阅量等等</td>
      <td>客户终生价值<br>（免费到付费）转化率<br>平均购物车大小<br>广告点入营收</td>
    </tr>
    <tr>
      <th>自传播<br>Referral</th>
      <td>已有用户对潜在用户的病毒式传播及口碑传播</td>
      <td>邀请发送量<br>病毒式传播<br>病毒传播周期</td>
    </tr>
    <tr>
  </tr></tbody>
</table>
</div>

<h2 id="Acquisition-获取用户"><a href="#Acquisition-获取用户" class="headerlink" title="Acquisition 获取用户"></a>Acquisition 获取用户</h2><p>运营者通过各种推广渠道，以各种方式获取目标用户，并对各种营销渠道的效果进行评估，从而更加合理的确定投入策略，最小化用户获取成本（CAC）。</p>
<p>需要关注的指标：</p>
<ul>
<li><strong>日新增用户数</strong>（DNU，Day New User）：每日注册并登录（游戏）的用户数 / 每日首次登录或启动APP的用户数</li>
<li><strong>渠道曝光量</strong></li>
<li><strong>渠道转化率</strong></li>
<li><strong>日应用下载量</strong></li>
<li><strong>获客成本</strong>（CAC，Customer Acquisition Cost）</li>
</ul>
<div class="note info">
            <p>解决问题：</p><ul><li>不同渠道贡献的用户份额</li><li>是否存在大量垃圾用户</li><li>注册转化率分析</li><li>宏观走势，确定投放策略</li></ul>
          </div>
<p>低成本获客：</p>
<ol>
<li>语言——市场匹配<blockquote>
<p>2001年iPod问世——“将1000首歌放在你的口袋里”</p>
</blockquote>
</li>
<li>渠道——产品匹配<ol>
<li>口碑渠道：适合病毒式营销</li>
<li>有机渠道：适合搜索引擎优化、内容营销</li>
<li>付费渠道</li>
</ol>
</li>
</ol>
<ul>
<li><strong>展示位广告</strong>：在网站或手机App的顶部、App的开屏广告位等<ul>
<li>通常按展示次数付费（CPM，Cost Per Mille）</li>
</ul>
</li>
<li><strong>搜索广告</strong>：搜索引擎的关键字搜索，电商搜索广告（如淘宝直通车等）<ul>
<li>广告主为某一个搜索关键词出价，用户看到的搜索结果是按广告主出价的高低来排名的</li>
<li>按点击次数付费（CPC，Cost Per Click）</li>
</ul>
</li>
<li><strong>信息流广告</strong>：如微博、今日头条、知乎、朋友圈（非用户动态）里的广告<ul>
<li>根据用户的兴趣爱好进行推荐</li>
<li>按点击次数付费（CPC，Cost Per Click）或按投放的实际效果付费（CPA，Cost Per Action）</li>
</ul>
</li>
</ul>
<div class="note default">
            <p>按投放的实际效果付费（CPA，Cost Per Action）包括：</p><ol><li>按App的下载数计费（CPD，Cost Per Download）</li><li>按激活App的数量计费（CPI，Cost Per Install）</li><li>按完成购买的用户数或销售额来计算（CPS，Cost Per Sale）</li></ol>
          </div>
<h2 id="Activation-活跃度"><a href="#Activation-活跃度" class="headerlink" title="Activation 活跃度"></a>Activation 活跃度</h2><p>新增用户经过沉淀转化为活跃用户，要关注活跃用户的数量、用户使用频次、停留时间的数据。</p>
<p>需关注的指标：</p>
<ul>
<li><strong>日活跃用户数</strong>（DAU，Daily Active Users）：反映网站/APP/游戏的运营情况<div class="note info">
            <p>解决问题：</p><ul><li>核心用户规模</li><li>产品生命周期分析</li><li>产品活跃用户流失，分解活跃用户</li><li>用户活跃率</li></ul>
          </div></li>
<li><p><strong>周活跃用户数</strong>（WAU，Weekly Active Users）：最近7日（含当日）登录过应用的用户数；一般按照自然周计算</p>
<div class="note info">
            <p>解决问题：</p><ul><li>周期性用户规模</li><li>周期性变化趋势（eg：推广期和非推广期的比较）</li></ul>
          </div>
</li>
<li><p><strong>月活跃用户数</strong>（MAU，Monthly Active Users）：最近一个月（30日，含当日）登录过应用的用户数；一般按照自然月计算</p>
<div class="note info">
            <p>解决问题：</p><ul><li>用户规模稳定性</li><li>推广效果评估</li><li>总体用户规模变化</li></ul>
          </div></li>
<li><strong>活跃用户日均使用时长</strong>（DAOT，Daily Average Online Time）：了解参与黏性<script type="math/tex; mode=display">DAOT=\frac{日总在线时长}{日活跃用户数}</script><ul>
<li>时长指标可分为单次使用时长、日使用时长、周使用时长等。<div class="note info">
            <p>解决问题：</p><ul><li>分析产品的质量问题</li><li>观察不同时间维度的平均使用时长，了解不同用户群的习惯</li><li>渠道质量的衡量标准之一</li><li>留存分析的依据</li></ul>
          </div>
</li>
</ul>
</li>
</ul>
<p>如果是网页端的产品，还有以下两个指标可用于衡量网页端活跃度</p>
<ul>
<li><strong>页面浏览量</strong>（PV，Page View）：用户每打开一个网页即新增一个PV</li>
<li><strong>独立访客数</strong>（UV，Unique Visitor）：一定时间内访问网页的人数。通过cookie或IP来判断是否是同一个人</li>
</ul>
<h2 id="Retention-留存率"><a href="#Retention-留存率" class="headerlink" title="Retention 留存率"></a>Retention 留存率</h2><p>留存率：用户在某段时间开始使用应用，经过一段时间后，仍然继续使用该应用的用户占当时新增用户的比例，即留存率</p>
<ul>
<li>留存用户和留存率体现了应用的质量和保留用户的能力</li>
<li>包括新增用户留存、活跃用户留存</li>
</ul>
<script type="math/tex; mode=display">次日留存率=\frac{在t日注册并在t+1日还登录的用户数}{t日新增用户数}</script><script type="math/tex; mode=display">第3日留存率=\frac{在t日注册并在t+3日还登录的用户数}{t日新增用户数}</script><script type="math/tex; mode=display">第7日留存率=\frac{在t日注册并在t+7日还登录的用户数}{t日新增用户数}</script><script type="math/tex; mode=display">第30日留存率=\frac{在t日注册并在t+30日还登录的用户数}{t日新增用户数}</script><blockquote>
<p>+3、+7、+30，强调新增当日不计入</p>
</blockquote>
<div class="note info">
            <p>解决问题：</p><ul><li>应用质量评估</li><li>用户质量评估</li><li>用户规模衡量</li></ul>
          </div>
<ul>
<li><strong>日流失率</strong>（Day 1 Churn Ratio）=$\frac{t日登录应用但随后7日未登录应用的活跃用户数}{t日活跃用户数}$</li>
<li><strong>周流失率</strong>（Week Churn Ratio）=$\frac{t周登录过应用但随后一周未登录应用的用户数}{t周周活跃用户数}$</li>
<li><strong>月流失率</strong>（Month Churn Ratio）=$\frac{t月登录过应用但随后一个月未登录应用的用户数}{t月月活跃用户数}$</li>
</ul>
<div class="note info">
            <p>解决问题：</p><ul><li>活跃用户生命周期分析</li><li>渠道的变化情况</li><li>版本更新对用户流失的影响评估</li><li>拉动收入的运营手段变化对用户流失的影响评估</li><li>行业比较</li><li>产品中期评估</li></ul>
          </div>
<blockquote>
<p>Facebook有一个著名的40-20-10法则，即新用户次日留存率为40%，7日留存率为20%，30日留存率为10%，有这个表现的产品属于数据比较好的。</p>
</blockquote>
<h2 id="Revenue-营收"><a href="#Revenue-营收" class="headerlink" title="Revenue 营收"></a>Revenue 营收</h2><p>创造营收的方式有：应用付费、应用内的特定功能付费、广告收入、流量变现等</p>
<p>需关注的指标：</p>
<ul>
<li><strong>付费率/付费渗透率</strong>（PR或PUR，Payment Ratio）：付费用户数占活跃用户的比例</li>
<li><strong>日付费率</strong>（DPR，Daily Payment Ratio）</li>
<li><strong>月付费率</strong>（MPR，Monthly Payment Ratio）<div class="note info">
            <p>解决问题：</p><ul><li>产品的收益转化能力标准</li><li>用户付费关键点和转化周期</li><li>付费转化效果评估</li></ul>
          </div></li>
<li><strong>月付费用户数</strong>（MPU，Month Payment Users）</li>
<li><strong>活跃付费用户数</strong>（APA）=月活跃用户数（MAU）×月付费率（MPR）<div class="note info">
            <p>解决问题：</p><ul><li>产品的付费用户规模</li><li>APA的构成情况</li><li>付费群体的价值（整体稳定性分析）</li></ul>
          </div></li>
<li><strong>客单价/平均每用户收入</strong>（ARPU）：在统计时间内，活跃用户产生的平均收入（一般以月计）；ARPU用于产品定位初期的不同规模下的收入估计，也是LTV的重要参考依据<script type="math/tex; mode=display">ARPU=\frac{总收入}{活跃用户AU}=\frac{Revenue}{User}</script><script type="math/tex; mode=display">Monthly\ ARPU=\frac{Revenue}{MAU}</script><div class="note info">
            <p>解决问题：</p><ul><li>不同渠道用户质量分析</li><li>产品收益贡献分析</li><li>活跃用户人均收入与投放成本的关系</li></ul>
          </div></li>
<li><strong>平均每付费用户收入</strong>（ ARPPU）：在统计时间内，付费用户产生的平均收入（一般以月计）<script type="math/tex; mode=display">ARPPU=\frac{总收入}{活跃付费用户数APA}</script><div class="note info">
            <p>解决问题：</p><ul><li>付费用户的付费能力和梯度变化</li><li>付费用户的整体付费趋势和不同付费阶层差异</li><li>对高付费用户的价值挖掘</li></ul>
          </div></li>
<li><strong>生命周期价值</strong>（LTV，Life Time Value）：公司从用户的互动中得到的全部经济收益的总和；不区分付费与非付费用户<script type="math/tex; mode=display">LTV = ARPU \times LT（按天或月计算的平均生命周期）</script><div class="note default">
            <p>实际计算：跟踪某日或某周的新增用户，计算该批用户在随后的7日、14日、30日的累积收入贡献，除以该批新增用户数，即为累积收入/新增用户数=累积ARPU（LTV）</p>
          </div>
<div class="note info">
            <p>解决问题：</p><ul><li>用户收益贡献周期</li><li>用户群与渠道的利润贡献</li></ul>
          </div></li>
<li><strong>复购率</strong>：一定时间内，消费两次以上的用户数/总购买用户数</li>
<li><strong>销售额</strong><script type="math/tex; mode=display">销售额=用户数\times 转化率\times 客单价\times 购买频率</script><ul>
<li>购买频率是指消费者或用户在一定时间内购买某种或某类商品的次数</li>
</ul>
</li>
</ul>
<h2 id="Referral-Refer-自传播"><a href="#Referral-Refer-自传播" class="headerlink" title="Referral / Refer 自传播"></a>Referral / Refer 自传播</h2><p>口碑传播、病毒式传播</p>
<p>需关注的指标：</p>
<ul>
<li><strong>K因子</strong>（K-factor）：<script type="math/tex; mode=display">K因子=每个用户向他人发出邀请的数量\times 接收到邀请的人转化为新用户的转化率</script><ul>
<li>K&gt;1：用户群会不断增长</li>
<li>K&lt;1：用户群达到某个规模会停止自传播增长</li>
</ul>
</li>
<li><strong>转化率</strong></li>
</ul>
<h1 id="RARRA模型"><a href="#RARRA模型" class="headerlink" title="RARRA模型"></a>RARRA模型</h1><p>AARRR专注于Acquisition，已较为过时。现在市场上产品井喷式产出，获取用户成本较高，需更多地关注用户留存（Retention）。Thomas Petit和Gabor Papp对海盗指标AARRR进行优化，提出RARRA模型，突出用户留存的重要性。</p>
<p><meta name="referrer" content="no-referrer"><br><img src="/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90-AARRR%E6%A8%A1%E5%9E%8B/AARRR2.png" class title="RARRA模型"></p>
<pre class="mermaid">graph LR;
    id0(Retention) --> id1(Activation);
    id1 --> id2(Referral);
    id2 --> id3(Revenue);
    id3 --> id4(Acquisition);</pre>

<h2 id="Retention"><a href="#Retention" class="headerlink" title="Retention"></a>Retention</h2><p>提高用户留存</p>
<ul>
<li>快速修复产品出现的错误并不断优化产品<blockquote>
<ul>
<li>游戏中不断推出的新式神、新皮肤、新联动（痒痒鼠，说的就是你！）</li>
</ul>
</blockquote>
</li>
<li>视频网站的高质量内容产出</li>
</ul>
<h2 id="Activation"><a href="#Activation" class="headerlink" title="Activation"></a>Activation</h2><p>加快用户激活</p>
<ul>
<li>为用户提供愉快、舒适的第一次体验</li>
<li>引导用户注册成为注册用户</li>
<li>新用户注册奖励</li>
</ul>
<h2 id="Referral"><a href="#Referral" class="headerlink" title="Referral"></a>Referral</h2><p>建立有效的推荐系统</p>
<ul>
<li>提供现金返还或折扣券/优惠券等推荐奖励机制</li>
<li>有研究表明，绝大多数人信任朋友的推荐</li>
</ul>
<h2 id="Revenue"><a href="#Revenue" class="headerlink" title="Revenue"></a>Revenue</h2><p>营收</p>
<p>提高用户的终身价值</p>
<ul>
<li>发送阶段性成就和进度的电子邮件</li>
<li>询问用户反馈</li>
</ul>
<h2 id="Acquisition"><a href="#Acquisition" class="headerlink" title="Acquisition"></a>Acquisition</h2><p>优化获客渠道</p>
<ul>
<li>通过群组分析，找出获客效果最好的渠道</li>
</ul>
<h1 id="增长引擎说"><a href="#增长引擎说" class="headerlink" title="增长引擎说"></a>增长引擎说</h1><p>埃里克·莱斯提出的驱动创业增长的三大引擎</p>
<ul>
<li>黏着式增长引擎</li>
<li>病毒式增长引擎</li>
<li>付费式增长引擎</li>
</ul>
<h2 id="黏着式增长引擎"><a href="#黏着式增长引擎" class="headerlink" title="黏着式增长引擎"></a>黏着式增长引擎</h2><p>让用户成为回头客，并持续使用你的产品</p>
<ul>
<li>相关KPI：客户留存率、流失率、使用频率</li>
<li>长期黏性往往来自用户在使用产品过程中为自身创造的价值</li>
</ul>
<blockquote>
<ul>
<li>用户很难放弃使用印象笔记（Evernote）、OneNote等产品，因为其中存储了用户自己的很多资料</li>
<li>游戏玩家将游戏账号删除，也是一件很艰难的决策，删号将会失去他在游戏中辛苦赢得、积累的一切地位和虚拟物品</li>
<li>如果使用了提高用户回访的方法，比如邮件提醒和更新，则邮件的打开率和相关链接的点入率也值得关注</li>
</ul>
</blockquote>
<h2 id="病毒式增长引擎"><a href="#病毒式增长引擎" class="headerlink" title="病毒式增长引擎"></a>病毒式增长引擎</h2><p>将产品传播出去，吸引新用户</p>
<ul>
<li>相关KPI：病毒式传播系数（每个用户所带来的新用户数，衡量每一个病毒传播周期的新用户量）</li>
<li>病毒式传播系数大于1，实现增长；系数越大，增长也越迅速</li>
</ul>
<p>还需要衡量哪些用户行为形成了一个病毒传播周期（循环）、用户完成一次邀请所需的时间、病毒性的类别</p>
<blockquote>
<p>eg：大部分应用会在你注册时询问是否要同步你的通讯录好友，然后诱导你邀请通讯录好友；通讯录好友受到邀请后，可能会欣然接受，注册成为该应用的用户；这些独立的行为连结在一起，决定着社交网络的病毒性</p>
</blockquote>
<h2 id="付费式增长引擎"><a href="#付费式增长引擎" class="headerlink" title="付费式增长引擎"></a>付费式增长引擎</h2><p>一般在产品具有黏着性和病毒性之后才是付费</p>
<ul>
<li>从某种程度上讲，赚钱是识别一个商业模式是否可持续的终极指标</li>
<li>要考虑的KPI：用户终生价值（CLV）、用户获取成本（CAC）</li>
<li>创造营收之后，还要把营收的一部分用于获取用户，营收才有助于用户增长</li>
<li>把控产品整体的成本/收入关系，用户生命周期价值（LTV）远大于用户获取成本（CAC）与用户经营成本（COC）之和，意味着产品的成功</li>
</ul>
<blockquote>
<p>eg：Meteor Entertainment公司开发的《机甲世界》是一款免费多人游戏，靠游戏内的增值服务赚钱。首先专注于提高beta测试小组的使用量（黏着性），然后致力于游戏的病毒性（邀请朋友来玩），最后才是付费（玩家购买增值服务的目的是在游戏中处于更有利的地位或提升游戏体验）</p>
</blockquote>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li>《精益数据分析》</li>
<li><a href="http://www.woshipm.com/operate/2439119.html" target="_blank" rel="noopener">用户分析 | 如何建立超详细的AARRR模型数据指标体系？</a></li>
<li><a href="http://shanzhaozhang.lofter.com/post/1e096217_f735a93" target="_blank" rel="noopener">用户留存率及DNU,DAU,WAU,MAU关系</a></li>
<li><a href="https://baike.baidu.com/item/AARRR/6962373?fr=aladdin" target="_blank" rel="noopener">百度百科-AARRR</a></li>
<li><a href="http://www.woshipm.com/operate/1518912.html" target="_blank" rel="noopener">AARRR已是过去式，而RARRA才是更好的增长黑客模型</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/101042908" target="_blank" rel="noopener">AARRR模型分析方法：如何分析用户行为？</a></li>
</ul>
]]></content>
      <categories>
        <category>数据分析</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
        <tag>业务向</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html</url>
    <content><![CDATA[<p><center>Data Structure</center><br><a id="more"></a></p>
<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><p>在数据结构中，</p>
<ul>
<li><u>数据元素</u>是数据的基本单位</li>
<li><u>数据项</u>是构成数据元素的最小单位</li>
</ul>
<blockquote>
<p>Data Structures by definition, the way that the data is organized in a computer’s memory very similar to the way the different kind of milks.<br>from <a href="https://courses.edx.org/courses/course-v1:Microsoft+DEV285x+3T2019/course/" target="_blank" rel="noopener">Algorithms and Data Structures</a> </p>
</blockquote>
<p>数据结构研究涉及的内容有：</p>
<ol>
<li>数据的<strong>逻辑结构</strong><ul>
<li>逻辑结构是指数据之间的逻辑关系</li>
</ul>
</li>
<li>数据的<strong>存储结构</strong><ul>
<li>存储结构是指数据的逻辑结构到计算机存储器的映射</li>
</ul>
</li>
<li>数据的<strong>运算</strong><ul>
<li>运算是指对数据元素进行加工和处理</li>
</ul>
</li>
</ol>
<p>三者的关系：</p>
<ul>
<li>三者是贯穿数据结构的主线，相辅相成</li>
</ul>
<p>数据结构：</p>
<ul>
<li>顺序表、哈希表、单链表表示几种数据结构，既描述<u>逻辑结构</u>，也描述<u>存储结构</u>和<u>数据运算</u>。</li>
<li><strong>有序表</strong>是指关键字有序的线性表，可以<u>链式存储</u>，也可以<u>顺序存储</u>，仅描述了元素之间的逻辑关系，属于<u>逻辑结构</u>。</li>
</ul>
<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><ul>
<li>合法的出栈序列条件：对于每个已出栈数之后的、切小于此数的数都必须按<u>降序</u>排列。</li>
</ul>
<h2 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h2><h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><h2 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h2><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://m.php.cn/faq/433878.html" target="_blank" rel="noopener">数据结构研究的内容涉及</a></li>
</ul>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>Machine Learning | KNN</title>
    <url>/%E7%AE%97%E6%B3%95-KNN.html</url>
    <content><![CDATA[<p><center>K最近邻算法</center><br><a id="more"></a></p>
<p>KNN</p>
<p>K-nearest neighbours</p>
<h1 id="KNN"><a href="#KNN" class="headerlink" title="KNN"></a>KNN</h1><p><strong>k最邻近算法</strong>（kNN, k-Nearest Neighbors Algorithm），是一种<u>lazy learning</u>（消极学习法）</p>
<ul>
<li>不需要使用训练集进行训练，训练的时间复杂度为0</li>
<li>kNN分类的计算复杂度和训练集中的样本数目成正比</li>
<li>kNN是一种可用于分类和回归的方法</li>
</ul>
<blockquote>
<p>In machine learning, <strong>lazy learning</strong> is a learning method in which generalization of the training data is, in theory, delayed until a query is made to the system, as opposed to in eager learning, where the system tries to generalize the training data before receiving queries.<br><strong>维基百科：Lazy Learning</strong></p>
<p>In AI, <strong>eager learning</strong> is a learning method in which the system tries to construct a general, input-independent target function during training of the system, as opposed to lazy learning, where generalization beyond the training data is delayed until a query is made to the system.<br><strong>维基百科：Eager Learning</strong></p>
</blockquote>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>假设有$m$类不同的样本数据，要判断某个待分类点A属于哪个类别，计算这个待分类点A与其他所有已知分类的样本点的距离（一般是计算<u>欧式距离</u>或<u>曼哈顿距离</u>）；距离点A最近的k个样本点中，属于同一类别的样本点数最多的那个类别记为 $i$ ，则待分类点A从属于类别 $i$ 。</p>
<p>考虑点$(x_i,y_i)$和$(x_j,y_j)$</p>
<ul>
<li><strong>欧氏距离</strong><script type="math/tex; mode=display">d=\sqrt{(x_i-x_j)^2+(y_i-y_j)^2}</script></li>
<li><strong>曼哈顿距离</strong><script type="math/tex; mode=display">d=|x_i-x_j|+|y_i-y_j|</script></li>
</ul>
<h3 id="K"><a href="#K" class="headerlink" title="K"></a>K</h3><ul>
<li>k值的选取非常重要<ul>
<li>如果k值太小，则该分类器容易受到训练数据的噪声而产生过拟合影响</li>
<li>如果k值太大，则分类器容易欠拟合；最邻近列表中可能包含远离其近邻的数据点</li>
</ul>
</li>
<li>k值一般选取1，3，5，7等较小的值</li>
<li>可以通过交叉验证来选取最优的k值</li>
</ul>
<div class="note default">
            <p>在large-scale且sparse的数据分析中，KNN的k个最近邻应该如何选择？<br>A. 随机选择<br>B. L1-norm最近的<br>C. L2-norm最近的<br>D.不用KNN</p><p>答案：D. 不用KNN</p><ul><li>KNN需要存储所有的样本</li><li>KNN需要进行繁重的距离计算量</li></ul><p>所以不适合大规模的稀疏的数据<br><a href="https://www.nowcoder.com/questionTerminal/e744eccb59194771916a15b772851d73?source=relative" target="_blank" rel="noopener">题目来源</a></p>
          </div>
<h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><ul>
<li>分类</li>
<li>回归</li>
</ul>
<p>应用：</p>
<ul>
<li>创建推荐系统</li>
<li>光学字符识别（OCR，Optical Character Recognition）：自动识别图片中的文字<ul>
<li>OCR算法提取线段、点和曲线等特征</li>
</ul>
</li>
<li>创建垃圾邮件（spam）分类器</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>适用数据：</p>
<ul>
<li>数值型</li>
<li>标称型</li>
</ul>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>精度高</li>
<li>对异常值不敏感</li>
<li>无数据输入假定</li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>时间复杂度高</li>
<li>空间复杂度高</li>
</ul>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><p>使用Python的<code>scikit-learn</code>库。<br>scikit-learn库中有若干个数据集Toy datasets。</p>
<h4 id="二分类"><a href="#二分类" class="headerlink" title="二分类"></a>二分类</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">##导入数据集生成器</span></span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> make_blobs</span><br><span class="line"><span class="comment">##导入kNN分类器</span></span><br><span class="line"><span class="keyword">from</span> sklearn.neighbors <span class="keyword">import</span> KNeighborsClassifier</span><br><span class="line"></span><br><span class="line"><span class="comment">##导入绘图工具</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="comment">###为了在Jupyter Notebook显示图片，加入以下代码行</span></span><br><span class="line">%matplotlib inline</span><br><span class="line"></span><br><span class="line"><span class="comment">##导入数据集拆分工具</span></span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"></span><br><span class="line"><span class="comment">##生成样本数n=200，分类为2的数据集</span></span><br><span class="line">data = make_blobs(n_samples=<span class="number">200</span>, centers=<span class="number">2</span>, random_state=<span class="number">8</span>)</span><br><span class="line">X, y = data</span><br><span class="line"></span><br><span class="line"><span class="comment">##可视化</span></span><br><span class="line">plt.scatter(X[:, <span class="number">0</span>], X[:, <span class="number">1</span>], c=y, cmap=plt.cm.spring, edgecolors=<span class="string">'k'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>补充图片</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 用kNN进行二分类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">kclassifier = KNeighborsClassifier()</span><br><span class="line">kclassifier.fit(X, y)</span><br><span class="line">%matplotlib inline</span><br><span class="line"><span class="comment">##横纵轴坐标范围</span></span><br><span class="line">x_min, x_max = X[:, <span class="number">0</span>].min() - <span class="number">1</span>, X[:, <span class="number">0</span>].max() + <span class="number">1</span></span><br><span class="line">y_min, y_max = X[:, <span class="number">1</span>].min() - <span class="number">1</span>, X[:, <span class="number">1</span>].max() + <span class="number">1</span></span><br><span class="line">xx, yy = np.meshgrid(np.arange(x_min, x_max, <span class="number">.02</span>),</span><br><span class="line">                    np.arange(y_min, y_max, <span class="number">.02</span>))</span><br><span class="line">Z = kclassifier.predict(np.c_[xx.ravel(), yy.ravel()])</span><br><span class="line">Z = Z.reshape(xx.shape)</span><br><span class="line">plt.pcolormesh(xx, yy, Z, cmap=plt.cm.Pastel1)</span><br><span class="line">plt.scatter(X[:, <span class="number">0</span>], X[:, <span class="number">1</span>], c=y, cmap=plt.cm.spring, edgecolors=<span class="string">'k'</span>)</span><br><span class="line">plt.xlim(xx.min(), xx.max())</span><br><span class="line">plt.ylim(yy.min(), yy.max())</span><br><span class="line">plt.title(<span class="string">"Classifier:kNN"</span>)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>补充图片</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">##对新数据点分类进行判断</span></span><br><span class="line">print(<span class="string">"新数据点的分类是："</span>, kclassifier.predict([[<span class="number">6.75</span>, <span class="number">4.82</span>]]))</span><br><span class="line"><span class="comment">#新数据点的分类是： [1]</span></span><br></pre></td></tr></table></figure>
<h4 id="多分类"><a href="#多分类" class="headerlink" title="多分类"></a>多分类</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> make_blobs</span><br><span class="line"><span class="keyword">from</span> sklearn.neighbors <span class="keyword">import</span> KNeighborsClassifier</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment">##生成样本数为500，分类数为5的数据集</span></span><br><span class="line">data2 = make_blobs(n_samples=<span class="number">500</span>, centers=<span class="number">5</span>, random_state=<span class="number">8</span>)</span><br><span class="line">X2, y2 = data2</span><br><span class="line"></span><br><span class="line">%matplotlib inline</span><br><span class="line"></span><br><span class="line">plt.scatter(X2[:, <span class="number">0</span>], X2[:,<span class="number">1</span>], c=y2, cmap=plt.cm.spring, edgecolors=<span class="string">'k'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>补充图片</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">clf = KNeighborsClassifier()</span><br><span class="line">clf.fit(X2, y2)</span><br><span class="line"></span><br><span class="line">x_min, x_max = X2[:, <span class="number">0</span>].min() - <span class="number">1</span>, X2[:, <span class="number">0</span>].max() + <span class="number">1</span></span><br><span class="line">y_min, y_max = X2[:, <span class="number">1</span>].min() - <span class="number">1</span>, X2[:, <span class="number">1</span>].max() + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">%matplotlib inline</span><br><span class="line"></span><br><span class="line">xx, yy = np.meshgrid(np.arange(x_min, x_max, <span class="number">.02</span>),</span><br><span class="line">                    np.arange(y_min, y_max, <span class="number">.02</span>))</span><br><span class="line">Z = clf.predict(np.c_[xx.ravel(), yy.ravel()])</span><br><span class="line">Z = Z.reshape(xx.shape)</span><br><span class="line"></span><br><span class="line">plt.pcolormesh(xx, yy, Z, cmap = plt.cm.Pastel1)</span><br><span class="line">plt.scatter(X2[:, <span class="number">0</span>], X2[:, <span class="number">1</span>], c=y2, cmap=plt.cm.spring, edgecolors=<span class="string">'k'</span>)</span><br><span class="line">plt.xlim(xx.min(), xx.max())</span><br><span class="line">plt.ylim(yy.min(), yy.max())</span><br><span class="line">plt.title(<span class="string">"Classifier:kNN"</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>补充图片</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">##模型的评分</span></span><br><span class="line">print(<span class="string">"模型正确率：&#123;:.2f&#125;"</span>.format(clf.score(X2, y2)))</span><br><span class="line"><span class="comment">#模型正确率：0.96</span></span><br></pre></td></tr></table></figure>
<h4 id="回归"><a href="#回归" class="headerlink" title="回归"></a>回归</h4><p>kNN的n_neighbors默认为5。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">##导入数据生成器make_regression</span></span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> make_regression</span><br><span class="line"></span><br><span class="line"><span class="comment">##生成特征数量为1，噪音为50的数据集</span></span><br><span class="line">X, y = make_regression(n_features=<span class="number">1</span>, n_informative=<span class="number">1</span>, noise=<span class="number">50</span>, random_state=<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">##可视化</span></span><br><span class="line">%matplotlib inline</span><br><span class="line">plt.scatter(X, y, c=<span class="string">'orange'</span>, edgecolors=<span class="string">'k'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>补充图片</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">##导入用于回归分析的kNN模型</span></span><br><span class="line"><span class="keyword">from</span> sklearn.neighbors <span class="keyword">import</span> KNeighborsRegressor</span><br><span class="line">reg = KNeighborsRegressor()</span><br><span class="line"></span><br><span class="line"><span class="comment">##用kNN模型拟合数据</span></span><br><span class="line">reg.fit(X, y)</span><br><span class="line"></span><br><span class="line"><span class="comment">##可视化预测结果</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">z = np.linspace(<span class="number">-3</span>, <span class="number">3</span>, <span class="number">200</span>).reshape(<span class="number">-1</span>, <span class="number">1</span>)</span><br><span class="line">%matplotlib inline</span><br><span class="line">plt.scatter(X, y, c=<span class="string">'orange'</span>, edgecolors=<span class="string">'k'</span>)</span><br><span class="line">plt.plot(z, reg.predict(z), c=<span class="string">'k'</span>, linewidth=<span class="number">3</span>)</span><br><span class="line">plt.title(<span class="string">"kNN Regressor"</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>补充图片</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">##模型评分</span></span><br><span class="line">print(<span class="string">"模型评分：&#123;:.2f&#125;"</span>.format(reg.score(X, y)))</span><br><span class="line"><span class="comment">#模型评分：0.77</span></span><br></pre></td></tr></table></figure>
<p>修改模型的<code>n_estimators</code>参数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">reg2 = KNeighborsRegressor(n_neighbors=<span class="number">2</span>)</span><br><span class="line">reg2.fit(X, y)</span><br><span class="line"></span><br><span class="line">%matplotlib inline</span><br><span class="line">plt.scatter(X, y, c=<span class="string">'orange'</span>, edgecolors=<span class="string">'k'</span>)</span><br><span class="line">plt.plot(z, reg2.predict(z), c=<span class="string">'k'</span>, linewidth=<span class="number">3</span>)</span><br><span class="line">plt.title(<span class="string">"kNN Regressor:n_neighbors=2"</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>补充图片</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="string">"模型评分为：&#123;:.2f&#125;"</span>.format(reg2.score(X, y)))</span><br><span class="line"><span class="comment">#模型评分为：0.86</span></span><br></pre></td></tr></table></figure>
<p>模型评分从0.77提升到0.86，有显著的提升。</p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><h3 id="酒的分类"><a href="#酒的分类" class="headerlink" title="酒的分类"></a>酒的分类</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">##导入数据集</span></span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_wine</span><br><span class="line">wine_dataset = load_wine()</span><br><span class="line"><span class="comment">###使用load_wine()导入的酒数据集，是一种Bunch对象，包括键（keys）和数值（values）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">###查看该数据集里的键</span></span><br><span class="line">print(<span class="string">"红酒数据集中的键：\n&#123;&#125;"</span>.format(wine_dataset.keys()))</span><br></pre></td></tr></table></figure>
<pre><code> 红酒数据集中的键：
 dict_keys([&#39;data&#39;, &#39;target&#39;, &#39;target_names&#39;, &#39;DESCR&#39;, &#39;feature_names&#39;])
</code></pre><p>数据集中包括数据data、目标分类target、目标分类名称target_names、数据描述DESCR和特征变量的名称features_names。</p>
<p>下面查看数据的样本量和变量数目：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="string">"数据概况：&#123;&#125;"</span>.format(wine_dataset[<span class="string">'data'</span>].shape))</span><br><span class="line"><span class="comment">#数据概况：(178, 13)</span></span><br></pre></td></tr></table></figure>
<p>共有178个样本，每个样本有13个特征变量。</p>
<p>下面查看该数据集的描述（超长）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(wine_dataset[<span class="string">'DESCR'</span>])</span><br></pre></td></tr></table></figure>
<pre><code> .. _wine_dataset:

 Wine recognition dataset
 ------------------------

 **Data Set Characteristics:**

 :Number of Instances: 178 (50 in each of three classes)
 :Number of Attributes: 13 numeric, predictive attributes and the class
 :Attribute Information:
     - Alcohol
     - Malic acid
     - Ash
    - Alcalinity of ash  
     - Magnesium
    - Total phenols
     - Flavanoids
     - Nonflavanoid phenols
     - Proanthocyanins
    - Color intensity
     - Hue
     - OD280/OD315 of diluted wines
     - Proline

 - class:
        - class_0
        - class_1
        - class_2

 :Summary Statistics:

 ============================= ==== ===== ======= =====
                               Min   Max   Mean     SD
 ============================= ==== ===== ======= =====
 Alcohol:                      11.0  14.8    13.0   0.8
 Malic Acid:                   0.74  5.80    2.34  1.12
 Ash:                          1.36  3.23    2.36  0.27
 Alcalinity of Ash:            10.6  30.0    19.5   3.3
 Magnesium:                    70.0 162.0    99.7  14.3
 Total Phenols:                0.98  3.88    2.29  0.63
 Flavanoids:                   0.34  5.08    2.03  1.00
 Nonflavanoid Phenols:         0.13  0.66    0.36  0.12
 Proanthocyanins:              0.41  3.58    1.59  0.57
 Colour Intensity:              1.3  13.0     5.1   2.3
 Hue:                          0.48  1.71    0.96  0.23
 OD280/OD315 of diluted wines: 1.27  4.00    2.61  0.71
 Proline:                       278  1680     746   315
 ============================= ==== ===== ======= =====

 :Missing Attribute Values: None
 :Class Distribution: class_0 (59), class_1 (71), class_2 (48)
 :Creator: R.A. Fisher
 :Donor: Michael Marshall (MARSHALL%PLU@io.arc.nasa.gov)
 :Date: July, 1988

 This is a copy of UCI ML Wine recognition datasets.
 https://archive.ics.uci.edu/ml/machine-learning-databases/wine/wine.data

 The data is the results of a chemical analysis of wines grown in the same
 region in Italy by three different cultivators. There are thirteen different
 measurements taken for different constituents found in the three types of
 wine.

 Original Owners: 

 Forina, M. et al, PARVUS - 
 An Extendible Package for Data Exploration, Classification and Correlation. 
 Institute of Pharmaceutical and Food Analysis and Technologies,
 Via Brigata Salerno, 16147 Genoa, Italy.

 Citation:

 Lichman, M. (2013). UCI Machine Learning Repository
 [http://archive.ics.uci.edu/ml]. Irvine, CA: University of California,
 School of Information and Computer Science. 

 .. topic:: References

 (1) S. Aeberhard, D. Coomans and O. de Vel, 
 Comparison of Classifiers in High Dimensional Settings, 
 Tech. Rep. no. 92-02, (1992), Dept. of Computer Science and Dept. of  
 Mathematics and Statistics, James Cook University of North Queensland. 
 (Also submitted to Technometrics). 

  The data was used with many others for comparing various 
 classifiers. The classes are separable, though only RDA 
 has achieved 100% correct classification. 
 (RDA : 100%, QDA 99.4%, LDA 98.9%, 1NN 96.1% (z-transformed data)) 
 (All results using the leave-one-out technique) 

 (2) S. Aeberhard, D. Coomans and O. de Vel, 
 &quot;THE CLASSIFICATION PERFORMANCE OF RDA&quot; 
 Tech. Rep. no. 92-01, (1992), Dept. of Computer Science and Dept. of 
 Mathematics and Statistics, James Cook University of North Queensland. 
 (Also submitted to Journal of Chemometrics).
</code></pre><p>划分训练集和测试集（使用scikit-learn中的train_test_split函数）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">##导入数据拆分工具</span></span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"></span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(wine_dataset[<span class="string">'data'</span>],</span><br><span class="line">                                                   wine_dataset[<span class="string">'target'</span>],</span><br><span class="line">                                                   random_state=<span class="number">0</span>)</span><br><span class="line"><span class="comment">###这里random_state即设置seed，固定seed则能保证每次产生的伪随机数不变；</span></span><br><span class="line"><span class="comment">###若random_state设置为0或者缺省时，则每次生成的伪随机数不同。</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">"X_train shape:&#123;&#125;"</span>.format(X_train.shape))</span><br><span class="line">print(<span class="string">"X_test shape:&#123;&#125;"</span>.format(X_test.shape))</span><br><span class="line">print(<span class="string">"y_train shape:&#123;&#125;"</span>.format(y_train.shape))</span><br><span class="line">print(<span class="string">"y_test shape:&#123;&#125;"</span>.format(y_test.shape))</span><br></pre></td></tr></table></figure>
<pre><code> X_train shape:(133, 13)
 X_test shape:(45, 13)
 y_train shape:(133,)
 y_test shape:(45,)
</code></pre><p>训练集样本数为133个，测试集样本数为45个。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">##导入kNN分类器</span></span><br><span class="line"><span class="keyword">from</span> sklearn.neighbors <span class="keyword">import</span> KNeighborsClassifier</span><br><span class="line"></span><br><span class="line"><span class="comment">##指定模型的n_neighbors参数为1</span></span><br><span class="line">knn = KNeighborsClassifier(n_neighbors=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">knn.fit(X_train, y_train)</span><br><span class="line">print(knn)</span><br></pre></td></tr></table></figure>
<p>score()：计算模型的得分（得分越高，则表示吻合度越高，模型表现越好）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">knn.score(X_test, y_test)</span><br></pre></td></tr></table></figure>
<pre><code> 0.7555555555555555
</code></pre><p>模型对新的样本数据做出正确分类预测的概率为76%。</p>
<p>对新的红酒分类：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">X_new = np.array([[<span class="number">13.2</span>, <span class="number">2.77</span>, <span class="number">2.51</span>, <span class="number">18.5</span>, <span class="number">96.6</span>, <span class="number">1.04</span>,<span class="number">2.55</span>, <span class="number">0.57</span>, <span class="number">1.47</span>, <span class="number">6.2</span>, <span class="number">1.05</span>, <span class="number">3.33</span>, <span class="number">820</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment">##对新的数据点进行预测</span></span><br><span class="line">prediction = knn.predict(X_new)</span><br><span class="line">print(<span class="string">"预测新红酒的分类为：&#123;&#125;"</span>.format(wine_dataset[<span class="string">'target_names'</span>][prediction]))</span><br></pre></td></tr></table></figure>
<pre><code> 预测新红酒的分类为：[&#39;class_2&#39;]
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="KNN-vs-K-Means"><a href="#KNN-vs-K-Means" class="headerlink" title="KNN vs K-Means"></a>KNN vs K-Means</h2><ul>
<li><a href="/%E7%AE%97%E6%B3%95-K-Means.html" title="K-Means算法">K-Means算法</a>
</li>
</ul>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: center;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: center;">
      <th></th>
      <th>K-Means</th>
      <th>KNN</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>分类</th>
      <td>聚类算法</td>
      <td>分类/回归算法</td>
    </tr>
    <tr>
      <th>监督</th>
      <td>无监督学习</td>
      <td>有监督学习</td>
    </tr>
    <tr>
      <th>训练集</th>
      <td>无标签数据</td>
      <td>有标签数据<br>无序变有序</td>
    </tr>
    <tr>
      <th>相似点</th>
      <td colspan="2">都包含——给定一个点，在数据集中找离它最近的点——的过程；即，二者都使用了NN（Nearest Neighbor）算法，一般用KD树实现NN</td>
    </tr>
    <tr>
  </tr></tbody>
</table>
</div>

<h1 id="kNN图"><a href="#kNN图" class="headerlink" title="kNN图"></a>kNN图</h1><p>k-Nearest Neighbour Graph</p>
<p>假设空间中有$n$个节点，对任一节点$v_i$，找出距离<sup><a href="#fn_1" id="reffn_1">1</a></sup>它最近的$k$个邻点$v_1,\cdots,v_k$，分别将$v_i$与这$k$个邻点连结起来，形成$k$条有向边。</p>
<p>对空间中的所有顶点都按此方法进行，最后得到的图便是kNN图。</p>
<blockquote id="fn_1">
<sup>1</sup>. 欧氏距离、马氏距离、……<a href="#reffn_1" title="Jump back to footnote [1] in the text."> &#8617;</a>
</blockquote>
<ul>
<li>可用于<strong>异常点检测</strong><blockquote>
<p>在大量高维数据点中，一般正常的数据点会聚集成一个个簇，而异常数据点与正常数据点的簇距离较远</p>
</blockquote>
</li>
</ul>
<h2 id="构建kNN图"><a href="#构建kNN图" class="headerlink" title="构建kNN图"></a>构建kNN图</h2><ol>
<li>空间分割树算法（Space-Partitioning Trees）</li>
<li>局部敏感哈希算法（Locality Sensitive Hashing）</li>
<li>邻居搜索算法（Neighbor Exploring Techniques)</li>
</ol>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://book.douban.com/subject/26979890/" target="_blank" rel="noopener">图解算法</a></li>
<li><a href="https://en.wikipedia.org/wiki/Lazy_learning" target="_blank" rel="noopener">维基百科-Lazy Learning</a></li>
<li><a href="https://en.wikipedia.org/wiki/Eager_learning" target="_blank" rel="noopener">维基百科-Eager Learning</a></li>
<li>段小手.<a href="https://baike.baidu.com/item/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAPython%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/22799668?fr=aladdin" target="_blank" rel="noopener">深入浅出 Python 机器学习</a>[M]. 清华大学出版社, 2018.</li>
<li><a href="https://blog.csdn.net/Dream_angel_Z/article/details/45896449" target="_blank" rel="noopener">机器学习算法-K最近邻从原理到实现（Python）</a></li>
<li><a href="https://www.cnblogs.com/ybjourney/p/4702562.html" target="_blank" rel="noopener">机器学习（一）——K-近邻（KNN）算法</a></li>
<li><a href="http://bindog.github.io/blog/2016/06/04/from-sne-to-tsne-to-largevis/" target="_blank" rel="noopener">从SNE到t-SNE再到LargeVis</a></li>
</ul>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>机器学习</tag>
        <tag>分类</tag>
        <tag>生成式模型</tag>
      </tags>
  </entry>
  <entry>
    <title>Algorithms | 动态规划</title>
    <url>/Algo-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.html</url>
    <content><![CDATA[<p><center>Dynamic Programming</center><br><a id="more"></a></p>
<h1 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h1><blockquote>
<p>有个背包，可以装4磅的东西。怎样装以下的商品，可以使得背包里的东西价值最高？</p>
<ul>
<li>音响：3000美元，4磅</li>
<li>笔记本电脑：2000美元，3磅</li>
<li>吉他：1500美元，1磅</li>
</ul>
</blockquote>
<h2 id="简单算法"><a href="#简单算法" class="headerlink" title="简单算法"></a>简单算法</h2><p>尝试所有可能的组合，并找出价值最高的组合</p>
<blockquote>
<ul>
<li>什么也不装：0美元</li>
<li>吉他：1500美元</li>
<li>笔记本电脑：2000美元</li>
<li>音响：3000美元</li>
<li>吉他+笔记本电脑：3500美元</li>
<li><del>吉他+音响：超重</del></li>
<li><del>笔记本电脑+音响：超重</del></li>
<li><del>吉他+笔记本电脑+音响：超重</del><br>所以，价值最高的装法是：吉他+笔记本电脑</li>
</ul>
</blockquote>
<p>若涉及$n$个商品，则需计算 $2^n$ 个可能的集合，运行时间为 $O(2^n)$</p>
<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>考虑背包问题：</p>
<blockquote>
<ul>
<li>有$n$个商品</li>
<li>背包最多可装重量为$m$的物品</li>
</ul>
</blockquote>
<p>将背包划分为$n行\times m列$的网格：</p>
<blockquote>
<ul>
<li>第$i$行表示将尝试将第$i$个商品装入背包</li>
<li>第$j$列表示背包的容量为$j$</li>
<li>$(i,j)$位置的网格表示只考虑前$i$个物品，容量为$j$的背包最多可容量的物品的总价值</li>
</ul>
</blockquote>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">1</th>
<th style="text-align:center">2</th>
<th style="text-align:center">3</th>
<th style="text-align:center">4</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">吉他</td>
<td style="text-align:center">$1500</td>
<td style="text-align:center">$1500</td>
<td style="text-align:center">$1500</td>
<td style="text-align:center">$1500</td>
</tr>
<tr>
<td style="text-align:center">音响</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">笔记本电脑</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
</div>
<p>只考虑1磅的吉他，1~4容量的背包最多可容纳1500美元的物品（只能容纳吉他）。</p>
<p>第$i$行、第$j$列单元格的价值为：</p>
<script type="math/tex; mode=display">cell[i][j] = \max\{cell[i-1][j], 当前商品的价值+cell[i-1][j-当前商品的重量]\}</script><p>即，考虑下面二者中较大的那个：</p>
<ul>
<li>上一个单元格的值</li>
<li>当前商品的价值+剩余空间的价值</li>
</ul>
<p>背包问题的约束不一定是容量，也可能是：</p>
<ul>
<li>有限的时间</li>
<li>有限的金钱</li>
</ul>
<p>小结：</p>
<ul>
<li>问题可分解为离散子问题时，可使用动态规划来解决</li>
</ul>
<h3 id="最长公共子串"><a href="#最长公共子串" class="headerlink" title="最长公共子串"></a>最长公共子串</h3><p>考虑两个字符串的最长公共子串：</p>
<ul>
<li>persecute 迫害</li>
<li>prosecute 起诉</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">P</th>
<th style="text-align:center">E</th>
<th style="text-align:center">R</th>
<th style="text-align:center">S</th>
<th style="text-align:center">E</th>
<th style="text-align:center">C</th>
<th style="text-align:center">U</th>
<th style="text-align:center">T</th>
<th style="text-align:center">E</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">P</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">R</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">O</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">S</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">E</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">2</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">C</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">3</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">U</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">4</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">T</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">5</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">E</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">6</td>
</tr>
</tbody>
</table>
</div>
<p>$(i,j)$位置的网格值$cell[i][j]$为</p>
<ul>
<li>如果第$i$行的字符和第$j$行的字符<strong>不相同</strong>，则为零<script type="math/tex; mode=display">cell[i][j]=0</script></li>
<li>如果第$i$行的字符和第$j$行的字符<strong>相同</strong>，则为左上角的值加1<script type="math/tex; mode=display">cell[i][j]=cell[i-1][j-1]+1</script></li>
</ul>
<p>最长公共子串的长度为网格中的最大值。</p>
<blockquote>
<p>上例为6——“secute”</p>
</blockquote>
<p>字符串长度并不要求一致</p>
<blockquote>
<p>查找“fish”和“flash”的最长公共子串</p>
</blockquote>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">F</th>
<th style="text-align:center">L</th>
<th style="text-align:center">A</th>
<th style="text-align:center">S</th>
<th style="text-align:center">H</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">F</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">I</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">S</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">H</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">2</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>最长公共子串（“sh”）长度为2</p>
</blockquote>
<h3 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h3><p>考虑两个字符串的最长公共子序列：</p>
<ul>
<li>persecute 迫害</li>
<li>prosecute 起诉</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">P</th>
<th style="text-align:center">E</th>
<th style="text-align:center">R</th>
<th style="text-align:center">S</th>
<th style="text-align:center">E</th>
<th style="text-align:center">C</th>
<th style="text-align:center">U</th>
<th style="text-align:center">T</th>
<th style="text-align:center">E</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">P</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">R</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">2</td>
<td style="text-align:center">2</td>
<td style="text-align:center">2</td>
<td style="text-align:center">2</td>
<td style="text-align:center">2</td>
<td style="text-align:center">2</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">O</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">2</td>
<td style="text-align:center">2</td>
<td style="text-align:center">2</td>
<td style="text-align:center">2</td>
<td style="text-align:center">2</td>
<td style="text-align:center">2</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">S</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">2</td>
<td style="text-align:center">3</td>
<td style="text-align:center">3</td>
<td style="text-align:center">3</td>
<td style="text-align:center">3</td>
<td style="text-align:center">3</td>
<td style="text-align:center">3</td>
</tr>
<tr>
<td style="text-align:center">E</td>
<td style="text-align:center">1</td>
<td style="text-align:center">2</td>
<td style="text-align:center">2</td>
<td style="text-align:center">3</td>
<td style="text-align:center">4</td>
<td style="text-align:center">4</td>
<td style="text-align:center">4</td>
<td style="text-align:center">4</td>
<td style="text-align:center">4</td>
</tr>
<tr>
<td style="text-align:center">C</td>
<td style="text-align:center">1</td>
<td style="text-align:center">2</td>
<td style="text-align:center">2</td>
<td style="text-align:center">3</td>
<td style="text-align:center">4</td>
<td style="text-align:center">5</td>
<td style="text-align:center">5</td>
<td style="text-align:center">5</td>
<td style="text-align:center">5</td>
</tr>
<tr>
<td style="text-align:center">U</td>
<td style="text-align:center">1</td>
<td style="text-align:center">2</td>
<td style="text-align:center">2</td>
<td style="text-align:center">3</td>
<td style="text-align:center">4</td>
<td style="text-align:center">5</td>
<td style="text-align:center">6</td>
<td style="text-align:center">6</td>
<td style="text-align:center">6</td>
</tr>
<tr>
<td style="text-align:center">T</td>
<td style="text-align:center">1</td>
<td style="text-align:center">2</td>
<td style="text-align:center">2</td>
<td style="text-align:center">3</td>
<td style="text-align:center">3</td>
<td style="text-align:center">5</td>
<td style="text-align:center">6</td>
<td style="text-align:center">7</td>
<td style="text-align:center">7</td>
</tr>
<tr>
<td style="text-align:center">E</td>
<td style="text-align:center">1</td>
<td style="text-align:center">2</td>
<td style="text-align:center">2</td>
<td style="text-align:center">3</td>
<td style="text-align:center">4</td>
<td style="text-align:center">5</td>
<td style="text-align:center">6</td>
<td style="text-align:center">7</td>
<td style="text-align:center">8</td>
</tr>
</tbody>
</table>
</div>
<p>$(i,j)$位置的网格值$cell[i][j]$为</p>
<ul>
<li>如果第$i$行的字符和第$j$行的字符<strong>不相同</strong>，则为上方和左方较大的那个网格值<script type="math/tex; mode=display">cell[i][j]=max\{cell[i-1][j], cell[i][j-1]\}</script></li>
<li>如果第$i$行的字符和第$j$行的字符<strong>相同</strong>，则为左上角的值加1<script type="math/tex; mode=display">cell[i][j]=cell[i-1][j-1]+1</script></li>
</ul>
<p>最长公共子序列的长度为网格中的最大值。</p>
<blockquote>
<p>上例为8——“prsecute”</p>
</blockquote>
<p>字符串长度并不要求一致</p>
<blockquote>
<p> 查找“fish”和“flash”的最长公共子序列</p>
</blockquote>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">F</th>
<th style="text-align:center">L</th>
<th style="text-align:center">A</th>
<th style="text-align:center">S</th>
<th style="text-align:center">H</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">F</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">I</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">S</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">2</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">H</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">2</td>
<td style="text-align:center">3</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>最长公共子序列（“fsh”）长度为3</p>
</blockquote>
<h3 id="最长递增子序列"><a href="#最长递增子序列" class="headerlink" title="最长递增子序列"></a>最长递增子序列</h3><p>计算序列nums=$[10,9,2,5,3,7,101,18]$中的最长递增子序列的长度</p>
<p>使用长度为序列长度的数组dp，其中dp$[i]$记录以nums$[i]$为结尾的最长递增子序列的长度。</p>
<ul>
<li>dp的初始值都为1</li>
<li>nums[2]=9<ul>
<li>nums[2] &lt; nums[1]，所以dp[2]=1不变</li>
</ul>
</li>
<li>nums[3]=2 <ul>
<li>nums[3] &lt; nums[1] ，所以 dp[3]=1 不变</li>
<li>nums[3] &lt; nums[2] ，所以 dp[3]=1 不变</li>
</ul>
</li>
<li>nums[4]=5 <ul>
<li>nums[4] &lt; nums[1] ，所以 dp[4]=1 不变</li>
<li>nums[4] &lt; nums[2] ，所以 dp[4]=1 不变</li>
<li>nums[4] &gt; nums[3] ，所以 dp[4]=$\max\{$dp[4], dp[3]+1$\}$=2 </li>
</ul>
</li>
<li>nums[5]=3 <ul>
<li>nums[5] &lt; nums[1] ，所以 dp[5]=1 不变</li>
<li>nums[5] &lt; nums[2] ，所以 dp[5]=1 不变</li>
<li>nums[5] &gt; nums[3] ，所以 dp[5]=$\max\{$dp[5], dp[3]+1$\}$=2 </li>
<li>nums[5] &gt; nums[4] ，所以 dp[5]=2 不变</li>
</ul>
</li>
<li>nums[6]=7 <ul>
<li>nums[6] &lt; nums[1] ，所以 dp[6]=1 不变</li>
<li>nums[6] &lt; nums[2] ，所以 dp[6]=1 不变</li>
<li>nums[6] &gt; nums[3] ，所以 dp[6]=$\max\{$dp[6], dp[3]+1$\}$=2 </li>
<li>nums[6] &gt; nums[4] ，所以 dp[6]=$\max\{$dp[6], dp[4]+1$\}$=3 </li>
<li>nums[6] &gt; nums[5] ，所以 dp[6]=$\max\{$dp[6], dp[5]+1$\}$=3 </li>
</ul>
</li>
<li>nums[7]=101 <ul>
<li>nums[7] &gt; nums[1] ，所以 dp[7]=$\max\{$dp[7], dp[1]+1$\}$=2 </li>
<li>nums[7] &gt; nums[2] ，所以 dp[7]=$\max\{$dp[7], dp[2]+1$\}$=2 </li>
<li>nums[7] &gt; nums[3] ，所以 dp[7]=$\max\{$dp[7], dp[3]+1$\}$=2 </li>
<li>nums[7] &gt; nums[4] ，所以 dp[7]=$\max\{$dp[7], dp[4]+1$\}$=3 </li>
<li>nums[7] &gt; nums[5] ，所以 dp[7]=$\max\{$dp[7], dp[5]+1$\}$=3 </li>
<li>nums[7] &gt; nums[6] ，所以 dp[7]=$\max\{$dp[7], dp[6]+1$\}$=4 </li>
</ul>
</li>
<li>nums[8]=18 <ul>
<li>nums[8] &gt; nums[1] ，所以 dp[8]=$\max\{$dp[8], dp[1]+1$\}$=2 </li>
<li>nums[8] &gt; nums[2] ，所以 dp[8]=$\max\{$dp[8], dp[2]+1$\}$=2 </li>
<li>nums[8] &gt; nums[3] ，所以 dp[8]=$\max\{$dp[8], dp[3]+1$\}$=2 </li>
<li>nums[8] &gt; nums[4] ，所以 dp[8]=$\max\{$dp[8], dp[4]+1$\}$=3 </li>
<li>nums[8] &gt; nums[5] ，所以 dp[8]=$\max\{$dp[8], dp[5]+1$\}$=3 </li>
<li>nums[8] &gt; nums[6] ，所以 dp[8]=$\max\{$dp[8], dp[6]+1$\}$=4 </li>
<li>nums[8] &lt; nums[7] ，所以 dp[8]=4 不变</li>
</ul>
</li>
</ul>
<blockquote>
<p>序列nums=[10,9,2,5,3,7,101,18]中的最长递增子序列长度为dp[8]=4<br>最长递增子序列为$[2, 5, 7, 101]$</p>
</blockquote>
<p>在线编程：<a href="https://leetcode.com/problems/longest-increasing-subsequence/" target="_blank" rel="noopener">Leetcode-300. Longest Increasing Subsequence</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLIS</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        n = len(nums)  <span class="comment">## 列表长度</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        dp = [<span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]  <span class="comment">## 初始值都是1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i):</span><br><span class="line">                <span class="keyword">if</span> nums[i] &gt; nums[j]:</span><br><span class="line">                    dp[i] = max(dp[i], dp[j] + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> max(dp)</span><br></pre></td></tr></table></figure>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://book.douban.com/subject/26979890/" target="_blank" rel="noopener">图解算法</a></li>
<li><a href="https://www.cnblogs.com/Taskr212/p/10467227.html" target="_blank" rel="noopener">动态规划</a></li>
<li><a href="https://labuladong.github.io/ebook/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B3%BB%E5%88%97/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%AE%BE%E8%AE%A1%EF%BC%9A%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97.html" target="_blank" rel="noopener">GitHub-Fucking Algorithm-动态规划设计：最长递增子序列</a></li>
</ul>
<h1 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h1><ul>
<li><a href="https://labuladong.github.io/ebook/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B3%BB%E5%88%97/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%AF%A6%E8%A7%A3%E8%BF%9B%E9%98%B6.html#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%AF%A6%E8%A7%A3" target="_blank" rel="noopener">GitHub-Fucking Algorithm-动态规划详解</a></li>
<li><a href="https://labuladong.github.io/ebook/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B3%BB%E5%88%97/%E6%9C%80%E4%BC%98%E5%AD%90%E7%BB%93%E6%9E%84.html" target="_blank" rel="noopener">GitHub-Fucking Algorithm-最优子结构</a></li>
</ul>
]]></content>
      <categories>
        <category>基础算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Algorithms | 狄克斯特拉算法</title>
    <url>/Algo-%E7%8B%84%E5%85%8B%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95.html</url>
    <content><![CDATA[<p><center>Dijkstra's Algorithm</center><br><a id="more"></a></p>
<h1 id="狄克斯特拉算法"><a href="#狄克斯特拉算法" class="headerlink" title="狄克斯特拉算法"></a>狄克斯特拉算法</h1><ul>
<li>加权图的最快路径查找</li>
<li>只适用于<strong>有向无环图</strong>（directed acyclic graph，DAG）</li>
</ul>
<blockquote>
<p>绕环的路径不可能是最短的路径<br>无向图意味着两个节点彼此指向对方，其实是环</p>
</blockquote>
<h2 id="加权图"><a href="#加权图" class="headerlink" title="加权图"></a>加权图</h2><ul>
<li>图的每条边都有关联的数字，这些数字称为<strong>权重</strong>（weight）</li>
<li>带权重的图称为<strong>加权图</strong>（weighted graph）</li>
<li>不带权重的图称为<strong>非加权图</strong>（unweighted graph）</li>
<li>计算非加权图中的最短路径，可使用广度优先搜索</li>
<li>计算加权图中的最短路径，可使用狄克斯特拉算法</li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://book.douban.com/subject/26979890/" target="_blank" rel="noopener">图解算法</a></li>
</ul>
]]></content>
      <categories>
        <category>基础算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>基础算法</tag>
        <tag>搜索算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Python | collections</title>
    <url>/python-collections%E6%A8%A1%E5%9D%97.html</url>
    <content><![CDATA[<p><center></center><br><a id="more"></a></p>
<h1 id="collections"><a href="#collections" class="headerlink" title="collections"></a>collections</h1><h2 id="Counter"><a href="#Counter" class="headerlink" title="Counter()"></a>Counter()</h2><p>统计列表中重复项出现的次数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"></span><br><span class="line">lst = [<span class="string">'a'</span>, <span class="string">'a'</span>, <span class="string">'v'</span>, <span class="string">'c'</span>, <span class="string">'b'</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'b'</span>]</span><br><span class="line">Counter(lst)</span><br><span class="line"><span class="comment"># Counter(&#123;'a': 3, 'v': 1, 'c': 2, 'b': 3&#125;)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">lst = [<span class="string">'a'</span>, <span class="string">'a'</span>, <span class="string">'v'</span>, <span class="string">'c'</span>, <span class="string">'b'</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'b'</span>]</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> set(lst):</span><br><span class="line">    print(<span class="string">'the %s appears %d times'</span> %(item, lst.count(item)))</span><br><span class="line"><span class="comment">#the c appears 2 times</span></span><br><span class="line"><span class="comment">#the v appears 1 times</span></span><br><span class="line"><span class="comment">#the a appears 3 times</span></span><br><span class="line"><span class="comment">#the b appears 3 times</span></span><br></pre></td></tr></table></figure>
<h2 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h2><p><strong>双边队列</strong>（double-ended queue），具有队列和栈的性质，在列表（list）的基础上增加了移动、旋转和增删等</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line">d = deque()  <span class="comment">## 创建一个队列</span></span><br><span class="line">print(d)</span><br><span class="line"><span class="comment"># deque([])</span></span><br><span class="line"></span><br><span class="line">d1 = deque(range(<span class="number">10</span>))</span><br><span class="line">print(d1)</span><br><span class="line"><span class="comment"># deque([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])</span></span><br></pre></td></tr></table></figure>
<p>如果指定了参数<code>maxlen</code>，则会生成固定长度的队列；插入元素时，若队列已满，</p>
<ul>
<li>从右侧插入，会“挤掉”最左侧的元素</li>
<li>从左侧插入，会“挤掉”最右侧的元素<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d = deque(maxlen=<span class="number">3</span>)</span><br><span class="line">d.append(<span class="number">1</span>)</span><br><span class="line">d.append(<span class="number">2</span>)</span><br><span class="line">d.append(<span class="number">3</span>)</span><br><span class="line">d</span><br><span class="line"><span class="comment"># deque([1, 2, 3])</span></span><br><span class="line">d.append(<span class="number">4</span>)</span><br><span class="line">d</span><br><span class="line"><span class="comment"># deque([2, 3, 4])</span></span><br><span class="line">d.appendleft(<span class="number">5</span>)</span><br><span class="line">d</span><br><span class="line"><span class="comment"># deque([5, 2, 3])</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="append"><a href="#append" class="headerlink" title=".append()"></a>.append()</h3><p>在队列右侧添加元素</p>
<h3 id="appendleft"><a href="#appendleft" class="headerlink" title=".appendleft()"></a>.appendleft()</h3><p>在队列左侧添加元素<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h3 id="count"><a href="#count" class="headerlink" title=".count()"></a>.count()</h3><p>统计队列中某元素的个数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="extend"><a href="#extend" class="headerlink" title=".extend()"></a>.extend()</h3><p>在队列右边依次添加所有元素<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h3 id="extendleft"><a href="#extendleft" class="headerlink" title=".extendleft()"></a>.extendleft()</h3><p>在队列左侧依次添加所有元素</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d = deque([<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>])</span><br><span class="line"></span><br><span class="line">d</span><br><span class="line"><span class="comment">#  deque(['a', 'b', 'c'])</span></span><br><span class="line"></span><br><span class="line">d.extendleft([<span class="string">'d'</span>, <span class="string">'e'</span>, <span class="string">'f'</span>])</span><br><span class="line"></span><br><span class="line">d</span><br><span class="line"><span class="comment"># deque(['f', 'e', 'd', 'a', 'b', 'c'])</span></span><br></pre></td></tr></table></figure>
<h3 id="pop"><a href="#pop" class="headerlink" title=".pop()"></a>.pop()</h3><p>从队列的右侧删除（取出）一个元素</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="popleft"><a href="#popleft" class="headerlink" title=".popleft()"></a>.popleft()</h3><p>从队列的左侧删除（取出）一个元素<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h3 id="remove"><a href="#remove" class="headerlink" title=".remove()"></a>.remove()</h3><p>将队列中的某元素删除<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h3 id="reverse"><a href="#reverse" class="headerlink" title=".reverse()"></a>.reverse()</h3><p>将队列倒序<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h3 id="rotate"><a href="#rotate" class="headerlink" title=".rotate()"></a>.rotate()</h3><p><code>.rotate(n)</code></p>
<ul>
<li>$n &gt; 0$：将队列最右边的n个数据，移到队列的左边</li>
<li>$n &lt; 0$：将队列最左边的n个数据，移到队列的右边</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d = deque(range(<span class="number">10</span>))</span><br><span class="line">d</span><br><span class="line"><span class="comment"># deque([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])</span></span><br><span class="line"></span><br><span class="line">d.rotate(<span class="number">3</span>)</span><br><span class="line">d</span><br><span class="line"><span class="comment">#  deque([7, 8, 9, 0, 1, 2, 3, 4, 5, 6])</span></span><br><span class="line"></span><br><span class="line">d = deque(range(<span class="number">10</span>))</span><br><span class="line">d</span><br><span class="line"><span class="comment"># deque([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])</span></span><br><span class="line"></span><br><span class="line">d.rotate(<span class="number">-3</span>)</span><br><span class="line">d</span><br><span class="line"><span class="comment"># deque([3, 4, 5, 6, 7, 8, 9, 0, 1, 2])</span></span><br></pre></td></tr></table></figure>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://blog.csdn.net/happyrocking/article/details/80058623" target="_blank" rel="noopener">collections.deque介绍</a></li>
<li><a href="https://www.cnblogs.com/LouisZJ/p/8118637.html" target="_blank" rel="noopener">deque 双向队列</a></li>
</ul>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Data Structure | 队列</title>
    <url>/%E9%98%9F%E5%88%97.html</url>
    <content><![CDATA[<p><center>queue</center><br><a id="more"></a></p>
<h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><ul>
<li>只支持两种操作：<ol>
<li>入队</li>
<li>出队</li>
</ol>
</li>
<li>队列是一种<strong>先进先出</strong>（FIFO，First In First Out）的数据结构</li>
<li>栈是一种<strong>后进先出</strong>（LIFO，Last In First Out）的数据结构</li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://book.douban.com/subject/26979890/" target="_blank" rel="noopener">图解算法</a></li>
</ul>
]]></content>
      <categories>
        <category>基础算法</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>Algorithm | 广度优先搜索</title>
    <url>/Algo-BFS.html</url>
    <content><![CDATA[<p><center>Breadth-First Search</center><br><a id="more"></a></p>
<h1 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h1><ul>
<li>最简便的图的搜索算法之一</li>
<li>用于解决<strong>最短路径问题</strong>（shortest-path problem）</li>
</ul>
<blockquote>
<ul>
<li>编写拼写检查器：计算最少编辑多少个地方就可以把所有拼错的单词改成正确的单词</li>
<li>迷宫问题：从起点最少需要走多少步可以走到出口</li>
<li>从厦大白城出发到厦门北站，找出换乘最少的公交乘车路线</li>
<li>……</li>
</ul>
</blockquote>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><ul>
<li>搜索范围从起点开始逐渐向外延伸——先检查一度关系，再检查二度关系</li>
</ul>
<h2 id="运行时间"><a href="#运行时间" class="headerlink" title="运行时间"></a>运行时间</h2><p>图的顶点（vertice）数为$V$，边数为$E$，则广度优先搜索的运行时间为$O(V+E)$</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>[1] <a href="https://book.douban.com/subject/26979890/" target="_blank" rel="noopener">图解算法</a></p>
]]></content>
      <categories>
        <category>基础算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>基础算法</tag>
        <tag>搜索算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Hash表</title>
    <url>/Hash%E8%A1%A8.html</url>
    <content><![CDATA[<p><center></center><br><a id="more"></a></p>
<h1 id="Hash表"><a href="#Hash表" class="headerlink" title="Hash表"></a>Hash表</h1><ul>
<li>使用散列函数来确定元素的存储位置</li>
<li>对于同样的输入，散列表必须返回同样的输出</li>
<li>散列表是无序的；散列表的键值对的添加顺序不重要</li>
</ul>
<p>不同叫法：</p>
<ul>
<li><strong>Hash表</strong></li>
<li><strong>哈希表</strong></li>
<li><strong>散列表</strong></li>
<li>散列映射</li>
<li>映射</li>
<li>字典</li>
<li>关联数组</li>
</ul>
<h2 id="散列函数"><a href="#散列函数" class="headerlink" title="散列函数"></a>散列函数</h2><ul>
<li>结果必须是均匀分布的</li>
<li>映射的范围必须尽可能大</li>
<li>最糟糕的散列函数是：将所有输入都映射到散列表的同一个位置</li>
<li></li>
</ul>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>散列表实现：</p>
<ul>
<li>Python提供的散列表实现为<strong>字典</strong></li>
</ul>
<h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><ul>
<li>模拟映射关系</li>
<li>防止重复</li>
<li>用作缓存<br>缓存的数据存储在散列表中</li>
</ul>
<h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">散列表-平均情况</th>
<th style="text-align:center">散列表-最糟情况</th>
<th style="text-align:center">数组</th>
<th style="text-align:center">链表</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">查找</td>
<td style="text-align:center">$O(1)$</td>
<td style="text-align:center">$O(n)$</td>
<td style="text-align:center">$O(1)$</td>
<td style="text-align:center">$O(n)$</td>
</tr>
<tr>
<td style="text-align:center">插入</td>
<td style="text-align:center">$O(1)$</td>
<td style="text-align:center">$O(n)$</td>
<td style="text-align:center">$O(n)$</td>
<td style="text-align:center">$O(1)$</td>
</tr>
<tr>
<td style="text-align:center">删除</td>
<td style="text-align:center">$O(1)$</td>
<td style="text-align:center">$O(n)$</td>
<td style="text-align:center">$O(n)$</td>
<td style="text-align:center">$O(1)$</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>散列表的查找、插入和删除速度都非常快</li>
<li>一旦填装因子超过0.7，就该调整散列表的长度</li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://book.douban.com/subject/26979890/" target="_blank" rel="noopener">图解算法</a></li>
</ul>
]]></content>
      <categories>
        <category>基础算法</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>Algorithm | 快速排序</title>
    <url>/Algo-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F.html</url>
    <content><![CDATA[<p><center>Divide and Conquer</center><br><a id="more"></a></p>
<h1 id="D-amp-C"><a href="#D-amp-C" class="headerlink" title="D&amp;C"></a>D&amp;C</h1><p>Divide and Conquer，分而治之</p>
<ol>
<li>找出基线条件<br>基线条件尽可能简单</li>
<li>不断将问题分解，直到符合基线条件</li>
</ol>
<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><ul>
<li>一种著名的<u>递归式</u>问题解决方法</li>
<li>分而治之（D&amp;C, divide and conquer）</li>
</ul>
<blockquote>
<p>C语言标准库中的函数qsort实现的是快速排序</p>
</blockquote>
<ol>
<li>基线条件：数组为空或只包含一个元素</li>
</ol>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><ol>
<li>从数组中选择一个元素——<strong>基准值</strong>（pivot）</li>
<li>找出比基准值小的元素以及比基准值大的元素——<strong>分区</strong>（partitioning）<ul>
<li>一个由小于基准值的数字组成的子数组</li>
<li>基准值</li>
<li>一个由所有大于基准值的数字组成的子数组</li>
</ul>
</li>
<li>对左右两个子数组进行快速排序</li>
</ol>
<h2 id="运行时间"><a href="#运行时间" class="headerlink" title="运行时间"></a>运行时间</h2><ul>
<li>最糟的情况下：$O(n^2)$</li>
<li>平均情况下：$O(n\log{n})$<blockquote>
<p>最佳的情况也是平均情况，只要每次都随机地选择一个数组元素作为基准值</p>
</blockquote>
</li>
</ul>
<p>算法的运行时间通常有个<strong>常量</strong>$c$，表示算法所需的固定时间</p>
<blockquote>
<p>如：简单查找的运行时间为10ms$*n$，二分查找的运行时间为1s$*\log{n}$。其中，10ms和1s都是常量</p>
</blockquote>
<ul>
<li>通常情况下，常量几乎没什么影响</li>
<li>但有时候，常量的影响可能很大<blockquote>
<p>如：运行时间都为$O(n\log{n})$的快速排序和合并排序，快速排序将会快很多</p>
</blockquote>
</li>
</ul>
<h2 id="Python实现"><a href="#Python实现" class="headerlink" title="Python实现"></a>Python实现</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quick_sort</span><span class="params">(arr)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    使用快速排序将数组从小到大排序</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> len(arr) &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> arr  <span class="comment">## 若数组arr为空或只包含一个元素，直接返回</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        pivot = arr[<span class="number">0</span>]</span><br><span class="line">        less = [i <span class="keyword">for</span> i <span class="keyword">in</span> arr[<span class="number">1</span>:] <span class="keyword">if</span> i &lt;= pivot]</span><br><span class="line">        greater = [j <span class="keyword">for</span> j <span class="keyword">in</span> arr[<span class="number">1</span>:] <span class="keyword">if</span> j &gt; pivot]</span><br><span class="line">        <span class="keyword">return</span> quick_sort(less) + [pivot] + quick_sort(greater)</span><br><span class="line">    </span><br><span class="line">print(quick_sort([<span class="number">3</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">19</span>, <span class="number">15</span>, <span class="number">2</span>]))</span><br><span class="line"><span class="comment">## [1, 2, 3, 5, 15, 19]</span></span><br></pre></td></tr></table></figure>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>[1] <a href="https://book.douban.com/subject/26979890/" target="_blank" rel="noopener">图解算法</a></p>
]]></content>
      <categories>
        <category>基础算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title>递归</title>
    <url>/%E9%80%92%E5%BD%92.html</url>
    <content><![CDATA[<p><center>Recursion</center><br><a id="more"></a></p>
<h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><p>函数调用自己</p>
<p>每个递归函数都有两部分：</p>
<ol>
<li>基线条件（base case）<br>函数不再调用自己（避免形成无限循环）</li>
<li>递归条件（recursive case）<br>函数自己调用自己</li>
</ol>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://book.douban.com/subject/26979890/" target="_blank" rel="noopener">图解算法</a></li>
</ul>
]]></content>
      <categories>
        <category>基础算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Algorithm | 选择排序</title>
    <url>/Algo-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F.html</url>
    <content><![CDATA[<p><center>Selection Sort</center><br><a id="more"></a></p>
<h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><p>将长度为$n$的列表按从大到小（从小到大）的顺序排列</p>
<ul>
<li>遍历该列表，找出最大的那个元素，添加到另一个新列表中</li>
</ul>
<p>对于下面这个列表，想按照“play times”按从大到小排序：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:right">music</th>
<th style="text-align:center">play times</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:right">Ref:rain</td>
<td style="text-align:center">240</td>
</tr>
<tr>
<td style="text-align:right">Silly</td>
<td style="text-align:center">130</td>
</tr>
<tr>
<td style="text-align:right">remember</td>
<td style="text-align:center">163</td>
</tr>
<tr>
<td style="text-align:right">Prayer X</td>
<td style="text-align:center">287</td>
</tr>
<tr>
<td style="text-align:right">Angels</td>
<td style="text-align:center">132</td>
</tr>
<tr>
<td style="text-align:right">Let it Out</td>
<td style="text-align:center">211</td>
</tr>
<tr>
<td style="text-align:right">My Sweetest One</td>
<td style="text-align:center">126</td>
</tr>
</tbody>
</table>
</div>
<p>遍历列表，找出播放次数最大的歌曲——“Prayer X”（287次），添加到新列表中。运行时间为$O(n)$（最坏的情况下，需要n个元素都找遍了才找到）。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:right">music</th>
<th style="text-align:center">play times</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:right">Prayer X</td>
<td style="text-align:center">287</td>
</tr>
<tr>
<td style="text-align:right"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:right"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:right"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:right"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:right"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:right"></td>
</tr>
</tbody>
</table>
</div>
<p>再次遍历列表，找到播放次数第二多的音乐。运行时间为$O(n)$。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:right">music</th>
<th style="text-align:center">play times</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:right">Prayer X</td>
<td style="text-align:center">287</td>
</tr>
<tr>
<td style="text-align:right">Ref:rain</td>
<td style="text-align:center">240</td>
</tr>
<tr>
<td style="text-align:right"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:right"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:right"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:right"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:right"></td>
</tr>
</tbody>
</table>
</div>
<p>重复进行下去，直到将$n$个元素都添加到新列表。<br>每次运行时间为$O(n)$，共需要进行$n$次，所以选择排序的运行时间为$O(n^2)$。</p>
<blockquote>
<p>实际上，第一次需要检查的元素有$n$个，第二次要检查的元素个数有$n-1$个，，随后要检查的元素个数依次为$n-2,\cdots,2,1$，平均每次检查的元素个数为$\frac{1}{2}n$，因此运行时间为$O(\frac{1}{2}n^2)$，即$O(n^2)$</p>
</blockquote>
<h2 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h2><ul>
<li>用数组实现的选择排序是不稳定的</li>
<li>用链表实现的选择排序是稳定的</li>
</ul>
<p>通常使用数组实现选择排序，认为选择排序是不稳定的</p>
<h2 id="Python实现"><a href="#Python实现" class="headerlink" title="Python实现"></a>Python实现</h2><p>使用Python实现选择排序：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_smallest</span><span class="params">(arr)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    找到数组arr中最小元素的索引</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    smallest = arr[<span class="number">0</span>] <span class="comment">## 用于存储最小值</span></span><br><span class="line">    smallest_index = <span class="number">0</span>  <span class="comment">## 用于存储最小值的索引</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(arr)):</span><br><span class="line">        <span class="keyword">if</span> arr[i] &lt; smallest:</span><br><span class="line">            smallest = arr[i]</span><br><span class="line">            smallest_index = i</span><br><span class="line">    <span class="keyword">return</span> smallest_index</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">selection_sort</span><span class="params">(arr)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    对数组arr进行选择排序</span></span><br><span class="line"><span class="string">    从小到大</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    new_arr = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(arr)):</span><br><span class="line">        smallest = find_smallest(arr)</span><br><span class="line">        new_arr.append(arr.pop(smallest))</span><br><span class="line">    <span class="keyword">return</span> new_arr</span><br><span class="line"></span><br><span class="line">print(selection_sort([<span class="number">3</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">19</span>, <span class="number">15</span>, <span class="number">2</span>]))</span><br><span class="line"><span class="comment">## [1, 2, 3, 5, 15, 19]</span></span><br></pre></td></tr></table></figure></p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://book.douban.com/subject/26979890/" target="_blank" rel="noopener">图解算法</a></li>
</ul>
]]></content>
      <categories>
        <category>基础算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Algorithms and Data Structures</title>
    <url>/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95.html</url>
    <content><![CDATA[<p><center>Basic!</center><br><a id="more"></a></p>
<h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><p>一个算法应该是<u>问题求解步骤的描述</u></p>
<blockquote>
<p>Algorithm by definition is precise steps that describes the solution of a certain task or a problem.</p>
<p><strong>算法</strong>（algorithm）是对特定问题求解步骤的一种描述，是指令的有序序列，其中每一条指令表示一个或多个操作。</p>
</blockquote>
<p>算法具有5个基本特征：</p>
<ol>
<li>有穷性</li>
<li>确定性</li>
<li>可行性</li>
<li>输入（$\geq 0$）</li>
<li>输出（$\geq 1$）</li>
</ol>
<h2 id="查找方法"><a href="#查找方法" class="headerlink" title="查找方法"></a>查找方法</h2><ul>
<li><a href="/Algo-%E4%BA%8C%E5%88%86%E6%B3%95.html" title="简单查找">简单查找</a></li>
<li><a href="/Algo-%E4%BA%8C%E5%88%86%E6%B3%95.html" title="二分查找">二分查找</a>
<blockquote>
<ul>
<li>二分查找的速度比简单查找快得多</li>
<li>$O(\log{n})$比$O(n)$快</li>
</ul>
</blockquote>
</li>
</ul>
<h2 id="排序方法"><a href="#排序方法" class="headerlink" title="排序方法"></a>排序方法</h2><ul>
<li><a href="/Algo-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F.html" title="选择排序">选择排序</a></li>
<li><a href="/Algo-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F.html" title="快速排序">快速排序</a></li>
<li>
</li>
</ul>
<h2 id="图相关"><a href="#图相关" class="headerlink" title="图相关"></a>图相关</h2><ul>
<li><a href="/Algo-BFS.html" title="广度优先搜索">广度优先搜索</a>
<ul>
<li>用于在非加权图中查找最短路径 </li>
</ul>
</li>
<li><a href="/Algo-%E7%8B%84%E5%85%8B%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95.html" title="狄克斯特拉算法">狄克斯特拉算法</a>
<ul>
<li>Dijkstra’s Algorithm</li>
<li>用于在加权图中查找最短路径</li>
<li>不能用于包含负权边的图</li>
</ul>
</li>
<li>
<ul>
<li>用于含负权边的加权图查找最短路径</li>
</ul>
</li>
<li>
</li>
</ul>
<h2 id><a href="#" class="headerlink" title=" "></a> </h2><ul>
<li><a href="/%E9%80%92%E5%BD%92.html" title="递归">递归</a></li>
<li><a href="/Algo-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.html" title="背包问题">背包问题</a>
<ul>
<li><a href="/Algo-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.html" title="动态规划">动态规划</a>
</li>
</ul>
</li>
</ul>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><ul>
<li><a href="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html" title="数据结构">数据结构</a>
<ul>
<li><a href="/%E6%A0%91.html" title="树">树</a></li>
<li>
</li>
</ul>
</li>
</ul>
<h1 id="通用知识"><a href="#通用知识" class="headerlink" title="通用知识"></a>通用知识</h1><h2 id="运行时间"><a href="#运行时间" class="headerlink" title="运行时间"></a>运行时间</h2><ul>
<li>算法运行时间并不以秒为单位</li>
<li>算法运行时间是从其增速的角度度量的</li>
<li>算法运行时间用<strong>大O表示法</strong>表示</li>
</ul>
<h3 id="大O表示法"><a href="#大O表示法" class="headerlink" title="大O表示法"></a>大O表示法</h3><ul>
<li>指出了算法运行时间的增速<blockquote>
<p>表示的并非是以秒为单位的速度</p>
</blockquote>
</li>
<li>指出了最糟情况下的运行时间</li>
</ul>
<p>常见的<strong>大O运行时间</strong>：</p>
<ul>
<li>$O(\log{n})$：对数时间<ul>
<li>二分查找</li>
</ul>
</li>
<li>$O(n)$：线性时间<ul>
<li>简单查找</li>
</ul>
</li>
<li>$O(n\log{n})$<ul>
<li>快速排序</li>
</ul>
</li>
<li>$O(n^2)$<ul>
<li>选择排序</li>
</ul>
</li>
<li>$O(n!)$<ul>
<li>旅行商问题</li>
</ul>
</li>
</ul>
<p>算法的运行时间通常有个<strong>常量</strong>$c$，表示算法所需的固定时间</p>
<blockquote>
<p>如：简单查找的运行时间为10ms$*n$，二分查找的运行时间为1s$*\log{n}$。其中，10ms和1s都是常量</p>
</blockquote>
<ul>
<li>通常情况下，常量几乎没什么影响</li>
<li>但有时候，常量的影响可能很大<blockquote>
<p>如：运行时间都为$O(n\log{n})$的快速排序和合并排序，快速排序将会快很多</p>
</blockquote>
</li>
</ul>
<p>常见的数组和链表操作的运行时间：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">数组</th>
<th style="text-align:center">链表</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">读取</td>
<td style="text-align:center">$O(1)$<sup><a href="#fn_1" id="reffn_1">1</a></sup></td>
<td style="text-align:center">$O(n)$<sup><a href="#fn_2" id="reffn_2">2</a></sup></td>
</tr>
<tr>
<td style="text-align:center">插入</td>
<td style="text-align:center">$O(n)$<sup><a href="#fn_3" id="reffn_3">3</a></sup></td>
<td style="text-align:center">$O(1)$<sup><a href="#fn_4" id="reffn_4">4</a></sup></td>
</tr>
<tr>
<td style="text-align:center">删除</td>
<td style="text-align:center">$O(n)$<sup><a href="#fn_5" id="reffn_5">5</a></sup></td>
<td style="text-align:center">$O(1)$<sup><a href="#fn_6" id="reffn_6">6</a></sup></td>
</tr>
</tbody>
</table>
</div>
<blockquote id="fn_1">
<sup>1</sup>. 数组的元素的位置都已知，直接根据索引读取某元素<a href="#reffn_1" title="Jump back to footnote [1] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_2">
<sup>2</sup>. 要访问链表的某个元素，必须先访问第一个元素以获得第二个元素的地址，再访问第二个元素以获得第三个元素的地址，……<a href="#reffn_2" title="Jump back to footnote [2] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_3">
<sup>3</sup>. 在数组中插入元素时，必须将后面的元素都向后移<a href="#reffn_3" title="Jump back to footnote [3] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_4">
<sup>4</sup>. 在链表中插入元素，只需修改那个元素指向的位置<a href="#reffn_4" title="Jump back to footnote [4] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_5">
<sup>5</sup>. 删除数组的某个元素后，该元素后的所有元素都需要向前移<a href="#reffn_5" title="Jump back to footnote [5] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_6">
<sup>6</sup>. 链表的第一个元素和最后一个元素已知，删除这些元素的运行时间为$O(1)$<a href="#reffn_6" title="Jump back to footnote [6] in the text."> &#8617;</a>
</blockquote>
<ul>
<li>数组擅长随机访问</li>
<li>链表擅长插入和删除</li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://tse1-mm.cn.bing.net/th/id/OIP.7h7LM5AhzNGHuM9T73jq1QHaEl?w=300&amp;h=178&amp;c=7&amp;o=5&amp;dpr=1.5&amp;pid=1.7" target="_blank" rel="noopener">首页缩略图</a></li>
<li><a href="https://book.douban.com/subject/26979890/" target="_blank" rel="noopener">图解算法</a></li>
</ul>
]]></content>
      <categories>
        <category>基础算法</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Algorithms | 二分查找</title>
    <url>/Algo-%E4%BA%8C%E5%88%86%E6%B3%95.html</url>
    <content><![CDATA[<p><center></center><br><a id="more"></a></p>
<h1 id="简单查找"><a href="#简单查找" class="headerlink" title="简单查找"></a>简单查找</h1><ul>
<li>查找某个元素是否在数组（长度为$n$）中、或者在数组的哪个位置，挨个把数组的每个元素都找一遍，找到目标元素。最糟的情况下，需要找$n$次，运行时间为$O(n)$</li>
</ul>
<p>以简单法猜1~30以内的数：</p>
<pre class="mermaid">graph TD;
    1-->|太小|2;
    2-->|太小|3;
    3-->|太小|4;
    4-->|太小|5;
    5-->|太小|...;
    ...-->|太小|29;
    29-->|太小|30;</pre>

<h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><ul>
<li>一种算法</li>
<li>快速查找有序元素列表中的符合条件的元素</li>
</ul>
<p>以二分法猜1~30以内的数：</p>
<p><pre class="mermaid">graph TD;
    15-->|太大|7;
    15-->|太小|22;
    7-->|太大|3;
    7-->|太小|11;
    3-->|太大|1;
    3-->|太小|5;
    1-->|太小|2;
    5-->|太大|4;
    5-->|太小|6;
    11-->|太大|9;
    11-->|太小|13;
    9-->|太大|8;
    13-->|太大|12;
    13-->|太小|14;
    22-->|太大|18;
    22-->|太小|26;
    18-->|太大|16;
    18-->|太小|20;
    16-->|太小|17;
    20-->|太大|19;
    20-->|太小|21;
    26-->|太大|24;
    26-->|太小|28;
    24-->|太大|23;
    24-->|太小|25;
    28-->|太大|27;
    28-->|太小|29;</pre><br>$2^5=32&gt;30$，最多只需要猜5步就好啦。</p>
<h2 id="运行时间"><a href="#运行时间" class="headerlink" title="运行时间"></a>运行时间</h2><ul>
<li>对于包含$n$个元素的列表，用二分查找最多需要$\log_2{n}步$</li>
<li>二分查找的运行时间为<strong>对数时间</strong> $O(\log{n})$</li>
<li>而普通查找的运行时间为<strong>线性时间</strong> $O(n)$</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binary_search</span><span class="params">(lst, item)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    使用二分法找到元素item在列表lst中的索引</span></span><br><span class="line"><span class="string">    lst中的元素已按从小到大排列</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    low, high = <span class="number">0</span>, len(lst) - <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> low &lt;= high:</span><br><span class="line">        mid = math.floor((low + high) / <span class="number">2</span>)</span><br><span class="line">        guess = lst[mid]</span><br><span class="line">        <span class="keyword">if</span> guess == item:</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        <span class="keyword">if</span> guess &gt; item:  <span class="comment">## 猜大了</span></span><br><span class="line">            high = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:  <span class="comment">## 猜小了</span></span><br><span class="line">            low = mid + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>
<p>例子：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_lst = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">9</span>]</span><br><span class="line">print(binary_search(my_lst, <span class="number">5</span>))</span><br><span class="line"><span class="comment">## 3</span></span><br><span class="line">print(binary_search(my_lst, <span class="number">7</span>))</span><br><span class="line"><span class="comment">## None</span></span><br></pre></td></tr></table></figure></p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://book.douban.com/subject/26979890/" target="_blank" rel="noopener">图解算法</a></li>
</ul>
<h1 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h1><ul>
<li><a href="https://labuladong.github.io/ebook/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B3%BB%E5%88%97/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%AE%BE%E8%AE%A1%EF%BC%9A%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97.html" target="_blank" rel="noopener">GitHub-Fucking Algorithm-动态规划设计：最长递增子序列(二分查找解法)</a></li>
<li><a href="https://labuladong.github.io/ebook/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E8%AF%A6%E8%A7%A3.html" target="_blank" rel="noopener">GitHub-Fucking Algorithm-二分查找详解</a></li>
</ul>
]]></content>
      <categories>
        <category>基础算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title>检验 | Mann-Whitney U检验</title>
    <url>/%E6%A3%80%E9%AA%8C-U%E6%A3%80%E9%AA%8C.html</url>
    <content><![CDATA[<p><center></center><br><a id="more"></a></p>
<h1 id="Mann-Whitney-U-检验"><a href="#Mann-Whitney-U-检验" class="headerlink" title="Mann-Whitney U 检验"></a>Mann-Whitney U 检验</h1><ul>
<li>非参数检验方法</li>
<li>Mann-Whitney U 检验是用得最广泛的两独立样本秩和检验，是与独立样本t检验相对应的方法，当样本数据的正态性、方差齐性等不能达到t检验的要求时，可使用该检验</li>
<li>该检验的原假设假设从一个总体中随机选择的值小于或大于另一个总体中随机选择的值的可能性相同</li>
</ul>
<p>不同叫法：</p>
<ul>
<li>Mann-Whitney U test</li>
<li>Mann-Whitney-Wilcoxon（MWW）</li>
<li>Wilcoxon rank-sum test</li>
<li>Wilcoxon-Mann-Whitney test</li>
</ul>
<p>Mann-Whitney U 检验的双边检验（two-tailed）的临界值表：</p>
<ul>
<li><a href="http://ocw.umb.edu/psychology/psych-270/other-materials/RelativeResourceManager.pdf" target="_blank" rel="noopener">Critical Values of the Mann-Whitney Test (Two-Tailed Testing)</a></li>
<li><a href="http://www.real-statistics.com/statistics-tables/mann-whitney-table/" target="_blank" rel="noopener">Mann-Whitney Table</a></li>
</ul>
<p>检验两组样本$\{X_1,X_2,\cdots,X_{n_1}\}$，$\{Y_1,Y_2,\cdots,Y_{n_2}\}$的均值是否有显著差别（假设这两组样本分别来自除了总体均值以外完全相同的两个总体）。</p>
<ul>
<li>原假设下，$P(X_i&gt;Y_j)=\frac{1}{2}$</li>
<li>备择假设下，$P(X_i&gt;Y_j)\neq \frac{1}{2}$</li>
</ul>
<ol>
<li>将两组数据混合，并求出每个数据的秩（按大小顺序排列）<blockquote>
<p>序列$\{3,5,2,4,5,8,9\}$排序得到$\{2,3,4,5,5,8,9\}$，则数字2的秩为1，数字3的秩为2，数字4的秩为3；数字5排序有“第4”和第“5”，则数字5的秩为$\frac{4+5}{2}=4.5$；数字8的秩为6，数字9的秩为7。<br>  所以序列$\{3,5,2,4,5,8,9\}$的秩对应为$\{2,4.5,1,3,4.5,6,7\}$</p>
</blockquote>
</li>
<li>分别求出两组样本的秩和$R_x$、$R_y$<blockquote>
<p>$R_x+R_y=\frac{N(N+1)}{2}=n_1n_2+\frac{n_1(n_1+1)}{2}+\frac{n_2(n_2+1)}{2}$<br>  其中$N=n_1+n_2$</p>
<ul>
<li>两组数据分别为$\{13,7,8,4,5\}$和$\{3,9,2,12,4,10\}$</li>
<li>混合排序后为$\{2,3,4,4,5,7,8,9,10,12,13\}$</li>
<li>排序后的序列对应的秩为$\{1,2,3.5,3.5,5,6,7,8,9,10,11\}$</li>
<li>原序列$\{13,7,8,4,5\}$在混合序列中的秩为$\{11,6,7,3.5,5\}$，秩和$R_x=11+6+7+3.5+5=32.5$</li>
<li>原序列$\{3,9,2,12,4,10\}$在混合序列中的秩为$\{2,8,1,10,3.5,9\}$，秩和$R_y=2+8+1+10+3.5+9=33.5$</li>
</ul>
</blockquote>
</li>
<li>计算Mann-Whitney U检验统计量<script type="math/tex; mode=display">U_x=\#\{X_i>Y_j\}=R_x-\frac{n_1(n_1+1)}{2}=n_1n_2+\frac{n_2(n_2+1)}{2}-R_y</script><script type="math/tex; mode=display">U_y=\#\{X_i < Y_j\}=R_y-\frac{n_2(n_2+1)}{2}=n_1n_2+\frac{n_1(n_1+1)}{2}-R_x</script>其中$n_1$是第一组样本的样本量，$n_2$是第二组样本的样本量。<br>取$U=\min\{W_1,W_2\}$；与临界值$U_\alpha$进行比较。当$U &lt; U_\alpha$时，拒绝原假设$H_0$；否则，接受$H_0$。<blockquote>
<ul>
<li>当样本量足够大时（$n_1$和$n_2$都不小于10 时，或者$n_1n_2&gt;20$时），随机变量$U$近似服从正态分布<ul>
<li>$E(U)=\frac{n_1n_2}{2}$, $D(U)=\frac{n_1n_2(n_1+n_2+1)}{12}$</li>
<li>$U_x=32.5-\frac{5*6}{2}=17.5$</li>
<li>$U_y=33.5-\frac{6*7}{2}=14.5$</li>
<li>$U=\min\{17.5,14.5\}=14.5$</li>
</ul>
</li>
</ul>
</blockquote>
</li>
<li>假设第一个总体的均值为$\mu_1$，第二个总体的均值为$\mu_2$，临界值$U_\alpha$，则<ol>
<li>$H_0:\mu_1\leq \mu_2,\quad H_1:\mu_1&gt;\mu_2$<br>如果$U&lt;-U_\alpha$，则拒绝$H_0$</li>
<li>$H_0:\mu_1\geq \mu_2,\quad H_1:\mu_1&lt;\mu_2$<br>如果$U&gt;U_\alpha$，则拒绝$H_0$</li>
<li>$H_0:\mu_1\geq \mu_2,\quad H_1:\mu_1&lt;\mu_2$<br>如果$U&gt;U_\alpha$，则拒绝$H_0$</li>
</ol>
</li>
</ol>
<h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><script type="math/tex; mode=display">E(U)=\frac{n_1n_2}{2},\quad D(U)=\frac{n_1n_2(n_1+n_2+1)}{12}</script><p>证明：<br>定义$x_i$为$X_i\in\{X_1,X_2,\cdots,X_{n_1}\}$ 在序列$\{X_1,X_2,\cdots,X_{n_1},Y_1,Y_2,\cdots,Y_{n_2}\}$中的秩（$i=1,\cdots,n_1$;$N=n_1+n_2$），则有<br>\begin{equation}<br>\begin{aligned}<br>E(x_i)&amp;=\frac{1}{N}\sum_{i=1}^{N}i=\frac{1}{N}\frac{N(N+1)}{2}=\frac{N+1}{2}=\frac{n_1+n_2+1}{2}\\<br>\sum_{i=1}^Ni^2&amp;=\frac{N(N+1)(2N+1)}{6}\\<br>\sum_{i=1}^N\sum_{j=1}^Nij&amp;=\left(\sum_{i=1}^Ni\right)\left(\sum_{j=1}^Nj\right)=\frac{N^2(N+1)^2}{4}\\<br>\sum_{i\neq j}^Nij&amp;=\sum_{i=1}^N\sum_{j=1}^Nij-\sum_{i=1}^Ni^2=\frac{N^2(N+1)^2}{4}-\frac{N(N+1)(2N+1)}{6}\\<br>E(x_i^2)&amp;=\frac{1}{N}\sum_{i=1}^Ni^2=\frac{(N+1)(2N+1)}{6}\\<br>E(x_ix_j)&amp;=\frac{1}{N(N-1)}\sum_{i\neq j}ij\\<br>&amp;=\frac{N(N+1)^2}{4(N-1)}-\frac{(N+1)(2N+1)}{6(N-1)} \quad (\mathrm{for}\ i\neq j)\\<br>\mu_x=E(R_x)&amp;=E\left(\sum_{i=1}^{n_1}x_i\right)=\sum_{i=1}^{n_1}E(x_i)=\frac{n_1(n_1+n_2+1)}{2}\\<br>Var(x_i)&amp;=E(x_i^2)-E^2(x_i)\\<br>&amp;=\frac{(N+1)(2N+1)}{6}-\left(\frac{N+1}{2}\right)^2=\frac{N^2-1}{12}\\<br>Cov(x_i,x_j)&amp;=E(x_ix_j)-E(x_i)E(x_j)\\<br>&amp;=\frac{N(N+1)^2}{4(N-1)}-\frac{(N+1)(2N+1)}{6(N-1)}-\left(\frac{N+1}{2}\right)^2=-\frac{N+1}{12}\\<br>\sigma^2_x=Var(R_x)&amp;=Var\left(\sum_{i=1}^{n_1}x_i\right)=\sum_{i=1}^{n_1}Var(x_i)+\sum_{i\neq j}^{n_1}Cov(x_i,x_j)\\<br>&amp;=\sum_{i=1}^{n_1}\frac{N^2-1}{12}+2\sum_{i&lt;j}^{n_1}\left(-\frac{N+1}{12}\right)\\<br>&amp;=n_1\frac{N^2-1}{12}+n_1(n_1-1)\left(-\frac{N+1}{12}\right)\\<br>&amp;=\frac{n_1n_2}{12}(n_1+n_2+1)<br>\end{aligned}<br>\end{equation}<br>同理，有</p>
<script type="math/tex; mode=display">\mu_y=E(R_y)=\frac{n_2(n_1+n_2+1)}{2},\quad \sigma_y^2=Var(R_y)=\frac{n_1n_2}{12}(n_1+n_2+1)</script><p>那么<br>\begin{equation}<br>  \begin{aligned}<br>E(U_1)&amp;=E\left(R_x-\frac{n_1(n_1+1)}{2}\right)=\frac{n_1n_2}{2}\\<br>E(U_2)&amp;=E\left(R_y-\frac{n_2(n_2+1)}{2}\right)=\frac{n_1n_2}{2}\\<br>Var(U_1)&amp;=Var\left(R_x-\frac{n_1(n_1+1)}{2}\right)=Var(R_x)\\<br>Var(U_2)&amp;=Var\left(R_y-\frac{n_2(n_2+1)}{2}\right)=Var(R_y)\\<br>E(U)&amp;=E\left(\min\{U_1,U_2\}\right)=\frac{n_1n_2}{2}\\<br>Var(U)&amp;=\frac{n_1n_2}{12}(n_1+n_2+1)<br>\end{aligned}<br>\end{equation}</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://www.skillsyouneed.com/num/statistics-identifying-patterns.html" target="_blank" rel="noopener">Statistical Analysis: Identifying Patterns</a></li>
<li><a href="https://en.wikipedia.org/wiki/Mann%E2%80%93Whitney_U_test" target="_blank" rel="noopener">Wiki: Mann–Whitney U test</a></li>
<li><a href="http://www.statstutor.ac.uk/resources/uploaded/mannwhitney.pdf" target="_blank" rel="noopener">The Mann-Whitney U Test</a></li>
<li><a href="https://blog.csdn.net/qq_34734303/article/details/80296316" target="_blank" rel="noopener">Mann-whitney 检验算法学习</a></li>
<li><a href="http://www.real-statistics.com/non-parametric-tests/mann-whitney-test/" target="_blank" rel="noopener">Mann-Whitney Test for Independent Samples</a></li>
<li><a href="http://www.real-statistics.com/non-parametric-tests/mann-whitney-test/mann-whitney-test-advanced/" target="_blank" rel="noopener">Mann-Whitney Test – Advanced</a></li>
</ul>
]]></content>
      <categories>
        <category>Statistics</category>
      </categories>
      <tags>
        <tag>概率统计基础</tag>
        <tag>检验</tag>
      </tags>
  </entry>
  <entry>
    <title>检验 | t检验</title>
    <url>/%E6%A3%80%E9%AA%8C-t%E6%A3%80%E9%AA%8C.html</url>
    <content><![CDATA[<p><center>t-test</center><br><a id="more"></a></p>
<ul>
<li>适用于样本量小、总体方差未知的样本</li>
<li>研究两组数据是否存在差异</li>
</ul>
<h1 id="t-分布"><a href="#t-分布" class="headerlink" title="$t$分布"></a>$t$分布</h1><p>Student’s t-distribution<sup><a href="#fn_1" id="reffn_1">1</a></sup></p>
<p>从均值为$\mu$、方差为$\sigma^2$的正态总体种抽取容量为$n$的随机样本，随机样本的</p>
<ul>
<li>均值：$\bar{x}$</li>
<li>方差：$s^2=\frac{1}{n-1}\sum_{i=1}^n(x_i-\bar{x})^2$</li>
</ul>
<p>则随机变量T</p>
<script type="math/tex; mode=display">T=\frac{\bar{x}-\mu}{s/\sqrt{n}}</script><p>服从自由度为$n-1$的$t$分布，即$T\sim t(n-1)$。</p>
<ul>
<li>$t$分布是一种典型的长尾分布</li>
</ul>
<blockquote id="fn_1">
<sup>1</sup>. ‘Student’是William Sealy Gosset的笔名<a href="#reffn_1" title="Jump back to footnote [1] in the text."> &#8617;</a>
</blockquote>
<h1 id="t-检验"><a href="#t-检验" class="headerlink" title="$t$检验"></a>$t$检验</h1><h2 id="单样本-t-检验"><a href="#单样本-t-检验" class="headerlink" title="单样本$t$检验"></a>单样本$t$检验</h2><p>设$x_1,\cdots,x_n$是来自$N(\mu,\sigma^2)$的样本，考虑如下三种关于$\mu$的检验问题：</p>
<ol>
<li><script type="math/tex; mode=display">H_0:\mu\leq\mu_0\quad vs \quad H_1:\mu>\mu_0</script></li>
<li><script type="math/tex; mode=display">H_0:\mu\geq\mu_0\quad vs \quad H_1:\mu<\mu_0</script></li>
<li><script type="math/tex; mode=display">H_0:\mu=\mu_0\quad vs \quad H_1:\mu\neq\mu_0</script></li>
</ol>
<p>对于上述检验问题.,若$\sigma$未知，则可用$t$检验统计量</p>
<script type="math/tex; mode=display">t=\frac{\bar{x}-\mu_0}{s/\sqrt{n}}=\frac{\sqrt{n}(\bar{x}-\mu_0)}{s}</script><p>来进行检验。</p>
<p>其中$s$为样本标准差</p>
<script type="math/tex; mode=display">s^2=\frac{1}{n-1}\sum_{i=1}^n(x_i-\bar{x})^2</script><p>对于给定的样本观测值计算得到的检验统计量$t$的值为</p>
<script type="math/tex; mode=display">t_0=\frac{\sqrt{n}(\bar{x}-\mu_0)}{s}</script><p>在零假设$H_0:\mu=\mu_0$下，有<br>$t\sim t(n-1)$</p>
<p>在显著性水平为$\alpha$的情况下：</p>
<ul>
<li>检验问题1：$H_0:\mu\leq\mu_0\quad vs \quad H_1:\mu&gt;\mu_0$<ul>
<li>拒绝域为<script type="math/tex; mode=display">C_1=\{t\geq t_{1-\alpha}(n-1)\}</script></li>
<li>$p$值为<script type="math/tex; mode=display">p_1=P(t\geq t_0)</script>其中$t$是服从自由度为$n-1$的$t$分布的随机变量</li>
</ul>
</li>
<li>检验问题2：$H_0:\mu\geq\mu_0\quad vs \quad H_1:\mu&lt;\mu_0$<ul>
<li>拒绝域为<script type="math/tex; mode=display">C_2=\{t\leq t_{\alpha}(n-1)\}</script></li>
<li>$p$值为<script type="math/tex; mode=display">p_2=P(t\leq t_0)</script>其中$t$是服从自由度为$n-1$的$t$分布的随机变量</li>
</ul>
</li>
<li>检验问题3：$H_0:\mu=\mu_0\quad vs \quad H_1:\mu\neq\mu_0$<ul>
<li>拒绝域为<script type="math/tex; mode=display">C_3=\{|t|\geq t_{1-\alpha/2}(n-1)\}</script></li>
<li>$p$值为<script type="math/tex; mode=display">p_3=P(|t|\geq |t_0|)</script>其中$t$是服从自由度为$n-1$的$t$分布的随机变量</li>
</ul>
</li>
</ul>
<h2 id="独立样本-t-检验"><a href="#独立样本-t-检验" class="headerlink" title="独立样本$t$检验"></a>独立样本$t$检验</h2><p>设$x_1,\cdots,x_m$是来自正态总体$N(\mu_1,\sigma_1^2)$的样本，$y_1,y_2,\cdots,y_n$是来自另一个正态总体$N(\mu_2,\sigma_2^2)$的样本，两个样本相互独立，其中</p>
<script type="math/tex; mode=display">\sigma_1=\sigma_2=\sigma但未知</script><p>考虑如下三类检验问题：</p>
<ol>
<li><script type="math/tex; mode=display">H_0:\mu_1-\mu_2 \leq 0 \quad vs \quad H_1:\mu_1-\mu_2 > 0</script></li>
<li><script type="math/tex; mode=display">H_0:\mu_1-\mu_2 \geq 0 \quad vs \quad H_1:\mu_1-\mu_2 < 0</script></li>
<li><script type="math/tex; mode=display">H_0:\mu_1-\mu_2 = 0 \quad vs \quad H_1:\mu_1-\mu_2 \neq 0</script></li>
</ol>
<p>已知$\bar{x}\sim N(\mu_1,\frac{1}{m}\sigma^2)$,$\bar{y}\sim N(\mu_2,\frac{1}{n}\sigma^2)$，且两个样本相互独立，则有</p>
<script type="math/tex; mode=display">\bar{x}-\bar{y}\sim N\left(\mu_1-\mu_2, \left(\frac{1}{m}+\frac{1}{n} \right)\sigma^2\right)</script><p>所以有</p>
<script type="math/tex; mode=display">\frac{(\bar{x}-\bar{y})-(\mu_1-\mu_2)}{\sqrt{\frac{1}{m}+\frac{1}{n}}\sigma}\sim N(0,1)</script><p>因为</p>
<script type="math/tex; mode=display">\frac{(m-1)}{\sigma^2}s_x^2=\frac{1}{\sigma^2}\sum_{i=1}^m(x_i-\bar{x})^2\sim\chi^2(m-1)</script><script type="math/tex; mode=display">\frac{(n-1)}{\sigma^2}s_y^2=\frac{1}{\sigma^2}\sum_{i=1}^n(y_i-\bar{y})^2\sim\chi^2(n-1)</script><p>所以有</p>
<script type="math/tex; mode=display">\frac{(m+n-2)}{\sigma^2}s_w^2=\frac{1}{\sigma^2}\left(\sum_{i=1}^m(x_i-\bar{x})^2+\sum_{j=1}^n(y_j-\bar{y})^2 \right)\sim\chi^2(m+n-2)</script><p>其中</p>
<script type="math/tex; mode=display">s_w^2=\frac{1}{m+n-2}\left(\sum_{i=1}^m(x_i-\bar{x})^2+\sum_{j=1}^n(y_j-\bar{y})^2 \right)</script><p>所以<br>\begin{aligned}<br>t&amp;=\frac{N(0,1)}{\sqrt{\frac{\chi^2(m+n-2)}{m+n-2}}}\sim t(m+n-2)\\<br>&amp;=\frac{\frac{(\bar{x}-\bar{y})-(\mu_1-\mu_2)}{\sqrt{\frac{1}{m}+\frac{1}{n}}\sigma}}{\sqrt{\frac{(m+n-2)}{\sigma^2}s_w^2/(m+n-2)}}\\<br>&amp;=\frac{(\bar{x}-\bar{y})-(\mu_1-\mu_2)}{s_w\sqrt{\frac{1}{m}+\frac{1}{n}}} \sim t(m+n-2)<br>\end{aligned}</p>
<p>配对样本$t$检验的统计量为</p>
<script type="math/tex; mode=display">t=\frac{\bar{x}-\bar{y}}{s_w\sqrt{\frac{1}{m}+\frac{1}{n}}} \sim t(m+n-2)</script><p>对给定样本，计算得到统计量的值为</p>
<script type="math/tex; mode=display">t_0=\frac{\bar{x}-\bar{y}}{s_w\sqrt{\frac{1}{m}+\frac{1}{n}}}</script><p>在显著性水平为$\alpha$的情况下：</p>
<ul>
<li>检验问题1：$H_0:\mu_1-\mu_2 \leq 0 \quad vs \quad H_1:\mu_1-\mu_2 &gt; 0$<ul>
<li>拒绝域为<script type="math/tex; mode=display">W_1=\{t\geq t_{1-\alpha(m+n-2)}\}</script></li>
<li>$p$值为<script type="math/tex; mode=display">p_1=P(t\geq t_0)</script></li>
</ul>
</li>
<li>$H_0:\mu_1-\mu_2 \geq 0 \quad vs \quad H_1:\mu_1-\mu_2 &lt; 0$<ul>
<li>拒绝域为<script type="math/tex; mode=display">W_2=\{t\leq t_{\alpha}(m+n-2)\}</script></li>
<li>$p$值为<script type="math/tex; mode=display">p_2=P(t\leq t_0)</script></li>
</ul>
</li>
<li>$H_0:\mu_1-\mu_2 = 0 \quad vs \quad H_1:\mu_1-\mu_2 \neq 0$<ul>
<li>拒绝域为<script type="math/tex; mode=display">W_3=\{|t|\geq t_{1-\alpha/2}(m+n-2)\}</script></li>
<li>$p$值为<script type="math/tex; mode=display">p_3=P(|t|\geq |t_0|)</script></li>
</ul>
</li>
</ul>
<h2 id="配对样本"><a href="#配对样本" class="headerlink" title="配对样本"></a>配对样本</h2><p>设配对样本为</p>
<script type="math/tex; mode=display">\mathbf{X}=\{X_1,X_2,\cdots,X_n\}</script><script type="math/tex; mode=display">\mathbf{Y}=\{Y_1,Y_2,\cdots,Y_n\}</script><p>令</p>
<script type="math/tex; mode=display">\mathbf{Z}=\{Z_1,Z_2,\cdots,Z_n\}</script><p>其中</p>
<script type="math/tex; mode=display">Z_i=X_i-Y_i</script><p>$i=1,2,\cdots,n$。</p>
<p>$\mu$是$Z$的总体均值，设假设为</p>
<script type="math/tex; mode=display">H_0:\mu=0\quad \mathrm{vs} \quad H_1:\mu\neq0</script><p>检验统计量为</p>
<script type="math/tex; mode=display">T=\frac{\overline{Z}}{S_z/\sqrt{n}}\sim t(n-1)</script><p>拒绝域为</p>
<script type="math/tex; mode=display">W=\left\{|T|\geq t_{1-\frac{\alpha}{2}}(n-1) \right\}</script><p>p值为</p>
<script type="math/tex; mode=display">p=2\cdot t_{n-1}(|T|)</script><h1 id="t-检验-vs-u-检验"><a href="#t-检验-vs-u-检验" class="headerlink" title="$t$检验 vs $u$检验"></a>$t$检验 vs $u$检验</h1><h2 id="单样本"><a href="#单样本" class="headerlink" title="单样本"></a>单样本</h2><div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: center;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: center;">
      <th>检验法</th>
      <th>$H_0$</th>
      <th>$H_1$</th>
      <th>检验统计量</th>
      <th>拒绝域</th>
      <th>$p$值</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="3">$u$检验<br>($\sigma$已知)</th>
      <td>$\mu\leq\mu_0$</td>
      <td>$\mu>\mu_0$</td>
      <td rowspan="3">$u=\frac{\bar{x}-\mu_0}{\sigma/\sqrt{n}}$</td>
      <td>$\{u\geq u_{1-\alpha}\}$</td>
      <td>$1-\Phi(u_0)$</td>
    </tr>
    <tr>
      <td>$\mu\geq\mu_0$</td>
      <td>$\mu < \mu_0$ </td>
      <td>$\{u\leq u_{\alpha}\}$</td>
      <td>$\Phi(u_0)$</td>
    </tr>
    <tr>
      <td>$\mu=\mu_0$</td>
      <td>$\mu\neq\mu_0$</td>
      <td>$\{|u|\geq u_{1-\alpha/2}\}$</td>
      <td>$2(1-\Phi(|u_0|))$</td>
    </tr>
    <tr>
      <th rowspan="3">$t$检验<br>($\sigma$未知)</th>
      <td>$\mu\leq\mu_0$</td>
      <td>$\mu>\mu_0$</td>
      <td rowspan="3">$t=\frac{\bar{x}-\mu_0}{s/\sqrt{n}}$</td>
      <td>$\{t\geq t_{1-\alpha}(n-1)\}$</td>
      <td>$P(T\geq t_0)$</td>
    </tr>
    <tr>
      <td>$\mu\geq\mu_0$</td>
      <td>$\mu < \mu_0$ </td>
      <td>$\{t\leq t_{\alpha}(n-1)\}$</td>
      <td>$P(T\leq t_0)$</td>
    </tr>
    <tr>
      <td>$\mu=\mu_0$</td>
      <td>$\mu\neq\mu_0$</td>
      <td>$\{|t|\geq t_{1-\alpha/2}(n-1)\}$</td>
      <td>$P(|T|\geq|t_0|)$</td>
    </tr>
    <tr>
  </tr></tbody>
</table>
</div>

<blockquote>
<ul>
<li>$u_0=\frac{\sqrt{n}(\bar{x}-\mu_0)}{\sigma}$</li>
<li>$T$是服从自由度为$n-1$的$t$分布的随机变量</li>
<li>$t_0=\frac{\sqrt{n}(\bar{x}-\mu_0)}{s}$</li>
</ul>
</blockquote>
<h2 id="独立样本"><a href="#独立样本" class="headerlink" title="独立样本"></a>独立样本</h2><div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: center;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: center;">
      <th>检验法</th>
      <th>$H_0$</th>
      <th>$H_1$</th>
      <th>检验统计量</th>
      <th>拒绝域</th>
      <th>$p$值</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="3">$u$检验<br>($\sigma_1,\sigma_2$已知)</th>
      <td>$\mu_1\leq\mu_2$</td>
      <td>$\mu_1>\mu_2$</td>
      <td rowspan="3">$u=\frac{\bar{x}-\bar{y}}{\sqrt{\frac{\sigma^2_1}{m}+\frac{\sigma_1^2}{n}}}$</td>
      <td>$\{u\geq u_{1-\alpha}\}$</td>
      <td>$1-\Phi(u_1)$</td>
    </tr>
    <tr>
      <td>$\mu_1\geq\mu_2$</td>
      <td>$\mu_1<\mu_2$ < td>
      <td>$\{u\leq u_{\alpha}\}$</td>
      <td>$\Phi(u_1)$</td>
    </\mu_2$></td></tr>
    <tr>
      <td>$\mu_1=\mu_2$</td>
      <td>$\mu_1\neq\mu_2$</td>
      <td>$\{|u|\geq u_{1-\alpha/2}\}$</td>
      <td>$2(1-\Phi(|u_1|))$</td>
    </tr>
    <tr>
      <th rowspan="3">$t$检验<br>($\sigma_1=\sigma_2$未知)</th>
      <td>$\mu_1\leq\mu_2$</td>
      <td>$\mu_1>\mu_2$</td>
      <td rowspan="3">$t=\frac{\bar{x}-\bar{y}}{s_w\sqrt{\frac{1}{m}+\frac{1}{n}}}$</td>
      <td>$\{t\geq t_{1-\alpha}(m+n-2)\}$</td>
      <td>$P(T_1\geq t_1)$</td>
    </tr>
    <tr>
      <td>$\mu_1\geq\mu_2$</td>
      <td>$\mu_1<\mu_2$ < td>
      <td>$\{t\leq t_{\alpha}(m+n-2)\}$</td>
      <td>$P(T_1\leq t_1)$</td>
    </\mu_2$></td></tr>
    <tr>
      <td>$\mu_1=\mu_2$</td>
      <td>$\mu_1\neq\mu_2$</td>
      <td>$\{|t|\geq t_{1-\alpha/2}(m+n-2)\}$</td>
      <td>$P(|T_1|\geq|t_1|)$</td>
    </tr>
    <th rowspan="3">大样本$u$检验<br>($m,n$充分大)</th>
      <td>$\mu_1\leq\mu_2$</td>
      <td>$\mu_1>\mu_2$</td>
      <td rowspan="3">$u=\frac{\bar{x}-\bar{y}}{\sqrt{\frac{s_x^2}{m}+\frac{s_y^2}{n}}}$</td>
      <td>$\{u\geq u_{1-\alpha}\}$</td>
      <td>$1-\Phi(u_2)$</td>
    
    <tr>
      <td>$\mu_1\geq\mu_2$</td>
      <td>$\mu_1<\mu_2$ < td>
      <td>$\{u\leq u_{\alpha}\}$</td>
      <td>$\Phi(u_2)$</td>
    </\mu_2$></td></tr>
    <tr>
      <td>$\mu_1=\mu_2$</td>
      <td>$\mu_1\neq\mu_2$</td>
      <td>$\{|u|\geq u_{1-\alpha/2}\}$</td>
      <td>$2(1-\Phi(|u_2|))$</td>
    </tr>
    <tr>
      <th rowspan="3">近似$t$检验<br>($m,n$没有很大)</th>
      <td>$\mu_1\leq\mu_2$</td>
      <td>$\mu_1>\mu_2$</td>
      <td rowspan="3">$t=\frac{\bar{x}-\bar{y}}{\sqrt{\frac{s_x^2}{m}+\frac{s_y^2}{n}}}$</td>
      <td>$\{t\geq t_{1-\alpha}(l)\}$</td>
      <td>$P(T_2\geq t_2)$</td>
    </tr>
    <tr>
      <td>$\mu_1\geq\mu_2$</td>
      <td>$\mu_1<\mu_2$ < td>
      <td>$\{t\leq t_{\alpha}(l)\}$</td>
      <td>$P(T_2\leq t_2)$</td>
    </\mu_2$></td></tr>
    <tr>
      <td>$\mu_1=\mu_2$</td>
      <td>$\mu_1\neq\mu_2$</td>
      <td>$\{|t|\geq t_{1-\alpha/2}(l)\}$</td>
      <td>$P(|T_2|\geq|t_2|)$</td>
    </tr>
    <tr>
  </tr></tbody>
</table>
</div>

<blockquote>
<ul>
<li>$u_1=\frac{\bar{x}-\bar{y}}{\sqrt{\frac{\sigma_1^2}{m}+\frac{\sigma_2^2}{n}}}$</li>
<li>$t_1=\frac{\bar{x}-\bar{y}}{s_w\sqrt{\frac{1}{m}+\frac{1}{n}}}$</li>
<li>$T_1$是服从自由度为$m+n-2$的$t$分布的随机变量</li>
<li>$u_2=\frac{\bar{x}-\bar{y}}{\sqrt{\frac{s_x^2}{m}+\frac{s_y^2}{n}}}$</li>
<li>$t_2=\frac{\bar{x}-\bar{y}}{\sqrt{\frac{s_x^2}{m}+\frac{s_y^2}{n}}}$</li>
<li>$T_2$是服从自由度为$l$的$t$分布的随机变量，其中$l$为<script type="math/tex; mode=display">l=\frac{s_x^2/m+s_y^2/n}{\frac{s_x^2}{m^2(m-1)}+\frac{s_y^2}{n^2(n-1)}}</script>$l$一般不为整数，可以取与$l$最接近的整数代替之。</li>
</ul>
</blockquote>
<h1 id="t-检验-vs-chi-2-检验"><a href="#t-检验-vs-chi-2-检验" class="headerlink" title="$t$检验 vs $\chi^2$检验"></a>$t$检验 vs $\chi^2$检验</h1><div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: center;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: center;">
      <th></th>
      <th>$t$检验</th>
      <th>$\chi^2$检验</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>用途</th>
      <td>检验两组样本之间是否存在统计意义上的差异</td>
      <td>检验两个变量之间是否有关系</td>
    </tr>
    <tr>
      <th>原假设<br>Null Hypothesis</th>
      <td>两组样本的均值不存在统计意义上的差异<br>There is no statistical difference between the means of the two groups</td>
      <td>两个变量之间没有关系<br>There is no relationship between the two variables</td>
    </tr>
    <tr>
      <th>拒绝原假设意味着</th>
      <td>两组样本的均值具有显著差异<br>the means are statistically different</td>
      <td>两个变量之间存在一定关系<br>There is a relationship between the two variables.<br>(But, it does not tell you the direction or the size of the relationship.)</td>
    </tr>
    <tr>
  </tr></tbody>
</table>
</div>



<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://www.skillsyouneed.com/num/statistics-identifying-patterns.html" target="_blank" rel="noopener">Statistical Analysis: Identifying Patterns</a></li>
<li><a href="https://book.douban.com/subject/5998092/" target="_blank" rel="noopener">概率论与数理统计教程</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/116002163" target="_blank" rel="noopener">数分面试-AB实验篇</a></li>
<li><a href="https://pages.ucsd.edu/~lspangle/CourseDocs/Ttest-v-ChiSquare.pdf" target="_blank" rel="noopener">Differences between a T-Test and Chi Square</a></li>
</ul>
]]></content>
      <categories>
        <category>Statistics</category>
      </categories>
      <tags>
        <tag>概率统计基础</tag>
        <tag>检验</tag>
      </tags>
  </entry>
  <entry>
    <title>假设检验</title>
    <url>/%E5%81%87%E8%AE%BE%E6%A3%80%E9%AA%8C.html</url>
    <content><![CDATA[<center>Hypothesis Testing</center>

<a id="more"></a>
<h1 id="假设检验"><a href="#假设检验" class="headerlink" title="假设检验"></a>假设检验</h1><p>什么是假设检验？</p>
<blockquote>
<p>假设检验是用来判断样本与样本、样本与总体的误差是由抽样误差引起还是本质差别造成的统计推断方法。</p>
</blockquote>
<h2 id="基本步骤"><a href="#基本步骤" class="headerlink" title="基本步骤"></a>基本步骤</h2><ol>
<li>建立假设</li>
<li>选择检验统计量，给出拒绝域形式</li>
<li>选择显著性水平</li>
<li>给出拒绝域</li>
<li>作出判断</li>
</ol>
<div class="note warning">
            <h2 id="参数假设检验"><a href="#参数假设检验" class="headerlink" title="参数假设检验"></a>参数假设检验</h2><p>考虑来自某个参数分布族$\{F(x,\theta)|\theta\in \Theta\}$的样本$x_1,\cdots,x_n$，其中$\Theta$为参数空间。</p><ul><li>设$\Theta_0\subset \Theta$，且$\Theta_0\neq \emptyset $</li><li>设$\Theta_1\subset \Theta$，$\Theta_0\cap \Theta_1=\emptyset$（一般是$\Theta_1=\Theta-\Theta_0=\Theta_0^c$）</li></ul><p>则命题</p><script type="math/tex; mode=display">H_0:\theta\in \Theta_0</script><p>称为一个<strong>假设</strong>或<strong>原假设</strong>或<strong>零假设</strong>（null hypothesis）。</p><p>命题</p><script type="math/tex; mode=display">H_1:\theta\in\Theta_1</script><p>称为$H_0$的<strong>对立假设</strong>或<strong>备择假设</strong>（alternative hypothesis）。</p><script type="math/tex; mode=display">H_0:\theta\in \Theta_0\quad \mathrm{vs} \quad H_1:\theta\in \Theta_1</script>
          </div>
<ol>
<li><strong>双侧假设</strong>/<strong>双边假设</strong>：如<script type="math/tex; mode=display">H_0:\theta=\theta_0\quad \mathrm{vs} \quad H_1:\theta\neq\theta_0</script></li>
<li><strong>单侧假设</strong>/<strong>单边假设</strong>：如<script type="math/tex; mode=display">H_0:\theta=\theta_0\quad \mathrm{vs} \quad H_1:\theta>\theta_0</script>或<script type="math/tex; mode=display">H_0:\theta=\theta_0\quad \mathrm{vs} \quad H_1:\theta<\theta_0</script>或<script type="math/tex; mode=display">H_0:\theta\geq\theta_0\quad \mathrm{vs} \quad H_1:\theta<\theta_0</script></li>
</ol>
<p><strong>检验</strong>假设即给出一个法则，按照法则根据给定的样本，决定接受$H_0$还是拒绝$H_0$，等价于把样本空间划分为互不相交的部分</p>
<ol>
<li><strong>拒绝域</strong>：$W$<ul>
<li>当样本属于$W$时，拒绝$H_0$</li>
</ul>
</li>
<li><strong>接受域</strong>：$\bar{W}$<ul>
<li>当样本属于$\bar{W}$时，接受$H_0$</li>
</ul>
</li>
</ol>
<p>通常通过<strong>检验统计量</strong>来判断样本所属的空间。</p>
<div class="note default">
            <p>若以样本均值$\bar{x}$为检验统计量，则检验假设</p><script type="math/tex; mode=display">H_0:\mu\geq 10\quad \mathrm{vs} \quad H_1:\mu<10</script><p>的拒绝域为</p><script type="math/tex; mode=display">W=\{(x_1,\cdots,x_n)|\bar{x}\leq c\}=\{\overline{x}\leq c\}</script><p>其中$c$为临界值（待定；根据检验统计量的分布、假设检验的置信水平确定）。</p>
          </div>
<ul>
<li>如果$(x_1,\cdots,x_n)\in W$，则拒绝$H_0$</li>
<li>如果$(x_1,\cdots,x_n)\in \overline{W}$，则接受$H_0$</li>
</ul>
<blockquote>
<ul>
<li>一个拒绝域唯一确定一个检验法则</li>
<li>一个检验法则也唯一确定一个拒绝域</li>
</ul>
</blockquote>
<div class="note warning">
            <h2 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h2><p>假设检验的两类错误</p><ul><li><p><strong>第一类错误</strong>（type Ⅰ Error）/ <strong>拒真错误</strong> / 错误拒绝 / false positive<br>$H_0$ is true but reject $H_0$</p><p>犯第一类错误概率：</p><script type="math/tex; mode=display">\alpha=P(X\in W|H_0)</script></li><li><p><strong>第二类错误</strong>（type Ⅱ Error）/ <strong>取伪错误</strong> / 错误接受<br>$H_0$ is not true but accept $H_0$</p><p>犯第二类错误概率：</p><script type="math/tex; mode=display">\beta=P(X\in \overline{W}|H_1)</script></li></ul>
          </div>
<p>无法找到一个检验使得犯两类错误的概率都尽可能地小。</p>
<div class="note warning">
            <h2 id="势函数"><a href="#势函数" class="headerlink" title="势函数"></a>势函数</h2><p>检验问题</p><script type="math/tex; mode=display">H_0:\theta\in \Theta_0\quad \mathrm{vs} \quad H_1:\theta\in \Theta_1</script><p>的拒绝域为$W$，则样本观测值$X$落在拒绝域内的概率称为该检验的<strong>势函数</strong>或<strong>功效函数</strong>（power function）</p><script type="math/tex; mode=display">g(\theta)=P_\theta(X\in W)</script><p>其中$\theta\in\Theta=\Theta_0\cup\Theta_1$。</p>
          </div>
<p>显然有</p>
<script type="math/tex; mode=display">g(\theta)=\left\{
     \begin{array}{ll}
     \alpha(\theta),&\quad \theta\in \Theta_0\\
     1-\beta(\theta), & \quad \theta\in\Theta_1
     \end{array}
     \right.</script><p>$1-\beta$也称作<strong>统计功效</strong>（Statistical Power）（正确拒绝$H_0$的概率）。</p>
<div class="note default">
            <ul><li>在样本量给定的条件下，$\alpha$与$\beta$中一个减小必导致另一个增大</li><li>不可能同时控制一个检验的犯第一类错误、犯第二类错误的概率</li></ul>
          </div>
<h2 id="显著性检验"><a href="#显著性检验" class="headerlink" title="显著性检验"></a>显著性检验</h2><p><strong>Fisher的显著性检验</strong>：仅限制犯第一类错误的概率。</p>
<div class="note warning">
            <p>对检验问题</p><script type="math/tex; mode=display">H_0:\theta\in \Theta_0\quad \mathrm{vs} \quad H_1:\theta\in \Theta_1</script><p>如果一个检验满足对任意的$\theta\in\Theta_0$，都有</p><script type="math/tex; mode=display">g(\theta)\leq \alpha</script><p>则称该检验为<strong>显著性水平为$\alpha$的显著性检验</strong>（水平为$\alpha$的检验）。</p>
          </div>
<ul>
<li>控制犯第一类错误的概率$\alpha$</li>
<li>在适当控制$\alpha$中制约$\beta$</li>
<li>$\alpha$的最常用选择为$\alpha=0.5$，此外还有$\alpha=0.1$或$\alpha=0.01$</li>
</ul>
<p>一般情况下，寻找某对假设的显著性检验的步骤如下：</p>
<ol>
<li>根据实际问题，建立假设$H_0\quad\mathrm{vs}\quad H_1$</li>
<li>选取一个合适的检验统计量$T(X)$，使当$H_0$成立时，$T$的分布完全已知，并根据$H_0$及$H_1$的特点，确定拒绝域$W$的形状</li>
<li>确定显著性水平$\alpha$</li>
<li>确定具体的拒绝域$W$</li>
<li>由样本观测值$x_1,\cdots,x_n$，计算检验统计量的值$T(x_1,\cdots,x_n)$，根据$T(x_1,\cdots,x_n)$是否属于$W$，作出判断</li>
</ol>
<div class="note warning">
            <h2 id="p值"><a href="#p值" class="headerlink" title="p值"></a>p值</h2><p>在一个假设检验问题中，利用样本观测值能够作出拒绝原假设的<u>最小的显著性水平</u>称为<strong>检验的p值</strong>。</p>
          </div>
<ul>
<li>如果$p\leq \alpha$，则在显著性水平$\alpha$下拒绝$H_0$</li>
<li>如果$p&gt;\alpha$，则在显著性水平$\alpha$下接受$H_0$</li>
</ul>
<p>在进行检验假设时，可能计算得到的p值与显著性水平$\alpha$非常接近，这时就比较难作出判断。</p>
<h1 id="检验方法"><a href="#检验方法" class="headerlink" title="检验方法"></a>检验方法</h1><h2 id="参数检验"><a href="#参数检验" class="headerlink" title="参数检验"></a>参数检验</h2><ul>
<li>两均值对比<ul>
<li>Z检验<blockquote>
<p>适用于样本量大、总体方差已知的样本</p>
</blockquote>
</li>
<li><a href="/%E6%A3%80%E9%AA%8C-t%E6%A3%80%E9%AA%8C.html" title="t检验">t检验</a>
<blockquote>
<p>适用于样本量小、总体方差未知的样本</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h2 id="非参数检验"><a href="#非参数检验" class="headerlink" title="非参数检验"></a>非参数检验</h2><ul>
<li>两均值对比<ul>
<li><a href="/%E6%A3%80%E9%AA%8C-U%E6%A3%80%E9%AA%8C.html" title="Mann-Whitney U检验">Mann-Whitney U检验</a>
</li>
</ul>
</li>
</ul>
<p><meta name="referrer" content="no-referrer"><br><img src="/%E5%81%87%E8%AE%BE%E6%A3%80%E9%AA%8C/howtochoose.png" class title="What Test?"></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">功能</th>
<th style="text-align:center">正态性</th>
<th style="text-align:center">不服从正态分布时</th>
<th style="text-align:center">方差齐性</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">单样本t检验</td>
<td style="text-align:center">与某数字对比</td>
<td style="text-align:center">服从正态分布</td>
<td style="text-align:center">单样本Wilcoxon检验</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">配对样本t检验</td>
<td style="text-align:center">配对数据差异</td>
<td style="text-align:center">差值服从正态分布</td>
<td style="text-align:center">配对Wilcoxon检验</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">独立样本t检验</td>
<td style="text-align:center">两组数据的差异</td>
<td style="text-align:center">两组数据都服从正态分布</td>
<td style="text-align:center">Mann-Whitney U检验</td>
<td style="text-align:center">要求同方差</td>
</tr>
</tbody>
</table>
</div>
<h1 id="笔试题"><a href="#笔试题" class="headerlink" title="笔试题"></a>笔试题</h1><div class="note default">
            <p>假设检验基本思想的<strong>依据</strong>是：<u>小概率事件原理</u><br>来自：<a href="https://www.nowcoder.com/test/23567918/summary" target="_blank" rel="noopener">小红书2020校招数据分析笔试题卷一</a></p>
          </div>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://tse3-mm.cn.bing.net/th/id/OIP.Kswu83OuyrC-6NiH646D-QHaGg?w=222&amp;h=160&amp;c=7&amp;o=5&amp;dpr=1.5&amp;pid=1.7" target="_blank" rel="noopener">首页缩略图</a></li>
<li><a href="https://www.skillsyouneed.com/num/statistics-identifying-patterns.html" target="_blank" rel="noopener">Statistical Analysis: Identifying Patterns</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/68736699" target="_blank" rel="noopener">三种T检验的详细区分</a></li>
<li><a href="https://book.douban.com/subject/5998092/" target="_blank" rel="noopener">概率论与数理统计教程</a></li>
</ul>
]]></content>
      <categories>
        <category>Statistics</category>
      </categories>
      <tags>
        <tag>检验</tag>
      </tags>
  </entry>
  <entry>
    <title>Machine Learning | 线性回归</title>
    <url>/%E7%AE%97%E6%B3%95-%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92.html</url>
    <content><![CDATA[<p><center>Linear Regression</center><br><a id="more"></a></p>
<h1 id="线性回归"><a href="#线性回归" class="headerlink" title="线性回归"></a>线性回归</h1><p>自变量$x$和因变量$y$之间存在线性相关关系</p>
<ul>
<li><a href="/%E7%94%9F%E6%88%90%E5%BC%8F%E6%A8%A1%E5%9E%8B-%E5%88%A4%E5%88%AB%E5%BC%8F%E6%A8%A1%E5%9E%8B.html" title="判别式模型">判别式模型</a>
</li>
</ul>
<h2 id="变量别名"><a href="#变量别名" class="headerlink" title="变量别名"></a>变量别名</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"><strong>自变量</strong></th>
<th style="text-align:center"><strong>因变量</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">input variable</td>
<td style="text-align:center">outcome variable</td>
</tr>
<tr>
<td style="text-align:center">explanatory variable</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">regressor</td>
<td style="text-align:center">regressand</td>
</tr>
<tr>
<td style="text-align:center">independent variable</td>
<td style="text-align:center">dependent variable</td>
</tr>
<tr>
<td style="text-align:center">feature</td>
<td style="text-align:center">target</td>
</tr>
<tr>
<td style="text-align:center">predictor variable</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">exogenous variable</td>
<td style="text-align:center">endogenous variable</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">criterion variable</td>
</tr>
</tbody>
</table>
</div>
<h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><ul>
<li>确定自变量对因变量影响的强度<br>to identify the strength of the effect that the independent variable(s) have on a dependent variable</li>
<li>预测效应<br>to forecast effects or impact of changes</li>
<li>预测趋势<br>to predict trends and future values</li>
</ul>
<h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><p>线性回归的类型有：</p>
<ul>
<li><strong>Simple linear regression</strong></li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">dependent variable</th>
<th style="text-align:center">independent variable</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">amount</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">type</td>
<td style="text-align:center">interval / ratio</td>
<td style="text-align:center">interval / ratio / dichotomous<sup><a href="#fn_1" id="reffn_1">1</a></sup></td>
</tr>
</tbody>
</table>
</div>
<blockquote id="fn_1">
<sup>1</sup>. dichotomous：二分类<a href="#reffn_1" title="Jump back to footnote [1] in the text."> &#8617;</a>
</blockquote>
<ul>
<li><strong>Multiple linear regression</strong></li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">dependent variable</th>
<th style="text-align:center">independent variable</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">amount</td>
<td style="text-align:center">1</td>
<td style="text-align:center">2+</td>
</tr>
<tr>
<td style="text-align:center">type</td>
<td style="text-align:center">interval / ratio</td>
<td style="text-align:center">interval / ratio / dichotomous</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li><strong>Logistic regression</strong></li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">dependent variable</th>
<th style="text-align:center">independent variable</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">amount</td>
<td style="text-align:center">1</td>
<td style="text-align:center">2+</td>
</tr>
<tr>
<td style="text-align:center">type</td>
<td style="text-align:center">dichotomous</td>
<td style="text-align:center">interval / ratio / dichotomous</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li><strong>Ordinal regression</strong></li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">dependent variable</th>
<th style="text-align:center">independent variable</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">amount</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1+</td>
</tr>
<tr>
<td style="text-align:center">type</td>
<td style="text-align:center">ordinal<sup><a href="#fn_2" id="reffn_2">2</a></sup></td>
<td style="text-align:center">nominal<sup><a href="#fn_3" id="reffn_3">3</a></sup> or dichotomous</td>
</tr>
</tbody>
</table>
</div>
<blockquote id="fn_2">
<sup>2</sup>. ordinal：有序，序数<a href="#reffn_2" title="Jump back to footnote [2] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_3">
<sup>3</sup>. nominal：名义<a href="#reffn_3" title="Jump back to footnote [3] in the text."> &#8617;</a>
</blockquote>
<ul>
<li><strong>Multinominal regression</strong></li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">dependent variable</th>
<th style="text-align:center">independent variable</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">amount</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1+</td>
</tr>
<tr>
<td style="text-align:center">type</td>
<td style="text-align:center">nominal</td>
<td style="text-align:center">interval / ratio / dichotomous</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li><strong>Discriminant analysis</strong><br>判别分析</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">dependent variable</th>
<th style="text-align:center">independent variable</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">amount</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1+</td>
</tr>
<tr>
<td style="text-align:center">type</td>
<td style="text-align:center">nominal</td>
<td style="text-align:center">interval / ratio</td>
</tr>
</tbody>
</table>
</div>
<h2 id="基本模型"><a href="#基本模型" class="headerlink" title="基本模型"></a>基本模型</h2><script type="math/tex; mode=display">y=\beta_0+\beta_1x_1+\beta_2x_2+\cdots+\beta_px_p+\varepsilon</script><ul>
<li>因变量（regressand）：$y$</li>
<li>自变量（regressor）：$x_1,\cdots,x_p$<ul>
<li>是确定性变量，不是随机变量 </li>
</ul>
</li>
<li>随机误差项：$\varepsilon$</li>
<li>截距项（intercept）：$\beta_0$</li>
<li>回归系数（regression coefficient）</li>
</ul>
<p>考虑$n$个样本、$p$个自变量$(\mathbf{X}_1,\mathbf{X}_2,\cdots, \mathbf{X}_p)$</p>
<p>\begin{equation}<br>\textbf{y}=\textbf{X} \mathbf{\beta} + \mathbf{\varepsilon}, \qquad \mathbf{\varepsilon} \sim \mathcal{N}(\mathbf{0},\sigma^2\mathbf{I})<br>\end{equation}</p>
<p>其中</p>
<script type="math/tex; mode=display">\mathbf{X}=(\mathbf{1},\mathbf{X}_1,\mathbf{X}_2,\cdots, \mathbf{X}_p)=\left(\begin{array}{cccc}
  1 & X_{11} & \cdots & X_{1p}\\
  1 & X_{21} & \cdots & X_{2p}\\
  \vdots & \vdots & \ddots & \vdots \\
  1 & X_{n1} & \cdots & X_{np}
\end{array}\right)</script><script type="math/tex; mode=display">\mathbf{\beta}=\left(\begin{array}{c}
  \beta_0\\ \beta_1 \\ \vdots \\ \beta_p
\end{array}\right),
\qquad \mathbf{\varepsilon}=
\left(\begin{array}{c}
  \varepsilon_1 \\ \varepsilon_2 \\ \vdots \\ \varepsilon_n
\end{array}\right)</script><h2 id="基本假设"><a href="#基本假设" class="headerlink" title="基本假设"></a>基本假设</h2><ol>
<li>自变量和因变量线性相关</li>
<li>自变量之间相互独立<ul>
<li>解释变量之间不存在（完全的）线性关系<script type="math/tex; mode=display">\mathrm{rank}(X)=p</script></li>
<li>若不满足，则模型具有<strong>多重共线性</strong>（Multicollinearity）</li>
</ul>
</li>
<li>随机误差项相互独立<ul>
<li>若不满足，则模型具有<strong>自相关性</strong>（Autocorrelation）</li>
</ul>
</li>
<li>$\varepsilon\sim i.i.d. N(0,\sigma^2)$<ul>
<li>随机误差项服从均值为零、方差为常数的正态分布</li>
<li>随机误差项独立同分布（i.i.d.，independent and identical distribution）<ul>
<li>随机误差项<strong>同方差</strong>（Homoskedasticity）；若不满足，则存在<strong>异方差性</strong>（Heteroskedasticity）</li>
</ul>
</li>
</ul>
</li>
<li>自变量和误差项之间相互独立</li>
</ol>
<h2 id="参数估计"><a href="#参数估计" class="headerlink" title="参数估计"></a>参数估计</h2><p>Linear regression:</p>
<script type="math/tex; mode=display">h_\beta(x)=\sum_{j=0}^p\beta_jx_j</script><p>where $x_0=1$.</p>
<p>Cost function:</p>
<script type="math/tex; mode=display">J(\beta)=\frac{1}{2n}\sum_{i=1}^n\left(h_\beta(x^{(i)})-y^{(i)}\right)^2</script><p>Objective function:</p>
<script type="math/tex; mode=display">\min_\beta J(\beta)</script><h3 id="Batch-Gradient-Descent"><a href="#Batch-Gradient-Descent" class="headerlink" title="(Batch) Gradient Descent"></a>(Batch) Gradient Descent</h3><p>（全批量）梯度下降法<br>Linear Regression with <strong>(Batch) Gradient Descent</strong>：<br>repeat until convergence $\{$</p>
<script type="math/tex; mode=display">\beta_j:=\beta_j-\alpha\frac{1}{n}\sum_{i=1}^n\left(h_\beta(x^{(i)})-y^{(i)}\right)x_j^{(i)}</script><p>for $\forall$ $j=0,1,\cdots,p$.<br>$\}$</p>
<p>其中<br>$\alpha$为<strong>学习率/学习步长</strong>（learning rate）：</p>
<ul>
<li>决定了在每一步梯度下降迭代过程中，<ul>
<li>每一步沿梯度负方向前进的长度（如果是最小化目标函数）</li>
<li>每一步沿梯度正方向前进的长度（如果是最大化目标函数）</li>
</ul>
</li>
<li>学习率过小，需要迭代的步数较多，需要花费较多的学习时间</li>
<li>学习率过大，会导致迭代过快，容易出现点在最优点的左右反复横跳（可能错过最优点）</li>
<li>需要经过多次试验，选取较优的学习率/步长</li>
</ul>
<blockquote>
<p>learning rate, $\alpha$, basically controls how big step we take downhill with gradient descent. If $\alpha$ is large, then that corresponds to a very aggressive gradient descent procedure, where we’re trying to take huge steps downhill. And if $\alpha$ is very small, then we’re taking little, little baby steps downhill.——吴恩达-机器学习</p>
</blockquote>
<h2 id="正则化"><a href="#正则化" class="headerlink" title="正则化"></a>正则化</h2><p>若训练模型过于复杂，容易出现<strong>过拟合</strong>（overfitting）问题。</p>
<p>解决方法：</p>
<ol>
<li>减少特征的数量</li>
<li>降低特征的权重，即正则化</li>
</ol>
<p><strong>正则化</strong>（Regularization）：<br>原目标函数为</p>
<script type="math/tex; mode=display">\hat{\beta}=\arg\min_\beta\left\{\sum_{i=1}^n(y_i-\sum_{j=0}^p\beta_jx_{ij})^2\right\}</script><p>在原始目标函数上添加惩罚项（penalty term）</p>
<script type="math/tex; mode=display">\hat{\beta}=\arg\min_\beta\left\{\sum_{i=1}^n(y_i-\sum_{j=0}^p\beta_jx_{ij})^2+\lambda g(\beta)\right\}</script><h3 id="岭回归"><a href="#岭回归" class="headerlink" title="岭回归"></a>岭回归</h3><p>Ridge regression</p>
<script type="math/tex; mode=display">\hat{\beta}^{ridge}={\arg\min}_\beta\left\{\sum_{i=1}^n(y_i-\sum_{j=0}^p\beta_jx_{ij})^2+\lambda \sum_{j=1}^p\beta_j^2\right\}</script><ul>
<li>若自变量间存在严重的共线性问题，普通最小二乘法并不适用，可以选用岭回归方法</li>
</ul>
<h3 id="Lasso"><a href="#Lasso" class="headerlink" title="Lasso"></a>Lasso</h3><script type="math/tex; mode=display">\hat{\beta}^{lasso}=\arg\min_\beta\left\{\sum_{i=1}^n(y_i-\sum_{j=0}^p\beta_jx_{ij})^2+\lambda \sum_{j=1}^p|\beta_j|\right\}</script><h3 id="Elastic-Net"><a href="#Elastic-Net" class="headerlink" title="Elastic Net"></a>Elastic Net</h3><script type="math/tex; mode=display">\hat{\beta}^{EN}=\arg\min_\beta\left\{\sum_{i=1}^n(y_i-\sum_{j=0}^p\beta_jx_{ij})^2+\lambda_2 \sum_{j=1}^p\beta_j^2+\lambda_1 \sum_{j=1}^p|\beta_j|\right\}</script><h2 id="残差"><a href="#残差" class="headerlink" title="残差"></a>残差</h2><script type="math/tex; mode=display">e_i=y_i-\hat{y}_i</script><h2 id="相关检验"><a href="#相关检验" class="headerlink" title="相关检验"></a>相关检验</h2><h3 id="DW检验"><a href="#DW检验" class="headerlink" title="DW检验"></a>DW检验</h3><p>用于检验残差是否具有自相关性<br>Durbin-Watson统计量</p>
<script type="math/tex; mode=display">DW=\frac{\sum_{i=2}^n(e_i-e_{i-1})^2}{\sum_{i=1}^ne_i^2}</script><h3 id="残差检验"><a href="#残差检验" class="headerlink" title="残差检验"></a>残差检验</h3><h2 id="平方和"><a href="#平方和" class="headerlink" title="平方和"></a>平方和</h2><h3 id="1-总平方和"><a href="#1-总平方和" class="headerlink" title="1. 总平方和"></a>1. 总平方和</h3><ul>
<li>总平方和</li>
<li>总离差平方和</li>
<li>SST (Sum of Squares Total)</li>
<li>TSS (Total Sum of Squares)<script type="math/tex; mode=display">\mathbf{\sum_{i=1}^n(y_i-\bar{y})^2}</script></li>
</ul>
<h3 id="2-回归平方和"><a href="#2-回归平方和" class="headerlink" title="2. 回归平方和"></a>2. 回归平方和</h3><ul>
<li>回归平方和</li>
<li>解释平方和</li>
<li>SSR (Sum of Squares Regression)</li>
<li>ESS (Explained Sum of Squares)</li>
</ul>
<script type="math/tex; mode=display">\mathbf{\sum_{i=1}^n(\hat{y}_i-\bar{y})^2}</script><h3 id="3-残差平方和"><a href="#3-残差平方和" class="headerlink" title="3. 残差平方和"></a>3. 残差平方和</h3><ul>
<li>残差平方和</li>
<li>SSE (Sum of Squared estimate of Errors/ Sum of Squares Error)</li>
<li>RSS (Residual Sum of Squares)</li>
<li>SSR (Sum of Squared Residuals)</li>
</ul>
<script type="math/tex; mode=display">\mathbf{\sum_{i=1}^n(y_i-\hat{y}_i)^2}</script><h3 id="SST-SSR-SSE"><a href="#SST-SSR-SSE" class="headerlink" title="SST=SSR+SSE"></a>SST=SSR+SSE</h3><div class="note success">
            <script type="math/tex; mode=display">SST=SSR+SSE</script>
          </div>
<div class="note default">
            <ul><li><p><strong>Simple linear regression</strong>情况</p><script type="math/tex; mode=display">y_i=\beta_0 +\beta_1 x_i+\varepsilon_i</script><p>\begin{aligned}<br>  SST&amp;=SSR+SSE\\<br>  SST&amp;=\sum_{i=1}^n(y_i-\bar{y})^2\\<br>  &amp;= \sum_{i=1}^n(y_i-\hat{y}_i+\hat{y}_i-\bar{y})^2\\<br>  &amp;= \sum_{i=1}^n(y_i-\hat{y}_i)^2 + 2\sum_{i=1}^n (y_i-\hat{y}_i)(\hat{y}_i-\bar{y})+ \sum_{i=1}^n(\hat{y}_i-\bar{y})^2\\<br>  &amp;= \sum_{i=1}^n(y_i-\hat{y}_i)^2 + \sum_{i=1}^n(\hat{y}_i-\bar{y})^2\\<br>  &amp;= SSR + SSE<br>\end{aligned}<br>下面证明</p><script type="math/tex; mode=display">\sum_{i=1}^n (y_i-\hat{y}_i)(\hat{y}_i-\bar{y})=0</script><p>在最小二乘法中，最小化$SSE$</p><script type="math/tex; mode=display">(\hat{\beta}_0,\hat{\beta}_1)=\arg \min_{\beta_0,\beta_1}\sum_{i=1}^n(y_i-\beta_0-\beta_1x_i)^2</script><p>$SSE$分别关于$\beta_0,\beta_1$求偏导<br>\begin{aligned}<br>  \frac{\partial{SSE}}{\partial{\beta_0}}&amp;=\sum_{i=1}^n2(y_i-\beta_0-\beta_1x_i)(-1)=0\\<br>  \frac{\partial{SSE}}{\partial{\beta_1}}&amp;=\sum_{i=1}^n2(y_i-\beta_0-\beta_1x_i)(-x_i)=0<br>\end{aligned}<br>所以有</p><script type="math/tex; mode=display">\sum_{i=1}^n(y_i-\hat{\beta}_0-\hat{\beta}_1x_i)=0</script><script type="math/tex; mode=display">\sum_{i=1}^n(y_i-\hat{\beta}_0-\hat{\beta}_1x_i)x_i=0</script><p>因此<br>\begin{aligned}<br>  \sum_{i=1}^n (y_i-\hat{y}_i)(\hat{y}_i-\bar{y})&amp;=\sum_{i=1}^n(y-\hat{\beta}_0-\hat{\beta}_1x_i)(\hat{\beta}_0+\hat{\beta}_1x_i-\bar{y})\\<br>  &amp;=(\hat{\beta}_0-\bar{y})\underline{\sum_{i=1}^n(y-\hat{\beta}_0-\hat{\beta}_1x_i)}+\hat{\beta}_1\underline{\sum_{i=1}^n(y-\hat{\beta}_0-\hat{\beta}_1x_i)x_i}\\<br>  &amp;=0<br>\end{aligned}</p></li><li><p><strong>Multiple linear regression</strong>情况<br>考虑$p$个自变量$({X}_1,{X}_2,\cdots, {X}_p)$</p><script type="math/tex; mode=display">\mathbf{y}=\mathbf{X}{\beta} + {\varepsilon}, \qquad {\varepsilon} \sim \mathcal{N}(\mathbf{0},\sigma^2\mathbf{I})</script><p>由最小二乘法得到的$\hat{\mathbf{\beta}}$满足</p><script type="math/tex; mode=display">\hat{\mathbf{\beta}}=\arg \min_{\mathbf{\beta}} \hat{\mathbf{\varepsilon}}^\prime \hat{\mathbf{\varepsilon}}=\arg \min_{\mathbf{\beta}} (\mathbf{y}-\mathbf{X}\mathbf{\beta})^\prime(\mathbf{y}-\mathbf{X}\mathbf{\beta})</script></li></ul><script type="math/tex; mode=display">\frac{\partial{\hat{\varepsilon}^\prime \hat{\varepsilon}}}{\partial{\beta}}=-2\mathbf{X}^\prime \mathbf{y}+2\mathbf{X}^\prime \mathbf{X}\mathbf{\beta}=\mathbf{0}</script><p>$\Longrightarrow$</p><script type="math/tex; mode=display">\hat{\beta}=(\mathbf{X}^\prime\mathbf{X})^{-1}\mathbf{X}^\prime \mathbf{y}</script><p>因此</p><script type="math/tex; mode=display">\hat{\mathbf{y}}=\mathbf{X}\hat{\mathbf{\beta}}=\mathbf{X}(\mathbf{X}^\prime\mathbf{X})^{-1}\mathbf{X}^\prime \mathbf{y}\triangleq \mathbf{H}\mathbf{y}</script><p>其中<br>$\mathbf{H}=\mathbf{X}(\mathbf{X}^\prime\mathbf{X})^{-1}\mathbf{X}^\prime$ 对称幂等，且$\mathbf{I}-\mathbf{H}$对称幂等。</p><p>\begin{aligned}<br>    SST&amp;=(\textbf{y}-\bar{\textbf{y}})^\prime(\textbf{y}-\bar{\textbf{y}})\\<br>    SSR&amp;=(\hat{\textbf{y}}-\bar{\textbf{y}})^\prime(\hat{\textbf{y}}-\bar{\textbf{y}})\\<br>    SSE&amp;=(\textbf{y}-\hat{\textbf{y}})^\prime(\textbf{y}-\hat{\textbf{y}})<br>  \end{aligned}</p><p>定义$\textbf{1}_n=(1,1,\cdots,1)^\prime$为元素全是1的 $n$ 维列向量，则均值算子为$\frac{\textbf{1}_n\textbf{1}_n^\prime}{n}$ （全是$\frac{1}{n}$ 的$n\times n$方阵），$\textbf{1}_n^\prime\textbf{1}_n=n$，且</p><script type="math/tex; mode=display">\left(\textbf{I}-\frac{\textbf{1}_n\textbf{1}_n^\prime}{n}\right)^\prime = \left(\textbf{I}-\frac{\textbf{1}_n\textbf{1}_n^\prime}{n}\right)</script><script type="math/tex; mode=display">\left(\textbf{I}-\frac{\textbf{1}_n\textbf{1}_n^\prime}{n}\right)^\prime\left(\textbf{I}-\frac{\textbf{1}_n\textbf{1}_n^\prime}{n}\right)=\textbf{I}-\frac{\textbf{1}_n\underline{\textbf{1}_n^\prime\textbf{1}_n}\textbf{1}_n^\prime}{n^2}=\left(\textbf{I}-\frac{\textbf{1}_n\textbf{1}_n^\prime}{n}\right)</script><p>即$\left(\textbf{I}-\frac{\textbf{1}_n\textbf{1}_n^\prime}{n}\right)$ 是对称幂等阵。则有</p><p>\begin{aligned}<br>    \textbf{y}-\bar{\textbf{y}}&amp;=\left(\textbf{I}-\frac{\textbf{1}_n\textbf{1}_n^\prime}{n}\right)\textbf{y}\\<br>    \hat{\mathbf{y}}-\bar{\mathbf{y}}&amp;=\left(\mathbf{H}-\frac{\textbf{1}_n\textbf{1}_n^\prime}{n}\right)\mathbf{y}\\<br>    \textbf{y}-\hat{\textbf{y}}&amp;=(\mathbf{I}-\mathbf{H})\mathbf{y}\\<br>    SST&amp;=\textbf{y}^\prime\left(\textbf{I}-\frac{\textbf{1}_n\textbf{1}_n^\prime}{n}\right)^\prime \left(\textbf{I}-\frac{\textbf{1}_n\textbf{1}_n^\prime}{n}\right) \textbf{y}=\textbf{y}^\prime \left(\textbf{I}-\frac{\textbf{1}_n\textbf{1}_n^\prime}{n}\right) \textbf{y}\\<br>    SSR&amp;=\mathbf{y}^\prime\left(\mathbf{H}-\frac{\textbf{1}_n\textbf{1}_n^\prime}{n}\right)^\prime\left(\mathbf{H}-\frac{\textbf{1}_n\textbf{1}_n^\prime}{n}\right)\mathbf{y}=\mathbf{y}^\prime\left(\mathbf{H}-\frac{\textbf{1}_n\textbf{1}_n^\prime}{n}\right)\mathbf{y}\\<br>    SSE&amp;=\mathbf{y}^\prime (\mathbf{I}-\mathbf{H})^\prime (\mathbf{I}-\mathbf{H}) \mathbf{y}=\mathbf{y}^\prime (\mathbf{I}-\mathbf{H}) \mathbf{y}<br>\end{aligned}<br>所以 <script type="math/tex">SST=SSR+SSE</script></p>
          </div>
<h1 id="线性回归-vs-逻辑回归"><a href="#线性回归-vs-逻辑回归" class="headerlink" title="线性回归 vs 逻辑回归"></a>线性回归 vs 逻辑回归</h1><div class="note default">
            <p>见<a href="/%E7%AE%97%E6%B3%95-LogisticRegression.html" title="Machine Learning | Logistic Regression">Machine Learning | Logistic Regression</a></p>
          </div>
<h1 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h1><ul>
<li>State the <strong>assumptions</strong> in linear regression model<blockquote>
<ul>
<li>自变量和因变量线性相关</li>
<li>自变量间相互独立</li>
<li>误差项间相互独立</li>
<li>误差项服从均值为零、方差为常数的比正态分布</li>
<li>自变量和误差项相互独立</li>
</ul>
</blockquote>
</li>
<li>How to avoid <strong>overfitting</strong> in linear regression?<blockquote>
<ul>
<li>减少特征的数量</li>
<li>减少自变量的权重，控制模型的复杂度。即，进行正则化<strong>Regularization</strong></li>
</ul>
</blockquote>
</li>
<li><p>Explain <strong>gradient descent</strong> with respect to linear regression</p>
</li>
<li><p>How to choose the value of the parameter <strong>learning rate</strong> $\alpha$?</p>
</li>
<li><p>How to choose the <strong>regularization parameter</strong>?</p>
</li>
</ul>
<p>未完</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://www.statisticssolutions.com/what-is-linear-regression/" target="_blank" rel="noopener">What is Linear Regression?</a></li>
<li><a href="https://www.dataapplab.com/linear-regression-5-quiz/" target="_blank" rel="noopener">Linear regression 5道经典必考题自测</a></li>
</ul>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>机器学习</tag>
        <tag>回归</tag>
        <tag>判别式模型</tag>
      </tags>
  </entry>
  <entry>
    <title>编程题库</title>
    <url>/%E7%BC%96%E7%A8%8B%E9%A2%98%E5%BA%93.html</url>
    <content><![CDATA[<center>Enjoy Coding</center>

<a id="more"></a>
<h1 id="无从属知识"><a href="#无从属知识" class="headerlink" title="无从属知识"></a>无从属知识</h1><ul>
<li><strong>编译程序</strong>是一种翻译程序<ul>
<li>翻译程序：将某种语言编写的程序转换成另一种语言形式的程序。如编译程序和汇编程序等。</li>
<li>汇编程序：把汇编语言书写的程序翻译成与之等价的机器语言程序。</li>
</ul>
</li>
</ul>
<h1 id="题库"><a href="#题库" class="headerlink" title="题库"></a>题库</h1><h2 id="大整数相乘"><a href="#大整数相乘" class="headerlink" title="大整数相乘"></a>大整数相乘</h2><ul>
<li>有两个用字符串表示的非常大的大整数,算出他们的乘积，也是用字符串表示。不能用系统自带的大整数类型。<blockquote>
<p>拼多多2018年校招内推编程题</p>
</blockquote>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        lst = list(input().split())</span><br><span class="line">        a, b = eval(lst[<span class="number">0</span>]), eval(lst[<span class="number">1</span>])</span><br><span class="line">        print(str(a * b))</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure>
<h2 id="合并表记录"><a href="#合并表记录" class="headerlink" title="合并表记录"></a>合并表记录</h2><p><a href="https://www.nowcoder.com/practice/de044e89123f4a7482bd2b214a685201?tpId=37&amp;tqId=21231&amp;tPage=1&amp;rp=&amp;ru=/ta/huawei&amp;qru=/ta/huawei/question-ranking" target="_blank" rel="noopener">题目详情</a><br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        dic = &#123;&#125;</span><br><span class="line">        n = int(input())</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            idx, val = list(map(int, input().split()))</span><br><span class="line">            <span class="keyword">if</span> idx <span class="keyword">not</span> <span class="keyword">in</span> dic:</span><br><span class="line">                dic[idx] = val</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dic[idx] = dic[idx] + val</span><br><span class="line">        dic = sorted(dic.items(), key=<span class="keyword">lambda</span> x:x[<span class="number">0</span>])  <span class="comment">## 按键升序排序</span></span><br><span class="line">        <span class="keyword">for</span> key, val <span class="keyword">in</span> dic:</span><br><span class="line">            print(key, val)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure></p>
<h2 id="计算字符个数"><a href="#计算字符个数" class="headerlink" title="计算字符个数"></a>计算字符个数</h2><p><a href="https://www.nowcoder.com/practice/a35ce98431874e3a820dbe4b2d0508b1?tpId=37&amp;tqId=21225&amp;tPage=1&amp;rp=&amp;ru=/ta/huawei&amp;qru=/ta/huawei/question-ranking" target="_blank" rel="noopener">题目详情</a><br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        lst = [s.lower() <span class="keyword">for</span> s <span class="keyword">in</span> input()]</span><br><span class="line">        stri = input()</span><br><span class="line">        print(lst.count(stri))</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure></p>
<h2 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h2><p><a href="https://www.nowcoder.com/practice/8f3df50d2b9043208c5eed283d1d4da6?tpId=37&amp;tqId=21228&amp;tPage=1&amp;rp=&amp;ru=/ta/huawei&amp;qru=/ta/huawei/question-ranking" target="_blank" rel="noopener">题目详情</a><br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        n = input()</span><br><span class="line">        print(int(n, <span class="number">16</span>))</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure></p>
<h2 id="句子逆序"><a href="#句子逆序" class="headerlink" title="句子逆序"></a>句子逆序</h2><p><a href="https://www.nowcoder.com/practice/48b3cb4e3c694d9da5526e6255bb73c3?tpId=37&amp;tqId=21236&amp;rp=0&amp;ru=/ta/huawei&amp;qru=/ta/huawei/question-ranking" target="_blank" rel="noopener">题目详情</a><br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        s = input()</span><br><span class="line">        lst = s.split(<span class="string">" "</span>)</span><br><span class="line">        lst = lst[::<span class="number">-1</span>]</span><br><span class="line">        print(<span class="string">" "</span>.join(lst))</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure></p>
<h2 id="六一儿童节"><a href="#六一儿童节" class="headerlink" title="六一儿童节"></a>六一儿童节</h2><ul>
<li>六一儿童节，老师带了很多好吃的巧克力到幼儿园。每块巧克力j的重量为w[j]，对于每个小朋友i，当他分到的巧克力大小达到h[i] (即w[j]&gt;=h[i])，他才会上去表演节目。老师的目标是将巧克力分发给孩子们，使得最多的小孩上台表演。可以保证每个w[i]&gt; 0且不能将多块巧克力分给一个孩子或将一块分给多个孩子。</li>
<li>第一行：n，表示h数组元素个数</li>
<li>第二行：n个h数组元素</li>
<li>第三行：m，表示w数组元素个数</li>
<li>第四行：m个w数组元素<blockquote>
<p>拼多多2018年校招内推编程题</p>
</blockquote>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        n = int(input())  <span class="comment">## 小孩个数</span></span><br><span class="line">        hlst = list(map(int, input().split()))  <span class="comment">## 小孩对应列表</span></span><br><span class="line">        m = int(input())  <span class="comment">## 巧克力个数</span></span><br><span class="line">        wlst = list(map(int, input().split()))  <span class="comment">## 巧克力对应列表</span></span><br><span class="line">        hlst.sort(revesrse=<span class="literal">True</span>)</span><br><span class="line">        wlst.sort(reverse=<span class="literal">True</span>)</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        dot = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(m):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(dot, n):</span><br><span class="line">                <span class="keyword">if</span> wlst[j] &gt;= hlst[i]:</span><br><span class="line">                    count += <span class="number">1</span></span><br><span class="line">                    dot = i</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> dot == n <span class="keyword">or</span> dot == m:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> count &gt; n:</span><br><span class="line">            print(n)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(count)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure>
<p><a href="https://blog.csdn.net/qq_28626909/article/details/88246948" target="_blank" rel="noopener">参考</a></p>
<h2 id="迷宫寻路"><a href="#迷宫寻路" class="headerlink" title="迷宫寻路"></a>迷宫寻路</h2><ul>
<li>假设一个探险家被困在了地底的迷宫之中，要从当前位置开始找到一条通往迷宫出口的路径。迷宫可以用一个二维矩阵组成，有的部分是墙，有的部分是路。迷宫之中有的路上还有门，每扇门都在迷宫的某个地方有与之匹配的钥匙，只有先拿到钥匙才能打开门。请设计一个算法，帮助探险家找到脱困的最短路径。如前所述，迷宫是通过一个二维矩阵表示的，每个元素的值的含义如下 0-墙，1-路，2-探险家的起始位置，3-迷宫的出口，大写字母-门，小写字母-对应大写字母所代表的门的钥匙</li>
<li>迷宫的地图，用二维矩阵表示。第一行是表示矩阵的行数和列数M和N</li>
<li>后面的M行是矩阵的数据，每一行对应与矩阵的一行（中间没有空格）。M和N都不超过100, 门不超过10扇。<blockquote>
<p>拼多多2018年校招内推编程题</p>
</blockquote>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="明明的随机数"><a href="#明明的随机数" class="headerlink" title="明明的随机数"></a>明明的随机数</h2><p><a href="https://www.nowcoder.com/practice/3245215fffb84b7b81285493eae92ff0?tpId=37&amp;tqId=21226&amp;tPage=1&amp;rp=&amp;ru=/ta/huawei&amp;qru=/ta/huawei/question-ranking" target="_blank" rel="noopener">题目详情</a><br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        n = int(input())</span><br><span class="line">        nums = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            nums.append(int(input()))</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> sorted(set(nums)):</span><br><span class="line">            print(j)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure></p>
<h2 id="求int型正整数在内存中存储时1的个数"><a href="#求int型正整数在内存中存储时1的个数" class="headerlink" title="求int型正整数在内存中存储时1的个数"></a>求int型正整数在内存中存储时1的个数</h2><p><a href="https://www.nowcoder.com/practice/440f16e490a0404786865e99c6ad91c9?tpId=37&amp;tqId=21238&amp;rp=0&amp;ru=/ta/huawei&amp;qru=/ta/huawei/question-ranking" target="_blank" rel="noopener">题目详情</a><br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        bin_n = bin(int(input()))</span><br><span class="line">        print(str(bin_n).count(<span class="string">'1'</span>))</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure></p>
<h2 id="取近似值"><a href="#取近似值" class="headerlink" title="取近似值"></a>取近似值</h2><p><a href="https://www.nowcoder.com/practice/3ab09737afb645cc82c35d56a5ce802a?tpId=37&amp;tqId=21230&amp;tPage=1&amp;rp=&amp;ru=/ta/huawei&amp;qru=/ta/huawei/question-ranking" target="_blank" rel="noopener">题目详情</a><br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        n = float(input())</span><br><span class="line">        a, b = list(map(int, str(n).split(<span class="string">"."</span>)))</span><br><span class="line">        <span class="keyword">if</span> b &gt;= <span class="number">5</span>:</span><br><span class="line">            print(a+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(a)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure></p>
<h2 id="数字颠倒"><a href="#数字颠倒" class="headerlink" title="数字颠倒"></a>数字颠倒</h2><p><a href="https://www.nowcoder.com/practice/ae809795fca34687a48b172186e3dafe?tpId=37&amp;tqId=21234&amp;tPage=1&amp;rp=&amp;ru=/ta/huawei&amp;qru=/ta/huawei/question-ranking" target="_blank" rel="noopener">题目详情</a><br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        n = input()[::<span class="number">-1</span>]</span><br><span class="line">        print(n)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure></p>
<h2 id="提取不重复的整数"><a href="#提取不重复的整数" class="headerlink" title="提取不重复的整数"></a>提取不重复的整数</h2><p><a href="https://www.nowcoder.com/practice/253986e66d114d378ae8de2e6c4577c1?tpId=37&amp;tqId=21232&amp;tPage=1&amp;rp=&amp;ru=/ta/huawei&amp;qru=/ta/huawei/question-ranking" target="_blank" rel="noopener">题目详情</a><br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        out = <span class="string">""</span></span><br><span class="line">        <span class="keyword">for</span> s <span class="keyword">in</span> input()[::<span class="number">-1</span>]:</span><br><span class="line">            <span class="keyword">if</span> s <span class="keyword">not</span> <span class="keyword">in</span> out:</span><br><span class="line">                out += s</span><br><span class="line">        print(out)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure></p>
<h2 id="质数-素数"><a href="#质数-素数" class="headerlink" title="质数/素数"></a>质数/素数</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 列出小于整数n的所有质数</span></span><br><span class="line"><span class="comment">## 不导入模块</span></span><br><span class="line">n = <span class="number">20</span></span><br><span class="line">[i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, n) <span class="keyword">if</span> <span class="number">0</span> <span class="keyword">not</span> <span class="keyword">in</span> [i%j <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">2</span>, int(i**<span class="number">0.5</span>) + <span class="number">1</span>)]]</span><br><span class="line"><span class="comment"># [2, 3, 5, 7, 11, 13, 17, 19]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 使用Python的模块</span></span><br><span class="line">[i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, n) <span class="keyword">if</span> <span class="number">0</span> <span class="keyword">not</span> <span class="keyword">in</span> [i%j <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">2</span>, int(math.sqrt(i)) + <span class="number">1</span>)]]</span><br><span class="line"><span class="comment"># [2, 3, 5, 7, 11, 13, 17, 19]</span></span><br></pre></td></tr></table></figure>
<h2 id="字符串反转"><a href="#字符串反转" class="headerlink" title="字符串反转"></a>字符串反转</h2><p><a href="https://www.nowcoder.com/practice/e45e078701ab4e4cb49393ae30f1bb04?tpId=37&amp;tqId=21235&amp;tPage=1&amp;rp=&amp;ru=/ta/huawei&amp;qru=/ta/huawei/question-ranking" target="_blank" rel="noopener">题目详情</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        s = input()</span><br><span class="line">        print(s[::<span class="number">-1</span>])</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure>
<h2 id="字符串分隔"><a href="#字符串分隔" class="headerlink" title="字符串分隔"></a>字符串分隔</h2><p><a href="https://www.nowcoder.com/practice/d9162298cb5a437aad722fccccaae8a7?tpId=37&amp;tqId=21227&amp;tPage=1&amp;rp=&amp;ru=/ta/huawei&amp;qru=/ta/huawei/question-ranking" target="_blank" rel="noopener">题目详情</a><br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decomp</span><span class="params">(string)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> string != <span class="string">""</span> <span class="keyword">and</span> len(string) &lt;= <span class="number">8</span>:</span><br><span class="line">        print(string + <span class="string">"0"</span> * (<span class="number">8</span> - len(string)))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(string[:<span class="number">8</span>])</span><br><span class="line">        string = string[<span class="number">8</span>:]</span><br><span class="line">        decomp(string)</span><br><span class="line">        </span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; <span class="number">2</span>:</span><br><span class="line">            ss = input()</span><br><span class="line">            decomp(ss)</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure></p>
<h2 id="字符串最后一个单词的长度"><a href="#字符串最后一个单词的长度" class="headerlink" title="字符串最后一个单词的长度"></a>字符串最后一个单词的长度</h2><p><a href="https://www.nowcoder.com/practice/8c949ea5f36f422594b306a2300315da?tpId=37&amp;tqId=21224&amp;tPage=1&amp;rp=&amp;ru=/ta/huawei&amp;qru=/ta/huawei/question-ranking" target="_blank" rel="noopener">题目详情</a><br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        s = input().split()[<span class="number">-1</span>]</span><br><span class="line">        print(len(s))</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure></p>
<h2 id="字符的连接最长路径查找"><a href="#字符的连接最长路径查找" class="headerlink" title="字符的连接最长路径查找"></a>字符的连接最长路径查找</h2><p><a href="https://www.nowcoder.com/practice/5af18ba2eb45443aa91a11e848aa6723?tpId=37&amp;tqId=21237&amp;rp=0&amp;ru=/ta/huawei&amp;qru=/ta/huawei/question-ranking" target="_blank" rel="noopener">题目详情</a><br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        n = int(input())</span><br><span class="line">        lst = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            lst.append(input())</span><br><span class="line">        lst.sort()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            print(lst[i])</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure></p>
<h2 id="最大乘积"><a href="#最大乘积" class="headerlink" title="最大乘积"></a>最大乘积</h2><ul>
<li>给定一个无序数组，包含正数、负数和0，要求从中找出3个数的乘积，使得乘积最大，要求时间复杂度：O(n)，空间复杂度：O(1)</li>
<li>输入共2行，第一行包括一个整数n，表示数组长度</li>
<li>第二行为n个以空格隔开的整数，分别为A1,A2, … ,An<blockquote>
<p>拼多多2018年校招内推编程题</p>
</blockquote>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        n = int(input())</span><br><span class="line">        lst = list(map(int, input().split()))</span><br><span class="line">        lst.sort()</span><br><span class="line">        print(max(lst[<span class="number">0</span>]*lst[<span class="number">1</span>]*lst[<span class="number">-1</span>], lst[<span class="number">-3</span>]*lst[<span class="number">-2</span>]*lst[<span class="number">-1</span>]))</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        n = int(input())</span><br><span class="line">        lst = list(map(int, input().split()))</span><br><span class="line">        lst.sort()</span><br><span class="line">        <span class="keyword">if</span> lst[<span class="number">0</span>]*lst[<span class="number">1</span>]*lst[<span class="number">-1</span>] &lt; lst[<span class="number">-1</span>]*lst[<span class="number">-2</span>]*lst[<span class="number">-3</span>]:</span><br><span class="line">            print(lst[<span class="number">-1</span>]*lst[<span class="number">-2</span>]*lst[<span class="number">-3</span>])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(lst[<span class="number">0</span>]*lst[<span class="number">1</span>]*lst[<span class="number">-1</span>]) </span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure>
<p><a href>题目详情</a><br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p><a href>题目详情</a><br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1>]]></content>
      <categories>
        <category>题库</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>编程</tag>
        <tag>题库</tag>
      </tags>
  </entry>
  <entry>
    <title>Python | re模块</title>
    <url>/python-re%E6%A8%A1%E5%9D%97.html</url>
    <content><![CDATA[<p><center></center><br><a id="more"></a></p>
<h1 id="re"><a href="#re" class="headerlink" title="re"></a>re</h1><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><h3 id><a href="#" class="headerlink" title="()"></a>()</h3><p>包住的数据为要提取的数据，通常与<code>.group()</code>函数连用</p>
<h3 id="-1"><a href="#-1" class="headerlink" title="."></a>.</h3><p>匹配单个任意字符</p>
<h3 id="-2"><a href="#-2" class="headerlink" title="*"></a>*</h3><p>匹配前一个字符出现0次或无限次</p>
<h3 id="-3"><a href="#-3" class="headerlink" title="?"></a>?</h3><p>匹配前一个字符出现0次或1次</p>
<h2 id="group"><a href="#group" class="headerlink" title=".group()"></a>.group()</h2><ul>
<li><code>.group(0)</code>：输出的是匹配正则表达式整体结果</li>
<li><code>.group(1)</code>：列出第一个括号匹配部分</li>
<li><code>.group(2)</code>：列出第二个括号匹配部分</li>
</ul>
<h2 id="re-I"><a href="#re-I" class="headerlink" title="re.I"></a>re.I</h2><p>使匹配对大小写不敏感</p>
<h2 id="re-M"><a href="#re-M" class="headerlink" title="re.M"></a>re.M</h2><p>多行匹配</p>
<h2 id="-4"><a href="#-4" class="headerlink" title=" "></a> </h2><h2 id="re-match"><a href="#re-match" class="headerlink" title="re.match()"></a>re.match()</h2>]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python | 模块</title>
    <url>/python-8-%E6%A8%A1%E5%9D%97.html</url>
    <content><![CDATA[<p><center></center><br><a id="more"></a></p>
<h1 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h1><h2 id="name"><a href="#name" class="headerlink" title="__name__"></a>__name__</h2><p>一个模块中有<code>__name__</code></p>
<blockquote>
<ul>
<li>直接运行，<code>__name__</code>为<code>__main__</code></li>
<li>调用该模块，<code>__name__</code>为被调用模块的“模块名”(文件名)</li>
</ul>
</blockquote>
<h2 id="new"><a href="#new" class="headerlink" title="__new__"></a>__new__</h2><ul>
<li>是<u>静态方法</u></li>
<li>返回一个创建的实例</li>
<li>只有在<code>__new__</code>返回一个cls的实例时，后面的<code>__init__</code>才能被调用</li>
<li>当创建一个新实例时，调用<code>__new__</code></li>
</ul>
<h2 id="init"><a href="#init" class="headerlink" title="__init__"></a>__init__</h2><ul>
<li>是<u>实例方法</u></li>
<li>什么都不返回</li>
<li>当初始化一个实例时，用<code>__init__</code></li>
<li>为类的实例提供一些属性或完成一些动作</li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://www.nowcoder.com/test/question/done?tid=33152813&amp;qid=370530#summary" target="_blank" rel="noopener">牛客网试题</a></li>
</ul>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python | 切片操作</title>
    <url>/python-7-%E5%88%87%E7%89%87%E6%93%8D%E4%BD%9C.html</url>
    <content><![CDATA[<p><center></center><br><a id="more"></a></p>
<ul>
<li><p>Python的切片操作不会引起下标越界异常</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lst = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>]</span><br><span class="line">print(lst[<span class="number">15</span>:])</span><br><span class="line"><span class="comment">## 输出 []</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>索引操作可能会引起下标越界异常</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lst = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>]</span><br><span class="line">print(lst[<span class="number">15</span>])</span><br><span class="line"><span class="comment">#Traceback (most recent call last):</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#  File "&lt;ipython-input-9-bcb28d671f1f&gt;", line #2, in &lt;module&gt;</span></span><br><span class="line"><span class="comment">#    print(lst[15])</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#IndexError: list index out of range</span></span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL | 数据完整性</title>
    <url>/sql-%E6%95%B0%E6%8D%AE%E5%AE%8C%E6%95%B4%E6%80%A7.html</url>
    <content><![CDATA[<p><center></center><br><a id="more"></a></p>
<h1 id="数据完整性约束"><a href="#数据完整性约束" class="headerlink" title="数据完整性约束"></a>数据完整性约束</h1><p>数据完整性是指存储在数据库中的所有数据值均正确的状态。</p>
<ul>
<li>防止数据库中存在不符合语义规定的数据</li>
<li>防止因错误信息的输入输出造成无效操作或错误信息</li>
</ul>
<p>数据完整性约束分为4类：</p>
<ul>
<li>实体完整性</li>
<li>域完整性</li>
<li>参照完整性</li>
<li>用户定义的完整性</li>
</ul>
<h2 id="实体完整性"><a href="#实体完整性" class="headerlink" title="实体完整性"></a>实体完整性</h2><p>规定表的每一行在表中是唯一的实体</p>
<blockquote>
<p>使用主键约束且主键不能为空</p>
</blockquote>
<ul>
<li>在满足实体完整性约束的条件下，一个关系中应该有一个或多个候选关键字</li>
</ul>
<h2 id="域完整性"><a href="#域完整性" class="headerlink" title="域完整性"></a>域完整性</h2><p>表中的列必须满足某种特定的数据类型约束</p>
<blockquote>
<p>通常指数据的有效性，包括</p>
<ul>
<li>字段的值域</li>
<li>字段的类型</li>
<li>字段的有效规则</li>
<li>……</li>
</ul>
</blockquote>
<ul>
<li>由确定关系结构时所定义的字段的属性决定</li>
<li>域完整性可以确保不会输入无效的值</li>
</ul>
<h2 id="参照完整性"><a href="#参照完整性" class="headerlink" title="参照完整性"></a>参照完整性</h2><p>两个表的主关键字和外关键字的数据应一致，保证了表之间的数据的一致性，防止了数据丢失或无意义的数据在数据库中扩散</p>
<blockquote>
<ul>
<li>不允许关系引用不存在的元组</li>
<li>外键或是实际存在的元组，或是为空</li>
</ul>
</blockquote>
<h2 id="用户定义的完整性"><a href="#用户定义的完整性" class="headerlink" title="用户定义的完整性"></a>用户定义的完整性</h2><p>在具体应用所涉及的数据必须满足的语义要求</p>
<h1 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h1><p>约束是表级的强制规定</p>
<h2 id="not-null"><a href="#not-null" class="headerlink" title="not null"></a>not null</h2><p>not null是列级约束，只能作用在列上</p>
<h2 id="unique"><a href="#unique" class="headerlink" title="unique"></a>unique</h2><p>唯一约束</p>
<ul>
<li>唯一约束允许多个空值</li>
</ul>
<h2 id="primary-key"><a href="#primary-key" class="headerlink" title="primary key"></a>primary key</h2><p>主键约束</p>
<ul>
<li>一个表只能有一个主键</li>
<li>主键非空</li>
</ul>
<h2 id="foreign-key"><a href="#foreign-key" class="headerlink" title="foreign key"></a>foreign key</h2><p>外键约束</p>
<h2 id="check"><a href="#check" class="headerlink" title="check"></a>check</h2><p>检查约束</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://www.nowcoder.com/test/question/done?tid=33151629&amp;qid=58021#summary" target="_blank" rel="noopener">牛客网试题</a></li>
<li><a href="https://blog.csdn.net/u013634252/article/details/80696882" target="_blank" rel="noopener">数据库中的数据完整性约束</a></li>
</ul>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>SQL</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL | 模式</title>
    <url>/sql-2-%E6%A8%A1%E5%BC%8F.html</url>
    <content><![CDATA[<p><center>Schema</center><br><a id="more"></a></p>
<p>数据库有三级模式：</p>
<ul>
<li>模式</li>
<li>外模式</li>
<li>内模式</li>
</ul>
<h1 id="模式-逻辑模式-概念模式"><a href="#模式-逻辑模式-概念模式" class="headerlink" title="模式/逻辑模式/概念模式"></a>模式/逻辑模式/概念模式</h1><p><strong>模式</strong>（Schema），也称<strong>逻辑模式</strong>、<strong>概念模式</strong>，是数据库中<u>全体数据</u>的逻辑结构和特征的描述，是所有用户的公共数据视图；用来叙述现实生活中的实体，以及它们之间的关系，从而定义记录数据项的完整性约束条件及记录之间的联系。</p>
<ul>
<li>一个数据库只有一个模式</li>
<li>模式是数据库数据在逻辑级上的视图</li>
<li>数据库模式以某一种数据类型为基础</li>
</ul>
<h1 id="外模式-子模式-用户模式"><a href="#外模式-子模式-用户模式" class="headerlink" title="外模式/子模式/用户模式"></a>外模式/子模式/用户模式</h1><p><strong>外模式</strong>（External Schema），也称<strong>子模式</strong>（Subschema）、<strong>用户模式</strong>，是数据库用户能够看见和使用的<u>局部数据</u>的的逻辑结构和特征的描述，是数据库用户的数据视图，是与某一应用有关的数据的逻辑表示。</p>
<ul>
<li>一个数据库可以有任意多个外模式</li>
<li>外模式就是<u>用户视图</u></li>
<li>外模式是保证数据安全性的一个有力措施</li>
</ul>
<h1 id="内模式"><a href="#内模式" class="headerlink" title="内模式"></a>内模式</h1><p><strong>内模式</strong>（Internal Schema），也称<strong>存储模式</strong>（Storage Schema），是数据物理结构和存储方式的描述，是数据在数据库内部的表示方式。</p>
<ul>
<li>一个数据库只有一个内模式</li>
<li>一个表可能由多个文件组成<blockquote>
<p>如：数据文件、索引文件</p>
</blockquote>
</li>
<li>内模式是所有模式中的最底层的表示</li>
</ul>
<p><meta name="referrer" content="no-referrer"><br><img src="/sql-2-%E6%A8%A1%E5%BC%8F/schema.png" class title="图片来自参考资料[2]"></p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://blog.csdn.net/qq_37808895/article/details/94394123" target="_blank" rel="noopener">数据库模式</a></li>
<li><a href="https://blog.csdn.net/qq_15950325/article/details/52654924" target="_blank" rel="noopener">浅谈数据库三大模式</a></li>
</ul>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>SQL</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL | 范式</title>
    <url>/sql-%E8%8C%83%E5%BC%8F.html</url>
    <content><![CDATA[<p><center>Normal Form</center><br><a id="more"></a></p>
<h1 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h1><p>数据库范式：</p>
<ol>
<li>第一范式 1NF：无重复的列</li>
<li>第二范式 2NF：消除部分函数依赖</li>
<li>第三范式 3NF：消除传递函数依赖</li>
<li>BCNF：消除对主码自己的依赖</li>
<li>第四范式 4NF：所有非平凡的多值依赖都是函数依赖</li>
<li>第五范式 5NF：连接依赖均由候选码所蕴含</li>
</ol>
<ul>
<li>通过数据范式的引入，可以减少数据冗余（第三范式），消除数据操作异常</li>
<li>高层范式满足低层范式</li>
</ul>
<ol>
<li>如果一个关系模式R的所有属性都是不可分的基本数据项，则$R\in 1NF$（R符合第一范式）</li>
<li>若关系模式$R\in 1NF$（R符合第一范式），并且每一个非主属性都完全依赖于R的键（码），则$R\in 2NF$（R符合第二范式）</li>
<li>若关系模式R每一个非主属性既不部分依赖于键（码）也不传递依赖于键（码），则$R\in 3NF$（R符合第三范式）</li>
</ol>
<h2 id="第一范式-1NF"><a href="#第一范式-1NF" class="headerlink" title="第一范式 1NF"></a>第一范式 1NF</h2><p>字段具有原子性，不可再分。</p>
<blockquote>
<p>无重复的列</p>
<ul>
<li>所有关系型数据库系统都满足第一范式，数据库表中的字段都是单一属性的，不可再分</li>
<li>在这种范式下，一个数据列只能有一个值</li>
<li>一个表满足1NF，如果表的每一行都是唯一的并且任何行都没有包含多个值的列</li>
<li>在任何一个关系型数据库中，第一范式是对关系模式的基本要求，不满足第一范式的数据库就不是关系型数据库</li>
</ul>
</blockquote>
<h1 id="第二范式-2NF"><a href="#第二范式-2NF" class="headerlink" title="第二范式 2NF"></a>第二范式 2NF</h1><p>要求数据库表中的每个实例（instance）或行必须可以被唯一地区分。</p>
<blockquote>
<p>非主属性<u>部分依赖</u>于主关键字</p>
<ul>
<li>满足第二范式必须先满足第一范式</li>
<li><u>部分依赖</u>是指组合主码的一部分可以函数确定关系的一列</li>
<li>如果一个关系有单列的主码，那么这个关系中就不可能存在部分函数依赖</li>
<li>通常要含有一个唯一属性列，该列被称为主键（主关键字）</li>
<li>第二范式要求实体（instance）的属性完全依赖于主关键字</li>
</ul>
</blockquote>
<h2 id="第三范式"><a href="#第三范式" class="headerlink" title="第三范式"></a>第三范式</h2><p>要求一个数据库表中不包含已在其他表中已包含的非主关键字信息</p>
<blockquote>
<p>消除冗余</p>
<ul>
<li>非主关键字段不能出现<u>传递依赖</u></li>
<li><u>传递依赖</u>是指一个关系的非码列确定另一个非码列</li>
<li>如果一个关系有传递依赖，那么它不满足3NF，需要被规范化到3NF</li>
<li>满足第四范式必然满足第三范式，满足第三范式必然满足第二范式</li>
</ul>
</blockquote>
<div class="note default">
            <p>如：存在一个部门信息表tbl_dept，其中每个部门有部门编号dept_id（主键）、部门名称dept_name、部门简介dept_desc等信息，那么在员工信息表employees中列出部门编号dept_id后就不能再将表tbl_dept中的非主关键字部门名称、部门简介等加入到表employees中。如果不存在部门信息表，则根据第三范式应该构建部门信息表，否则会有大量的信息冗余。</p>
          </div>
<p>第三范式的<strong>特征</strong>：</p>
<ul>
<li>每一列只有一个值</li>
<li>每一行都能被区分</li>
<li>每一个表都不包含其他表已包含的非主关键字信息</li>
</ul>
<h2 id="巴斯-科德范式-BCNF"><a href="#巴斯-科德范式-BCNF" class="headerlink" title="巴斯-科德范式 BCNF"></a>巴斯-科德范式 BCNF</h2><p>BCNF在3NF的基础上消除对主码子集的依赖。</p>
<ul>
<li>BCNF是3NF的一个子集，即满足BCNF必须满足3NF</li>
<li>消除了删除异常、插入异常、更新异常</li>
<li>BCNF实际是对3NF的修正，使数据库冗余度更小</li>
</ul>
<h2 id="第四范式-4NF"><a href="#第四范式-4NF" class="headerlink" title="第四范式 4NF"></a>第四范式 4NF</h2><h2 id="第五范式-5NF"><a href="#第五范式-5NF" class="headerlink" title="第五范式 5NF"></a>第五范式 5NF</h2><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU5NzkxODMxOA==&amp;tempkey=MTA1OV84Y1hhdGQ4czVBNkVGOEhMMWQ1aXA0VW95VG14UjRKYWhpeUwzZm4yUnYyV0loMU9nekN6cmp6TTQ0LTdpeXNfempxSTlKSktSU2ZKdlBTM2w4REhBdGRQVXBXcDJzZW5XQnJrS3A4a0hpX3Q2ejRXMXV4eS1EOTFMSFIxTDhHa2s1aUp2QTdDWHgzTi1yZ21NS2toR2lLSVo4OGhrVHhObXRnOVZRfn4%3D&amp;chksm=7e4d524e493adb5865db235ecd5b893bf9916fb11b6c00e5ee583c6c70add792cafe9c81c76f#rd" target="_blank" rel="noopener">数据库三范式</a></li>
<li><a href="https://www.cnblogs.com/ktao/p/7775100.html" target="_blank" rel="noopener">第一、第二、第三范式之间的理解和比较</a></li>
</ul>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>SQL</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>Python | 循环</title>
    <url>/python-6-%E5%BE%AA%E7%8E%AF.html</url>
    <content><![CDATA[<p><center></center><br><a id="more"></a></p>
<h1 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h1><ul>
<li>在<code>if...elif...else</code>的多个语句块中只会执行一个语句块</li>
<li><code>for</code>和<code>while</code>都可以有<code>else</code>语句</li>
</ul>
<h2 id="for…else"><a href="#for…else" class="headerlink" title="for…else"></a>for…else</h2><ul>
<li><code>for</code>循环正常执行完的情况下，执行<code>else</code>输出</li>
<li>当<code>for</code>循环中执行了跳出循环的语句<sup><a href="#fn_1" id="reffn_1">1</a></sup>，将不执行<code>else</code>代码块的内容</li>
</ul>
<blockquote id="fn_1">
<sup>1</sup>. 如<code>break</code><a href="#reffn_1" title="Jump back to footnote [1] in the text."> &#8617;</a>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> condition:</span><br><span class="line">    statement1</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    statement2</span><br></pre></td></tr></table></figure>
<h1 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h1><h2 id="while…else"><a href="#while…else" class="headerlink" title="while…else"></a>while…else</h2><ul>
<li><code>while</code>循环正常执行完的情况下，执行<code>else</code>输出</li>
<li>当<code>while</code>循环中执行了跳出循环的语句<sup><a href="#fn_2" id="reffn_2">2</a></sup>，将不执行<code>else</code>代码块的内容</li>
</ul>
<blockquote id="fn_2">
<sup>2</sup>. 如<code>break</code><a href="#reffn_2" title="Jump back to footnote [2] in the text."> &#8617;</a>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> condition:</span><br><span class="line">    statement1</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    statement2</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="break语句"><a href="#break语句" class="headerlink" title="break语句"></a>break语句</h1><ul>
<li><code>break</code>语句用于终止当前循环</li>
<li>通常与<code>if</code>、<code>if...else</code>和<code>if...elif...else</code>语句一起使用</li>
</ul>
<h1 id="continue语句"><a href="#continue语句" class="headerlink" title="continue语句"></a>continue语句</h1><ul>
<li><code>continue</code>语句用于跳过当前剩余要执行的代码，执行下一次循环</li>
<li>通常与<code>if</code>、<code>if...else</code>和<code>if...elif...else</code>语句一起使用</li>
</ul>
<h1 id="pass语句"><a href="#pass语句" class="headerlink" title="pass语句"></a>pass语句</h1><ul>
<li><code>pass</code>不做任何事情，一般用作<u>占位</u>语句</li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://www.nowcoder.com/test/question/done?tid=33151324&amp;qid=618873#summary" target="_blank" rel="noopener">牛客Python测试题</a></li>
<li><a href="https://blog.csdn.net/weixin_42595012/article/details/91569770" target="_blank" rel="noopener">Python while…else… 和 for…else…</a></li>
</ul>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python | 函数</title>
    <url>/python-5-%E5%87%BD%E6%95%B0.html</url>
    <content><![CDATA[<p><center></center><br><a id="more"></a></p>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><ul>
<li>函数可以赋值给一个变量</li>
<li>函数可以作为元素添加到集合对象中</li>
<li>函数可以作为参数值传递给其他函数</li>
<li>函数可以当做函数的返回值</li>
</ul>
<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><ul>
<li>带有星号 * 的参数<code>*arg</code>会以<u>元组</u>的形式导入，存放所有未命名的变量参数</li>
<li>参数的顺序：必选参数、默认参数、可变参数<code>*args</code>、命名关键字参数、关键字参数<code>**kwargs</code></li>
</ul>
<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><ul>
<li>如果函数没有使用<code>return</code>语句，则函数返回<u>None对象</u></li>
<li><code>return</code>可以返回多个值</li>
<li><code>return</code>不是必须的</li>
<li>执行到<code>return</code>时，程序将停止函数内<code>return</code>后面的语句</li>
</ul>
<h2 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h2><ul>
<li>递归函数用于调用函数的本身</li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://www.nowcoder.com/test/question/done?tid=33151142&amp;qid=618880#summary" target="_blank" rel="noopener">关于递归函数描述正确的是？</a></li>
<li><a href="https://www.nowcoder.com/test/question/done?tid=33151142&amp;qid=618878#summary" target="_blank" rel="noopener">函数返回值</a></li>
</ul>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python | 运算符</title>
    <url>/python-4-%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7.html</url>
    <content><![CDATA[<p><center></center><br><a id="more"></a></p>
<h1 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h1><ul>
<li>比较运算符优先级大于逻辑运算符</li>
<li>逻辑型运算符优先从高到低为：<script type="math/tex; mode=display">not > and > or</script></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x <span class="keyword">or</span> y <span class="keyword">and</span> z</span><br><span class="line"><span class="comment">## = x or (y and z)</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>VIP会员套餐定价策略</title>
    <url>/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90-VIP%E4%BC%9A%E5%91%98%E5%A5%97%E9%A4%90%E5%AE%9A%E4%BB%B7%E7%AD%96%E7%95%A5.html</url>
    <content><![CDATA[<p><center></center><br><a id="more"></a></p>
<p>VIP会员套餐如何定价？</p>
<p>不同的定价策略：</p>
<ul>
<li>不同行业的基础月单价定价</li>
<li>不同套餐类型的定价</li>
</ul>
<h1 id="常见VIP会员套餐"><a href="#常见VIP会员套餐" class="headerlink" title="常见VIP会员套餐"></a>常见VIP会员套餐</h1><ul>
<li>电商类<ul>
<li>淘宝<ul>
<li>88VIP：88元/年（7.33元/月）</li>
</ul>
</li>
<li>京东<ul>
<li>PLUS经典卡：99元/年（8.25元/月）</li>
</ul>
</li>
<li>小红书<ul>
<li>小红卡会员：<blockquote>
<p>连续包年：199元/年（16.583元/月）<br>年卡会员：266元/年（22.167元/月）</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
<li>知识付费</li>
<li><p>娱乐类</p>
<ul>
<li><p>音乐类</p>
<ul>
<li>网易云音乐<ul>
<li>黑胶VIP：<blockquote>
<p>连续包月：首月4.8元、次月11元<br>12个月：138元（11.5元/月）<br>3个月：40元（13.3元/月）</p>
</blockquote>
</li>
<li>音乐包：<blockquote>
<p>连续包月：8元/月<br>12个月：88元（7.3元/月）<br>3个月：24元（8元/月）</p>
</blockquote>
</li>
</ul>
</li>
<li>QQ音乐<ul>
<li>豪华绿钻<blockquote>
<p>连续包月：首月1元、次月11.4元<br>12个月：168元（14元/月）<br>3个月：45元</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
<li><p>视频类</p>
</li>
<li>其他</li>
</ul>
</li>
<li>知识付费类<ul>
<li>知乎<ul>
<li>盐选会员<blockquote>
<p>连续包月：首月9元、次月19元<br>连续包年：198元/年（16.5元/月）<br>连续包季：53元/季（17.67元/月）<br>月卡会员：25元/月<br>年卡会员：238元/年（19.9元/月）<br>季卡会员：68元/季（22.7元/月）</p>
</blockquote>
</li>
<li>读书卡<blockquote>
<p>连续包年：188元/年（15.67元/月）<br>年卡会员：198元/年（16.5元/月） </p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="定价因素"><a href="#定价因素" class="headerlink" title="定价因素"></a>定价因素</h1><p>整体月单价的趋势是：</p>
<script type="math/tex; mode=display">娱乐类<工具类<电商类<知识付费类</script><p>可以从以下4点思考影响产品定价的因素：</p>
<ul>
<li>受众</li>
<li>成本</li>
<li>会员权益</li>
<li>营收来源</li>
</ul>
<h2 id="受众"><a href="#受众" class="headerlink" title="受众"></a>受众</h2><ul>
<li>工具类/知识付费类产品：<ul>
<li>根据马斯洛需求层次理论，该类需求更偏自我实现</li>
<li>使用场景有局限性，覆盖面小，受众少</li>
</ul>
</li>
<li>娱乐类/电商类：<ul>
<li>娱乐类偏社交需求；电商类偏生理需求、安全需求</li>
<li>使用场景丰富，覆盖面大，受众多</li>
</ul>
</li>
</ul>
<h2 id="成本"><a href="#成本" class="headerlink" title="成本"></a>成本</h2><ul>
<li>工具类/电商类：<ul>
<li>最基本的成本：技术成本、营销成本</li>
</ul>
</li>
<li>知识付费类：<ul>
<li>额外成本：强运营成本（如课程教师费用、内容制作沟通等成本）</li>
</ul>
</li>
<li>娱乐类：<ul>
<li>额外成本：版权成本（音乐版权、电视剧版权等）</li>
</ul>
</li>
</ul>
<h2 id="会员权益"><a href="#会员权益" class="headerlink" title="会员权益"></a>会员权益</h2><ul>
<li>工具类：解决更高级且便捷的功能</li>
<li>电商类：享受商品优惠、购物包邮、退换货包邮等</li>
<li>娱乐类：免广告、无限看、无限听、头像挂件等</li>
<li>知识付费类：解锁更多知识内容</li>
</ul>
<h2 id="营收来源"><a href="#营收来源" class="headerlink" title="营收来源"></a>营收来源</h2><ul>
<li>工具类：<ul>
<li>依靠功能优势吸引用户使用，进一步转化更多VIP会员付费</li>
<li>用户基数少，且转化率偏向于斜率较小的线性增长，回本周期较长</li>
</ul>
</li>
<li>电商类：<ul>
<li>营收抽成（营收=访客数$\times$转化率$\times$客单价）</li>
<li>每一步优化都可以有效提升营收</li>
<li>对于电商平台而言，吸引更多的商家和购买者，就会越大幅度地提升平台收益</li>
</ul>
</li>
<li>知识付费类：<ul>
<li>需要依靠课程对用户地吸引力，引导用户新增、试用、付费</li>
<li>但用户基数少，且知识付费前期需要高运营投入，所以回本也较难</li>
</ul>
</li>
<li>娱乐类：<ul>
<li>主要依靠会员用户付费</li>
<li>用户基数大，且用户留存率较高，因此扩展会员的难度较低</li>
<li>版权成本会呈边际递减趋势</li>
</ul>
</li>
</ul>
<h1 id="定价规律"><a href="#定价规律" class="headerlink" title="定价规律"></a>定价规律</h1><p>不同套餐月单价从低到高的规律是：</p>
<script type="math/tex; mode=display">连续包年<连续包半年=连续包季<连续包月<普通包年<普通包季<普通包月</script><h2 id="价格锚点"><a href="#价格锚点" class="headerlink" title="价格锚点"></a>价格锚点</h2><p>价格锚点的运用场景：</p>
<ol>
<li>建立和同行竞品的锚点</li>
<li>在自家产品里建立不同定位的产品，起到互相锚点的作用</li>
</ol>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>[1] <a href="http://www.woshipm.com/operate/2450659.html" target="_blank" rel="noopener">VIP 会员套餐的定价策略</a></p>
]]></content>
      <tags>
        <tag>数据分析</tag>
        <tag>业务向</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>数据分析 | 指标异动类问题</title>
    <url>/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90-%E6%8C%87%E6%A0%87%E5%BC%82%E5%8A%A8%E7%B1%BB%E9%97%AE%E9%A2%98.html</url>
    <content><![CDATA[<ul>
<li>机票的成交转化率下降了，怎么分析？</li>
<li>航班公司觉得自己的某个航线经营状况不好，怎么分析原因</li>
<li>某个产品的销售量下降了，怎么分析？</li>
<li>xxx转化率最近在下降，询盘量有点上升，请分析下是什么情况?</li>
</ul>
<a id="more"></a>
<p>什么是<strong>异常值</strong>？<br>异常值，也称为离群值（outlier），指数据统计中，偏离多数数据样本或不符合现有数据统计规律的数值。一般来说，异常值会明显大于或小于其他数据样本。</p>
<p>作用：</p>
<ul>
<li>监控告警</li>
<li>数据分析前处理</li>
</ul>
<p>可以使用变化率、距离、密度等指标设定阈值进行监控</p>
<h1 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h1><p>首先要对数据波动进行界定——<strong>明确定义</strong></p>
<h2 id="明确定义"><a href="#明确定义" class="headerlink" title="明确定义"></a>明确定义</h2><h2 id="问题定位"><a href="#问题定位" class="headerlink" title="问题定位"></a>问题定位</h2><h2 id="指标拆解"><a href="#指标拆解" class="headerlink" title="指标拆解"></a>指标拆解</h2><h2 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h2><h1 id="细分维度"><a href="#细分维度" class="headerlink" title="细分维度"></a>细分维度</h1><h2 id="平台-版本"><a href="#平台-版本" class="headerlink" title="平台/版本"></a>平台/版本</h2><ul>
<li>某产品列表页到详情页的转化提升<ul>
<li>猜测是Android版本中优化列表布局方式</li>
<li>则应分 IOS 、Android以及Android的新版、老版来对比转化数据，从而进一步验证前述猜测</li>
</ul>
</li>
</ul>
<h2 id="区域-城市"><a href="#区域-城市" class="headerlink" title="区域/城市"></a>区域/城市</h2><h2 id="用户群体"><a href="#用户群体" class="headerlink" title="用户群体"></a>用户群体</h2><h2 id="类目"><a href="#类目" class="headerlink" title="类目"></a>类目</h2><h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><h2 id="转化率与询盘量异常"><a href="#转化率与询盘量异常" class="headerlink" title="转化率与询盘量异常"></a>转化率与询盘量异常</h2><blockquote>
<p>xxx转化率最近在下降，询盘量有点上升，请分析下是什么情况?——来自<a href="https://mp.weixin.qq.com/s?__biz=MzIxNjA2ODUzNg==&amp;mid=2651440599&amp;idx=1&amp;sn=8faf27a155d144461b540dabe4d31260&amp;chksm=8c73dd00bb045416f137942afb2d35e36a87858c3453644a680a45140b5cb67c336d5d2758b0&amp;mpshare=1&amp;scene=24&amp;srcid=&amp;sharer_sharetime=1589157451953&amp;sharer_shareid=b539221659d6ecf12200314308b58dd3&amp;key=7813388b7074583853a1569b61fe6d4df6117bd6400a8cd3f226306ae46a8c728f41f75fbf88090ef2e59f4f1bf473ff1b5403c46ebed25f7a497fd77299f1d5c5b1b2a7d1160f8a5dda9cc908481d43&amp;ascene=14&amp;uin=MjAwNDUzMjgxNw%3D%3D&amp;devicetype=Windows+10+x64&amp;version=62090070&amp;lang=zh_CN&amp;exportkey=Ad2%2FlcnRfQtiskYNJjaBXFQ%3D&amp;pass_ticket=hGGS7EaUpIDlASL51iQWn3S1qU2l9x%2BRBIBXN3TjHYK2XsRZIXuz61NfsnX%2FuM4F" target="_blank" rel="noopener">数据异常波动，应该如何分析？</a></p>
</blockquote>
<ol>
<li>对数据波动进行界定<ul>
<li>去除周期性、季节性后，判断数据波动是否为异常（对比前后一段时间内的变化情况</li>
<li>确定异常发生的维度（主要从时间维度来看）</li>
<li>波动的程度</li>
<li>是否需要深入分析</li>
</ul>
</li>
<li>拆解指标<ul>
<li>根据<u>指标计算逻辑</u>来拆<pre class="mermaid">   graph TD;
   询盘量转化率-->询盘量;
   询盘量转化率-->会话量;
   询盘量-----会话量;
   会话量-->弹出会话量;
   会话量-->非弹出会话量;
   弹出会话量-----非弹出会话量;</pre></li>
<li>根据<u>相关维度</u>来拆<ul>
<li>访问渠道：直接访问、自然搜索、付费搜索、…</li>
<li>着陆页：着陆页1、着陆页2、着陆页3、…</li>
<li>国家：国家1、国家2、国家3、…</li>
</ul>
</li>
<li>从<u>产品、运营、技术及用户</u>四个角度来考虑原因<ul>
<li>产品：新版本上线（新功能、功能变更）、替代产品出现、…</li>
<li>运营：促销活动、价格战减少、…</li>
<li>技术：服务器瘫痪、系统故障、接口不稳定、…</li>
<li>用户：用户成长、节假日、淡旺季、…</li>
</ul>
</li>
</ul>
</li>
<li>用数据来验证假设</li>
<li>提出切实可执行的方法——要落地到业务和产品上的具体建议，确保方案可执行，效果可评估</li>
</ol>
<p>未完</p>
<h2 id="如何分析次日留存率下降的问题"><a href="#如何分析次日留存率下降的问题" class="headerlink" title="如何分析次日留存率下降的问题"></a>如何分析次日留存率下降的问题</h2><ol>
<li>从用户画像、渠道、产品、行为环节等角度细分，明确是哪里的次日留存率下降了</li>
<li>指标拆解<script type="math/tex; mode=display">次日留存率=\sum\frac{次日留存数}{今日获客人数}</script></li>
<li>原因分析<ul>
<li>内部</li>
<li>运营活动</li>
<li>产品变动</li>
<li>技术故障</li>
<li>设计漏洞</li>
<li>外部</li>
<li>竞品</li>
<li>用户偏好</li>
<li>节假日</li>
<li>社会事件（如舆论事件等）</li>
</ul>
</li>
</ol>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://www.cnblogs.com/bellz/p/11448562.html" target="_blank" rel="noopener">指标异动类问题分析框架 - 数据分析师面试题</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzIxNjA2ODUzNg==&amp;mid=2651440599&amp;idx=1&amp;sn=8faf27a155d144461b540dabe4d31260&amp;chksm=8c73dd00bb045416f137942afb2d35e36a87858c3453644a680a45140b5cb67c336d5d2758b0&amp;mpshare=1&amp;scene=24&amp;srcid=&amp;sharer_sharetime=1589157451953&amp;sharer_shareid=b539221659d6ecf12200314308b58dd3&amp;key=7813388b7074583853a1569b61fe6d4df6117bd6400a8cd3f226306ae46a8c728f41f75fbf88090ef2e59f4f1bf473ff1b5403c46ebed25f7a497fd77299f1d5c5b1b2a7d1160f8a5dda9cc908481d43&amp;ascene=14&amp;uin=MjAwNDUzMjgxNw%3D%3D&amp;devicetype=Windows+10+x64&amp;version=62090070&amp;lang=zh_CN&amp;exportkey=Ad2%2FlcnRfQtiskYNJjaBXFQ%3D&amp;pass_ticket=hGGS7EaUpIDlASL51iQWn3S1qU2l9x%2BRBIBXN3TjHYK2XsRZIXuz61NfsnX%2FuM4F" target="_blank" rel="noopener">数据异常波动，应该如何分析？</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzUzODYwMDAzNA==&amp;mid=2247490797&amp;idx=2&amp;sn=e4488e6ae078fd04992ee19c3ea43e0d&amp;chksm=fad46be0cda3e2f606f3faffe800c819c2cacb5ded2c4bb6e1b0b061bc2c06d276bd18a4a9f4&amp;mpshare=1&amp;scene=24&amp;srcid=&amp;sharer_sharetime=1589846441823&amp;sharer_shareid=b539221659d6ecf12200314308b58dd3&amp;key=391433877af29848d80eb268dfdb67e70c94dbc8461e647ef4fd9cf863b97fcbf05fe3cc098469dd0eed236ecaa0ce9b4afa6518cb6c2e116156d348ec25c79484217b352893ff4b5a26e8f3fd8d7f35&amp;ascene=14&amp;uin=MjAwNDUzMjgxNw%3D%3D&amp;devicetype=Windows+10+x64&amp;version=62090070&amp;lang=zh_CN&amp;exportkey=AYJS0mHna0hF6l9GD1%2B%2BuCY%3D&amp;pass_ticket=hSPy%2FUU8oxUcSxTs%2F5nB1TD0Hf4oMyJJiFtHAk4RLQ6enp8U%2FMNrC0H1aJAXQF7t" target="_blank" rel="noopener">24个「数据分析师」岗位面试题和答案解析</a></li>
</ul>
]]></content>
      <categories>
        <category>数据分析</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
        <tag>业务向</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>数据分析 | 费米问题</title>
    <url>/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90-%E8%B4%B9%E7%B1%B3%E9%97%AE%E9%A2%98.html</url>
    <content><![CDATA[<p><center>Fermi Problem</center><br><a id="more"></a></p>
<h1 id="费米问题"><a href="#费米问题" class="headerlink" title="费米问题"></a>费米问题</h1><ul>
<li>全国一年消费多少猪肉？</li>
<li>芝加哥有多少个调音师？</li>
<li>北京有多少个加油站？</li>
<li>估算中国K12课外英语辅导的市场</li>
<li>一个正常成年人有多少根头发？</li>
<li>估算一下北京有多少理发店？</li>
<li>一辆公交车里能装下多少个煎饼果子？</li>
<li>你知道厦门一天的燃油税费是多少吗？</li>
<li>怎样估算北京市餐馆的数量？</li>
<li>怎样估算深圳市学生的数量？</li>
<li>怎样估算上海市理发师的数量？</li>
<li>上海有多少辆出租车？</li>
<li>北京市每天有多少人乘坐地铁？</li>
<li>公司楼下的星巴克一年的咖啡收益？</li>
<li>深圳有多少个学校？</li>
<li>北京有多少个产品经理？</li>
<li>上海有多少辆本田汽车？</li>
<li>广州白云区有多少间7-11便利店？</li>
<li>北京胡同巷子的煎饼摊一年能卖多少个烧饼？</li>
<li>……</li>
</ul>
<p>在产品、运营、数据分析相关的面试中，经常会遇到上述这类问题，这类问题英文称之为<strong>Fermi Problem</strong>，即<strong>费米问题</strong>。</p>
<h2 id="估算"><a href="#估算" class="headerlink" title="估算"></a>估算</h2><p>费米问题的估算通常有</p>
<ul>
<li><strong>大</strong>：资本市场对青睐的公司或行业的潜力预测</li>
<li><strong>小</strong>：某场运营活动的前期市场调研</li>
</ul>
<p>首先，要与面试官/需求方明确<u>统计口径</u>！</p>
<ul>
<li>估算北京市餐馆的数量？<ul>
<li>餐馆的范围是哪些？</li>
<li>包括无门店的外卖、街边摊大排档吗？</li>
<li>“北京”是包括所有区划吗？</li>
<li>……</li>
</ul>
</li>
<li>估算深圳市学生的数量？<ul>
<li>学生的范围是哪些？</li>
<li>只算九年制义务教育阶段的在校生吗？</li>
<li>幼儿园学生、大专、高校生要考虑吗？</li>
<li>……</li>
</ul>
</li>
<li>估算上海市的理发师数量？<ul>
<li>“理发师”是指只做洗剪吹的理发师吗？</li>
<li>包括只做美发、染烫、造型的理发师吗？</li>
<li>……</li>
</ul>
</li>
</ul>
<p>进行费米问题估算时，重要的是——<strong>将难获得的数据拆分为易获得的数据</strong>。</p>
<p>大致流程：</p>
<pre class="mermaid">graph TD;
    假设推算模型，并列出需要的数据-->确认并预估已知数据;
    确认并预估已知数据-->进行毛估算;</pre>

<p>估算分析方法主要有：</p>
<ul>
<li>供需角度<ul>
<li>需求端</li>
<li>供给端</li>
<li>供需端<blockquote>
<p>\begin{aligned}<br>理发师数量&amp;=需求÷供给\\<br>&amp;=上海市每天需要剪发的人数÷每个理发师每天理发客户量\\<br>&amp;=\frac{上海人口}{人均剪发周期（天）}÷\frac{理发师每日平均工作时间}{每个客户所需的理发时间}<br>\end{aligned}</p>
</blockquote>
</li>
</ul>
</li>
<li>自顶向下 Top-down、bottom-up<blockquote>
<p>估算深圳市的九年义务教育阶段的学生数量<br>假设人均寿命为75岁<br>\begin{aligned}<br>学生数量&amp;=深圳市人口\times中小学生适龄人口比例\\<br>&amp;= 深圳市人口\times\frac{6-14岁人口}{0-75岁人口}<br>\end{aligned}</p>
</blockquote>
</li>
<li>同类推断<blockquote>
<p>估算深圳市的九年义务教育阶段的学生数量<br>假设九年义务教育入学率为100%<br>假设高中入学率为90%<br>\begin{aligned}<br>学生数量&amp;=深圳市每年高考人数\times9\\<br>&amp;= \frac{全国每年高考人数}{全国人口}\times深圳市人口\times9<br>\end{aligned}<br>每年的高考学生中，有部分不是应届高考生，更细致的估算时需要考虑剔除</p>
</blockquote>
</li>
</ul>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="全国一年消费多少猪肉"><a href="#全国一年消费多少猪肉" class="headerlink" title="全国一年消费多少猪肉"></a>全国一年消费多少猪肉</h3><p><u>需求端</u></p>
<ol>
<li>确定估算模型<script type="math/tex; mode=display">全国一年消费猪肉量=每人每天消费的猪肉量\times 全国人数\times 一年的天数</script></li>
<li>估算模型中的数据是否已知？若仍有未知，继续拆解<ul>
<li>全国人数$N$（已知）</li>
<li>一年的天数$n$（365或366）</li>
<li>每人每天消费的猪肉量（未知）<script type="math/tex; mode=display">每人每天消费的猪肉量=每人每天消耗的肉量\times 猪肉在肉类食材中的占比</script><ul>
<li>估算：平均每人每天的肉类消耗量为200g</li>
<li>估算：肉类=猪肉+牛肉+羊肉+鸡鸭+水产+…，假设猪肉在肉类食材中的占比为50$\%$<script type="math/tex; mode=display">每人每天消费的猪肉量=200g\times 50\%=100g</script></li>
</ul>
</li>
</ul>
</li>
<li>数据整合，粗略估计<br>\begin{equation}<br>\begin{aligned}<br>全国一年消费猪肉量&amp;=每人每天消费的猪肉量\times 全国人数\times 一年的天数\\<br>&amp;= 每人每天消耗的肉量\times 猪肉在肉类食材中的占比\times 14亿\times 365天\\<br>&amp;= 200g \times 50\% \times 14亿\times 365天<br>\end{aligned}<br>\end{equation}</li>
</ol>
<p>更细致的分析：</p>
<ul>
<li>市场调查：采用问卷调查形式，调查人均每日消耗肉量及猪肉的占比，然后选取中位数</li>
<li>市场细分：前面考虑的是全国，可以按不同区域划分分别估算再进行整合，也可以考虑按消费者的不同年龄划分分别估算再进行整合</li>
</ul>
<h3 id="芝加哥有多少钢琴调音师"><a href="#芝加哥有多少钢琴调音师" class="headerlink" title="芝加哥有多少钢琴调音师"></a>芝加哥有多少钢琴调音师</h3><p><u>供给端</u></p>
<ol>
<li>假设推算模型，列出需要的数据<br>\begin{aligned}<br>调音师数量&amp;=需求÷供给\\<br>&amp;=每年需要调音的钢琴总数÷每个调音师的工作效率<br>\end{aligned}</li>
<li>确认并预估已知数据<br>即：判断公式中的数据是否已知，若仍有数据未知，则继续拆解。<ul>
<li>在芝加哥生活的人数（900万）</li>
<li>芝加哥平均每个家庭人数（2人）</li>
<li>大约20个家庭中有一个家庭有定期给钢琴调钢琴的需要</li>
<li>钢琴定期调音平均每1年进行一次</li>
<li>每个调音师完成一台钢琴的调音工作平均需要花费2小时</li>
<li>每个调音师每天工作8小时，一周工作5天，一年工作50周</li>
</ul>
</li>
<li>进行粗略估算<script type="math/tex; mode=display">每年需要调音的钢琴数量=\frac{900万}{2}\frac{1}{20}\frac{1}{1年}=22.5万台</script><script type="math/tex; mode=display">每个调音师的工作效率=\frac{8小时\times5天\times50周}{2小时/台}=1000</script>\begin{aligned}<br>调音师数量&amp;=\frac{每年需要调音的钢琴数量}{每个调音师的工作效率}\\<br>&amp;= 22.5万台÷1000=225名<br>\end{aligned}</li>
</ol>
<h3 id="北京有多少个加油站"><a href="#北京有多少个加油站" class="headerlink" title="北京有多少个加油站"></a>北京有多少个加油站</h3><p><u>需求端</u></p>
<ol>
<li>假设推算模型<br>\begin{aligned}<br>加油站数&amp;=需求÷供给\\<br>&amp;=\frac{每天需加油的车辆数}{每个加油站平均每天可加油车辆数}<br>\end{aligned}</li>
<li>确认并预估已知数据<ul>
<li>北京每天需加油的车辆数$C$<blockquote>
<ul>
<li>北京人口（2150万人）</li>
<li>平均每个家庭4个人</li>
<li>平均每个家庭1台车</li>
<li>每台车平均5天需加油一次<script type="math/tex; mode=display">北京每天需加油的车辆数=2150万÷4\times1÷5=107.5万台</script></li>
</ul>
</blockquote>
</li>
<li>每个加油站平均每天可加油车辆数<blockquote>
<ul>
<li>每个加油站平均加油桩个数（4个）</li>
<li>加油站平均每天工作14小时</li>
<li>每小时加油桩利用率60%</li>
<li>每个桩加一次油耗时5分钟<script type="math/tex; mode=display">每个加油站平均每天可加油车辆数=4\times14\times60\%÷\frac{5分钟}{60分钟}=403.2</script></li>
</ul>
</blockquote>
</li>
</ul>
</li>
<li>进行粗略估算<br>\begin{aligned}<br>加油站数&amp;=\frac{每天需加油的车辆数}{每个加油站平均每天可加油车辆数}\\<br>&amp;= \frac{107.5万}{403.2}\approx2666个<br>\end{aligned}</li>
</ol>
<h3 id="中国K12课外英语辅导的市场"><a href="#中国K12课外英语辅导的市场" class="headerlink" title="中国K12课外英语辅导的市场"></a>中国K12课外英语辅导的市场</h3><p><u>供需端</u></p>
<p><strong>K12</strong>：Kindergarten through twelfth grade</p>
<ol>
<li>需求端分析<script type="math/tex; mode=display">市场规模=参与英语培训的学生人数\times 平均每人英语培训年均花费</script><ul>
<li>在校中小学生人数<blockquote>
<ul>
<li>中国人口（14亿）</li>
</ul>
</blockquote>
</li>
<li>人均寿命（75岁）</li>
<li>假设人口按照岁数均匀分布</li>
<li>九年义务教育入学率100%，高中入学率90$\%$<script type="math/tex; mode=display">K12阶段人群数=14亿\times\frac{9+3\times90\%}{75}=2.184亿</script></li>
<li>参与课外培训率（60%）</li>
<li>参与课外培训学生中参与英语辅导率（60%）</li>
<li>英语辅导年均培训费用（2000元/人）<script type="math/tex; mode=display">市场规模=2.184亿\times60\%\times60\%\times2000元=1572.48亿元</script><blockquote>
<p>参与英语培训的人中很大一部分是为了考研、留学的大学生，上述分析没有考虑到这一部分需求</p>
</blockquote>
</li>
</ul>
</li>
<li>供给端分析<script type="math/tex; mode=display">市场规模=K12教育英语老师每天辅导学生人次\times人均辅导费用</script><blockquote>
<ul>
<li></li>
</ul>
</blockquote>
</li>
</ol>
<h3 id="深圳市的丰田汽车数量"><a href="#深圳市的丰田汽车数量" class="headerlink" title="深圳市的丰田汽车数量"></a>深圳市的丰田汽车数量</h3><p>层级拆解：</p>
<ol>
<li>深圳市汽车</li>
<li>丰田汽车</li>
</ol>
<p>思路1：Top-down</p>
<blockquote>
<ol>
<li>假设深圳全市共有机动车300万辆</li>
<li>在深圳市多地采样，记录每100辆车中丰田车的占比，最后取占比的平均值（假设为25%）<script type="math/tex; mode=display">300万辆\times 25\%=75万辆</script></li>
</ol>
</blockquote>
<p>思路2：Bottom-up</p>
<blockquote>
<ol>
<li>假设已知“深圳全市有特斯拉汽车3万辆”（与丰田横向同层）</li>
<li>在深圳市多地采样，记录每100辆汽车中，特斯拉汽车的占比为1%、丰田车的占比为25%<script type="math/tex; mode=display">\frac{3万辆}{1%}\times 25%=75万辆</script></li>
</ol>
</blockquote>
<p>不同方法可以灵活运用、相互验证。</p>
<p>此外：</p>
<ul>
<li>对丰田汽车进行采样时，要怎么选择地点呢？<ul>
<li>选取车流密集区域</li>
<li>口岸、机场、商场等是否会影响数据的真实性？</li>
<li>若只取口岸附近的车流密集区域，占比可能会偏高</li>
<li>应该取多少个采样地点呢？</li>
</ul>
</li>
<li>怎样进行对特斯拉汽车的采样<ul>
<li>特斯拉可以充电，若选采样地点是“特斯拉充电桩”附近，则会造成数据偏高</li>
<li>特斯拉在深圳属于什么定位？</li>
</ul>
</li>
</ul>
<h3 id="深圳的便利店数量"><a href="#深圳的便利店数量" class="headerlink" title="深圳的便利店数量"></a>深圳的便利店数量</h3><p>首先需要确定“便利店”的定义：</p>
<ul>
<li>包括<br>未完</li>
</ul>
<h2 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h2><ul>
<li>如果所有数据开放，应该找哪些数据源？</li>
<li>怎样筛选数据源或找数据源？</li>
<li>……</li>
</ul>
<blockquote>
<p>估算北京市的餐馆（门店）的数量</p>
<ul>
<li>官方数据源<ul>
<li>国家统计局</li>
<li>工商局餐饮类营业执照</li>
<li>……</li>
</ul>
</li>
<li>互联网企业数据源<ul>
<li>美团点评数据</li>
<li>地图采样统计</li>
<li>……</li>
</ul>
</li>
<li>产业链上下游<ul>
<li>盐的消耗量</li>
<li>可出租商铺量</li>
<li>……</li>
</ul>
</li>
</ul>
</blockquote>
<p>未完</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="http://www.woshipm.com/zhichang/631625.html" target="_blank" rel="noopener">新技能Get：面试中常见的费米估算要怎么破</a></li>
<li><a href="https://mp.weixin.qq.com/s/UopcXE3SAZIwi8UXCZ7aDg" target="_blank" rel="noopener">你的城市有多少理发店？费米估算问题套路详解（1）</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/79510656" target="_blank" rel="noopener">费米估算</a></li>
<li><a href="https://blog.csdn.net/weixin_42464525/article/details/81322655" target="_blank" rel="noopener">费米估算类问题-解决方法</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1559156" target="_blank" rel="noopener">试估算中国K12课外英语辅导的市场，请至少使用2种不同的方案来估算，以便能够交叉验证</a></li>
<li><a href="https://mp.weixin.qq.com/s/gEHs2MWgBFn70StSmJD2tQ" target="_blank" rel="noopener">数量估算类面试题应该如何应对？</a></li>
<li><a href="http://www.woshipm.com/zhichang/1602007.html" target="_blank" rel="noopener">产品经理面试策略：针对问数量、估算的“面试问题”如何进行思考和回答？</a></li>
</ul>
]]></content>
      <categories>
        <category>数据分析</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
        <tag>业务向</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>树</title>
    <url>/%E6%A0%91.html</url>
    <content><![CDATA[<p><center>Tree</center><br><a id="more"></a></p>
<p>一对多的数据结构——树</p>
<h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><h2 id="树-1"><a href="#树-1" class="headerlink" title="树"></a>树</h2><p><strong>树</strong>（Tree）是$n$个结点的有限集。</p>
<ul>
<li><strong>空树</strong>：$n=0$</li>
<li><p><strong>非空树</strong>：</p>
<ul>
<li>$n&gt;0$</li>
<li>有且仅有一个特定的<strong>根结点</strong>（Root）</li>
<li>当$n&gt;1$时，其余结点可分为$m(m&gt;0)$个互不相交的有限集$T_1,\cdots,T_m$；其中每一个集合自身是一棵树，称之为根的<strong>子树</strong>（SubTree）</li>
</ul>
</li>
<li><p><strong>有序树</strong><br>如果树中结点的各子树从左至右是有次序的、不能互换左右子树的，则该树为有序树</p>
</li>
<li><strong>无序树</strong><br>树中结点可互换左右子树，则该树为无序树</li>
</ul>
<h2 id="森林"><a href="#森林" class="headerlink" title="森林"></a>森林</h2><p><strong>森林</strong>（Forest）：$m$棵互不相交的树的集合</p>
<ul>
<li>树中的每个结点的子树的集合就是森林</li>
</ul>
<h1 id="结点"><a href="#结点" class="headerlink" title="结点"></a>结点</h1><p>树的<strong>结点</strong>（Node）包含一个数据元素及若干指向其子树的分支。</p>
<h2 id="度"><a href="#度" class="headerlink" title="度"></a>度</h2><p>结点拥有的子树的数目称为结点的<strong>度</strong>（Degree）。</p>
<ul>
<li><strong>叶结点</strong>（Leaf）：度为0的结点</li>
<li><strong>非终端结点/分支结点</strong>：度不为0的结点</li>
<li><strong>内部结点</strong>：除根结点外的分支结点</li>
</ul>
<p><strong>树的度</strong>是指树内各结点的度的最大值。</p>
<h2 id="结点间关系"><a href="#结点间关系" class="headerlink" title="结点间关系"></a>结点间关系</h2><ul>
<li><strong>Child</strong>：结点的子树的根，称为该结点的Child</li>
<li><strong>Parent</strong>：Child的前一个结点称为Child的Parent</li>
<li><strong>Sibling</strong>：同一个Parent的Child之间互称Sibling（兄弟）</li>
<li><strong>祖先</strong>：某结点的祖先是从根结点（Root）到该结点所经分支上的所有结点</li>
<li><strong>子孙</strong>：以某结点为根的所有子树的结点都称为该结点的子孙</li>
<li><strong>堂兄弟</strong>：双亲在同一层的结点互为堂兄弟</li>
</ul>
<h2 id="层次"><a href="#层次" class="headerlink" title="层次"></a>层次</h2><p>结点的<strong>层次</strong>（Level）：从根开始，根为第一层；根的孩子为第二层；第二层结点的孩子（第二层结点的子树的根）所在的为第三层；依此类推。</p>
<p>树的<strong>深度</strong>（Depth）或<strong>高度</strong>：树中结点的最大层次</p>
<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><p><strong>二叉树</strong>（Binary Tree）：$n$个结点的有限集合</p>
<ul>
<li><strong>空二叉树</strong>：$n=0$</li>
<li>由一个根结点和两棵互不相交的二叉树组成。这两棵二叉树称为根结点的<strong>左子树</strong>和<strong>右子树</strong></li>
</ul>
<p>二叉树的<strong>特点</strong>：</p>
<ul>
<li>每个结点最多有2棵子树。即，二叉树的所有结点的度$\leq2$</li>
<li>二叉树是<u>有序树</u>。左子树和右子树的次序不能任意颠倒</li>
<li>即使某个结点的子树只有一棵，也必须区分它是左子树还是右子树</li>
</ul>
<p>二叉树可能的<strong>基本形态</strong>：</p>
<ol>
<li>空二叉树（$n=0$）</li>
<li>只有一个根结点（$n=1$）</li>
<li>根结点只有左子树（$n=2$）</li>
<li>根结点只有右子树（$n=2$）</li>
<li>根结点既有左子树又有右子树（$n\geq3$）</li>
</ol>
<blockquote>
<p>具有2个结点的二叉树的可能形态有2种<br>具有3个结点的二叉树的可能形态有5种</p>
</blockquote>
<h2 id="斜树"><a href="#斜树" class="headerlink" title="斜树"></a>斜树</h2><p>左斜树和右斜树统称为斜树。</p>
<ul>
<li><strong>左斜树</strong>：所有结点都只有左子树的二叉树</li>
<li><strong>右斜树</strong>：所有结点都只有右子树的二叉树<ul>
<li>斜树的每一层都只有一个结点</li>
<li>斜树的结点个数与树的深度相同</li>
</ul>
</li>
</ul>
<h2 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h2><p>所有分支结点都存在左子树和右子树、所有叶子结点都在同一层上的二叉树称为<strong>满二叉树</strong>(Full Binary Tree)。</p>
<p>满二叉树的<strong>特点</strong>：</p>
<ul>
<li>叶子结点只能出现在最底层</li>
<li>非叶子结点的度一定为2</li>
<li>在同样深度的二叉树中，满二叉树的结点个数最多、叶子结点数最多</li>
</ul>
<h2 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h2><p>定义（待补充）(Complete Binary Tree)</p>
<ul>
<li>满二叉树一定是一棵完全二叉树</li>
<li>完全二叉树不一定是满二叉树</li>
</ul>
<p>完全二叉树的<strong>特点</strong>：</p>
<ul>
<li>叶子结点只能出现在最底两层</li>
<li>最底层的叶子结点一定集中在左部连续位置（？？）</li>
<li>倒数第二层，若有叶子结点，一定都在右部连续位置（？？）</li>
<li>完全二叉树不存在只有右子树的情况</li>
<li>同样结点数的二叉树，完全二叉树的深度最小</li>
</ul>
<h2 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h2><p><strong>平衡二叉树</strong>（BT，Balance Tree），又称<strong>AVL树</strong>：是一棵空树，或它的左右子树的高度差的绝对值不超过1，且左右子树都是一棵平衡二叉树</p>
<h2 id="二叉树性质"><a href="#二叉树性质" class="headerlink" title="二叉树性质"></a>二叉树性质</h2><ol>
<li>二叉树的第$i$层上最多有$2^{i-1}$个结点（$i\geq 1$）</li>
<li>深度为$k$的二叉树最多有$2^k-1$个结点（$k\geq1$）<ul>
<li>$k=1$：最多有$1(2^1-1)$个结点</li>
<li>$k=1$：最多有$1+2=3(2^2-1)$个结点</li>
<li>$k=2$：最多有$1+2+2^2=7(2^3-1)$个结点</li>
<li>……</li>
<li>对任意的$k$，最多有$2^0+2^1+\cdots+2^k=2^k-1$个结点</li>
</ul>
</li>
<li>对任意一棵二叉树$T$，有$n_0$个叶子结点（度为0）、$n_2$个度为2的结点，则有$n_1=n_2+1$<ul>
<li>度为0的结点数为$n_0$</li>
<li>度为1的结点数为$n_1$</li>
<li>度为2的结点数为$n_2$<ul>
<li>二叉树的结点的度最多为2，所以树$T$的结点总数为<script type="math/tex; mode=display">n=n_0+n_1+n_2</script></li>
</ul>
</li>
<li>只有根结点没有连接线进入，其他结点都有连接线进入，所以连接线总数为$n-1$</li>
<li>度为1的结点有一条向下的连接线，度为2的结点有2条向下的连接线，度为0的结点没有向下的连接线，所以连接线总数为$n_1+2n_2$<ul>
<li>连接线总数为<script type="math/tex; mode=display">n_L=n-1=n_1+2n_2</script></li>
</ul>
</li>
<li>由上面两个等式可得<script type="math/tex; mode=display">n_0=n_2+1</script></li>
</ul>
</li>
<li>具有$n$个结点的完全二叉树的深度为$[\log_2{n}]+1$（$[x]$表示不大于$x$的最大整数）<ul>
<li>深度为$k$的满二叉树的结点数为$n=2^k-1$</li>
<li>有$n$个结点的满二叉树的深度为$k=\log_2{(n+1)}$</li>
<li>完全二叉树的叶子结点只可能出现在最下面两层，则深度为$k$的完全二叉树的结点数$n$一定多于深度为$k-1$的满二叉树、不多于深度为$k$的满二叉树。即<script type="math/tex; mode=display">2^{k-1}-1<n\leq2^k-1</script>  也即<script type="math/tex; mode=display">2^{k-1}\leq n<2^k</script><script type="math/tex; mode=display">k-1\leq\log_2n<k</script>  所以有<script type="math/tex">k=[\log_2n]+1</script></li>
</ul>
</li>
<li>对一棵有$n$个结点的完全二叉树（深度为$[\log_2n]+1$）的结点按层序编号（从第1层到第$[\log_2n]+1$层，每层从左到右），对任一结点$i(1\leq i\leq n)$有：<ul>
<li>如果$i=1$，则结点$i$为二叉树的根结点，无双亲（Parent）</li>
<li>如果$i&gt;1$，则结点$i$的双亲是$[\frac{i}{2}]$</li>
<li>如果$2i&gt;n$，则结点$i$为叶子结点、无左孩子（Left Child）；否则其左孩子是结点$2i$</li>
<li>如果$2i+1&gt;n$，则结点$i$为叶子结点、无右孩子（Right Child）；否则其右孩子是结点$2i+1$</li>
</ul>
</li>
</ol>
<h2 id="二叉树的存储结构"><a href="#二叉树的存储结构" class="headerlink" title="二叉树的存储结构"></a>二叉树的存储结构</h2><h3 id="顺序存储"><a href="#顺序存储" class="headerlink" title="顺序存储"></a>顺序存储</h3><ul>
<li>用一维数组存储二叉树中的结点，数组的下标是结点的存储位置</li>
<li>深度为$k$的二叉树的顺序存储有$2^k-1$个存储单元空间</li>
<li>顺序存储结构一般只用于完全二叉树</li>
</ul>
<h3 id="二叉链表"><a href="#二叉链表" class="headerlink" title="二叉链表"></a>二叉链表</h3><ul>
<li>一个数据域（存储结点）、两个指针域（分别存储left child和right child）的链式存储结构</li>
</ul>
<h2 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h2><p>遍历二叉树（traversing binary tree）是指从根结点（Root）出发，按照某种次序依次访问二叉树中的所有结点，使得每个结点被访问一次、且只被访问一次。</p>
<ul>
<li>已知前序遍历序列和中序遍历序列，可以唯一确定一棵二叉树</li>
<li>已知后序遍历序列和中序遍历序列，可以唯一确定一棵二叉树</li>
<li>已知前序和后序遍历序列，不能确定一棵二叉树</li>
</ul>
<h3 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h3><ul>
<li>二叉树为空<blockquote>
<p>返回空</p>
</blockquote>
</li>
<li>二叉树非空<blockquote>
<script type="math/tex; mode=display">根结点 \rightarrow前序遍历左子树 \rightarrow 前序遍历右子树</script><script type="math/tex; mode=display">中\rightarrow左\rightarrow右</script></blockquote>
</li>
</ul>
<p><meta name="referrer" content="no-referrer"><br><img src="/%E6%A0%91/preorder.png" class title="前序遍历"></p>
<script type="math/tex; mode=display">1→2→4→5→3→6→7</script><h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><ul>
<li>二叉树为空<blockquote>
<p>返回空</p>
</blockquote>
</li>
<li>二叉树非空<blockquote>
<script type="math/tex; mode=display">中序遍历根结点的左子树\rightarrow根结点\rightarrow中序遍历右子树</script><script type="math/tex; mode=display">左\rightarrow中\rightarrow右</script></blockquote>
</li>
</ul>
<p><meta name="referrer" content="no-referrer"><br><img src="/%E6%A0%91/inorder.png" class title="中序遍历"></p>
<script type="math/tex; mode=display">4→2→5→1→6→3→7</script><h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h3><ul>
<li>二叉树为空<blockquote>
<p>返回空</p>
</blockquote>
</li>
<li>二叉树非空<blockquote>
<script type="math/tex; mode=display">后序遍历左子树\rightarrow后序遍历右子树\rightarrow根结点</script><script type="math/tex; mode=display">左\rightarrow右\rightarrow中</script></blockquote>
</li>
</ul>
<p><meta name="referrer" content="no-referrer"><br><img src="/%E6%A0%91/postorder.png" class title="后序遍历"></p>
<script type="math/tex; mode=display">4→5→2→6→7→3→1</script><h3 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h3><ul>
<li>二叉树为空<blockquote>
<p>返回空</p>
</blockquote>
</li>
<li>二叉树非空<blockquote>
<p>从根结点、从上往下逐层遍历；在同一层，按从左到右的顺序对结点逐个访问</p>
</blockquote>
</li>
</ul>
<p><meta name="referrer" content="no-referrer"><br><img src="/%E6%A0%91/cneg.png" class title="层序遍历"></p>
<script type="math/tex; mode=display">1→2→3→4→5→6→7</script><h1 id="赫夫曼"><a href="#赫夫曼" class="headerlink" title="赫夫曼"></a>赫夫曼</h1><h2 id="赫夫曼树"><a href="#赫夫曼树" class="headerlink" title="赫夫曼树"></a>赫夫曼树</h2><h2 id="赫夫曼编码"><a href="#赫夫曼编码" class="headerlink" title="赫夫曼编码"></a>赫夫曼编码</h2><h1 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h1><p><strong>二叉搜索树/二叉查找树</strong>（Binary Search Tree）</p>
<ul>
<li>是一种数据结构</li>
<li>不能随机访问</li>
</ul>
<p>左子树上所有结点的值均小于根结点的值，而右子树上所有结点的值均大于根结点的值（？？？）</p>
<h2 id="运行时间"><a href="#运行时间" class="headerlink" title="运行时间"></a>运行时间</h2><ul>
<li>平均运行时间为$O(\log{n})$</li>
<li>最糟的运行时间为$O(n)$</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">数组</th>
<th style="text-align:center">二叉查找树</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">查找</td>
<td style="text-align:center">$O(\log{n})$</td>
<td style="text-align:center">$O(\log{n})$</td>
</tr>
<tr>
<td style="text-align:center">插入</td>
<td style="text-align:center">$O(n)$</td>
<td style="text-align:center">$O(\log{n})$</td>
</tr>
<tr>
<td style="text-align:center">删除</td>
<td style="text-align:center">$O(n)$</td>
<td style="text-align:center">$O(\log{n})$</td>
</tr>
</tbody>
</table>
</div>
<h1 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h1><p><strong>最小生成树</strong>（MST，Minimum Spanning Tree）：一个有$n$个结点的连通图的生成树是原图的极小连通子图，且包含原图中的所有$n$个结点，并且有保持图连通的最少的边。</p>
<ul>
<li>一个图可以有许多棵不同的生成树</li>
<li>生成树的定点数与图的定点数相同</li>
<li>生成树是图的<strong>极小连通子图</strong>，去掉一条边则非连通</li>
<li>一个有$n$个顶点的连通图的生成树有$n-1$条边</li>
<li>含$n$个顶点、$n-1$条边的图不一定是生成树</li>
</ul>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>可用</p>
<ul>
<li>克鲁斯卡尔算法（Kruskal）</li>
<li>普里姆算法（Prim）<br>实现</li>
</ul>
<p>B树、红黑树、堆、伸展树</p>
<p>未完</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://book.douban.com/subject/6424904/" target="_blank" rel="noopener">大话数据结构</a></li>
<li><a href="https://www.cnblogs.com/songwenjie/p/8955856.html" target="_blank" rel="noopener">【图解数据结构】二叉树遍历</a></li>
<li><a href="https://book.douban.com/subject/26979890/" target="_blank" rel="noopener">图解算法</a></li>
<li><a href="https://baijiahao.baidu.com/s?id=1646617486319372351&amp;wfr=spider&amp;for=pc" target="_blank" rel="noopener">一文读懂平衡二叉树</a></li>
<li><a href="https://my.oschina.net/u/4365394/blog/3234185/print" target="_blank" rel="noopener">最小生成树</a></li>
</ul>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>Kaggle | Titanic</title>
    <url>/%E6%95%B0%E6%8D%AE%E6%B8%85%E6%B4%97-Titanic.html</url>
    <content><![CDATA[<p><center></center><br><a id="more"></a></p>
<h1 id="Titanic数据集"><a href="#Titanic数据集" class="headerlink" title="Titanic数据集"></a>Titanic数据集</h1><p>数据来源：Kaggle<br><a href="https://www.kaggle.com/c/titanic/data" target="_blank" rel="noopener">点击下载</a></p>
<h2 id="数据预览"><a href="#数据预览" class="headerlink" title="数据预览"></a>数据预览</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">os.chdir(<span class="string">"你的路径"</span>)  <span class="comment">##设置工作路径</span></span><br><span class="line">os.getcwd()  <span class="comment">##读取当前工作路径</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">train_data = pd.read_csv(<span class="string">"train.csv"</span>)</span><br><span class="line">train_data.head()  <span class="comment">##查看前5行</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">train_data.describe()  <span class="comment">##变量的描述统计</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">train_data.isnull().sum().sort_values(ascending=<span class="literal">False</span>)  <span class="comment">##统计每列的缺失值个数</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">train_data = train_data.drop(columns=[<span class="string">"Cabin"</span>, <span class="string">"Name"</span>, <span class="string">"PassengerId"</span>, <span class="string">"Ticket"</span>])  <span class="comment">##去除缺失值较多的变量Cabin以及其他无用信息</span></span><br><span class="line">train_data.head()</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">train_data = train_data.dropna(axis=<span class="number">0</span>) <span class="comment">##保留没有空值的行</span></span><br><span class="line">train_data.shape</span><br></pre></td></tr></table></figure>
<p>未完待续</p>
]]></content>
      <tags>
        <tag>Data Cleaning</tag>
      </tags>
  </entry>
  <entry>
    <title>Data Cleaning Projects</title>
    <url>/Data-Cleaning-Projects.html</url>
    <content><![CDATA[<center>Data Cleansing Projects 汇总</center>

<a id="more"></a>
<h1 id="Projects"><a href="#Projects" class="headerlink" title="Projects"></a>Projects</h1><ul>
<li><a href="/%E6%95%B0%E6%8D%AE%E6%B8%85%E6%B4%97-Titanic.html" title="Kaggle | Titanic">Kaggle | Titanic</a></li>
<li><a href="/%E6%95%B0%E6%8D%AE%E6%B8%85%E6%B4%97-%E5%A4%A9%E6%B1%A0-%E4%BA%8C%E6%89%8B%E8%BD%A6%E4%BA%A4%E6%98%93%E6%95%B0%E6%8D%AE.html" title="天池 | 二手车交易数据">天池 | 二手车交易数据</a></li>
<li><a href="/%E6%95%B0%E6%8D%AE%E6%B8%85%E6%B4%97-kaggle-MedicalCostPersonal.html" title="Kaggle | Medical Cost Personal">Kaggle | Medical Cost Personal</a></li>
<li><a href="/%E6%95%B0%E6%8D%AE%E6%B8%85%E6%B4%97-kaggle-HousePrice.html" title="Kaggle | House Prices:Advanced Regression Techniques">Kaggle | House Prices:Advanced Regression Techniques</a>
</li>
</ul>
<h1 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h1><h2 id="缺失值"><a href="#缺失值" class="headerlink" title="缺失值"></a>缺失值</h2><h3 id="可视化缺失值"><a href="#可视化缺失值" class="headerlink" title="可视化缺失值"></a>可视化缺失值</h3><ul>
<li>直接统计</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment">## 读取数据</span></span><br><span class="line">train_data = pd.read_csv(<span class="string">"used_car_train_20200313.csv"</span>, sep=<span class="string">" "</span>)</span><br><span class="line">missing = train_data.isnull().sum()  <span class="comment">## 统计每列的缺失值样本数</span></span><br><span class="line">missing = missing[missing &gt; <span class="number">0</span>]</span><br><span class="line">missing.sort_values(inplace=<span class="literal">True</span>)</span><br><span class="line">missing.plot.bar()</span><br></pre></td></tr></table></figure>
<p><meta name="referrer" content="no-referrer"><br></p>
<ul>
<li><a href="/python-missingno.html" title="missingno">missingno</a>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> missingno <span class="keyword">as</span> msno</span><br><span class="line"></span><br><span class="line">msno.matrix(train_data.sample(<span class="number">250</span>))</span><br></pre></td></tr></table></figure>
<p><meta name="referrer" content="no-referrer"><br><img src="/Data-Cleaning-Projects/na_pic2.png" class title="将缺失值数量可视化"></p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://cn.bing.com/images/search?view=detailV2&amp;ccid=gpCSzLGU&amp;id=1898D7F14E27BFCC00B895A307ECC5F04313DE94&amp;thid=OIP.gpCSzLGUdIzn2Pkx-1iVFAHaEN&amp;mediaurl=https%3a%2f%2fpublic.tableau.com%2fs%2fsites%2fdefault%2ffiles%2fmedia%2fdata-cleaning-thumb2_20.jpg&amp;exph=766&amp;expw=1349&amp;q=data+cleaning&amp;simid=608010194433082183&amp;selectedIndex=175" target="_blank" rel="noopener">首页缩略图</a></li>
<li><a href="https://tianchi.aliyun.com/notebook-ai/detail?spm=5176.12281978.0.0.68021b43hxXs9w&amp;postId=95457" target="_blank" rel="noopener">数据分析</a></li>
</ul>
]]></content>
      <categories>
        <category>Data Scientist</category>
      </categories>
      <tags>
        <tag>Data</tag>
        <tag>Python</tag>
        <tag>R</tag>
        <tag>Projects</tag>
      </tags>
  </entry>
  <entry>
    <title>Jupyter Notebook使用技巧</title>
    <url>/Jupyter-Notebook%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7.html</url>
    <content><![CDATA[<center>Jupyter Tips!</center>

<a id="more"></a>
<h3 id="输出结果显示图片"><a href="#输出结果显示图片" class="headerlink" title="输出结果显示图片"></a>输出结果显示图片</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">%matplotlib inline</span><br></pre></td></tr></table></figure>
<h3 id="同时输出多个命令的结果"><a href="#同时输出多个命令的结果" class="headerlink" title="同时输出多个命令的结果"></a>同时输出多个命令的结果</h3><ol>
<li>方法一：在文件开头添加以下命令（仅对当前文件有效）<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> IPython.core.interactiveshell <span class="keyword">import</span> InteractiveShell</span><br><span class="line">InteractiveShell.ast_node_interactivity = <span class="string">"all"</span></span><br></pre></td></tr></table></figure></li>
<li>方法二：直接添加配置文件（对所有文件有效）<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">vi ~/.ipython/profile_default/ipython_config.py</span><br></pre></td></tr></table></figure>
配置文件内容为：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">c = get_config()</span><br><span class="line"><span class="comment">#Run all nodes interactively</span></span><br><span class="line">c.InteractiveShell.ast_node_interactivity = <span class="string">"all"</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="安装R-kernel"><a href="#安装R-kernel" class="headerlink" title="安装R kernel"></a>安装R kernel</h3><p>先在R中安装以下几个package：<br><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">install.packages(c(<span class="string">'repr'</span>, <span class="string">'IRdisplay'</span>, <span class="string">'evaluate'</span>, <span class="string">'crayon'</span>, </span><br><span class="line">                   <span class="string">'pbdZMQ'</span>, <span class="string">'devtools'</span>, <span class="string">'uuid'</span>, <span class="string">'digest'</span>))</span><br><span class="line">devtools::install_github(<span class="string">'IRkernel/IRkernel'</span>)</span><br></pre></td></tr></table></figure><br>在Anaconda Prompt中输入以下命令：<br>第一步：输入R，调用R<br><figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">R</span></span><br></pre></td></tr></table></figure><br>第二步：安装R kernel，有2种方式（自由选择，个人建议第二种）：</p>
<ol>
<li>直接安装在当前用户中：<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">IRkernel::installspec()</span><br></pre></td></tr></table></figure></li>
<li>安装在系统中：<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">IRkernel::installspec(user = <span class="literal">FALSE</span>)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="运行时间"><a href="#运行时间" class="headerlink" title="运行时间"></a>运行时间</h3><p>在cell中添加 <code>%%time</code> ，返回结果中会含有cell单次运行的时间。<br>在cell中添加 <code>%timeit</code> ，会运行该cell 100,000次（默认），然后以运行最快的3次结果的平均值作为结果。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy</span><br><span class="line">%timeit numpy.random.normal(size = <span class="number">10</span>)</span><br><span class="line"><span class="comment"># 5.91 µs ± 258 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)</span></span><br><span class="line">%%time</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">100</span>):</span><br><span class="line">    time.sleep(<span class="number">0.01</span>)</span><br><span class="line"><span class="comment"># Wall time: 1.73 s</span></span><br></pre></td></tr></table></figure></p>
<h3 id="插件管理器"><a href="#插件管理器" class="headerlink" title="插件管理器"></a>插件管理器</h3><p>Nbextensions相当于Jupyter的插件管理器。<br>安装：（在Anaconda Prompt中输入）<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda install -c conda-forge jupyter_contrib_nbextensions</span><br></pre></td></tr></table></figure><br>安装过程需要选择[y/n]，输入y。</p>
<p>该选项卡下方罗列了大量Jupyter可用的插件；点击某个插件的名称，即可在列表下方显示该插件的说明文档；勾选某个插件前面的方框，则系统会加载启用该插件。</p>
<h3 id="Jupyter-Lab！"><a href="#Jupyter-Lab！" class="headerlink" title="Jupyter Lab！"></a>Jupyter Lab！</h3><p>超好用！是Project Jupyter的下一代用户界面，具体安装和使用说明请见《<a href="https://mp.weixin.qq.com/s/T-Afq0vAw0lVB9Bave-aNQ" target="_blank" rel="noopener">Jupyter：超强的下一代Jupyter Notebook</a>》（原文作者Parul Pandey，EarlGrey翻译，<a href="https://towardsdatascience.com/jupyter-lab-evolution-of-the-jupyter-notebook-5297cacde6b?gi=dec00114bf03" target="_blank" rel="noopener">原文网址</a>）。</p>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line"><span class="section">## Jupyter Notebook的本地访问地址为</span></span><br><span class="line">http://localhost:8888/tree</span><br><span class="line"></span><br><span class="line"><span class="section">## Jupyter Lab的本地访问地址为</span></span><br><span class="line">http://localhost:8888/lab</span><br></pre></td></tr></table></figure>
<h3 id="切换Code和Markdown"><a href="#切换Code和Markdown" class="headerlink" title="切换Code和Markdown"></a>切换Code和Markdown</h3><p>要快捷地切换Cell的形式（Code或Markdown），可按如下操作：<br>选中Cell（光标在Cell中闪烁），点击“Esc”，进入命令模式（光标不再Cell中闪烁，但Cell左侧仍有蓝色粗线条）；然后键盘按“Y”将Cell切换为Code模式，键盘按“M”则将Cell切换为Markdown模式。即</p>
<ul>
<li>Esc+Y：code模式</li>
<li>Esc+M：Markdown模式</li>
<li>Esc+B：快速添加新的Cell</li>
</ul>
<h3 id="禁止输出警告（warnings）"><a href="#禁止输出警告（warnings）" class="headerlink" title="禁止输出警告（warnings）"></a>禁止输出警告（warnings）</h3><p>运行以下代码：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> warnings</span><br><span class="line">warnings.filterwarnings(<span class="string">"ignore"</span>)</span><br></pre></td></tr></table></figure></p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>[1] <a href="https://www.google.com/Jupyter" target="_blank" rel="noopener">首页缩略图</a><br>[2] <a href="https://www.cnblogs.com/bella1102/p/11032519.html" target="_blank" rel="noopener">Jupyter Notebook 如何让一个Cell 可以同时输出多个语句的值？</a><br>[3] <a href="https://www.sohu.com/a/219989263_774914" target="_blank" rel="noopener">Jupyter Notebook/Lab中添加R Kernel的详细步骤</a><br>[4] <a href="https://blog.csdn.net/create115721/article/details/79243641" target="_blank" rel="noopener">Jupyter Notebook的27个窍门，技巧和快捷键</a><br>[5] <a href="https://mp.weixin.qq.com/s/5sFkpI4eEodVQuLya3K5rw" target="_blank" rel="noopener">九大神招，让Python里数据分析神器Jupyter，完美升华</a></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Jupyter</tag>
      </tags>
  </entry>
  <entry>
    <title>Python | 字节</title>
    <url>/python-3.html</url>
    <content><![CDATA[<p><center>byte</center><br><a id="more"></a></p>
<h2 id="位"><a href="#位" class="headerlink" title="位"></a>位</h2><ul>
<li>bit，比特位，b</li>
<li>是<u>计算机内部数据存储的最小单位</u>，表示二进制数（也就是0, 1）</li>
</ul>
<h2 id="字节"><a href="#字节" class="headerlink" title="字节"></a>字节</h2><ul>
<li>byte，B</li>
<li>是<u>计算机中数据处理的基本单位</u></li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">简写</th>
<th style="text-align:center">英文名称</th>
<th style="text-align:left">中文名称</th>
<th style="text-align:left">换算</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">B</td>
<td style="text-align:center">byte</td>
<td style="text-align:left">字节</td>
<td style="text-align:left">1B = 8 b</td>
</tr>
<tr>
<td style="text-align:center">KB</td>
<td style="text-align:center">Kilobyte</td>
<td style="text-align:left">千字节</td>
<td style="text-align:left">1KB = 1024 B</td>
</tr>
<tr>
<td style="text-align:center">MB</td>
<td style="text-align:center">Megabyte</td>
<td style="text-align:left">兆字节/百万字节，简称兆</td>
<td style="text-align:left">1 MB = 1024 KB</td>
</tr>
<tr>
<td style="text-align:center">GB</td>
<td style="text-align:center">Gigabyte</td>
<td style="text-align:left">吉字节/十亿字节，简称千兆</td>
<td style="text-align:left">1 GB = 1024 MB</td>
</tr>
<tr>
<td style="text-align:center">TB</td>
<td style="text-align:center">Terabyte</td>
<td style="text-align:left">太字节/万亿字节</td>
<td style="text-align:left">1 TB = 1024 GB</td>
</tr>
<tr>
<td style="text-align:center">PB</td>
<td style="text-align:center">Petabyte</td>
<td style="text-align:left">拍字节/千万亿字节</td>
<td style="text-align:left">1 PB = 1024 TB</td>
</tr>
<tr>
<td style="text-align:center">EB</td>
<td style="text-align:center">Exabyte</td>
<td style="text-align:left">艾字节/百亿亿字节</td>
<td style="text-align:left">1 EB = 1024 PB</td>
</tr>
<tr>
<td style="text-align:center">ZB</td>
<td style="text-align:center">Zettabyte</td>
<td style="text-align:left">泽字节/十万亿亿字节</td>
<td style="text-align:left">1 ZB = 1024 EB</td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode刷题</title>
    <url>/Leetcode%E5%88%B7%E9%A2%98.html</url>
    <content><![CDATA[<p><center>Leetcode刷题记录~</center><br><a id="more"></a></p>
<h1 id="1-Two-Sum"><a href="#1-Two-Sum" class="headerlink" title="1. Two Sum"></a>1. Two Sum</h1><p><a href="https://leetcode.com/problems/two-sum/" target="_blank" rel="noopener">题目详情</a><br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; List[int]:</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> nums:</span><br><span class="line">            num = nums[<span class="number">0</span>]</span><br><span class="line">            nums.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">if</span> target - num <span class="keyword">in</span> nums:</span><br><span class="line">                <span class="keyword">return</span> [i, nums.index(target-num) + i + <span class="number">1</span>]</span><br><span class="line">            i += <span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<h1 id="9-Palindrome-Number"><a href="#9-Palindrome-Number" class="headerlink" title="9. Palindrome Number"></a>9. Palindrome Number</h1><p><a href="https://leetcode.com/problems/palindrome-number/" target="_blank" rel="noopener">题目详情</a><br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span><span class="params">(self, x: int)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">return</span> str(x) == str(x)[::<span class="number">-1</span>]</span><br></pre></td></tr></table></figure></p>
<h1 id="14-Longest-Common-Prefix"><a href="#14-Longest-Common-Prefix" class="headerlink" title="14. Longest Common Prefix"></a>14. Longest Common Prefix</h1><ul>
<li><a href="https://leetcode.com/problems/longest-common-prefix/" target="_blank" rel="noopener">题目详情</a></li>
<li>TAG: 公共子串, 字符串<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestCommonPrefix</span><span class="params">(self, strs: List[str])</span> -&gt; str:</span></span><br><span class="line">        prefix = <span class="string">""</span></span><br><span class="line">        <span class="keyword">if</span> strs == []:</span><br><span class="line">            <span class="keyword">return</span> prefix</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            n = min([len(x) <span class="keyword">for</span> x <span class="keyword">in</span> strs])</span><br><span class="line">            <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> prefix</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">                    pre = [x[:i+<span class="number">1</span>] <span class="keyword">for</span> x <span class="keyword">in</span> strs]</span><br><span class="line">                    <span class="keyword">if</span> len(set(pre)) == <span class="number">1</span>:</span><br><span class="line">                        prefix = strs[<span class="number">0</span>][:i+<span class="number">1</span>]</span><br><span class="line">                        <span class="keyword">if</span> i == n<span class="number">-1</span>:</span><br><span class="line">                            <span class="keyword">return</span> prefix</span><br><span class="line">                        <span class="keyword">else</span>:</span><br><span class="line">                            <span class="keyword">pass</span></span><br><span class="line">                <span class="keyword">return</span> prefix</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><a href>题目详情</a><br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h1 id="67-Add-Binary"><a href="#67-Add-Binary" class="headerlink" title="67. Add Binary"></a>67. Add Binary</h1><p><a href="https://leetcode.com/problems/add-binary/" target="_blank" rel="noopener">题目详情</a><br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addBinary</span><span class="params">(self, a: str, b: str)</span> -&gt; str:</span></span><br><span class="line">        <span class="keyword">return</span> bin(int(a, <span class="number">2</span>) + int(b, <span class="number">2</span>))[<span class="number">2</span>:]</span><br></pre></td></tr></table></figure></p>
<h1 id="177-Nth-Highest-Salary"><a href="#177-Nth-Highest-Salary" class="headerlink" title="177. Nth Highest Salary"></a>177. Nth Highest Salary</h1><ul>
<li><a href="https://leetcode.com/problems/nth-highest-salary/" target="_blank" rel="noopener">题目详情</a></li>
<li>TAG: SQL<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- Runtime=553ms</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> getNthHighestSalary(N <span class="built_in">INT</span>) <span class="keyword">RETURNS</span> <span class="built_in">INT</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">DECLARE</span> M <span class="built_in">INT</span>;</span><br><span class="line"><span class="keyword">SET</span> M=N<span class="number">-1</span>;</span><br><span class="line">  RETURN (</span><br><span class="line">      <span class="comment"># Write your MySQL query statement below.</span></span><br><span class="line">      <span class="keyword">SELECT</span> Salary <span class="keyword">FROM</span> </span><br><span class="line">            (<span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> Salary <span class="keyword">FROM</span> Employee <span class="keyword">ORDER</span> <span class="keyword">BY</span> Salary <span class="keyword">DESC</span>) a</span><br><span class="line">      <span class="keyword">LIMIT</span> <span class="number">1</span> <span class="keyword">OFFSET</span> M</span><br><span class="line">  );</span><br><span class="line"><span class="keyword">END</span></span><br><span class="line"><span class="comment">-- Runtime=416ms</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> getNthHighestSalary(N <span class="built_in">INT</span>) <span class="keyword">RETURNS</span> <span class="built_in">INT</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">DECLARE</span> M <span class="built_in">INT</span>;</span><br><span class="line"><span class="keyword">SET</span> M=N<span class="number">-1</span>;</span><br><span class="line">  RETURN (</span><br><span class="line">      <span class="comment"># Write your MySQL query statement below.</span></span><br><span class="line">      <span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> Salary <span class="keyword">FROM</span> Employee</span><br><span class="line">      <span class="keyword">ORDER</span> <span class="keyword">BY</span> Salary <span class="keyword">DESC</span></span><br><span class="line">      <span class="keyword">LIMIT</span> <span class="number">1</span> <span class="keyword">OFFSET</span> M</span><br><span class="line">  );</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="268-Missing-Number"><a href="#268-Missing-Number" class="headerlink" title="268. Missing Number"></a>268. Missing Number</h1><p><a href="https://leetcode.com/problems/missing-number/" target="_blank" rel="noopener">题目详情</a><br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## Runtime: 4364 ms, Memory Usage: 15 MB</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">missingNumber</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> nums:</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line"><span class="comment">## Runtime: 128 ms, Memory Usage: 15.1 MB</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">missingNumber</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        <span class="keyword">return</span> n*(n+<span class="number">1</span>)//<span class="number">2</span> -sum(nums)</span><br></pre></td></tr></table></figure></p>
<h1 id="300-Longest-Increasing-Subsequence"><a href="#300-Longest-Increasing-Subsequence" class="headerlink" title="300. Longest Increasing Subsequence"></a>300. Longest Increasing Subsequence</h1><ul>
<li><a href="https://leetcode.com/problems/longest-increasing-subsequence/" target="_blank" rel="noopener">题目详情</a></li>
<li>TAG: 动态规划</li>
<li>思路：<a href="https://labuladong.github.io/ebook/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B3%BB%E5%88%97/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%AE%BE%E8%AE%A1%EF%BC%9A%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97.html" target="_blank" rel="noopener">GitHub-Fucking Algorithm-动态规划设计：最长递增子序列</a><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLIS</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        n = len(nums)  <span class="comment">## 列表长度</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        dp = [<span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]  <span class="comment">## 初始值都是1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i):</span><br><span class="line">                <span class="keyword">if</span> nums[i] &gt; nums[j]:</span><br><span class="line">                    dp[i] = max(dp[i], dp[j] + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> max(dp)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="371-Sum-of-Two-Integers"><a href="#371-Sum-of-Two-Integers" class="headerlink" title="371. Sum of Two Integers"></a>371. Sum of Two Integers</h1><ul>
<li><a href="https://leetcode.com/problems/sum-of-two-integers/" target="_blank" rel="noopener">题目详情</a></li>
<li>TAG: 数, amazing</li>
<li>Calculate the sum of two integers a and b, but you are <strong>not allowed</strong> to use the operator + and -.</li>
<li>参考:<a href="https://leetcode.com/problems/sum-of-two-integers/discuss/607587/Python-two-liner-beats-100-(12-ms-runtime)-without-bit-manipulation-or-native-addition" target="_blank" rel="noopener">https://leetcode.com/problems/sum-of-two-integers/discuss/607587/Python-two-liner-beats-100-(12-ms-runtime)-without-bit-manipulation-or-native-addition</a><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getSum</span><span class="params">(self, a: int, b: int)</span> -&gt; int:</span></span><br><span class="line">        base = <span class="number">1.0000000001</span></span><br><span class="line">        <span class="keyword">return</span> round(math.log((base**a) * (base**b), base))</span><br></pre></td></tr></table></figure></li>
<li>$a=\log_z{z^a}$</li>
<li>$b=\log_z{z^b}$</li>
<li>$a+b=\log_z{z^a}+\log_z{z^b}=\log_z{(z^a\cdot z^b)}$</li>
</ul>
<h1 id="657-Robot-Return-to-Origin"><a href="#657-Robot-Return-to-Origin" class="headerlink" title="657. Robot Return to Origin"></a>657. Robot Return to Origin</h1><p><a href="https://leetcode.com/problems/robot-return-to-origin/" target="_blank" rel="noopener">题目详情</a><br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## Runtime=64ms, Memory=13.8MB</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">judgeCircle</span><span class="params">(self, moves: str)</span> -&gt; bool:</span></span><br><span class="line">        pos = [<span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> move <span class="keyword">in</span> moves:</span><br><span class="line">            <span class="keyword">if</span> move==<span class="string">'L'</span>:</span><br><span class="line">                pos[<span class="number">0</span>] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> move==<span class="string">'R'</span>:</span><br><span class="line">                pos[<span class="number">0</span>] -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> move==<span class="string">'U'</span>:</span><br><span class="line">                pos[<span class="number">1</span>] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                pos[<span class="number">1</span>] -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> pos==[<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line"><span class="comment">## Solution</span></span><br><span class="line"><span class="comment">## Runtime=60ms, Memory=13.8MB</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">judgeCircle</span><span class="params">(self, moves: str)</span> -&gt; bool:</span></span><br><span class="line">        x = y = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> move <span class="keyword">in</span> moves:</span><br><span class="line">            <span class="keyword">if</span> move == <span class="string">'U'</span>: y -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> move == <span class="string">'D'</span>: y += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> move == <span class="string">'L'</span>: x -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> move == <span class="string">'R'</span>: x += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> x == y == <span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<h1 id="728-Self-Dividing-Numbers"><a href="#728-Self-Dividing-Numbers" class="headerlink" title="728. Self Dividing Numbers"></a>728. Self Dividing Numbers</h1><p><a href="https://leetcode.com/problems/self-dividing-numbers/" target="_blank" rel="noopener">题目详情</a><br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## Runtime=68ms, Memory=13.9MB</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">selfDividingNumbers</span><span class="params">(self, left: int, right: int)</span> -&gt; List[int]:</span></span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> range(left, right+<span class="number">1</span>):</span><br><span class="line">            nums = list(map(int, list(str(num))))</span><br><span class="line">            count = <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> <span class="number">0</span> <span class="keyword">in</span> nums:</span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> nums:</span><br><span class="line">                    <span class="keyword">if</span> num%j == <span class="number">0</span>:</span><br><span class="line">                        count += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> count == len(nums):</span><br><span class="line">                    result.append(num)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"><span class="comment">## 参考 Solution</span></span><br><span class="line"><span class="comment">## Rumtime=36ms, Memory=14MB</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">selfDividingNumbers</span><span class="params">(self, left: int, right: int)</span> -&gt; List[int]:</span></span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> range(left, right+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> x <span class="keyword">in</span> str(num):</span><br><span class="line">                <span class="keyword">if</span> x == <span class="string">"0"</span> <span class="keyword">or</span> num % int(x) != <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                result.append(num)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure></p>
<h1 id="796-Rotate-String"><a href="#796-Rotate-String" class="headerlink" title="796. Rotate String"></a>796. Rotate String</h1><p><a href="https://leetcode.com/problems/rotate-string/" target="_blank" rel="noopener">题目详情</a><br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Solution</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rotateString</span><span class="params">(self, A: str, B: str)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">return</span> len(A)==len(B) <span class="keyword">and</span> B <span class="keyword">in</span> A+A</span><br></pre></td></tr></table></figure></p>
<p><a href>题目详情</a><br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h1 id="832-Flipping-an-Image"><a href="#832-Flipping-an-Image" class="headerlink" title="832. Flipping an Image"></a>832. Flipping an Image</h1><p><a href="https://leetcode.com/problems/flipping-an-image/" target="_blank" rel="noopener">题目详情</a><br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## Runtime=56ms, Memory=13.9MB</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">flipAndInvertImage</span><span class="params">(self, A: List[List[int]])</span> -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(A)):</span><br><span class="line">            A[i].reverse()</span><br><span class="line">            A[i] = [<span class="number">1</span>-x <span class="keyword">for</span> x <span class="keyword">in</span> A[i]]</span><br><span class="line">        <span class="keyword">return</span> A</span><br><span class="line"><span class="comment">## Runtime=52ms, Memory=14MB</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">flipAndInvertImage</span><span class="params">(self, A: List[List[int]])</span> -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(A)):</span><br><span class="line">            A[i] = A[i][::<span class="number">-1</span>]  <span class="comment">## difference</span></span><br><span class="line">            A[i] = [<span class="number">1</span>-x <span class="keyword">for</span> x <span class="keyword">in</span> A[i]]</span><br><span class="line">        <span class="keyword">return</span> A</span><br><span class="line"><span class="comment">## Runtime=48ms, Memory=14MB</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">flipAndInvertImage</span><span class="params">(self, A: List[List[int]])</span> -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="keyword">for</span> i, row <span class="keyword">in</span> enumerate(A):  <span class="comment">## differencee</span></span><br><span class="line">            A[i] = row[::<span class="number">-1</span>]</span><br><span class="line">            <span class="keyword">for</span> j, col <span class="keyword">in</span> enumerate(A[i]):  <span class="comment">## difference</span></span><br><span class="line">                A[i][j] = <span class="number">1</span> - col</span><br><span class="line">        <span class="keyword">return</span> A</span><br></pre></td></tr></table></figure></p>
<h1 id="852-Peak-Index-in-a-Mountain-Array"><a href="#852-Peak-Index-in-a-Mountain-Array" class="headerlink" title="852. Peak Index in a Mountain Array"></a>852. Peak Index in a Mountain Array</h1><p><a href="https://leetcode.com/problems/peak-index-in-a-mountain-array/" target="_blank" rel="noopener">题目详情</a><br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## Runtime=84ms, Memory=15.1MB</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">peakIndexInMountainArray</span><span class="params">(self, A: List[int])</span> -&gt; int:</span></span><br><span class="line">        idx = int((len(A)<span class="number">-1</span>)/<span class="number">2</span> <span class="keyword">if</span> len(A)%<span class="number">2</span>==<span class="number">1</span> <span class="keyword">else</span> len(A)/<span class="number">2</span>)</span><br><span class="line">        left, right = idx<span class="number">-1</span>, idx+<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left&gt;=<span class="number">0</span> <span class="keyword">and</span> right&lt;len(A):</span><br><span class="line">            <span class="keyword">if</span> A[idx]&gt;A[left] <span class="keyword">and</span> A[idx]&gt;A[right]:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">elif</span> A[idx]&lt;A[left]:</span><br><span class="line">                left -= <span class="number">1</span></span><br><span class="line">                idx -= <span class="number">1</span></span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">                idx += <span class="number">1</span></span><br><span class="line">                right += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> idx</span><br><span class="line"><span class="comment">## Runtime=80ms, Memory=15MB</span></span><br><span class="line"><span class="comment">## Binary search in Solution</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">peakIndexInMountainArray</span><span class="params">(self, A: List[int])</span> -&gt; int:</span></span><br><span class="line">        lo, hi = <span class="number">0</span>, len(A) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> lo &lt; hi:</span><br><span class="line">            mi = int((lo + hi) / <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">if</span> A[mi] &lt; A[mi + <span class="number">1</span>]:</span><br><span class="line">                lo = mi + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                hi = mi</span><br><span class="line">        <span class="keyword">return</span> lo</span><br><span class="line"><span class="comment">## Runtime=84ms, Memory=15.2MB</span></span><br><span class="line"><span class="comment">## Linear scan</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">peakIndexInMountainArray</span><span class="params">(self, A: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(A)):</span><br><span class="line">            <span class="keyword">if</span> A[i] &gt; A[i+<span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">return</span> i</span><br></pre></td></tr></table></figure></p>
<h1 id="942-DI-String-Match"><a href="#942-DI-String-Match" class="headerlink" title="942. DI String Match"></a>942. DI String Match</h1><p><a href="https://leetcode.com/problems/di-string-match/" target="_blank" rel="noopener">题目详情</a><br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 参考了 Solution</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">diStringMatch</span><span class="params">(self, S: str)</span> -&gt; List[int]:</span></span><br><span class="line">        low, high = <span class="number">0</span>, len(S)</span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">for</span> s <span class="keyword">in</span> S:</span><br><span class="line">            <span class="keyword">if</span> s == <span class="string">'I'</span>:</span><br><span class="line">                result.append(low)</span><br><span class="line">                low += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                result.append(high)</span><br><span class="line">                high -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> result + [low]</span><br></pre></td></tr></table></figure></p>
<h1 id="965-Univalued-Binary-Tree"><a href="#965-Univalued-Binary-Tree" class="headerlink" title="965. Univalued Binary Tree"></a>965. Univalued Binary Tree</h1><p><a href="https://leetcode.com/problems/univalued-binary-tree/" target="_blank" rel="noopener">题目详情</a><br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isUnivalTree</span><span class="params">(self, root: TreeNode)</span> -&gt; bool:</span></span><br><span class="line">        values = []</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(node)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> node:</span><br><span class="line">                values.append(node.val)</span><br><span class="line">                dfs(node.left)</span><br><span class="line">                dfs(node.right)</span><br><span class="line">        </span><br><span class="line">        dfs(root)</span><br><span class="line">        <span class="keyword">return</span> len(set(values)) == <span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<h1 id="977-Squares-of-a-Sorted-Array"><a href="#977-Squares-of-a-Sorted-Array" class="headerlink" title="977. Squares of a Sorted Array"></a>977. Squares of a Sorted Array</h1><p><a href="https://leetcode.com/problems/squares-of-a-sorted-array/" target="_blank" rel="noopener">题目详情</a><br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## Runtime=228ms, Memory=15.7MB</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortedSquares</span><span class="params">(self, A: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">         <span class="keyword">return</span> sorted([x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> A])</span><br><span class="line"><span class="comment">## Runtime=216ms, Memory=15.8MB</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortedSquares</span><span class="params">(self, A: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">         <span class="keyword">return</span> sorted([x*x <span class="keyword">for</span> x <span class="keyword">in</span> A])</span><br></pre></td></tr></table></figure></p>
<h1 id="1021-Remove-Outermost-Parentheses"><a href="#1021-Remove-Outermost-Parentheses" class="headerlink" title="1021. Remove Outermost Parentheses"></a>1021. Remove Outermost Parentheses</h1><p><a href="https://leetcode.com/problems/remove-outermost-parentheses/" target="_blank" rel="noopener">题目详情</a><br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 参考了solutions in discuss</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeOuterParentheses</span><span class="params">(self, S: str)</span> -&gt; str:</span></span><br><span class="line">        count, result = <span class="number">0</span>, []</span><br><span class="line">        <span class="keyword">for</span> s <span class="keyword">in</span> S:</span><br><span class="line">            <span class="keyword">if</span> s == <span class="string">")"</span>:  <span class="comment">##  完整配对count=0；增加一个")"count减一；增加一个"("count加一</span></span><br><span class="line">                count -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> count &gt; <span class="number">0</span>:</span><br><span class="line">                result.append(s)</span><br><span class="line">            <span class="keyword">if</span> s == <span class="string">"("</span>: </span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>.join(result)</span><br></pre></td></tr></table></figure></p>
<p><a href>题目详情</a><br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h1 id="1108-Defanging-an-IP-Address"><a href="#1108-Defanging-an-IP-Address" class="headerlink" title="1108. Defanging an IP Address"></a>1108. Defanging an IP Address</h1><p><a href="https://leetcode.com/problems/defanging-an-ip-address/" target="_blank" rel="noopener">题目详情</a><br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">defangIPaddr</span><span class="params">(self, address: str)</span> -&gt; str:</span></span><br><span class="line">        <span class="keyword">return</span> address.replace(<span class="string">"."</span>, <span class="string">"[.]"</span>)</span><br></pre></td></tr></table></figure></p>
<h1 id="1221-Split-a-String-in-Balanced-Strings"><a href="#1221-Split-a-String-in-Balanced-Strings" class="headerlink" title="1221. Split a String in Balanced Strings"></a>1221. Split a String in Balanced Strings</h1><p><a href="https://leetcode.com/problems/split-a-string-in-balanced-strings/" target="_blank" rel="noopener">题目详情</a><br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">balancedStringSplit</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        ans_count = <span class="number">0</span></span><br><span class="line">        L_num, R_num = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> ss <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> ss==<span class="string">"L"</span>:</span><br><span class="line">                L_num += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                R_num += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> L_num==R_num:</span><br><span class="line">                ans_count += <span class="number">1</span></span><br><span class="line">                L_num, R_num = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> ans_count</span><br></pre></td></tr></table></figure></p>
<h1 id="1252-Cells-with-Odd-Values-in-a-Matrix"><a href="#1252-Cells-with-Odd-Values-in-a-Matrix" class="headerlink" title="1252. Cells with Odd Values in a Matrix"></a>1252. Cells with Odd Values in a Matrix</h1><p><a href="https://leetcode.com/problems/cells-with-odd-values-in-a-matrix/" target="_blank" rel="noopener">题目详情</a><br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">oddCells</span><span class="params">(self, n: int, m: int, indices: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        nums = [[<span class="number">0</span>]*m]*n  <span class="comment">## 快速创建0矩阵</span></span><br><span class="line">        rows, cols = [<span class="number">0</span>]*n, [<span class="number">0</span>]*m</span><br><span class="line">        lst = []</span><br><span class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> indices:</span><br><span class="line">            ri, ci = index[<span class="number">0</span>], index[<span class="number">1</span>]</span><br><span class="line">            rows[ri] += <span class="number">1</span></span><br><span class="line">            cols[ci] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(m):</span><br><span class="line">                nums[i][j] = rows[i] + cols[j]</span><br><span class="line">            lst += nums[i]</span><br><span class="line">        <span class="keyword">return</span> sum([<span class="number">1</span> <span class="keyword">if</span> x%<span class="number">2</span>==<span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">for</span> x <span class="keyword">in</span> lst])</span><br></pre></td></tr></table></figure></p>
<p><a href>题目详情</a><br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h1 id="1266-Minimum-Time-Visiting-All-Points"><a href="#1266-Minimum-Time-Visiting-All-Points" class="headerlink" title="1266. Minimum Time Visiting All Points"></a>1266. Minimum Time Visiting All Points</h1><p><a href="https://leetcode.com/problems/minimum-time-visiting-all-points/" target="_blank" rel="noopener">题目详情</a><br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minTimeToVisitAllPoints</span><span class="params">(self, points: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        steps = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(points)<span class="number">-1</span>):</span><br><span class="line">            x1, y1 = points[i][<span class="number">0</span>], points[i][<span class="number">1</span>]</span><br><span class="line">            x2, y2 = points[i+<span class="number">1</span>][<span class="number">0</span>], points[i+<span class="number">1</span>][<span class="number">1</span>]</span><br><span class="line">            m, n = abs(x2 - x1), abs(y2 - y1)</span><br><span class="line">            steps += max(m, n)</span><br><span class="line">        <span class="keyword">return</span> steps</span><br></pre></td></tr></table></figure></p>
<h1 id="1281-Subtract-the-Product-and-Sum-of-Digits-of-an-Integer"><a href="#1281-Subtract-the-Product-and-Sum-of-Digits-of-an-Integer" class="headerlink" title="1281. Subtract the Product and Sum of Digits of an Integer"></a>1281. Subtract the Product and Sum of Digits of an Integer</h1><p><a href="https://leetcode.com/problems/subtract-the-product-and-sum-of-digits-of-an-integer/" target="_blank" rel="noopener">题目详情</a><br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subtractProductAndSum</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        num = [x <span class="keyword">for</span> x <span class="keyword">in</span> str(n)]</span><br><span class="line">        num = list(map(int, num))  <span class="comment">## 将int拆开成单个数字列表</span></span><br><span class="line">        pp = <span class="number">1</span></span><br><span class="line">        ss = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> nn <span class="keyword">in</span> num:</span><br><span class="line">            pp *= nn</span><br><span class="line">            ss += nn</span><br><span class="line">        <span class="keyword">return</span> pp - ss</span><br></pre></td></tr></table></figure></p>
<h1 id="1290-Convert-Binary-Number-in-a-Linked-List-to-Integer"><a href="#1290-Convert-Binary-Number-in-a-Linked-List-to-Integer" class="headerlink" title="1290. Convert Binary Number in a Linked List to Integer"></a>1290. Convert Binary Number in a Linked List to Integer</h1><p><a href="https://leetcode.com/problems/convert-binary-number-in-a-linked-list-to-integer/" target="_blank" rel="noopener">题目详情</a><br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getDecimalValue</span><span class="params">(self, head: ListNode)</span> -&gt; int:</span></span><br><span class="line">        str_num = <span class="string">""</span></span><br><span class="line">        <span class="keyword">while</span> head:  <span class="comment">## 当head非空</span></span><br><span class="line">            str_num += str(head.val)</span><br><span class="line">            head = head.next</span><br><span class="line">        <span class="keyword">return</span> int(str_num, <span class="number">2</span>)</span><br></pre></td></tr></table></figure></p>
<p><a href>题目详情</a><br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h1 id="1295-Find-Numbers-with-Even-Number-of-Digits"><a href="#1295-Find-Numbers-with-Even-Number-of-Digits" class="headerlink" title="1295. Find Numbers with Even Number of Digits"></a>1295. Find Numbers with Even Number of Digits</h1><p><a href="https://leetcode.com/problems/find-numbers-with-even-number-of-digits/" target="_blank" rel="noopener">题目详情</a><br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findNumbers</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        ans_count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            num_count = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> num:</span><br><span class="line">                num_count += <span class="number">1</span></span><br><span class="line">                num //= <span class="number">10</span>  <span class="comment">## num除以10的商</span></span><br><span class="line">            <span class="keyword">if</span> num_count % <span class="number">2</span> == <span class="number">0</span>:  <span class="comment">## num_count除以2的余数等于0</span></span><br><span class="line">                ans_count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans_count</span><br></pre></td></tr></table></figure></p>
<h1 id="1299-Replace-Elements-with-Greatest-Element-on-Right-Side"><a href="#1299-Replace-Elements-with-Greatest-Element-on-Right-Side" class="headerlink" title="1299. Replace Elements with Greatest Element on Right Side"></a>1299. Replace Elements with Greatest Element on Right Side</h1><p><a href="https://leetcode.com/problems/replace-elements-with-greatest-element-on-right-side/" target="_blank" rel="noopener">题目详情</a><br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## Runtime=4720ms</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">replaceElements</span><span class="params">(self, arr: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">        out = []</span><br><span class="line">        n = len(arr)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n<span class="number">-1</span>):</span><br><span class="line">            out.append(max(arr[(i+<span class="number">1</span>):]))</span><br><span class="line">        out.append(<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> out</span><br><span class="line"><span class="comment">## A solution in 'Discuss'</span></span><br><span class="line"><span class="comment">## Runtime=125ms</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">replaceElements</span><span class="params">(self, arr: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">        max_num = <span class="number">-1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(arr)<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            hold = arr[i]</span><br><span class="line">            arr[i] = max_num</span><br><span class="line">            <span class="keyword">if</span> hold &gt; max_num:</span><br><span class="line">                max_num = hold</span><br><span class="line">        <span class="keyword">return</span> arr</span><br></pre></td></tr></table></figure></p>
<h1 id="1304-Find-N-Unique-Integers-Sum-up-to-Zero"><a href="#1304-Find-N-Unique-Integers-Sum-up-to-Zero" class="headerlink" title="1304. Find N Unique Integers Sum up to Zero"></a>1304. Find N Unique Integers Sum up to Zero</h1><p><a href="https://leetcode.com/problems/find-n-unique-integers-sum-up-to-zero/" target="_blank" rel="noopener">题目详情</a><br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sumZero</span><span class="params">(self, n: int)</span> -&gt; List[int]:</span></span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">if</span> n % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">            lst = [x <span class="keyword">for</span> x <span class="keyword">in</span> range(n<span class="number">-1</span>)]</span><br><span class="line">            result.extend(lst)</span><br><span class="line">            result.append(-sum(lst))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            lst = [x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>,int((n+<span class="number">1</span>)//<span class="number">2</span>))]</span><br><span class="line">            result.extend(lst)</span><br><span class="line">            result.extend([-x <span class="keyword">for</span> x <span class="keyword">in</span> lst])</span><br><span class="line">            result.append(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure></p>
<h1 id="1309-Decrypt-String-from-Alphabet-to-Integer-Mapping"><a href="#1309-Decrypt-String-from-Alphabet-to-Integer-Mapping" class="headerlink" title="1309. Decrypt String from Alphabet to Integer Mapping"></a>1309. Decrypt String from Alphabet to Integer Mapping</h1><p><a href="https://leetcode.com/problems/decrypt-string-from-alphabet-to-integer-mapping/" target="_blank" rel="noopener">题目详情</a><br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">freqAlphabets</span><span class="params">(self, s: str)</span> -&gt; str:</span></span><br><span class="line">        result = <span class="string">""</span></span><br><span class="line">        dic = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">97</span>,<span class="number">123</span>):</span><br><span class="line">            <span class="keyword">if</span> i &lt;= <span class="number">105</span>:</span><br><span class="line">                dic[str(i - <span class="number">96</span>)] = chr(i)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dic[str(i - <span class="number">96</span>) + <span class="string">'#'</span>] = chr(i)</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; len(s):</span><br><span class="line">            <span class="keyword">if</span>  i+<span class="number">2</span> &lt; len(s) <span class="keyword">and</span> s[i+<span class="number">2</span>] == <span class="string">'#'</span>:</span><br><span class="line">                key = s[i:i+<span class="number">3</span>]</span><br><span class="line">                i += <span class="number">3</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                key = s[i]</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            result += dic[key]</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure></p>
<h1 id="1313-Decompress-Run-Length-Encoded-List"><a href="#1313-Decompress-Run-Length-Encoded-List" class="headerlink" title="1313. Decompress Run-Length Encoded List"></a>1313. Decompress Run-Length Encoded List</h1><p><a href="https://leetcode.com/problems/decompress-run-length-encoded-list/" target="_blank" rel="noopener">题目详情</a><br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decompressRLElist</span><span class="params">(self, nums: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        ans = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(int(n/<span class="number">2</span>)):</span><br><span class="line">            n = nums[<span class="number">2</span>*i]</span><br><span class="line">            num = nums[<span class="number">2</span>*i+<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">                ans.append(num)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></p>
<h1 id="1323-Maximum-69-Number"><a href="#1323-Maximum-69-Number" class="headerlink" title="1323. Maximum 69 Number"></a>1323. Maximum 69 Number</h1><p><a href="https://leetcode.com/problems/maximum-69-number/" target="_blank" rel="noopener">题目详情</a><br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maximum69Number</span> <span class="params">(self, num: int)</span> -&gt; int:</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        out = [x <span class="keyword">for</span> x <span class="keyword">in</span> str(num)]</span><br><span class="line">        <span class="keyword">while</span> i&lt;len(out):</span><br><span class="line">            <span class="keyword">if</span> out[i] == <span class="string">'6'</span>:</span><br><span class="line">                out[i] = <span class="string">'9'</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> int(<span class="string">''</span>.join(out))</span><br></pre></td></tr></table></figure></p>
<h1 id="1342-Number-of-Steps-to-Reduce-a-Number-to-Zero"><a href="#1342-Number-of-Steps-to-Reduce-a-Number-to-Zero" class="headerlink" title="1342. Number of Steps to Reduce a Number to Zero"></a>1342. Number of Steps to Reduce a Number to Zero</h1><p><a href="https://leetcode.com/problems/number-of-steps-to-reduce-a-number-to-zero/" target="_blank" rel="noopener">题目详情</a><br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numberOfSteps</span> <span class="params">(self, num: int)</span> -&gt; int:</span></span><br><span class="line">        cou = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> num&gt;<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> num % <span class="number">2</span> == <span class="number">0</span>:  <span class="comment">## if even</span></span><br><span class="line">                num = int(num / <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">else</span>:  <span class="comment">## if odd</span></span><br><span class="line">                num -= <span class="number">1</span></span><br><span class="line">            cou += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> cou</span><br></pre></td></tr></table></figure></p>
<h1 id="1351-Count-Negative-Numbers-in-a-Sorted-Matrix"><a href="#1351-Count-Negative-Numbers-in-a-Sorted-Matrix" class="headerlink" title="1351. Count Negative Numbers in a Sorted Matrix"></a>1351. Count Negative Numbers in a Sorted Matrix</h1><p><a href="https://leetcode.com/problems/count-negative-numbers-in-a-sorted-matrix/" target="_blank" rel="noopener">题目详情</a><br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countNegatives</span><span class="params">(self, grid: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        nums = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(grid)):</span><br><span class="line">            nums += grid[i]</span><br><span class="line">        <span class="keyword">return</span> sum([<span class="number">1</span> <span class="keyword">if</span> x&lt;<span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">for</span> x <span class="keyword">in</span> nums])</span><br></pre></td></tr></table></figure></p>
<h1 id="1370-Increasing-Decreasing-String"><a href="#1370-Increasing-Decreasing-String" class="headerlink" title="1370. Increasing Decreasing String"></a>1370. Increasing Decreasing String</h1><p><a href="https://leetcode.com/problems/increasing-decreasing-string/" target="_blank" rel="noopener">题目详情</a><br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 参考了 solution in discuss</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortString</span><span class="params">(self, s: str)</span> -&gt; str:</span></span><br><span class="line">        result = []</span><br><span class="line">        s = [x <span class="keyword">for</span> x <span class="keyword">in</span> s]  <span class="comment">## 等价于 s = list(s)</span></span><br><span class="line">        direct = <span class="number">1</span>  <span class="comment">## =1表示从小到大；=-1表示从大到小</span></span><br><span class="line">        <span class="keyword">while</span> s:  <span class="comment">## 当s非空时</span></span><br><span class="line">            <span class="keyword">if</span> direct == <span class="number">1</span>:</span><br><span class="line">                ss = sorted(set(s))  <span class="comment">## 从小到大</span></span><br><span class="line">            <span class="keyword">else</span>: </span><br><span class="line">                ss = sorted(set(s))[::<span class="number">-1</span>]  <span class="comment">## 从大到小</span></span><br><span class="line">            result.extend(ss)</span><br><span class="line">            <span class="keyword">for</span> x <span class="keyword">in</span> ss:</span><br><span class="line">                s.remove(x)</span><br><span class="line">            direct *= <span class="number">-1</span>  <span class="comment">## 反向</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>.join(result)</span><br></pre></td></tr></table></figure></p>
<h1 id="1374-Generate-a-String-With-Characters-That-Have-Odd-Counts"><a href="#1374-Generate-a-String-With-Characters-That-Have-Odd-Counts" class="headerlink" title="1374. Generate a String With Characters That Have Odd Counts"></a>1374. Generate a String With Characters That Have Odd Counts</h1><p><a href="https://leetcode.com/problems/generate-a-string-with-characters-that-have-odd-counts/" target="_blank" rel="noopener">题目详情</a><br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generateTheString</span><span class="params">(self, n: int)</span> -&gt; str:</span></span><br><span class="line">        <span class="keyword">if</span> n%<span class="number">2</span>==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'a'</span>*(n<span class="number">-1</span>) + <span class="string">'b'</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'a'</span>*n</span><br></pre></td></tr></table></figure></p>
<h1 id="1380-Lucky-Numbers-in-a-Matrix"><a href="#1380-Lucky-Numbers-in-a-Matrix" class="headerlink" title="1380. Lucky Numbers in a Matrix"></a>1380. Lucky Numbers in a Matrix</h1><p><a href="https://leetcode.com/problems/lucky-numbers-in-a-matrix/" target="_blank" rel="noopener">题目详情</a><br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">luckyNumbers</span> <span class="params">(self, matrix: List[List[int]])</span> -&gt; List[int]:</span></span><br><span class="line">        rows = [min(x) <span class="keyword">for</span> x <span class="keyword">in</span> matrix]</span><br><span class="line">        n, m = len(matrix), len(matrix[<span class="number">0</span>])</span><br><span class="line">        cols, ans = [], []</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(m):</span><br><span class="line">            col = [x[j] <span class="keyword">for</span> x <span class="keyword">in</span> matrix]</span><br><span class="line">            cols.append(max(col))</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(m):</span><br><span class="line">                <span class="keyword">if</span> matrix[i][j] == rows[i] <span class="keyword">and</span> matrix[i][j] == cols[j]:</span><br><span class="line">                    ans.append(matrix[i][j])</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></p>
<h1 id="1389-Create-Target-Array-in-the-Given-Order"><a href="#1389-Create-Target-Array-in-the-Given-Order" class="headerlink" title="1389. Create Target Array in the Given Order"></a>1389. Create Target Array in the Given Order</h1><p><a href="https://leetcode.com/problems/create-target-array-in-the-given-order/" target="_blank" rel="noopener">题目详情</a><br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">createTargetArray</span><span class="params">(self, nums: List[int], index: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">        ans = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            num, idx = nums[i], index[i]</span><br><span class="line">            <span class="keyword">if</span> idx &gt;= len(ans):</span><br><span class="line">                ans.append(num)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                a, b = ans[:idx], ans[idx:]</span><br><span class="line">                ans = a + [num] + b</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></p>
<p><a href>题目详情</a><br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p><a href>题目详情</a><br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p><a href>题目详情</a><br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p><a href>题目详情</a><br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h1 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h1><ul>
<li><a href="https://www.ranxiaolang.com/static/leetcode_python.pdf" target="_blank" rel="noopener">Leetcode-Python解题思路</a></li>
<li><a href="https://labuladong.github.io/ebook/" target="_blank" rel="noopener">labuladong的算法小抄</a></li>
</ul>
]]></content>
      <categories>
        <category>题库</category>
      </categories>
      <tags>
        <tag>SQL</tag>
        <tag>Python</tag>
        <tag>编程</tag>
        <tag>Leetcode</tag>
        <tag>题库</tag>
      </tags>
  </entry>
  <entry>
    <title>Python题库</title>
    <url>/Python%E9%A2%98%E5%BA%93.html</url>
    <content><![CDATA[<p><center>Python相关题目积累~</center><br><a id="more"></a></p>
<ul>
<li></li>
<li></li>
<li><a href="/python-3.html" title="b, B, KB, MB, GB的区别">b, B, KB, MB, GB的区别</a></li>
<li><a href="/python-7-%E5%88%87%E7%89%87%E6%93%8D%E4%BD%9C.html" title="切片操作不会引起下标越界异常">切片操作不会引起下标越界异常</a></li>
<li><a href="/python-23%E5%8C%BA%E5%88%AB.html" title="Python 2和Python 3的区别">Python 2和Python 3的区别</a></li>
<li></li>
</ul>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo+GitHub+Markdown常用用法</title>
    <url>/Hexo-GitHub-Markdown%E5%B8%B8%E7%94%A8%E7%94%A8%E6%B3%95.html</url>
    <content><![CDATA[<center>记录一些Hexo+Markdown的常用语法~</center>

<a id="more"></a>
<!--toc-->
<h1 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h1><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><h3 id="新建博客"><a href="#新建博客" class="headerlink" title="新建博客"></a>新建博客</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> hexo n <span class="string">'博客名称'</span></span></span><br></pre></td></tr></table></figure>
<h3 id="上传"><a href="#上传" class="headerlink" title="上传"></a>上传</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> hexo g</span></span><br></pre></td></tr></table></figure>
<p>即 <code>hexo generate</code></p>
<h2 id="标题自动编号"><a href="#标题自动编号" class="headerlink" title="标题自动编号"></a>标题自动编号</h2><ul>
<li><a href="http://r12f.com/posts/adding-index-to-your-headings-with-hexo-heading-index/" target="_blank" rel="noopener">为Hexo博客标题自动添加序号：hexo-heading-index</a></li>
</ul>
<h2 id="代码高亮"><a href="#代码高亮" class="headerlink" title="代码高亮"></a>代码高亮</h2><ul>
<li><a href="https://www.zfl9.com/hexo-code.html" target="_blank" rel="noopener">使用prism.js进行代码高亮</a></li>
<li><a href="https://www.jianshu.com/p/1f223eb78ad8" target="_blank" rel="noopener">markdown代码块支持的语言</a></li>
</ul>
<h2 id="Fluid主题"><a href="#Fluid主题" class="headerlink" title="Fluid主题"></a>Fluid主题</h2><p>安装可见：<a href="https://hexo.fluid-dev.com/docs/guide/#%E4%B8%BB%E9%A2%98%E7%AE%80%E4%BB%8B" target="_blank" rel="noopener">Hexo-fluid</a></p>
<p>压缩包<a href="https://github.com/fluid-dev/hexo-theme-fluid/releases/tag/v1.8.0-beta2">下载</a></p>
<h2 id="Fork-me-on-GitHub"><a href="#Fork-me-on-GitHub" class="headerlink" title="Fork me on GitHub"></a>Fork me on GitHub</h2><ul>
<li><a href="https://blog.csdn.net/fly_wt/article/details/86674138" target="_blank" rel="noopener">在右上角实现fork me on github</a></li>
</ul>
<h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2><ul>
<li><a href="https://www.cnblogs.com/icoty23/p/10911231.html" target="_blank" rel="noopener">Hexo引入Mermaid流程图和MathJax数学公式</a></li>
<li><a href="https://blog.csdn.net/Olivia_Vang/article/details/92987859#%E8%AF%AD%E6%B3%95" target="_blank" rel="noopener">Hexo中插入mermaid diagrams</a></li>
<li><a href="https://tyloafer.github.io/posts/7790/" target="_blank" rel="noopener">Hexo中引入Mermaid流程图</a></li>
<li><a href="https://rogersnowing.cn/post/38b5106c.html" target="_blank" rel="noopener">hexo集成mermaid画图</a></li>
<li><a href="https://blog.csdn.net/Subson/article/details/78054689" target="_blank" rel="noopener">Markdown里面使用mermaid画流程图（基础）</a></li>
</ul>
<h2 id="NeXT主题"><a href="#NeXT主题" class="headerlink" title="NeXT主题"></a>NeXT主题</h2><ul>
<li><a href="https://juejin.im/post/5bcd2d395188255c3b7dc1db#heading-11" target="_blank" rel="noopener">Hexo+NexT 打造一个炫酷博客</a></li>
<li><a href="https://tding.top/archives/dfac1e9c.html" target="_blank" rel="noopener">Hexo-NexT 主题样式美化 - 动画设置</a></li>
<li><a href="https://lvxuefei.top/%E5%88%A9%E7%94%A8Hexo-Next%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%B8%89%EF%BC%89-%E4%BC%98%E5%8C%96-%E5%90%84%E7%A7%8Dtips%E3%80%81%E9%BB%91%E7%A7%91%E6%8A%80%EF%BC%8C%E4%B8%8D%E6%96%AD%E6%9B%B4%E6%96%B0/" target="_blank" rel="noopener">利用 Hexo+Next 搭建个人博客（三）—— 优化 (各种 tips、黑科技，不断更新)</a></li>
<li><a href="https://jzwdsb.github.io/2019/02/next_canvax/" target="_blank" rel="noopener">next 主题背景添加 canvas nest 特效</a></li>
<li><a href="https://blog.qust.cc/archives/63320.html" target="_blank" rel="noopener">Hexo Next阅读次数不正常、显示多个阅读次数</a></li>
<li><a href="https://io-oi.me/tech/hexo-next-optimization/" target="_blank" rel="noopener">打造个性超赞博客 Hexo + NexT + GitHub Pages 的超深度优化</a></li>
</ul>
<h2 id="评论"><a href="#评论" class="headerlink" title="评论"></a>评论</h2><ul>
<li><a href="https://litstronger.github.io/2020/04/03/hexo-fluid%E6%B7%BB%E5%8A%A0utterances%E8%AF%84%E8%AE%BA%E5%8A%9F%E8%83%BD/" target="_blank" rel="noopener">hexo-fluid添加utterances评论功能</a></li>
<li><a href="https://tding.top/archives/ed8b904f.html" target="_blank" rel="noopener">Hexo-NexT 配置 Valine</a></li>
<li><a href="https://zucchiniy.cn/archives/c7b31ff.html" target="_blank" rel="noopener">Valine 评论使用报错 504</a></li>
<li><a href="https://qianfanguojin.github.io/2019/07/23/Hexo%E5%8D%9A%E5%AE%A2%E8%BF%9B%E9%98%B6%EF%BC%9A%E4%B8%BANext%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0Valine%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F/" target="_blank" rel="noopener">Hexo博客进阶：为Next主题添加Valine评论系统</a></li>
</ul>
<h2 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h2><ul>
<li><a href="https://vic.kim/2019/05/22/Hexo%20Next%20%E4%B8%BB%E9%A2%98%E4%B8%AD%E6%B7%BB%E5%8A%A0%E6%9C%AC%E5%9C%B0%E6%90%9C%E7%B4%A2%E5%8A%9F%E8%83%BD/" target="_blank" rel="noopener">Hexo Next 主题中添加本地搜索功能</a></li>
</ul>
<h2 id="SEO"><a href="#SEO" class="headerlink" title="SEO"></a>SEO</h2><ul>
<li><a href="http://www.ehcoo.com/seo.html" target="_blank" rel="noopener">【搜索优化】Hexo-next百度和谷歌搜索优化</a></li>
</ul>
<h1 id="Markdown"><a href="#Markdown" class="headerlink" title="Markdown"></a>Markdown</h1><h2 id="Font-matter区"><a href="#Font-matter区" class="headerlink" title="Font-matter区"></a>Font-matter区</h2><p>Font-matter区即 两行<code>---</code>之间的内容</p>
<h2 id="文章摘要"><a href="#文章摘要" class="headerlink" title="文章摘要"></a>文章摘要</h2><p>若想要在博客首页只展示文章的摘要，在摘要与正文中间插入<br><figure class="highlight md"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="comment">&lt;!--more--&gt;</span></span></span><br></pre></td></tr></table></figure></p>
<h2 id="引用站内文章"><a href="#引用站内文章" class="headerlink" title="引用站内文章"></a>引用站内文章</h2><figure class="highlight md"><table><tr><td class="code"><pre><span class="line">&#123;% post_link 站内文章对应的.md名称（不带后缀.md） %&#125;</span><br></pre></td></tr></table></figure>
<p>如：引用站内文章《<a href="/Restart.html" title="Restart!">Restart!</a>》，对应的文件名是<code>Restart.md</code><br><figure class="highlight md"><table><tr><td class="code"><pre><span class="line">&#123;% post_link Restart %&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="引用文章内锚点"><a href="#引用文章内锚点" class="headerlink" title="引用文章内锚点"></a>引用文章内锚点</h2><p>如：跳转到本文的<code>##代码高亮</code>小节<a href="#代码高亮">代码高亮</a><br><figure class="highlight md"><table><tr><td class="code"><pre><span class="line">[<span class="string">代码高亮</span>](<span class="link">#代码高亮</span>)</span><br></pre></td></tr></table></figure></p>
<ul>
<li>如果描点名称中有空格或下划线<code>_</code>等字符串，应将其改为分隔符<code>-</code></li>
</ul>
<h2 id="居中引用"><a href="#居中引用" class="headerlink" title="居中引用"></a>居中引用</h2><ul>
<li><a href="https://tding.top/archives/29bfe8c9.html" target="_blank" rel="noopener">Hexo-NexT Tag 插件的使用</a></li>
</ul>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">&#123;% cq %&#125;居中引用&#123;% endcq %&#125;</span><br></pre></td></tr></table></figure>
<p>效果：</p>
<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>居中引用</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<h2 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h2><figure class="highlight md"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">font</span> <span class="attr">face</span>=<span class="string">"字体"</span> <span class="attr">size</span>=<span class="string">"字号"</span> <span class="attr">color</span>=<span class="string">"颜色"</span>&gt;</span></span>这里是需要突出显示的内容<span class="xml"><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<h2 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h2><p>参考：<a href="https://blog.csdn.net/xjm850552586/article/details/84101345" target="_blank" rel="noopener">hexo引用本地图片无法显示</a></p>
<p>Markdown语法：<br><figure class="highlight md"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"referrer"</span> <span class="attr">content</span>=<span class="string">"no-referrer"</span> /&gt;</span></span></span><br><span class="line">&#123;% asset_img inorder.png 中序遍历 %&#125;</span><br></pre></td></tr></table></figure><br>或<br><figure class="highlight md"><table><tr><td class="code"><pre><span class="line">![<span class="string">title</span>](<span class="link">name.jpg</span>)</span><br></pre></td></tr></table></figure><br>或<br><figure class="highlight md"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"/asset/[your_image]"</span> <span class="attr">width</span>=<span class="string">"[width]"</span> <span class="attr">height</span>=<span class="string">"[height]"</span> <span class="attr">alt</span>=<span class="string">"[alternative_text]"</span> <span class="attr">title</span>=<span class="string">"[title]"</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p>
<h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><ul>
<li><a href="https://www.jianshu.com/p/b6c85800c44e" target="_blank" rel="noopener">Markdown表格中换行、合并单元格</a></li>
<li>插入表格：<figure class="highlight md"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span></span></span><br><span class="line"><span class="code">    .dataframe tbody tr th:only-of-type &#123;</span></span><br><span class="line"><span class="code">        vertical-align: middle;</span></span><br><span class="line"><span class="code">    &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="code">    .dataframe tbody tr th &#123;</span></span><br><span class="line"><span class="code">        vertical-align: top;</span></span><br><span class="line"><span class="code">    &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="code">    .dataframe thead th &#123;</span></span><br><span class="line"><span class="code">        text-align: center;</span></span><br><span class="line"><span class="code">    &#125;</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">"1"</span> <span class="attr">class</span>=<span class="string">"dataframe"</span>&gt;</span></span></span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">thead</span>&gt;</span></span></span><br><span class="line"><span class="code">    &lt;tr style="text-align: center;"&gt;</span></span><br><span class="line"><span class="code">      &lt;th&gt;标题行&lt;/th&gt;</span></span><br><span class="line"><span class="code">      &lt;th&gt;第一列标题&lt;/th&gt;</span></span><br><span class="line"><span class="code">      &lt;th&gt;第二列标题&lt;/th&gt;</span></span><br><span class="line"><span class="code">    &lt;/tr&gt;</span></span><br><span class="line">  <span class="xml"><span class="tag">&lt;/<span class="name">thead</span>&gt;</span></span></span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span></span><br><span class="line"><span class="code">    &lt;tr&gt;</span></span><br><span class="line"><span class="code">      &lt;th&gt;第一行&lt;/th&gt;</span></span><br><span class="line"><span class="code">      &lt;td&gt;$a_&#123;11&#125;$&lt;/td&gt;</span></span><br><span class="line"><span class="code">      &lt;td&gt;$a_&#123;12&#125;$&lt;/td&gt;</span></span><br><span class="line"><span class="code">    &lt;/tr&gt;</span></span><br><span class="line"><span class="code">    &lt;tr&gt;</span></span><br><span class="line"><span class="code">      &lt;th rowspan="2"&gt;合并两行单元格&lt;/th&gt;</span></span><br><span class="line"><span class="code">      &lt;td&gt;$a_&#123;21&#125;$&lt;/td&gt;</span></span><br><span class="line"><span class="code">      &lt;td&gt;$a_&#123;22&#125;$&lt;/td&gt;</span></span><br><span class="line"><span class="code">    &lt;/tr&gt;</span></span><br><span class="line"><span class="code">    &lt;tr&gt;</span></span><br><span class="line"><span class="code">      &lt;td&gt;第三行就少一个单元格&lt;/td&gt;</span></span><br><span class="line"><span class="code">      &lt;td&gt;$a_&#123;32&#125;$&lt;/td&gt;</span></span><br><span class="line"><span class="code">    &lt;/tr&gt;</span></span><br><span class="line"><span class="code">    &lt;tr&gt;</span></span><br><span class="line"><span class="code">      &lt;th&gt;第四行&lt;/th&gt;</span></span><br><span class="line"><span class="code">      &lt;td colspan="2"&gt;合并两列&lt;/td&gt;</span></span><br><span class="line"><span class="code">    &lt;/tr&gt;</span></span><br><span class="line"><span class="code">    &lt;tr&gt;</span></span><br><span class="line">  <span class="xml"><span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>效果：</p>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: center;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: center;">
      <th>标题行</th>
      <th>第一列标题</th>
      <th>第二列标题</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>第一行</th>
      <td>$a_{11}$</td>
      <td>$a_{12}$</td>
    </tr>
    <tr>
      <th rowspan="2">合并两行单元格</th>
      <td>$a_{21}$</td>
      <td>$a_{22}$</td>
    </tr>
    <tr>
      <td>第三行就少一个单元格</td>
      <td>$a_{32}$</td>
    </tr>
    <tr>
      <th>第四行</th>
      <td colspan="2">合并两列</td>
    </tr>
    <tr>
  </tr></tbody>
</table>
</div>

<h2 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h2><ul>
<li>公式对齐<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">\begin&#123;equation&#125;</span><br><span class="line">\begin&#123;aligned&#125;</span><br><span class="line">第一行 &amp;= 对齐符号为\&amp; 然后两个斜杠换行\\</span><br><span class="line">第二 &amp;+ 左边有个对齐符 \\</span><br><span class="line">三 &amp;+ 第二三行的加号与第一行的等号对齐</span><br><span class="line">\end&#123;aligned&#125;</span><br><span class="line">\end&#123;equation&#125;</span><br></pre></td></tr></table></figure>
效果如下：<br>\begin{equation}<br>\begin{aligned}<br>第一行 &amp;= 对齐符号为\&amp; 然后两个斜杠换行\\<br>第二 &amp;+ 左边有个对齐符 \\<br>三 &amp;+ 第二三行的加号与第一行的等号对齐<br>\end{aligned}<br>\end{equation}</li>
</ul>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="提示块"><a href="#提示块" class="headerlink" title="提示块"></a>提示块</h3><ul>
<li><a href="https://tding.top/archives/29bfe8c9.html" target="_blank" rel="noopener">Hexo-NexT Tag 插件的使用</a></li>
</ul>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">&#123;% note default %&#125;</span><br><span class="line">default 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note primary %&#125;</span><br><span class="line">primary 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note success %&#125;</span><br><span class="line">success 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note info %&#125;</span><br><span class="line">info 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note warning %&#125;</span><br><span class="line">warning 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note danger %&#125;</span><br><span class="line">danger 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure>
<p>在主题配置文件<code>_config.yml</code>中修改配置:<br><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Note tag (bs-callout)</span></span><br><span class="line"><span class="attr">note:</span></span><br><span class="line">  <span class="comment"># Note tag style values:</span></span><br><span class="line">  <span class="comment">#  - simple    bs-callout old alert style. Default.</span></span><br><span class="line">  <span class="comment">#  - modern    bs-callout new (v2-v3) alert style.</span></span><br><span class="line">  <span class="comment">#  - flat      flat callout style with background, like on Mozilla or StackOverflow.</span></span><br><span class="line">  <span class="comment">#  - disabled  disable all CSS styles import of note tag.</span></span><br><span class="line">  <span class="attr">style:</span> <span class="string">flat</span>  <span class="comment">## 风格</span></span><br><span class="line">  <span class="attr">icons:</span> <span class="literal">false</span> <span class="comment">## 要不要图标</span></span><br><span class="line">  <span class="attr">border_radius:</span> <span class="number">3</span>  <span class="comment">## 圆角矩形</span></span><br><span class="line">  <span class="comment"># Offset lighter of background in % for modern and flat styles (modern: -12 | 12; flat: -18 | 6).</span></span><br><span class="line">  <span class="comment"># Offset also applied to label tag variables. This option can work with disabled note tag.</span></span><br><span class="line">  <span class="attr">light_bg_offset:</span> <span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<p>效果：<br><div class="note default">
            <p>default 提示块标签</p>
          </div></p>
<div class="note primary">
            <p>primary 提示块标签</p>
          </div>
<div class="note success">
            <p>success 提示块标签</p>
          </div>
<div class="note info">
            <p>info 提示块标签</p>
          </div>
<div class="note warning">
            <p>warning 提示块标签</p>
          </div>
<div class="note danger">
            <p>danger 提示块标签</p>
          </div>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">&#123;% note warning %&#125;</span><br><span class="line">定义</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure>
<div class="note warning">
            <p>定义</p>
          </div>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">&#123;% note danger %&#125;</span><br><span class="line">算法</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure>
<div class="note danger">
            <p>算法</p>
          </div>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">&#123;% note success %&#125;</span><br><span class="line">定理/性质</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure>
<div class="note success">
            <p>定理/性质</p>
          </div>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">&#123;% note default %&#125;</span><br><span class="line">证明 或 推荐 或 引用 或 示例</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure>
<div class="note default">
            <p>证明 或 推荐 或 引用 或 示例</p>
          </div>
<h1 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h1><h2 id="github-io无法访问"><a href="#github-io无法访问" class="headerlink" title="github.io无法访问"></a>github.io无法访问</h2><ul>
<li><a href="https://juejin.im/post/6863358382410203144" target="_blank" rel="noopener">解决无法访问github pages的方法</a></li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1>]]></content>
      <categories>
        <category>Everything</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>GitHub</tag>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>Machine Learning | 随机森林</title>
    <url>/%E7%AE%97%E6%B3%95-%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97.html</url>
    <content><![CDATA[<p><center>Random Forest</center><br><a id="more"></a></p>
<h1 id="随机森林"><a href="#随机森林" class="headerlink" title="随机森林"></a>随机森林</h1><ul>
<li>随机森林是一种<u>判别分类方法</u></li>
<li>随机森林是建立在基础上的集成学习器(一个包含多个决策树的分类器；输出结果由各个树的输出结果的众数决定)</li>
<li>是bagging的一个特殊进阶版</li>
<li>随机森林=Bagging+随机选择特征<script type="math/tex; mode=display">Random Forest=Bagging+Decision Tree</script></li>
<li>随机森林的弱学习器都是决策树（CART）</li>
<li>如何产生不同的决策树（Decision Tree，DT）？<ul>
<li>每棵决策树使用训练集的Bootstrap随机采样样本</li>
<li>每个根节点（node）使用不同的特征子集</li>
</ul>
</li>
<li>树的数目通常不少于500棵</li>
<li>不需要剪枝；在构建决策树时，RF的每棵决策树都最大可能地进行生长而不进行剪枝</li>
<li>概括RF包括4部分：<ol>
<li>随机选择样本</li>
<li>随机选择特征</li>
<li>构建决策树</li>
<li>随机森林投票（平均）</li>
</ol>
</li>
<li><p>每个基学习器只使用了训练集中约63.2%的样本，剩下约36.8%的样本可用作验证集来对其泛化性能进行“包外（Out of Bag）估计”</p>
</li>
<li><p>随机森林不需要归一化/标准化</p>
<blockquote>
<p>概率模型（树形模型）不需要归一化。因为它们不关心变量的值，而是关心变量的分布和变量之间的条件概率，如决策树、随机森林</p>
</blockquote>
</li>
</ul>
<h2 id="RF-vs-GBDT"><a href="#RF-vs-GBDT" class="headerlink" title="RF vs GBDT"></a>RF vs GBDT</h2><table>
  <tr>
    <td></td>
    <td>随机森林RF</td>
    <td>GBDT</td>
  </tr>
  <tr>
    <td>相同点</td>
    <td colspan="2">1.都是由多棵树组成<br>2.最终的结果都是由多棵树一起决定</td>
  </tr>
  <tr>
    <td rowspan="2">子树</td>
    <td>可以是分类树或回归树</td>
    <td>只能是回归树</td>
  </tr>
  <tr>
    <td>并行生成子树</td>
    <td>串行（序列）生成子树</td>
  </tr>
  <tr>
    <td>集成方法</td>
    <td>多数投票</td>
    <td>将所有结果累加 或 加权累加</td>
  </tr>
  <tr>
    <td>异常值</td>
    <td>不敏感</td>
    <td>敏感</td>
  </tr> 
  <tr>
    <td></td>
    <td>对训练集一视同仁</td>
    <td>基于权值的弱分类器的集成</td>
  </tr> 
  <tr>
    <td></td>
    <td>减少方差</td>
    <td>减少偏差</td>
  </tr> 
  <tr>
    <td></td>
    <td>容易过拟合</td>
    <td></td>
  </tr> 
</table>





<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1>]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>机器学习</tag>
        <tag>分类</tag>
        <tag>有监督学习</tag>
        <tag>集成学习</tag>
        <tag>判别式模型</tag>
        <tag>Bagging</tag>
      </tags>
  </entry>
  <entry>
    <title>Machine Learning | 支持向量机</title>
    <url>/%E7%AE%97%E6%B3%95-SVM.html</url>
    <content><![CDATA[<p><center>Support Vector Machine</center><br><a id="more"></a><br>SVM</p>
<h1 id="支持向量机"><a href="#支持向量机" class="headerlink" title="支持向量机"></a>支持向量机</h1><ul>
<li><a href="/%E7%AE%97%E6%B3%95-SupervisedLearning.html" title="有监督学习">有监督学习</a></li>
<li>分类</li>
<li>回归</li>
<li><a href="/%E7%94%9F%E6%88%90%E5%BC%8F%E6%A8%A1%E5%9E%8B-%E5%88%A4%E5%88%AB%E5%BC%8F%E6%A8%A1%E5%9E%8B.html" title="判别式模型">判别式模型</a></li>
<li>训练完成后，大部分训练样本都不需要保留，最终模型仅与支持向量有关</li>
</ul>
<p>支持向量机是一种<u>有监督学习</u>算法，既可以用于分类，也可以用于回归。</p>
<p>最初SVM被提出用于二类分类问题。</p>
<p>支持向量机是<a href="/%E7%94%9F%E6%88%90%E5%BC%8F%E6%A8%A1%E5%9E%8B-%E5%88%A4%E5%88%AB%E5%BC%8F%E6%A8%A1%E5%9E%8B.html" title="判别分类方法">判别分类方法</a>，用一条分割线（二维空间中的直线或曲线）或流形体（多维空间中的曲线、曲面等概念的推广）将各种类型分割开。</p>
<h2 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h2><p>在特征空间中寻找间隔最大的分离超平面将数据高效地分为两类。</p>
<ul>
<li>正确划分数据集</li>
<li>分离超平面几何间隔最大</li>
</ul>
<p><meta name="referrer" content="no-referrer"><br><img src="/%E7%AE%97%E6%B3%95-SVM/svm2.jpg" class title="支持向量机"></p>
<h3 id="类别"><a href="#类别" class="headerlink" title="类别"></a>类别</h3><ol>
<li><strong>线性可分支持向量机</strong><ul>
<li>训练样本线性可分</li>
<li>通过<u>硬间隔</u>最大化，学习一个线性分类器</li>
</ul>
</li>
<li><strong>线性支持向量机</strong><ul>
<li>训练样本近似线性可分</li>
<li>引入松弛变量，通过<u>软间隔</u>最大化，学习一个线性分类器</li>
</ul>
</li>
<li><strong>非线性支持向量机</strong><ul>
<li>训练样本线性不可分</li>
<li>通过使用核函数及软间隔最大化，学习一个分类器</li>
</ul>
</li>
</ol>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>考虑样本容量为$n$的训练数据集</p>
<script type="math/tex; mode=display">S=\{(\mathbf{x}_1,y_1),(\mathbf{x}_2,y_2),\cdots,(\mathbf{x}_n,y_n)\}</script><ul>
<li>$\mathbf{x}_i\in \mathbb{R}^p$为第$i$个样本（$i=1,\cdots,n$）</li>
<li>$x_j$为第$j$个特征（$j=1,\cdots,p$）</li>
<li>$y_i\in\{+1,-1\}$为第$i$个样本的标签（$i=1,\cdots,n$）</li>
</ul>
<h4 id="线性可分"><a href="#线性可分" class="headerlink" title="线性可分"></a>线性可分</h4><p>假设训练数据集线性可分的。</p>
<ul>
<li><strong>几何间隔</strong>：对于给定的数据集$S$和超平面  $\mathbf{w}\cdot \mathbf{x}+b=0$，超平面关于样本点$(\mathbf{x}_i,y_i)$的几何间隔为<script type="math/tex; mode=display">\gamma_i=y_i\left(\frac{\mathbf{w}}{||\mathbf{w}||}\cdot\mathbf{x}_i+\frac{b}{||\mathbf{w}||}  \right)</script></li>
<li><strong>支持向量</strong>（Support Vector）：在线性可分情况下，训练数据集中与分离超平面距离最近的样本点的实例称为支持向量<ul>
<li>即：满足约束条件$y_i(\mathbf{w}\cdot\mathbf{x}_i+b)=1$的样本点实例</li>
<li>$y_i=+1$的正例点，支持向量在超平面$H_1:\mathbf{w}\cdot\mathbf{x}+b=1$上</li>
<li>$y_i=-1$的负例点，支持向量在超平面$H_2:\mathbf{w}\cdot\mathbf{x}+b=-1$上</li>
</ul>
</li>
<li><strong>间隔</strong>（margin）：超平面$H_1$和$H_2$之间的距离，等于<script type="math/tex; mode=display">\frac{2}{||\mathbf{w}||}</script></li>
</ul>
<p>超平面$\mathbf{w}\cdot \mathbf{x}+b=0$关于所有样本点的几何间隔最小值为</p>
<script type="math/tex; mode=display">\gamma=\min_{i=1,\cdots,n}\gamma_i</script><p>即支持向量到超平面的距离。</p>
<p>因此，求解“最大分割超平面问题”即求解下列带约束的最优化问题</p>
<script type="math/tex; mode=display">\max_{\mathbf{w},b}\gamma\quad \mathrm{s.t.}\quad y_i\left(\frac{\mathbf{w}}{||\mathbf{w}||}\cdot\mathbf{x}_i+\frac{b}{||\mathbf{w}||}  \right)\geq \gamma,\quad i=1,\cdots,n</script><p>等价于</p>
<script type="math/tex; mode=display">y_i\left(\frac{\mathbf{w}}{||\mathbf{w}||\gamma}\cdot\mathbf{x}_i+\frac{b}{||\mathbf{w}||\gamma}  \right)\geq1,\quad i=1,\cdots,n</script><p>令</p>
<script type="math/tex; mode=display">\mathbf{w}\triangleq\frac{\mathbf{w}}{||\mathbf{w}||\gamma}</script><script type="math/tex; mode=display">b\triangleq\frac{b}{||\mathbf{w}||\gamma}</script><p>则约束问题为</p>
<script type="math/tex; mode=display">y_i(\mathbf{w}\cdot \mathbf{x}_i+b)\geq1,\quad i=1,\cdots,n.</script><script type="math/tex; mode=display">\max{\gamma}\Longleftrightarrow\max{\frac{1}{||\mathbf{w}||}}\Longleftrightarrow\min\frac{1}{2}||\mathbf{w}||^2</script><p>因此，SVM模型“求解最大分割超平面问题”即求解以下带约束条件的最优化问题</p>
<script type="math/tex; mode=display">\min_{\mathbf{w},b}\frac{1}{2}||\mathbf{w}||^2</script><script type="math/tex; mode=display">\mathrm{s.t.}\quad y_i(\mathbf{w}^T\mathbf{x}_i+b)\geq 1, \forall i</script><p>$\mathbf{w}$是超平面参数。</p>
<p>使用拉格朗日乘子法求解上述<u>有约束条件的最优化问题</u></p>
<script type="math/tex; mode=display">L(\mathbf{w},b,\mathbf{\lambda})=\frac{1}{2}||\mathbf{w}||^2-\sum_{i=1}^n\lambda_i\left[y_i(\mathbf{w}^T\mathbf{x}_i+b)-1 \right]</script><p>其中，$\lambda_i$为拉格朗日乘子，且$\lambda_i\geq 0$。</p>
<p>令</p>
<script type="math/tex; mode=display">\theta(\mathbf{w})=\max_{\lambda_i\geq0}L(\mathbf{w},b,\mathbf{\lambda})</script><ul>
<li>当样本点不满足约束条件时，即$y_i(\mathbf{w}^T\mathbf{x}_i+b)&lt;1$，将$\lambda_i$设置为无穷大，则$\theta(\mathbf{w})$也为无穷大</li>
<li>当样本点满足约束条件时，即$y_i(\mathbf{w}^T\mathbf{x}_i+b)\geq 1$，将$\theta(\mathbf{w})$设置为原函数本身</li>
</ul>
<p>即</p>
<script type="math/tex; mode=display">\theta(\mathbf{w})=\left\{
    \begin{array}{ll}
    \frac{1}{2}||\mathbf{w}||^2, & \mathbf{x}\in 可行区域\\
    +\infty, & \mathbf{x}\in 不可行区域
    \end{array}
    \right.</script><p>因此，约束问题等价于</p>
<script type="math/tex; mode=display">\min_{\mathbf{w},b}\theta(\mathbf{w})=\min_{\mathbf{w},b}\max_{\lambda_1\geq 0}L(\mathbf{w},b,\mathbf{\lambda})=p^*</script><p>由拉格朗日函数的<strong>对偶性</strong>可得</p>
<script type="math/tex; mode=display">\max_{\lambda_1\geq 0}\min_{\mathbf{w},b}L(\mathbf{w},b,\mathbf{\lambda})=d^*</script><p>要使得$p^*=d^*$，需满足：</p>
<ol>
<li>优化问题是凸优化问题<br>本优化问题是一个凸优化问题</li>
<li>满足KKT条件<br>即要求<script type="math/tex; mode=display">\left\{
  \begin{array}{l}
  \lambda_i\geq0\\
  y_i(\mathbf{w}_i\cdot\mathbf{x}_i+b)-1\geq0\\
  \lambda_i\left[y_i(\mathbf{w}_i\cdot\mathbf{x}_i+b)-1 \right]=0
  \end{array}
  \right.</script></li>
</ol>
<p>令</p>
<script type="math/tex; mode=display">\frac{\partial L(\mathbf{w},b,\lambda)}{\partial \mathbf{w}}=0,\quad \frac{\partial L(\mathbf{w},b,\lambda)}{\partial b}=0</script><p>可得</p>
<script type="math/tex; mode=display">\left\{\begin{array}{l}
    \mathbf{w}=\sum_{i=1}^n\lambda_i y_i \mathbf{x}_i\\
    \sum_{i=1}^n\lambda_iy_i=0
    \end{array}
    \right.</script><p>代入$L(\mathbf{w},b,\lambda)$消去$\mathbf{w}$和$b$得<br>\begin{equation}<br>\begin{aligned}<br>L(\mathbf{w},b,\lambda) &amp;= \frac{1}{2}\sum_{i=1}^n\sum_{j=1}^n\lambda_i\lambda_jy_iy_j(\mathbf{x}_i \cdot \mathbf{x}_j )-\sum_{i=1}^n\lambda_iy_i\left[\left(\sum_{j=1}^n\lambda_jy_j\mathbf{x}_j \right)\cdot \mathbf{x}_i+b \right]+\sum_{i=1}^n\lambda_i\\<br>&amp;= -\frac{1}{2}\sum_{i=1}^n\sum_{j=1}^n\lambda_i\lambda_jy_iy_j(\mathbf{x}_i \cdot \mathbf{x}_j )+\sum_{i=1}^n\lambda_i<br>\end{aligned}<br>\end{equation}</p>
<p>则</p>
<script type="math/tex; mode=display">\min_{\mathbf{w},b}L(\mathbf{w},b,\mathbf{\lambda})=-\frac{1}{2}\sum_{i=1}^n\sum_{j=1}^n\lambda_i\lambda_jy_iy_j(\mathbf{x}_i \cdot \mathbf{x}_j )+\sum_{i=1}^n\lambda_i</script><p>那么<script type="math/tex">\max_{\lambda}\min_{\mathbf{w},b}L(\mathbf{w},b,\mathbf{\lambda})</script>等价于<br>\begin{equation}<br>\begin{aligned}<br>\max_{\lambda} &amp; -\frac{1}{2}\sum_{i=1}^n\sum_{j=1}^n\lambda_i\lambda_jy_iy_j(\mathbf{x}_i \cdot \mathbf{x}_j )+\sum_{i=1}^n\lambda_i\\<br>\mathrm{s.t.} &amp; \sum_{i=1}^n\lambda_iy_i=0\\<br>&amp; \lambda_i\geq0,\quad i=1,\cdots,n.<br>\end{aligned}<br>\end{equation}</p>
<p>使用<strong>序列最小化算法</strong>（SMO）（待补充）求解上述优化问题。</p>
<p>通过SMO算法求解得到最优$\pmb{\lambda}^*$，从而求解出$\mathbf{w}$和$b$，进而求得最优超平面——决策平面。</p>
<blockquote>
<p>在$\pmb{\lambda}^*$中，至少存在一个$\lambda_j^*&gt;0$</p>
<font face="仿宋">
证明（反证法）：若不存在$\lambda_j^*>0$，则$\mathbf{w}=0$，矛盾
</font>

</blockquote>
<p>对$\lambda_j^*&gt;0$有</p>
<script type="math/tex; mode=display">y_j\left(\mathbf{w}^*\cdot\mathbf{x}_j+b^* \right)-1=0</script><p>因此<br>\begin{equation}<br>\begin{aligned}<br>    \mathbf{w}^* &amp;= \sum_{i=1}^n\lambda_i^*y_i\mathbf{x}_i\\<br>    b^* &amp;= y_j-\sum_{i=1}^n\lambda_i^*y_i(\mathbf{x}_i\cdot\mathbf{x}_j)<br>\end{aligned}<br>\end{equation}</p>
<blockquote>
<p>对于任意训练样本$(\mathbf{x}_i,y_i)$，总有$\lambda_i=0$或$y_i\left(\mathbf{w}^*\cdot\mathbf{x}_i+b^* \right)=1$。</p>
</blockquote>
<ul>
<li>若$\lambda_i=0$，则该样本不会出现在求解“决策平面”参数得式子中</li>
<li>若$\lambda_i&gt;0$，则必有$y_i\left(\mathbf{w}^*\cdot\mathbf{x}_i+b^* \right)=1$，即样本点位于最大间隔边界上——$(\mathbf{x}_i,y_i)$是一个<strong>支持向量</strong></li>
</ul>
<h4 id="近似线性可分"><a href="#近似线性可分" class="headerlink" title="近似线性可分"></a>近似线性可分</h4><p>实际情况下，几乎不存在完全线性可分的数据，对于近似线性可分的训练数据集，引入<strong>软间隔</strong>——允许某些点不满足约束$y_i(\mathbf{w}\cdot\mathbf{x}_i+b)\geq 1$</p>
<p>引入<strong>松弛变量</strong>(Hinge损失函数)$\xi_i=\max\{0,1-y_i(\mathbf{w}\cdot\mathbf{x}_i+b)\}$，将原优化问题改写为<br>\begin{equation}<br>\begin{aligned}<br>\min_{\mathbf{w},b,\xi} &amp;\quad \frac{1}{2}||\mathbf{w}||^2+\phi\sum_{i=1}^nxi_i\\<br>\mathrm{s.t.} &amp;\quad y_i(\mathbf{w}\cdot\mathbf{x}_i+b)\geq1-\xi_i\\<br>&amp; \quad \xi_i\geq 0,\quad i=1,\cdots,n.<br>\end{aligned}<br>\end{equation}<br>其中$\phi$为惩罚参数，$\phi$越大，对分类的惩罚越大。</p>
<h4 id="非线性SVM"><a href="#非线性SVM" class="headerlink" title="非线性SVM"></a>非线性SVM</h4><p>通过非线性变换将非线性分类问题转化为线性分类问题。</p>
<blockquote>
<p>用核函数替换线性SVM中的内积</p>
</blockquote>
<ul>
<li><strong>核函数</strong>（Kernel function）：存在一个从输入空间到特征空间的映射$\varphi(\cdot)$，对输入空间中的任意两点$x,z$有<script type="math/tex; mode=display">K(x,z)=\varphi(x)\cdot\varphi(z)</script></li>
</ul>
<p>则分类决策函数变为</p>
<script type="math/tex; mode=display">f(\mathbf{x})=\mathrm{sign}\left(\sum_{i=1}^n\lambda_i^*y_iK(\mathbf{x},\mathbf{x}_i)+b^* \right)</script><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h3 id="线性支持向量机"><a href="#线性支持向量机" class="headerlink" title="线性支持向量机"></a>线性支持向量机</h3><p>综合原理章节的讨论，总结<strong>线性支持向量机学习算法</strong>如下：</p>
<ul>
<li><strong>输入</strong>：训练数据集<script type="math/tex; mode=display">S=\{(\mathbf{x}_1,y_1),(\mathbf{x}_2,y_2),\cdots,(\mathbf{x}_n,y_n)\}</script><ul>
<li>$\mathbf{x}_i\in \mathbb{R}^p$为第$i$个样本（$i=1,\cdots,n$）</li>
<li>$x_j$为第$j$个特征（$j=1,\cdots,p$）</li>
<li>$y_i\in\{+1,-1\}$为第$i$个样本的标签（$i=1,\cdots,n$）</li>
</ul>
</li>
<li><strong>输出</strong>：分离超平面、分类决策函数</li>
</ul>
<ol>
<li>选择惩罚参数$\phi&gt;0$，构造并求解凸二次规划问题<br>\begin{equation}<br>\begin{aligned}<br>\min_{\pmb{\lambda}} &amp;\quad \frac{1}{2}\sum_{i=1}^n\sum_{j=1}^n\lambda_i\lambda_jy_iy_j(\mathbf{x}_i\cdot\mathbf{x}_j)-\sum_{i=1}^n\lambda_i\\<br>\mathrm{s.t.} &amp;\quad \sum_{i=1}^n\lambda_iy_i=0\\<br>&amp; \quad 0\leq \lambda_i\leq \phi,\quad i=1,\cdots,n.<br>\end{aligned}<br>\end{equation}<br>得到最优解<script type="math/tex; mode=display">\pmb{\lambda}^*=(\lambda_1^*,\cdots,\lambda_n^*)^T</script></li>
<li>计算<script type="math/tex; mode=display">\mathbf{w}^*=\sum_{i=1}^n\lambda^*_iy_i\mathbf{x}_i</script>选择$\pmb{\lambda}^*$的一个满足条件$0&lt;\lambda_j^*&lt;\phi$的分量$\lambda_j^*$，计算<script type="math/tex; mode=display">b^*=y_j-\sum_{i=1}^n\lambda_j^*y_j(\mathbf{x}_i\cdot\mathbf{x}_j)</script></li>
<li>求分离超平面<script type="math/tex; mode=display">\mathbf{w}^*\cdot\mathbf{x}+b^*=0</script>分类决策函数为<script type="math/tex; mode=display">f(\mathbf{x})=\mathrm{sign}{(\mathbf{w}^*\cdot\mathbf{x}+b^*)}</script></li>
</ol>
<h3 id="非线性支持向量机"><a href="#非线性支持向量机" class="headerlink" title="非线性支持向量机"></a>非线性支持向量机</h3><ul>
<li><strong>输入</strong>：训练数据集<script type="math/tex; mode=display">S=\{(\mathbf{x}_1,y_1),(\mathbf{x}_2,y_2),\cdots,(\mathbf{x}_n,y_n)\}</script><ul>
<li>$\mathbf{x}_i\in \mathbb{R}^p$为第$i$个样本（$i=1,\cdots,n$）</li>
<li>$x_j$为第$j$个特征（$j=1,\cdots,p$）</li>
<li>$y_i\in\{+1,-1\}$为第$i$个样本的标签（$i=1,\cdots,n$）</li>
</ul>
</li>
<li><strong>输出</strong>：分离超平面、分类决策函数</li>
</ul>
<ol>
<li>选择适当的核函数$K(x,z)$和惩罚参数$\phi&gt;0$，构造并求解凸二次规划问题<br>\begin{equation}<br>\begin{aligned}<br>\min_{\pmb{\lambda}} &amp;\quad \frac{1}{2}\sum_{i=1}^n\sum_{j=1}^n\lambda_i\lambda_jy_iy_jK(\mathbf{x_i},\mathbf{x}_j)-\sum_{i=1}^n\lambda_i\\<br>\mathrm{s.t.} &amp;\quad \sum_{i=1}^n\lambda_iy_i=0\\<br>&amp; \quad 0\leq \lambda_i\leq \phi,\quad i=1,\cdots,n.<br>\end{aligned}<br>\end{equation}<br>得到最优解<script type="math/tex; mode=display">\pmb{\lambda}^*=(\lambda_1^*,\cdots,\lambda_n^*)^T</script></li>
<li>选择$\pmb{\lambda}^*$的一个满足条件$0&lt;\lambda_j^*&lt;\phi$的分量$\lambda_j^*$，计算<script type="math/tex; mode=display">b^*=y_j-\sum_{i=1}^n\lambda_j^*y_jK(\mathbf{x}_i,\mathbf{x}_j)</script></li>
<li>分类决策函数为<script type="math/tex; mode=display">f(\mathbf{x})=\mathrm{sign}{\left(\sum_{i=1}^n\lambda_i^*y_iK(\mathbf{x},\mathbf{x}_i)+b^*\right)}</script></li>
</ol>
<h2 id="核函数"><a href="#核函数" class="headerlink" title="核函数"></a>核函数</h2><ul>
<li>SVM使用核函数的过程实质是进行特征转换的过程</li>
</ul>
<h3 id="线性核"><a href="#线性核" class="headerlink" title="线性核"></a>线性核</h3><h3 id="多项式核"><a href="#多项式核" class="headerlink" title="多项式核"></a>多项式核</h3><h3 id="RBF核"><a href="#RBF核" class="headerlink" title="RBF核"></a>RBF核</h3><p>高斯核函数/高斯径向基函数（Radial Basis Function）</p>
<script type="math/tex; mode=display">K(x,z)=\exp\left(-\frac{||x-z||^2}{2\sigma^2} \right)</script><ul>
<li>对应的SVM是<strong>高斯径向基函数分类器</strong></li>
<li>对应的分类决策函数为<script type="math/tex; mode=display">f(\mathbf{x})=\mathrm{sign}{\left(\sum_{i=1}^n\lambda_i^*y_i\exp{\left(-\frac{||\mathbf{x}-\mathrm{x}_i||^2}{2\sigma^2}\right)}+b^*\right)}</script></li>
</ul>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: center;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: center;">
      <th>核函数</th>
      <th>形式</th>
      <th>优点</th>
      <th>缺点</th>
      <th>适用情形</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>线性核</th>
      <td>$\mathbf{x}_i^T\mathbf{x}_j$</td>
      <td>高效实现，不易过拟合</td>
      <td>无法解决非线性可分问题</td>
      <td>$p\gg n$（如：文本分类问题）</td>
    </tr>
    <tr>
      <th>多项式核</th>
      <td>$(\beta\mathbf{x}_i^T\mathbf{x}_j+\theta)^n$</td>
      <td>比线性核更一般，$n$直接描述了被映射空间的复杂度</td>
      <td>参数多，当$n$很大时会导致计算不稳定</td>
      <td></td>
    </tr>
    <tr>
      <th>RBF核</th>
      <td>$\exp{\left(-\frac{||\mathbf{x}_i-\mathbf{x}_j||^2}{2\sigma^2} \right)}$</td>
      <td>只有一个参数，没有计算不稳定问题</td>
      <td>计算慢，过拟合风险大</td>
      <td>$p$较小、$n$中等</td>
    </tr>
    <tr>
  </tr></tbody>
</table>
</div>

<p>其中</p>
<ul>
<li>$n$：样本数</li>
<li>$p$：特征维度</li>
</ul>
<blockquote>
<p>当$p$较小、$n$较大时，支持向量机性能通常不如深度神经网络</p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>若样本的某些特征数据缺失，可能会影响SVM模型训练结果的好坏。</p>
<ul>
<li>SVM希望样本在特征空间中线性可分，所以特征空间的好坏对SVM的性能很重要</li>
</ul>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>SVM的优点：</p>
<ul>
<li>模型以来的支持向量比较少，消耗内存少</li>
<li>预测阶段的速度快</li>
<li>模型只受边界线附近的点的影响，因此对于高维数据的学习效果非常好</li>
<li>与核函数方法的配合极具通用性，能够适用于不同类型的数据（不仅适用于线性问题，还适用于非线性问题）</li>
<li>SVM是一个凸优化问题，所以求得的解是全局最优而不是局部最优</li>
<li>理论基础比较完善</li>
<li>通过调参往往可以得到很好的分类效果</li>
<li>泛化能力好</li>
<li>SVM对线性不可分的数据有较好的分类性能</li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>SVM的缺点：</p>
<ul>
<li>随着样本量$N$的增加，模型的训练复杂度可能会高达$\mathcal{O}(N^3)$，即使经过高效处理后，复杂度也有$\mathcal{O}(N^2)$。即，大样本下模型学习的计算成本会很高。</li>
<li>训练效果非常依赖于边界软化参数$C$的选择是否合理；需要通过交叉检验进行检索；当数据集较大时，计算量也很大</li>
<li>SVM对缺失数据敏感</li>
<li>非线性问题的核函数的选择没有通用标准，难以选择一个合适的核函数</li>
</ul>
<h1 id="支持向量回归机"><a href="#支持向量回归机" class="headerlink" title="支持向量回归机"></a>支持向量回归机</h1><p>SVR<br>Support Vector Regression</p>
<ul>
<li>SVM本身是针对二分类问题提出的</li>
<li>SVR是SVM的一个重要的应用分支</li>
</ul>
<p>SVR与SVM的区别在于：</p>
<blockquote>
<p>SVR的样本点只有一类，所寻求的最优超平面是使所有的样本点离该超平面的总偏差最小</p>
</blockquote>
<p><meta name="referrer" content="no-referrer"><br></p>
<h1 id="SVM-vs-LR"><a href="#SVM-vs-LR" class="headerlink" title="SVM vs LR"></a>SVM vs LR</h1><p>SVM：支持向量机<br>LR：逻辑回归</p>
<ul>
<li>最本质的区别：损失函数不同</li>
</ul>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: center;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: center;">
      <th></th>
      <th>支持向量机</th>
      <th>逻辑回归</th>
    </tr>
  </thead>
  <tbody>
      <tr>
      <th rowspan="4">相同点</th>
      <td colspan="2">都是分类算法(也都可以用于回归)</td>
    </tr>
    <tr>
      <td colspan="2">（如果不考虑核函数）分类决策面都是线性的<br>原始的LR和SVM都是线性分类器</td>
    </tr>
    <tr>
      <td colspan="2">都是监督学习算法</td>
    </tr>
    <tr>
      <td colspan="2">都是<a href="/%E7%94%9F%E6%88%90%E5%BC%8F%E6%A8%A1%E5%9E%8B-%E5%88%A4%E5%88%AB%E5%BC%8F%E6%A8%A1%E5%9E%8B.html" title="判别式模型">判别式模型</a></td>
    </tr>
    <tr>
      <th>损失函数</th>
      <td>Hinge Loss</td>
      <td>Log-Loss</td>
    </tr>
    <tr>
      <th>目标</th>
      <td>最大化分割超平面距离</td>
      <td>最大化数据分到正确的类的概率</td>
    </tr>
    <tr>
      <th>样本点</th>
      <td>只考虑局部的边界线附近的点</td>
      <td>考虑所有点（全局）</td>
    
    </tr><tr>
      <th>数据分布</th>
      <td>不直接依赖于数据分布</td>
      <td>受所有数据点的影响</td>
    </tr>
    <tr>
      <th>非线性问题</th>
      <td>使用核函数</td>
      <td>不适用核函数</td>
    </tr>
    <tr>
      <th>正则化</th>
      <td>线性SVM依赖数据的距离测度，需要先对数据进行归一化（Normalization）</td>
      <td>不需要事先Normalization</td>
    </tr>
    <tr>
      <th>正则项</th>
      <td>损失函数自带正则项$\frac{1}{2}||\mathbf{w}||^2$</td>
      <td>需要另外添加正则项</td>
    </tr>
    <tr>
  </tr></tbody>
</table>
</div>

<p>考虑标签为$y\in\{0,1\}$的LR和SVM。<br>LR的决策函数可以为</p>
<script type="math/tex; mode=display">\hat{y}=\left\{
    \begin{array}{ll}
    1 & \mathrm{if} P(y=1|x)\geq P(y=0|x)\\
    0 & \mathrm{otherwise}
    \end{array}
    \right.</script><p>其中<br>\begin{equation}<br>\begin{aligned}<br>P(y=1|x) &amp; \propto \exp{(\mathbf{w}^T\cdot\mathbf{x}+b)}\\<br>P(y=0|x) &amp; \propto 1<br>\end{aligned}<br>\end{equation}</p>
<p>如果我们只是想做出正确决策，而不是获得每个类别的概率，可以用似然比来进行决策</p>
<script type="math/tex; mode=display">\frac{P(y=1|x)}{P(y=0|x)}\geq c,\quad c>1</script><p>上述不等式两边同取对数，得</p>
<script type="math/tex; mode=display">\log{(P(y=1|x))}- \log{(P(y=0|x))}\geq \log{c}</script><p>则有</p>
<script type="math/tex; mode=display">\exp{(\mathbf{w}^T\cdot\mathbf{x}+b)}\geq \log{c}</script><p>因为$c$是任意常数，所以我们可取$c$满足$\log{c}=1$，使得</p>
<script type="math/tex; mode=display">\exp{(\mathbf{w}^T\cdot\mathbf{x}+b)}\geq 1</script><p>上式可能存在多个解，如果添加一个二次惩罚项进行约束，则能使解唯一：<br>\begin{equation}<br>\begin{aligned}<br>\min &amp; \quad \frac{1}{2}||\mathbf{w}||^2\\<br>\mathrm{s.t.} &amp; \quad (2y_i-1)(\mathbf{w}^T\mathbf{x}_i+b)\geq 1,\quad \forall i=1,\cdots,n.<br>\end{aligned}<br>\end{equation}</p>
<blockquote>
<p>注意这里考虑的$y_i\in\{0,1\}$，而不是前面的$y_i\in\{-1,+1\}$，因此约束条件中是$(2y_i-1)$而不是$y_i$。</p>
</blockquote>
<p>添加了约束条件后，得到的是SVM！</p>
<blockquote>
<p>We derived an SVM by asking LR to make the right decisions. ——from <a href="http://www.cs.toronto.edu/~kswersky/wp-content/uploads/svm_vs_lr.pdf" target="_blank" rel="noopener">Support Vector Machines vs Logistic Regression</a></p>
</blockquote>
<h2 id="多分类"><a href="#多分类" class="headerlink" title="多分类"></a>多分类</h2><ul>
<li>多分类逻辑回归（Multi-class LR）<script type="math/tex; mode=display">P(y=i|x)=\frac{\exp{(w_i^Tx+b_i)}}{\sum_{j}\exp{(w_j^Tx+b_j)}}</script></li>
<li>多分类支持向量机（Multi-class SVM）<script type="math/tex; mode=display">\frac{P(y=i|x)}{P(y=k|x)}\geq c \quad \forall \quad k\neq i</script>即<script type="math/tex; mode=display">w_i^Tx-w_k^Tx\geq 1 \quad \forall \quad k\neq i</script></li>
</ul>
<h2 id="选择SVM还是LR？"><a href="#选择SVM还是LR？" class="headerlink" title="选择SVM还是LR？"></a>选择SVM还是LR？</h2><blockquote>
<p>参考<a href="http://www.cs.toronto.edu/~kswersky/wp-content/uploads/svm_vs_lr.pdf" target="_blank" rel="noopener">Support Vector Machines vs Logistic Regression</a></p>
</blockquote>
<ul>
<li>As always, depends on your problem.</li>
<li>LR gives calibrated probabilities that can be interpreted as confidence in a decision.</li>
<li>LR gives us an unconstrained, smooth objective.</li>
<li>SVMs don’t penalize examples for which the correct decision is made with sufficient confidence. 有利于泛化</li>
<li>SVMs have a nice dual form（对偶形式）, giving sparse solutions when using the kernel trick (better scalability 良好的伸缩性)</li>
</ul>
<h1 id="Python实现"><a href="#Python实现" class="headerlink" title="Python实现"></a>Python实现</h1><p>简单分类数据：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line">sns.set()</span><br><span class="line"></span><br><span class="line"><span class="comment">## 创建类别数为2的分类数据</span></span><br><span class="line"><span class="keyword">from</span> sklearn.datasets.samples_generator <span class="keyword">import</span> make_blobs</span><br><span class="line">X, y = make_blobs(n_samples=<span class="number">50</span>, centers=<span class="number">2</span>, random_state=<span class="number">0</span>, cluster_std=<span class="number">0.60</span>)</span><br><span class="line">plt.scatter(X[:, <span class="number">0</span>], X[:, <span class="number">1</span>], c=y, s=<span class="number">50</span>, cmap=<span class="string">'autumn'</span>)</span><br></pre></td></tr></table></figure></p>
<p><img src="/img/SVM-Figure_1.png" alt="简单分类数据"></p>
<p>简单分割线：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">xfit = np.linspace(<span class="number">-1</span>, <span class="number">3.5</span>)</span><br><span class="line">plt.scatter(X[:, <span class="number">0</span>], X[:, <span class="number">1</span>], c=y, s=<span class="number">50</span>, cmap=<span class="string">'autumn'</span>)</span><br><span class="line">plt.plot([<span class="number">0.6</span>], [<span class="number">2.1</span>], <span class="string">'x'</span>, color=<span class="string">'red'</span>, markeredgewidth=<span class="number">2</span>, markersize=<span class="number">10</span>)  <span class="comment">##特殊点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> m, b <span class="keyword">in</span> [(<span class="number">1</span>, <span class="number">0.65</span>), (<span class="number">0.5</span>, <span class="number">1.6</span>), (<span class="number">-0.2</span>, <span class="number">2.9</span>)]:</span><br><span class="line">    plt.plot(xfit, m * xfit + b, <span class="string">'-k'</span>)  <span class="comment">##画三条分割直线</span></span><br><span class="line"></span><br><span class="line">plt.xlim(<span class="number">-1</span>, <span class="number">3.5</span>)</span><br></pre></td></tr></table></figure></p>
<p><img src="/img/SVM-Figure_3.png" alt="三条简单分割直线"><br>上图中的三条简单分割直线（分割器）都能很好地判别这些样本（每条直线都能将圆点数据点正确地分为两类）。但是对于点“X”，不同的分割器将其分配到不同的标签。</p>
<p>若将分割直线变成具有宽度的、到最近点边界的线条，如下图：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">xfit = np.linspace(<span class="number">-1</span>, <span class="number">3.5</span>)</span><br><span class="line">plt.scatter(X[:, <span class="number">0</span>], X[:, <span class="number">1</span>], c=y, s=<span class="number">50</span>, cmap=<span class="string">'autumn'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> m, b, d <span class="keyword">in</span> [(<span class="number">1</span>, <span class="number">0.65</span>, <span class="number">0.33</span>), (<span class="number">0.5</span>, <span class="number">1.6</span>, <span class="number">0.55</span>), (<span class="number">-0.2</span>, <span class="number">2.9</span>, <span class="number">0.2</span>)]:</span><br><span class="line">    yfit = m * xfit + b</span><br><span class="line">    plt.plot(xfit, yfit, <span class="string">'-k'</span>)</span><br><span class="line">    plt.fill_between(xfit, yfit - d, yfit + d, edgecolor=<span class="string">'none'</span>, color=<span class="string">'#AAAAAA'</span>, alpha=<span class="number">0.4</span>)</span><br><span class="line"></span><br><span class="line">plt.xlim(<span class="number">-1</span>, <span class="number">3.5</span>)</span><br></pre></td></tr></table></figure></p>
<p><img src="/img/SVM-Figure_2.png" alt="带有边界的分割器"></p>
<p><img src="/img/SVM-Figure_4.jpeg" alt="带边界线和支持向量的支持向量机分类器"></p>
<p>正好在边界线上的点，被称为<strong>支持向量</strong>。</p>
<p>在scikit-learn中，支持向量的坐标存放在分类器的<code>support_vectors_</code>属性中。</p>
<p>SVM对远离边界的数据点不敏感。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li>Python数据科学手册：<a href="https://book.douban.com/subject/27667378/" target="_blank" rel="noopener">豆瓣图书</a>；<a href="https://jakevdp.github.io/PythonDataScienceHandbook/" target="_blank" rel="noopener">英文版在线阅读</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzI3NTkyMjA4NA==&amp;mid=2247493162&amp;idx=1&amp;sn=59c051af70c1b4e0ab40d661df1d1ade&amp;chksm=eb7fcbe1dc0842f7cfc9c7224d4c0e2a3fe52d5abe18fe241b717bdf85b59c15d6c16fc99ee8&amp;scene=126&amp;sessionid=1588039863&amp;key=974eeeca00c2ed2bc09cde22429650400361fd61321edc232f5976aa402ec1f37e927d042d76e7eba2cc584551a40b22a7d2cd6e65fe539e5bd3854b306460a7770a747143ced86385ab3a53ffb7ba92&amp;ascene=1&amp;uin=MjAwNDUzMjgxNw%3D%3D&amp;devicetype=Windows+10&amp;version=62080079&amp;lang=zh_CN&amp;exportkey=AWzG3axKR6jb4RKDg8wBmkw%3D&amp;pass_ticket=581sFN8nM0rkEWD6Hp%2BhUJbN5RHzfuAW3vhCzJ2BWY6u9zDUMhZpRh3fnoocgekU" target="_blank" rel="noopener">中文开源！《Python数据科学》PDF下载</a></li>
<li><a href="https://github.com/jakevdp/PythonDataScienceHandbook">Python Data Science Handbook: full text in Jupyter Notebooks</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU4OTQ1MTA4OQ==&amp;mid=2247484526&amp;idx=2&amp;sn=2b4c5e1515399faa68c0a26c4af86a8a&amp;chksm=fdcc1e50cabb9746ed4540e85f04a46d619c9f742983263ec7e0d745461207130dc942d9b13a&amp;mpshare=1&amp;scene=1&amp;srcid=&amp;sharer_sharetime=1589763512771&amp;sharer_shareid=b539221659d6ecf12200314308b58dd3&amp;key=7813388b70745838ea5587ffa273a7987bc9cc48091ec6078d4ee6aa0f4006b626cf94cde5ee7e9421ccece1dfec15a1470a661bf846a2f2c04d777ecb964c1269220b461add3339f0275e49b7b93a94&amp;ascene=1&amp;uin=MjAwNDUzMjgxNw%3D%3D&amp;devicetype=Windows+10+x64&amp;version=62090070&amp;lang=zh_CN&amp;exportkey=AczC7cKlIl3ih7o5BG26J80%3D&amp;pass_ticket=xR1KSeE3lIX5nnCWlcYTeKvMJAtr4TZjSz63TI%2BWkF05sxtwyAUkGLgSphim0pcM" target="_blank" rel="noopener">关于SVM，面试官们都怎么问</a></li>
<li><a href="https://pic3.zhimg.com/v2-197913c461c1953c30b804b4a7eddfcc_1200x500.jpg" target="_blank" rel="noopener">图-支持向量机</a></li>
<li><a href="https://book.douban.com/subject/10590856/" target="_blank" rel="noopener">李航-统计学习方法</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/31886934" target="_blank" rel="noopener">支持向量机（SVM）——原理篇</a></li>
<li><a href="http://www.cs.toronto.edu/~kswersky/wp-content/uploads/svm_vs_lr.pdf" target="_blank" rel="noopener">Support Vector Machines vs Logistic Regression</a></li>
<li><a href="https://blog.csdn.net/xiaocong1990/article/details/83004159" target="_blank" rel="noopener">LR和SVM区别</a></li>
<li><a href="https://www.jianshu.com/p/399ddcac2178" target="_blank" rel="noopener">SVR（Support Vector Regression）支持向量回归机</a></li>
<li><a href="https://www.jianshu.com/p/399ddcac2178" target="_blank" rel="noopener">图-支持向量回归机</a></li>
<li><a href="https://www.cnblogs.com/pinard/p/6113120.html" target="_blank" rel="noopener">刘建平-支持向量机原理(五)线性支持回归</a></li>
</ul>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>机器学习</tag>
        <tag>分类</tag>
        <tag>有监督学习</tag>
        <tag>回归</tag>
        <tag>判别式模型</tag>
      </tags>
  </entry>
  <entry>
    <title>Tableau学习资源</title>
    <url>/Tableau%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90.html</url>
    <content><![CDATA[<p><center>汇总Tableau软件的相关学习资料~</center><br><a id="more"></a></p>
<h2 id="书籍"><a href="#书籍" class="headerlink" title="书籍"></a>书籍</h2><h3 id="《触手可及的大数据分析工具：Tableau案例集》"><a href="#《触手可及的大数据分析工具：Tableau案例集》" class="headerlink" title="《触手可及的大数据分析工具：Tableau案例集》"></a>《触手可及的大数据分析工具：Tableau案例集》</h3><p><a href="https://book.douban.com/subject/26614166/" target="_blank" rel="noopener">豆瓣图书</a></p>
<h2 id="视频"><a href="#视频" class="headerlink" title="视频"></a>视频</h2><h3 id="未明学院-Tableau可视化软件的基础操作和进阶"><a href="#未明学院-Tableau可视化软件的基础操作和进阶" class="headerlink" title="未明学院-Tableau可视化软件的基础操作和进阶"></a>未明学院-Tableau可视化软件的基础操作和进阶</h3><p><a href="https://www.bilibili.com/video/av66028664?from=search&amp;seid=5882922976125124544" target="_blank" rel="noopener">视频地址</a></p>
<p>共14个视频</p>
<ol>
<li>Tableau简介、条形图与直方图</li>
<li>数据预处理、折线图、饼图</li>
<li>基本表、树状图、气泡图、词云</li>
<li>标靶图、甘特图、瀑布图</li>
<li>Tableau进阶：数据集合并、符号地图、智能显示、插入自定义形状、仪表板</li>
<li>填充地图、多维地图、混合地图</li>
<li>多边形地图和背景地图：设置地理信息，自定义地图码导入、设置地图源</li>
<li>数据分层、数据分组、数据集</li>
<li>计算字段与表计算：粒度、聚合与比率</li>
<li>人口金字塔、漏斗图、箱线图</li>
<li>范围：线图、倾斜图</li>
<li>网络图与弧线图</li>
<li>雷达图与弧线图</li>
<li>回归分析、时间序列分析</li>
</ol>
]]></content>
      <categories>
        <category>Everything</category>
      </categories>
      <tags>
        <tag>Tableau</tag>
        <tag>可视化</tag>
      </tags>
  </entry>
  <entry>
    <title>分布 | 泊松分布</title>
    <url>/%E5%88%86%E5%B8%83-%E6%B3%8A%E6%9D%BE%E5%88%86%E5%B8%83.html</url>
    <content><![CDATA[<p><center>Poisson Distribution</center><br><a id="more"></a></p>
<p>生活中大多数场景服从泊松分布，如奶茶店一天的顾客数、理发店一天的顾客数、馒头店一天卖出的馒头数等等。</p>
<p>假设我经营着一家咖啡馆——SW Coffee。</p>
<p>考虑长度为$T$的时间段内光顾的客人数量。将$T$时间切分为$n$份，每个时间段内只会发生“来了一位客人”或“没来客人”，即二项分布Binomial(p)</p>
<script type="math/tex; mode=display">P(来了一位客人)=p</script><p>那么，$T$时间段内来的客人数量$X$服从$n$重Bernoulli分布B(n,p)</p>
<script type="math/tex; mode=display">P(X=k)=\left(
\begin{array}{c}
n\\
k
\end{array}\right)
p^k(1-p)^{n-k}</script><p>均值为</p>
<script type="math/tex; mode=display">\lambda=E(X)=np</script><p>若将$T$时间段切分得足够小（$n\rightarrow\infty$），则$T$时间内来了$k$个客人的概率为<br>\begin{equation}<br>\begin{aligned}<br>&amp; \lim_{n\rightarrow \infty}\left(<br>\begin{array}{c}<br>n\\<br>k<br>\end{array}\right)<br>p^k(1-p)^{n-k}\\<br>=&amp; \lim_{n\rightarrow\infty}\frac{n(n-1)\cdots(n-k+1)}{k!}\left(\frac{\lambda}{n}\right)^k\left(1-\frac{\lambda}{n}\right)^{n-k}\\<br>=&amp; \lim_{n\rightarrow\infty}\frac{\lambda^k}{k!}\frac{n}{n}\frac{n-1}{n}\cdots\frac{n-k+1}{n}\left(1-\frac{\lambda}{n}\right)^{n-k}\\<br>=&amp; \lim_{n\rightarrow\infty}\frac{\lambda^k}{k!}1\cdot(1-\frac{1}{n})\cdot\cdots\cdot\left(1-\frac{k-1}{n}\right)\left(1-\frac{\lambda}{n}\right)^{-k}\left(1-\frac{\lambda}{n}\right)^{n}\\<br>=&amp; \frac{\lambda^k}{k!}e^{-\lambda}<br>\end{aligned}<br>\end{equation}<br>其中</p>
<script type="math/tex; mode=display">\lim_{n\rightarrow\infty}1\cdot(1-\frac{1}{n})\cdot\cdots\cdot(1-\frac{k-1}{n})\left(1-\frac{\lambda}{n}\right)^{-k}=1</script><script type="math/tex; mode=display">\lim_{n\rightarrow\infty}\left(1-\frac{\lambda}{n}\right)^{n}=\lim_{n\rightarrow\infty}e^{\lambda}\left(1-\frac{\lambda}{n}\right)^{\frac{n}{\lambda}}=e^{\lambda}e^{-1}=e^{-\lambda}</script><p>强度为$\lambda$的泊松分布过程的点间间距服从参数为$\lambda$的指数分布（均值为$1/\lambda$）。</p>
<p>未完待续（表示本篇博客未写完~会继续更新）</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://www.zhihu.com/question/26441147" target="_blank" rel="noopener">泊松分布的现实意义是什么，为什么现实生活多数服从于泊松分布？</a></li>
</ul>
]]></content>
      <categories>
        <category>Statistics</category>
      </categories>
      <tags>
        <tag>概率统计基础</tag>
        <tag>概率分布</tag>
      </tags>
  </entry>
  <entry>
    <title>Restart!</title>
    <url>/Restart.html</url>
    <content><![CDATA[<center>从零开始我的个人博客！</center>

<a id="more"></a>
<p>一年前已经成功搭建此博客，但是我在调整博客主题时把它搞成404了（泪目），于是重新搭建了，那么就从零restart吧！</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>[1] <a href="https://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html" target="_blank" rel="noopener">使用hexo+github搭建免费个人博客详细教程</a><br>[2] <a href="https://wangcong.net/article/HexoWihLaTeX.html" target="_blank" rel="noopener">Hexo中Latex公式渲染</a><br>[3] <a href="https://github.com/iissnan/hexo-theme-next/wiki/%E5%88%9B%E5%BB%BA%E5%88%86%E7%B1%BB%E9%A1%B5%E9%9D%A2">创建分类页面</a><br>[4] <a href="https://www.jianshu.com/p/70e46dc95676" target="_blank" rel="noopener">设定代码高亮格式</a><br>[5] <a href="https://bing.ioliu.cn/photo/MalhamStars_ZH-CN4163177154?force=home_6" target="_blank" rel="noopener">博客首页图片</a></p>
]]></content>
      <categories>
        <category>Everything</category>
      </categories>
      <tags>
        <tag>Something</tag>
      </tags>
  </entry>
</search>
